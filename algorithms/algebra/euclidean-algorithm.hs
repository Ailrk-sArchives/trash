{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeFamilies #-}

module EuclideanAlgorithm where

-- euclidean algorithm in abstract algebra.
-- https://www.math.cmu.edu/~bkell/21110-2010s/extended-euclidean.html

-- Simple euclidean algorithm to compute greatest common divisor --
euclideanGCD :: Integer -> Integer -> Integer
euclideanGCD a 0 = a
euclideanGCD a b = euclideanGCD b (a `mod` b)

-- a and b are coprime if gcd(a, b) = 1 --
isCoprime :: Integer -> Integer -> Bool
isCoprime a b = 1 == euclideanGCD a b

class Monoid r => Group r where
  invA :: r -> r -- additive inverse

-- define another monoid on top of the group
class (Monoid r) => Ring r where
  (<@>) :: r -> r
  rempty :: r -- 1

-- ring --
-- a ring with no zero divisor. All fields are integral domain
-- think of the ring of integer. ab = 0 ⇔ a = 0 or b = 0
-- counter example: field R₆ is not an integral domain.
--    3 * 2 ≡ 0 (mod 4)

-- an invertible element in commutative ring is called unit.
-- an ideal of a ring is a subset of the ring if it's an additive sub group
-- that any element mutiply with e in the entire ring will still be in the
-- subgroup.
class Ring r => CommutativeRing r where
  type Ideal r
  isUnit :: r -> Bool
  leftIdealMul :: Ideal r -> r -> Ideal r
  rightIdealMul :: r -> Ideal r -> Ideal r
  generateIdeal :: r -> Ideal r -> [Ideal r]

class CommutativeRing r => IntegralDomain r

-- PID is an integral domain with it's ideals to be principle. (Can be
-- generated by a single element)
-- A ring has multiple ideals, a pid has all these ideals being able to
-- be generated by an element in those ideals.
-- Think about 1*n, 2*n in Z.
-- 1, 2 are elements that generate each ideals.
class IntegralDomain r => PrincipleIdealDomain r

-- An euclidean domain needs to be an integral domain first.
-- each ideal in euclidean domain is principle.
class (IntegralDomain r, PrincipleIdealDomain r) => EuclideanDomain r where
  euclidean :: r -> r -> r

-- UFD is an integral domain with all elements being able to written as product of
-- irreducible elements.
class IntegralDomain r => UniqueFactorizationDomain r where
  isIrreducible :: r -> Bool
  factorize :: r -> [r]

-- integral domain and euclidean domain are somewhere between a ring and
-- A field is always a
class EuclideanDomain r => Field r where
  invM :: r -> r -- multiplicative inverse

-- bezouts theorem
-- gcd(a, b) = xa + yb
-- gcd can be written as linear combination of a and b.

-- use bezouts theorem and extended euclidean algorithm to solve
-- multiplicative inverse of integer modulo n.

-- first see a simple modulo arithmetics:
-- a ≡ b (mod n)
-- so a - b = nx
-- so a = nx + b
-- or p = nq + r
-- in another word, n | a - b
data Congruence = Cong Integer Integer Integer
  deriving (Show)

congruence :: Integer -> Integer -> Integer -> Maybe Congruence
congruence a b n
  | (a - b) `mod` n == 0 = Just (Cong a b n)
  | otherwise = Nothing

cong1 = congruence 4 1 3

-- and if a is a product of two numbers, we have
-- ax ≡ b (mod n)
-- so ax - b = ny
-- so b = ax - ny
-- written as b = ax + ny

-- extended euclidean algorithm:
--  if we keep track of more information of the naive euclidean algorithm, we can
--  compute the gcd as an integer linear combination of two numbers.
--    gcd(a, b) = n = xa + yb
--
-- The main idea is at

-- When gcd(a, b) = 1, or a, b are coprime, we have
-- 1 = xa + yb.
--
-- given a, we want to find a inverse:
--   a . a¯¹ ≡ 1 (mod b)
-- ⇔ a . a¯¹  ≡ 1 (mod b)
-- ⇔ 1 = a.a¯¹ + by
-- a, b are known, but a¯¹ and y are not known.
-- we want to solve this integer linear combination to get a¯¹.

-- easily computed with the table.
--  q   r   s   t
--  --------------
--      a   1   0
--  q1  b   0   1
--  q2
--      ...
-- stop when r = 0

type Col = (Integer, Integer, Integer, Integer)

extendedEuclidean' :: Col -> Col -> (Integer, Integer)
extendedEuclidean' (_, _, s, t) (_, 0, _, _) = (s, t)

extendedEuclidean' (_, r, s, t) (q', r', s', t') =
  let c1 = (q', r', s', t')
      c2 = let r'' = r - q' * r'
            in (r' `div` r'', r'', s - q' * s', t - q' * t')
   in extendedEuclidean' c1 c2

extendedEuclidean :: Integer -> Integer -> (Integer, Integer)
extendedEuclidean a b | a < b = error "a must > b"
extendedEuclidean a b = extendedEuclidean' (0, a, 1, 0) (a `div` b, b, 0, 1)


