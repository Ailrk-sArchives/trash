#include "regex.h"
#include <assert.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_STATE_NUM 128
#define MAX_SYM_NUM 128
#define STACK_SZ 128

int state;
char sym;

char *code;
char *stack;
char *sp;

char table[MAX_SYM_NUM][MAX_STATE_NUM];
char final_state[MAX_STATE_NUM];

// clear regex state.
void regex_clear() {
  code = NULL;
  state = 0;
  sym = 0;
  stack = NULL;
  sp = NULL;
  memset(table, 0, MAX_SYM_NUM * MAX_STATE_NUM * sizeof(char));
  memset(final_state, 0, MAX_STATE_NUM * sizeof(char));
}

node *new_node(char s, node *left, node *right) {
  node *n = (node *)malloc(sizeof(node));
  n->s = s;
  n->left = left;
  n->right = right;
  return n;
}

void print_node(node *n) {
  if (n == NULL)
    return;
  printf("<%c ", n->s);
  if (n->left)
    print_node(n->left);
  else
    printf(" _ ");
  if (n->right)
    print_node(n->right);
  else
    printf(" _ ");
  printf("> ");
}

void preorder_traversal(node *n, void (*preprocess)(node *),
                        void (*cb)(node *)) {
  if (preprocess)
    preprocess(n);
  if (n->left)
    preorder_traversal(n->left, preprocess, cb);
  if (cb)
    cb(n);
  if (n->right)
    preorder_traversal(n->right, preprocess, cb);
}

#define PRINT_NODE(msg, n)                                                     \
  printf(msg "\n");                                                            \
  print_node(n);                                                               \
  printf("\n");

void free_node(node *n) {
  if (n->left)
    free_node(n->left);
  if (n->right)
    free_node(n->right);
  free(n);
}

void error(char const msg[]) {
  fprintf(stderr, msg);
  fprintf(stderr, "\n");
}

void nextsym() {
  static int pos = 0;
  if (code[pos] != '\0')
    sym = code[pos++];
  else
    sym = '\0';
}

int accept(char s) {
  if (sym == s) {
    nextsym();
    return 1;
  } else
    return 0;
}

// accept an char in range a-z, return the accepted char.
char accept_alpha() {
  if (sym >= 'a' && sym <= 'z') {
    char n = sym;
    nextsym();
    return n;
  } else
    return 0;
}

int expect(char s) {
  if (accept(s))
    return 1;
  error("expect: unexpected token");
  return 0;
}

// factor = char | "(" expression ")"
// term = factor ["*"]
// term1 = term { term }
// expression = term1 { "|" term1 }

node *expression();

node *factor() {
  if (accept('(')) {
    node *e;
    e = expression();
    expect(')');
    return e;
  } else {
    char s;
    s = accept_alpha();
    if (s > 1) {
      node *p = new_node(s, NULL, NULL);
      return p;
    } else {
      printf("factor error %c\n", sym);
      error("factor: syntax error");
      nextsym();
    }
    return NULL;
  }
}

node *term() {
  node *f;
  f = factor();
  if (accept('*')) {
    node *klenee_star = new_node('*', NULL, f);
    return klenee_star;
  }
  return f;
}

node *term1() {
  node *t1, *t2, *o;
  o = term();
  while (isalpha((int)sym) || sym == '(') {
    t1 = o;
    o = new_node('^', NULL, NULL);
    t2 = term();
    if (t2) {
      o->left = t1;
      o->right = t2;
      t1 = o;
    } else {
      error("term1: term { term }");
      nextsym();
    }
  }
  return o;
}

node *expression() {
  node *t1, *t2, *o;
  o = term1();
  while (accept('|')) {
    t1 = o;
    o = new_node('|', NULL, NULL);
    t2 = term1();
    if (t2) {
      o->left = t1;
      o->right = t2;
      t1 = o;
    } else {
      error("expression: error for term1 { [\"|\"] term1 } ");
      nextsym();
    }
  }
  return o;
}

node *parse() {
  nextsym();
  return expression();
}

// callbacks for preorder traversal.

void mark_node(node *n) {
  if (n->s == '|') {
    *sp++ = (char)state; // record the current state when hit a |
    *sp++ = '|';
    printf("fisrt | : %d\n", state);
  }

  if (n->s == '*') {
    *sp++ = (char)state;
    *sp++ = '*';
    printf("first * : %d\n", state);
  }
}

void build_from_node(node *n) {
  char sym;
  static int sig = 0;

  if (n->s == '|') { // hit | the second time.
    --sp;
    sig = *--sp;

  } else if (n->s == '*') {
    // note: * in the ast has the shape
    //      *
    //     / \
    //    _   n
    // so in a preorder traversal * will be visited twice before
    // it visits n. Thus by the time n is visited sig is already set.
    --sp;
    sig = *--sp;
  } else if (isalnum(n->s)) {
    sym = n->s;
    if (sig) {
      printf("sig %d\n", sig);
      table[sym][sig] = state++;
      sig = 0;
    } else {
      int prev_state = state++;
      table[sym][prev_state] = state;
    }
  }
}

int regex(char pat[], char str[]) {
  // a langauge with 256 state and 256 symbols maximum.
  // state is indexed by chars.
  node *expr;

  regex_clear();

  {
    state = 0;
    code = pat;
    stack = (char *)malloc(STACK_SZ);
    sp = stack;
    expr = parse();
    preorder_traversal(expr, mark_node, build_from_node);
    free_node(expr);
  }

  {
    state = 0;
    for (char *p = str; *p != '\0'; ++p) {
      state = table[*p][state];
    }

    for (int i = 0; i < MAX_STATE_NUM && final_state[i] == state; ++i) {
      if (final_state[i] == '\0')
        return 0;
    }
  }
  return 1;
}
