{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE StandaloneDeriving #-}

module DataStructure.Lazy where

-- Represent a suspend computation.
-- wrap wrap
data Suspend a = Suspend { unSuspend :: !(() -> a) }

instance Show a => Show (Suspend a) where
  show _ = "<a suspend operation>"

delay :: (() -> a) -> Suspend a
delay = Suspend

force :: Suspend a -> a
force !s = (unSuspend s) ()


strictAdd :: Num a => a -> a -> a
strictAdd !a !b = a + b

-- >>> force . delay $ (\_ -> strictAdd 1 2)
-- 3


-- A lazy stream
data StreamCell a = Nil | Cons !(a, Stream a) deriving Show
data Stream a = Stream !(Suspend (StreamCell a)) deriving Show

fromList :: [a] -> Stream a
fromList ![] = Stream (delay (\_ -> Nil))
fromList !(x:xs) = Stream (delay (\_ -> Cons (x, fromList xs)))

-- >>> fromList [1, 2, 3]
-- Stream <a suspend operation>

headStream :: Stream a -> StreamCell a
headStream (Stream xs) = force xs

tailStream :: Stream a -> Stream a
tailStream (Stream sus) | Cons (a, rest) <- force sus  = rest
tailStream (Stream (Suspend _)) = error "sad"
