{-# LANGUAGE RoleAnnotations #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeFamilies #-}

module Types.TypeRole where

import Data.Coerce
import Data.Foldable
import qualified Data.Map as M
import Data.Monoid

-- a new type is always coercible to it's underlying type.
newtype ZipList a = ZipList { unZipList :: [a] }

-- >>> coerce (123 :: Sum Int) :: Product Int
-- >>> coerce (ZipList [1, 2, 3] :: ZipList Int) :: [Int]
-- Product {getProduct = 123}
-- [1,2,3]


-- why extra map if Sum Int is just Int?
slowSum :: [Int] -> Int
slowSum = getSum . mconcat . fmap Sum

fastSum :: [Int] -> Int
fastSum = getSum . mconcat . coerce


