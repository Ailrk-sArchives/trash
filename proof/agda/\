module plfa.p1.Relations where

import Relation.Binary.PropositionalEquality as Eq
open Eq using (_≡_; refl; cong)
open import Data.Nat using (ℕ; zero; suc; _+_)
open import Data.Nat.Properties using (+-comm; +-identityʳ)

-- # Relations #
--  note: {} means n is implicit.
data _≤_ : ℕ → ℕ → Set where
    z≤n : ∀ {n : ℕ}   -- define relation of less than
        -----------
        → zero ≤ n

    s≤s : ∀ {m n : ℕ}
        → m ≤ n       -- index type. indexed by two nats m, n
        --------------
        → suc m ≤ suc n

infix 4 _≤_

-- definition:
--      base case: ∀ n ∈ ℕ, zero ≤ n holds
--                 (z≤n gives he evidence that it holds)
--      inductive case: ∀ m, n ∈ ℕ, m ≤ n → suc m  ≤ suc n
--                      (s≤s takes evidence that m ≤ n holds
--                       and then gives evidence that suc m  ≤ suc n holds)

-- # Implicit arguments #
-- implict arguments don't need to be written explicitly. They are
-- inferred by the typechecker.
_ : 2 ≤ 4
_ = s≤s (s≤s z≤n)   -- 0 ≤ ? → 0 ≤ 2 → 1 ≤ 3 → 2 ≤ 4

-- write the same proof explicitly
_ : 2 ≤ 4
_ = s≤s {1} {3} (s≤s {0} {2} (z≤n {2}))

-- more explicitly
_ : 2 ≤ 4
_ = s≤s  {m = 1} {n = 3} (s≤s {m = 0} {n = 2} (z≤n {n = 2}))

-- decrease m by 1 until it hits 0.
_ : 5 ≤ 10
_ = s≤s (s≤s (s≤s (s≤s (s≤s z≤n))))

_ : 3 ≤ 10
_ = s≤s {m = 2} {n = 9}
    (s≤s {m = 1} {n = 8}
    (s≤s {m = 0} {n = 7}
    (z≤n {n = 7})))


-- # Inversion #
inv-s≤s : ∀ {m n : ℕ}
    → suc m ≤ suc n
    ---------------
    → m ≤ n
inv-s≤s (s≤s m≤n) = m≤n

inv-z≤n : ∀ {m : ℕ}
    → m ≤ zero
    -----------
    → m ≡ zero
inv-z≤n z≤n = refl

-- # Properties of ordering relations #
--     reflexive:       ∀ n. the relation nRn holds
--     transitive:      ∀ m, n. p, (mRn ∧ nRp → mRp)
--     anti-symmetric:  ∀ m, n. mRn ∧ nRm → m ≡ n
--     total:           ∀ m, n. mRn ∨ nRm
-- ! some name for combination of common properties
--     preorder: reflexive and transitive
--     partial order: any preorder that is also anti-symmetric.
--     total order: any parital order that is also total.
--
-- To be preorder you don't need to be an equivalence relation.
--      preorder + | symmetric -> equivalence relation
--                 | antisymmetric -> partial order

-- exercise orderings
-- An example of a preorder that is not a partial order
--    reflexive and transitive relation but not anti-symmetric.
--    tons.
--    e.g
--    1. + (mod n)
--       not anti-symmetric because a + b (mod n) and b + a (mod n)
--       doesn't mean a = b. at all
--    2. The reachability relationship in any directed graph.
--       a can reach b but it's not necessarily for b to go back.
--    3. {(a, a), (a, b), (b, a), (b, b)} as preorder on {a, b}
-- An example of a partial order that is not a total order
--    e.g ⊆
--    It's partial order becauase  if a ⊆ b and b ⊆ a a = b
--    But not all sets are subset of each other. they can be disjoint.

-- ! Reflexivity
--≤-refl : ∀ {n : ℕ}
--    -----
--    → n ≤ n
--≤-refl {zero} = z≤n
--≤-refl {suc n} = s≤s ≤-refl

≤-refl : ∀ {n : ℕ}
    -----
    → n ≤ n
≤-refl {zero} = z≤n
≤-refl {suc n} = s≤s ≤-refl   -- again use inductive hypothesis.


-- ! Transitivity
≤-trans : ∀ {m n p : ℕ}
    → m ≤ n
    → n ≤ p
    -----
    → m ≤ p
≤-trans z≤n _ = z≤n
≤-trans (s≤s m≤n) (s≤s n≤p) = s≤s (≤-trans m≤n n≤p)

-- ! Antisymmetry
≤-antisym : ∀ {m n : ℕ}
    → m ≤ n
    → n ≤ m
    ----
    → m ≡ n
≤-antisym z≤n z≤n = refl
≤-antisym (s≤s m≤n) (s≤s n≤m) = cong suc (≤-antisym m≤n n≤m)


-- ! Total
-- first let's define what does it mean for a relation to be total
-- if ≤ is total, either m ≤ n or n ≤ m or both.
-- if we can get a instance of the data type defined below, we proved
-- it exists.
data Total (m n : ℕ) : Set where
  forward :
    m ≤ n
    -----
    → Total m n

  flipped :
    n ≤ m
    -----
    → Total m n

-- note the above defintion create a datatype with parameter. It's the
-- same as the following indexed type:

data Total' : ℕ → ℕ → Set where
  forward' : ∀ {m n : ℕ}
    → m ≤ n
    -----
    → Total' m n

  flipped' : ∀ {m n : ℕ}
    → n ≤ m
    -----
    → Total' m n


≤-total : ∀ (m n : ℕ) → Total m n
≤-total zero n = forward z≤n
≤-total (suc m) zero = flipped z≤n
≤-total (suc m) (suc n) with ≤-total m n
                        | forward m≤n = forward (s≤s m≤n)
                        | flipped m≤n = flipped (s≤s n≤m)

