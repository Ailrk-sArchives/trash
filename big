module demo.AbstractDef where

import Relation.Binary.PropositionalEquality as Eq
-- open the module (add names specified in using)
open Eq using (_≡_; refl; cong; sym)
open Eq.≡-Reasoning using (begin_; _≡⟨⟩_; _∎)
open import Data.Nat using (ℕ; zero; suc; _+_; _*_; _∸_)
open import Function using (_∘_; flip)


-- abstract definitions

-- define integer as the difference of two natural numbers
abstract
  ℤ = ℕ × ℕ

  0ℤ : ℤ
  0ℤ = 0 , 0

  1ℤ : ℤ
  1ℤ = 1 , 0

  _+ℤ_ : (x y : ℤ) → ℤ
  (p, n) +ℤ (p' , n') = (p + p') , (n + n')

  -ℤ_  : ℤ → ℤ
  -ℤ (p , n) = (n , p)

  _≡ℤ_ : (x y : ℤ) → Set
  (p, n) ≡ℤ (p' , n') = (p + n') ≡ (p' + n)

  private
    postulate
      +comm : ∀ n m → (n + m) ≡ (m + n)

  invℤ : ∀ x → (x +ℤ (-ℤ x)) ≡ℤ 0ℤ
  invℤ (p, n) rewrite +comm (p + n) 0 | +comm p n = refl
module demo.demo1 where

data Bool : Set where
  true : Bool
  false : Bool

-- \l reload.
-- \c split into cases
-- \g put an expression in the hole {! !} ahead of time
--    and it will automatically fill the expression if it
--    type checks.
if_then_else_ : {a : Set} → Bool → a → a → a
if true then t else f = t
if false then t else f = f

-- \a search for an answer
not : Bool → Bool
not true = false
not false = true

data ℕ : Set where
  zero : ℕ
  suc : ℕ → ℕ

-- \r refine. make sure expression typechecks
--    if not add some extra holes to make it typecheck
--    it's a more powerful give
_+_ : ℕ → ℕ → ℕ
zero + y = y
suc x + y = suc (x + y)


data Vec (a : Set) : ℕ → Set where
  nil : Vec a zero
  cons : {n : ℕ} → a → Vec a n → Vec a (suc n)

-- {! -c !} let the auto command also do case analysis
-- in this case it solve the problem completely.
vconcat : {a : Set} {m n : ℕ} → Vec a m → Vec a n → Vec a (m + n)
vconcat {_} {zero} v1 v2 = v2
vconcat {_} {suc x} (cons x₁ x₂) v2 = cons x₁ (vconcat x₂ v2)

-- create a vector
one = suc zero
two = one + one
three = one + two
four = one + three
five = one + four
six = one + five
seven = one + six
eight = one + seven
nine = one + eight
ten = one + nine

-- normalize to long long expression
vec1 = cons zero (cons (ten + ten) (cons six (cons five nil)))

-- normalize with \n
-- give you the normalized form of the expression
-- \n high will normalize high to (suc (suc zero))
--
-- \e gives the types in the context.
low = suc zero
high = low + low
module hello.hello where

open import IO

main = run (putStrLn "hello agda")


module plfa.p1.Equality where

-- define equality
-- refl is another indexed type with implicit parameter.
-- it just take one parameter and getting the type x≡x
-- if it's possible to construct refl we can prove to types
-- are equal.
data _≡_ {A : Set} (x : A) : A → Set where
  refl : x ≡ x

infix 4 _≡_

-- equality is Equivalence relation. --
-- we don't need to prove reflexivity, because ... it's alreay
-- there.

sym : ∀ {A : Set} {x y : A} → x ≡ y → y ≡ x
sym refl = refl

trans : ∀ {A : Set} {x y z : A} → x ≡ y → y ≡ z → x ≡ z
trans refl refl = refl

-- congruence and substitution --
cong : ∀ {A B : Set} (f : A → B) {x y : A} → x ≡ y → f x ≡ f y
cong f refl = refl

cong2 : ∀ {A B C : Set} {f : A → B → C} {u x : A} {v y : B}
  → u ≡ x
  → v ≡ y
  → f u v ≡ f x y
cong2 refl refl = refl

-- equality congruence in function application
cong-app : ∀ {A B : Set} {f g : A → B}
  → f ≡ g
  → ∀ (x : A)
  → f x ≡ g x
cong-app refl x = refl

-- equality satisfies substittion
-- P is a predicate.
-- if x y are equal, then P holds for both
-- x and y.
subst : ∀ {A : Set} {x y : A} (P : A → Set)
  → x ≡ y
  → P x → P y
subst P refl px = px


-- Chains of equations --
-- we are building the proof framework..
module ≡-Reasoning {A : Set} where

  infix 1 begin_
  infixr 2 _≡⟨⟩_ _≡⟨_⟩_
  infix 3 _∎

  -- dummy id specializef for ≡
  begin_ : ∀ {x y : A}
    → x ≡ y
    → x ≡ y
  begin x≡y = x≡y

  -- x => y
  _≡⟨⟩_ : ∀ (x : A) {y : A}
    → x ≡ y
    → x ≡ y
  x ≡⟨⟩ x≡y = x≡y

  --   x=y
  -- x ---> y=z : x=z
  _≡⟨_⟩_ : ∀ (x : A) {y z : A}
    → x ≡ y
    → y ≡ z
    → x ≡ z
  x ≡⟨ x≡y ⟩ y≡z = trans x≡y y≡z

  _∎ : ∀ (x : A) → x ≡ x
  x ∎ = refl

open ≡-Reasoning  -- open the module

trans' : ∀ {A : Set} → {x y z : A}
  → x ≡ y → y ≡ z → x ≡ z
trans' {A} {x} {y} {z} x≡y y≡z =
  begin x ≡⟨ x≡y ⟩ y ≡⟨ y≡z ⟩ z ∎

-- the fixity:
-- begin (x ≡⟨ x≡y ⟩ (y ≡⟨ y≡z ⟩ (z ∎)))

data ℕ : Set where
  zero : ℕ
  suc : ℕ → ℕ

_+_ : ℕ → ℕ → ℕ
zero + n = n
(suc m) + n = suc (m + n)

-- claim without proof. This is very bad...
-- use it unless you're sure these are correct lemmas.
postulate
  +-identity : ∀ (m : ℕ) → m + zero ≡ m
  +-suc : ∀ (m n : ℕ) → m + suc n ≡ suc (m + n)

+-comm : ∀ (m n : ℕ) → m + n ≡ n + m
+-comm m zero =
  begin
    m + zero
  ≡⟨ +-identity m ⟩
    m
  ≡⟨⟩
    zero + m
  ∎

+-comm m (suc n) =
  begin
    m + suc n
  ≡⟨ +-suc m n ⟩
    suc (m + n)
  ≡⟨ cong suc (+-comm m n) ⟩
    suc (n + m)
  ≡⟨⟩
    suc n + m
  ∎

-- rewriting --
data even : ℕ → Set
data odd : ℕ → Set

data even where
  even-zero : even zero
  even-suc : ∀ {n : ℕ} → odd n → even (suc n)

data odd where
  odd-suc : ∀ (n : ℕ) → even n → odd (suc n)

-- we already proved addition is commutative. Also we know
-- we can have even (m + n). Thus we should be able to reuse
-- the +-comm lemma to prove commutativity for even number additions.
-- in agda you do this with rewrite.

{-# BUILTIN EQUALITY _≡_ #-}

even-comm : ∀ (m n : ℕ)
  → even (m + n)
  → even (n + m)
even-comm m n ev rewrite +-comm n m = ev

-- mutiple rewrites --

+-comm' : ∀ (m n : ℕ) → m + n ≡ n + m
+-comm' zero n rewrite +-identity n = refl
+-comm' (suc m) n rewrite +-suc n m | +-comm' m n = refl


-- rewrite expanded
-- rewrite is just a shorthand for with.
-- this actually is equivalent with the proof above.
even-comm' : ∀ (m n : ℕ)
  → even (m + n)
  → even (n + m)
even-comm' m n ev with m + n | +-comm m n
... | .(n + m) | refl  = ev

-- with is more complicated than pattern macthing in most MLs.
-- you need to pattern match on indexed type too.
-- first column here assert m n has commutativity.
-- def: dot pattern: (inaccessable pattern) can be used when the only
--      type-correct value of the argument is determined by the pattern
--      given for the other argument
--

-- unification:
--  mechanism behind polymorphic type inference and pattern matching.
--  def : process of finding a substition that makes two given terms equal.
--  pattern matching: apply unification on expression
--  type inference:   apply unification on type expression
--
-- essence:
--  find a substitution S that unifies two given terms (make them equal).
--  thus, given s and t, we want to find S such that s S = t S
--  such S is called a unifier for s and t
--  e.g:
--    two terms:
--      f x (g y)   f (g z) w
--    with substitution
--      S = [x <- g z, w <- g y]
--    would be a unifier.
--    because
--        f x (g y) [x <- g z, w <-  g y]
--      = f (g z) w
--      = f (g z) (g y).
--      https://cs.stackexchange.com/questions/4650/unification-vs-sat-solver
--
-- 1. a unifier doesn't necessarily exists.
-- 2. if unifier exists, it doesn't necessarily unique.
-- 3. there exists a most general unifier (mgu) which is unique.
-- 4. unifiers that are not mgu are called refinement of the mgu.

-- use substitution instead
even-comm'' : ∀ (m n : ℕ)
  → even (m + n)
  → even (n + m)
even-comm'' m n = subst even (+-comm m n)

-- we were using martin lof's form of equality, but there is a eailer, more naive
-- notino of equality

-- leibniz equality --
--  def: two objects are equal iff they satisfy the same properties
--    relevent: spock's law "a difference that make no difference is no difference"

-- Two terms satisfy leibniz equality iff they satisfy martin lof equalify.

-- define leibniz equlity x ≐ y if exists property P that P x and P y
-- P: predicates that takes A and return a Set
-- so the result of x ≐ y is actually a lambda that takes a P : A → Set,
-- a P x, and gives you a P y.
_≐_ : ∀ {A : Set} (x y : A) → Set₁  -- using levels
_≐_ {A} x y = ∀ (P : A → Set) → P x → P y

-- Levels like Set₁ forms a hierachy oftypes.
-- This way we don't need to assign Set to Set itself.
-- To avoid Russell's paradox and girard's paradox.

refl-≐ : ∀ {A : Set} {x : A} → x ≐ x
refl-≐ P Px = Px

trans-≐ : ∀ {A : Set} {x y z : A}
  → x ≐ y
  → y ≐ z
  → x ≐ z
trans-≐ x≐y y≐z P Px = y≐z P (x≐y P Px)
module plfa.p1.Induction where

-- ## Prove properties of inductive type by induction

import Relation.Binary.PropositionalEquality as Eq
-- open the module (add names specified in using)
open Eq using (_≡_; refl; cong; sym)
open Eq.≡-Reasoning using (begin_; _≡⟨⟩_; step-≡; _∎)
open import Data.Nat using (ℕ; zero; suc; _+_; _*_; _∸_)
open import Function using (_∘_; flip)

-- peano natural numbers
data Nat : Set where
  zero' : Nat
  suc : Nat → Nat


-- # Properties of operators

-- prove associativity
-- base case + inductive step
-- type sig is the proposition
-- the function definition is the evidence we provide as the proof.

+-assoc : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc zero n p =
  begin
    (zero + n) + p
  ≡⟨⟩
    n + p
  ≡⟨⟩
    n + (zero + p)
  ∎

+-assoc (suc m) n p =
  begin
    (suc m) + n + p
  ≡⟨⟩
    suc (m + n) + p
  ≡⟨⟩
    suc ((m + n) + p)
  ≡⟨⟩
    suc ((m + n) + p)
  ≡⟨ cong suc (+-assoc m n p) ⟩ -- inductive hypothesis
    suc (m + (n + p))
  ≡⟨⟩
    suc m + (n + p)
  ∎

-- concrete example of proof by induction
+-assoc-2 : ∀ (n p : ℕ) → (2 + n) + p ≡ 2 + (n + p)
+-assoc-2 n p =
  begin
    (2 + n) + p
  ≡⟨⟩
    suc (1 + n) + p
  ≡⟨⟩
    suc ((1 + n) + p)
  ≡⟨ cong suc (+-assoc-1 n p) ⟩  -- inductive hypothesis
    suc (1 + (n + p))
  ≡⟨⟩
    2 + (n + p)
  ∎
  where
  +-assoc-1 : ∀ (n p : ℕ) → (1 + n) + p ≡ 1 + (n + p)
  +-assoc-1 n p =
    begin
      (1 + n) + p
    ≡⟨⟩
      suc (0 + n) + p
    ≡⟨⟩
      suc ((0 + n) + p)
    ≡⟨ cong suc (+-assoc-0 n p) ⟩ -- inductive hypothesis
      suc (0 + (n + p))
    ≡⟨⟩
      1 + (n + p)
    ∎
    where
    +-assoc-0 : ∀ (n p : ℕ) → (0 + n) + p ≡ 0 + (n + p)
    +-assoc-0 n p =
      begin
        (0 + n) + p
      ≡⟨⟩
        n + p
      ≡⟨⟩
        0 + (n + p)
      ∎



-- cong stands for congruence.
-- a relation is said to be congruence for a given function if it preserved by
-- applying that function. If e is evidence that x ≡ y, then cong f e is
-- evidence that f x ≡ f y ∀ f.

-- ! Dependent function
-- +-assoc : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p) has different type
-- compare  with that of a traditional function say ℕ → ℕ → ℕ.
-- Variables are associated with each argument type, and the result type
-- may depend upon these variables. Hence they are called dependent function.

-- ! proof commutativity
-- Proof it by proving several smaller lemma
-- base case of addition state zero is left-identity

-- Lemma 1: proof zero is also right-identity
+-identityʳ : ∀ (m : ℕ) → m + zero ≡ m  -- <- proposition (type)
+-identityʳ zero =                      -- <- pf (function take m return evidence)
    begin
        zero + zero
    ≡⟨⟩
        zero
    ∎

+-identityʳ (suc m) =
    begin
        (suc m) + zero
    ≡⟨⟩
        suc (m + zero)
    ≡⟨ cong suc (+-identityʳ m) ⟩
        suc m
    ∎

-- lemma 2: proof the other direction of inductive case of addition.
+-suc : ∀ (m n : ℕ) → m + suc n ≡ suc (m + n)
+-suc zero n =
    begin
        zero + suc n
    ≡⟨⟩
        suc n
    ≡⟨⟩
        suc (zero + n)
    ∎

+-suc (suc m) n =
    begin
        suc m + suc n
    ≡⟨⟩
        suc (m + suc n)
    ≡⟨ cong suc (+-suc m n) ⟩
        suc (suc (m + n))
    ≡⟨⟩
        suc (suc m + n)
    ∎

-- finally proof commutativity
+-comm : ∀ (m n : ℕ) → m + n ≡ n + m
+-comm m zero =
    begin
        m + zero
    ≡⟨ +-identityʳ m ⟩ -- you can say the reason now.
        m
    ≡⟨⟩
        zero + m
    ∎

+-comm m (suc n) =
    begin
        m + (suc n)
    ≡⟨ +-suc m n ⟩
        suc (m + n)
    ≡⟨ cong suc (+-comm m n) ⟩
        suc (n + m)
    ≡⟨⟩
        suc n + m
    ∎

-- ! rearranging corollary
-- proof our first corollary
-- sym stands for symmetric, is used to shift the side of an equation.
-- (e → x ≡ y) → (sym e → y ≡ x)
+-rearrange : ∀ (m n p q : ℕ) → (m + n) + (p + q) ≡ m + (n + p) + q
+-rearrange m n p q =
    begin
        (m + n) + (p + q)
    ≡⟨ +-assoc m n (p + q) ⟩
        m + (n + (p + q))
    ≡⟨ cong (m +_) (sym (+-assoc n p q)) ⟩  -- use symmetry
        m + ((n + p) + q)
    ≡⟨ sym (+-assoc m (n + p) q) ⟩
        (m + (n + p)) + q
    ∎

-- previous proofs are all based on a chain of equations. Here we use rewrite
-- instead.

-- ! Associativity with rewrite
+-assoc' : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc' zero n p = refl
+-assoc' (suc m) n p rewrite +-assoc' m n p = refl

-- ! Commutativity with rewrite
+-identity' : ∀ (n : ℕ) → n + zero ≡ n
+-identity' zero = refl
+-identity' (suc n) rewrite +-identity' n = refl

+-suc' : ∀ (m n : ℕ) → m + suc n ≡ suc (m + n)
+-suc' zero n = refl
+-suc' (suc m) n rewrite +-suc' m n = refl

+-comm' : ∀ (m n : ℕ) → m + n ≡ n + m
+-comm' m zero rewrite +-identity' m = refl
+-comm' m (suc n) rewrite +-suc' m n | +-comm' m n = refl      -- rewrite with two equations

-- ! Exerceises
-- this can be proved directly
+-swap : ∀ (m n p : ℕ) → m + (n + p) ≡ n + (m + p)
+-swap m n p =
    begin
        m + (n + p)
    ≡⟨ sym (+-assoc m n p) ⟩
        (m + n) + p
    ≡⟨ cong (_+ p) (+-comm m n) ⟩  -- (_+ p) as the function takes m n as parameters
        (n + m) + p
    ≡⟨ +-assoc n m p ⟩
        n + (m + p)
    ∎

*-distrib-+ : ∀ (m n p : ℕ) → (m + n) * p ≡ m * p + n * p
*-distrib-+ zero n p =
    begin
        (zero + n) * p
    ≡⟨⟩
        n * p
    ≡⟨⟩
        zero * p + n * p
    ∎

*-distrib-+ (suc m) n p =
    begin
        (suc m + n) * p
    ≡⟨⟩
        (suc (m + n)) * p
    ≡⟨⟩
        p + ((m + n) * p)
    ≡⟨ cong (p +_) (*-distrib-+ m n p) ⟩
        p + (m * p + n * p)
    ≡⟨ sym (+-assoc p (m * p) (n * p)) ⟩
        (p + m * p) + n * p
    ≡⟨⟩
        (suc m) * p + n * p
    ∎

*-assoc : ∀ (m n p : ℕ) → (m * n) * p ≡ m * (n * p)
*-assoc zero n p = refl
*-assoc (suc m) n p rewrite
      *-distrib-+ n (m * n) p | *-assoc m n p = refl

-- proof small lemmas
n*0≡0 : ∀ (n : ℕ) → n * zero ≡ zero
n*0≡0 zero = refl
n*0≡0 (suc n) = n*0≡0 n

n+n*m≡n*[1+m] : ∀ (n m : ℕ) → n + n * m ≡ n * suc m
n+n*m≡n*[1+m] zero m =
    begin
        zero + zero * m
    ≡⟨⟩
        zero
    ≡⟨⟩
        zero * suc m
    ∎

n+n*m≡n*[1+m] (suc n) m =
    begin
        suc n + suc n * m
    ≡⟨⟩
        suc (n + suc n * m)
    ≡⟨⟩
        suc (n + (m + n * m))
    ≡⟨ cong suc (+-swap n m (n * m)) ⟩
        suc (m + (n + n * m))
    ≡⟨ cong (suc ∘ _+_ m) (n+n*m≡n*[1+m] n m) ⟩
        suc (m + (n * suc m))
    ≡⟨⟩
        suc m + n * suc m
    ≡⟨⟩
        suc n * suc m
    ∎

*-comm : ∀ (m n : ℕ) → m * n ≡ n * m
*-comm zero n = sym (n*0≡0 n)
*-comm (suc m) n =
    begin
        (suc m) * n
    ≡⟨⟩
        n + m * n
    ≡⟨ cong (_+_ n) (*-comm m n) ⟩
        n + n * m
    ≡⟨ n+n*m≡n*[1+m] n m ⟩
        n * (suc m)
    ∎

0∸n≡0 : ∀ (n : ℕ) → zero ∸ n ≡ zero
0∸n≡0 zero = refl
0∸n≡0 (suc n) = refl

∸-+-assoc : ∀ (m n p : ℕ) → m ∸ n ∸ p ≡ m ∸ (n + p)
∸-+-assoc zero n p =
    begin
        zero ∸ n ∸ p
    ≡⟨ cong (flip _∸_ p) (0∸n≡0 n)⟩
        zero ∸ p
    ≡⟨ 0∸n≡0 p ⟩
        zero
    ≡⟨ sym (0∸n≡0 (n + p)) ⟩
        zero ∸ (n + p)
    ∎

∸-+-assoc (suc m) zero p = refl
∸-+-assoc (suc m) (suc n) p = ∸-+-assoc m n p
module plfa.p1.Isomorphism where

import Relation.Binary.PropositionalEquality as Eq
open Eq using (_≡_; refl; cong; cong-app)
open Eq.≡-Reasoning
open import Data.Nat using (ℕ; zero; suc; _+_)
open import Data.Nat.Properties using (+-comm)

--
module plfa.p1.Naturals where


-- # Naturals are inductive datatype #
-- definition of natural number in agda
data ℕ : Set where
    zero : ℕ
    suc : ℕ → ℕ

-- here zero and suc are constructors of the datatype.
-- ! Inductive definition:
--  Base case: zero ∈ ℕ
--  Inductive step: m ∈ ℕ → suc m ∈ ℕ
-- so zero is ∈ ℕ, (suc (suc zero)) is also ∈ ℕ

-- # unpacking the inference rules #
-- inference rule consists:
--      zero or more judgments (hypotheses)
--      -----------------------------------
--      one judgment (conclusion)

-- # use pragma #
--
-- this load N directly use 0, 1 .. as short hand for zero, (succ zero) ..

{-# BUILTIN NATURAL ℕ  #-}


import Relation.Binary.PropositionalEquality as Eq
-- open the module (add names specified in using)
open Eq using (_≡_; refl)
open Eq.≡-Reasoning using (begin_; _≡⟨⟩_; _∎)

-- # Operations on natruals are recursive functions #
-- we use pattern matching when constructors appear on the left hand side of an equation.
_+_ : ℕ → ℕ → ℕ
zero + n = n
(suc m) + n = suc (m + n)
-- the definition of addition is recursive, because
--  add is defined based on definition of add.
--  because the inductive definition of natrual number circularity is not a problem.
--  Larger numbers are defined in terms of smaller numbers (such definition is called well founded).

-- ! Try type hole!

--  dummy case name _ can be reused
_ : 2 + 3 ≡ 5  -- after : is a type.
_ =
    begin
        2 + 3
    ≡⟨⟩     -- is short hand for
        (suc (suc zero)) + (suc (suc (suc zero)))
    ≡⟨⟩     -- inductive case (associativity)
        suc ((suc zero) + (suc (suc (suc zero))))
    ≡⟨⟩     -- inductive case (associativity agagin)
        suc (suc (zero + (suc (suc (suc zero)))))
    ≡⟨⟩     -- base case
        suc (suc (suc (suc (suc zero))))
    ≡⟨⟩     -- is longhand for
        5
    ∎

-- in compact form
_ : 2 + 3 ≡ 5
_ =
    begin
        2 + 3
    ≡⟨⟩
        suc (1 + 3)
    ≡⟨⟩
        suc (suc (0 + 3))
    ≡⟨⟩
        suc (suc 3)
    ≡⟨⟩
        5
    ∎


-- check reflexive
-- agda compute 2 + 3 and compare the value with 5 immediately
-- (a binary relation is reflexive if every value relates to itself)
_ : 2 + 3 ≡ 5
_ = refl

-- ! How does agda run these code?
--  Agda check is each term simplifies to the same value.
--  So you can omit some lines and the whole term is still valid. Extra terms are good for readability.

-- ! 2 + 3 ≡ 5 is a type
-- ! chain of equations are terms of the given type
-- ! you can also think it as:
--      type is the proposition
--      term is the evidence
-- ! This duality is central to how we formalize concepts in Agda.

-- Exercise 3 add 4
_ : 3 + 4 ≡ 7
_ =
  begin
    3 + 4
  ≡⟨⟩
    suc (2 + 4)
  ≡⟨⟩
    suc (suc (1 + 4))
  ≡⟨⟩
    suc (suc (suc (0 + 4)))
  ≡⟨⟩
    suc (suc (suc 4))
  ≡⟨⟩
    7
  ∎


-- # Multiplication #
_*_ : ℕ → ℕ → ℕ
zero * n = zero
(suc m) * n = n + (m * n)

_^_ : ℕ → ℕ → ℕ
m ^ 0 = 1
m ^ 1 = m
m ^ (suc n) = n * (m ^ n)

-- # Monus #
_∸_ : ℕ → ℕ → ℕ
m ∸ zero = m
zero ∸ suc n = zero
suc m ∸ suc n = m ∸ n

_ =
  begin
    3 ∸ 2
  ≡⟨⟩
    2 ∸ 1
  ≡⟨⟩
    1 ∸ 0
  ≡⟨⟩
    1
  ∎

-- # Precedence #
-- provide specific precedence for operators.
--
infixl 6 _+_  _∸_
infixl 7 _*_

-- ! Exercise: Bin
-- A more efficient representation of natural numbers uses a binary rather than
-- a unary system.

data Bin : Set where
  ⟨⟩ : Bin
  _O : Bin → Bin
  _I : Bin → Bin

-- 1001 can be represented as  ⟨⟩ I O O I
inc : Bin -> Bin
inc (⟨⟩) = ⟨⟩ I
inc (n O) = n I
inc (n I) = (inc n) O

-- you can proof this kind of equivalence with refl
-- but it's better to do more practice
inc-case0 : inc (⟨⟩ O) ≡ ⟨⟩ I
inc-case0 = refl

inc-case1 : inc (⟨⟩ I) ≡ ⟨⟩ I O
inc-case1 =
    begin
        inc (⟨⟩ I)
    ≡⟨⟩
        (inc ⟨⟩) O
    ≡⟨⟩
        ⟨⟩ I O
    ∎

inc-case2 : inc (⟨⟩ I O) ≡ ⟨⟩ I I
inc-case2 =
    begin
        inc (⟨⟩ I O)
    ≡⟨⟩
        ⟨⟩ I I
    ∎

inc-case3 : inc (⟨⟩ I I) ≡ ⟨⟩ I O O
inc-case3 =
    begin
        inc (⟨⟩ I I)
    ≡⟨⟩
        (inc (⟨⟩ I)) O
    ≡⟨⟩
        ⟨⟩ I O O
    ∎

to : ℕ → Bin
to 0 = ⟨⟩ O
to (suc n) = inc (to n)

from : Bin → ℕ
from (⟨⟩) = 0
from (n O) = 2 * from n
from (n I) = suc (2 * from n)
module plfa.p1.Relations where

import Relation.Binary.PropositionalEquality as Eq
open Eq using (_≡_; refl; cong)
open import Data.Nat using (ℕ; zero; suc; _+_; _*_)
open import Data.Nat.Properties using (+-comm; +-identityʳ; *-comm; *-identityˡ)

-- Relations --
--  note: {} means n is implicit, which gives us implicit types.
data _≤_ : ℕ → ℕ → Set where
    z≤n : ∀ {n : ℕ} → zero ≤ n
    s≤s : ∀ {m n : ℕ} → m ≤ n → suc m ≤ suc n

infix 4 _≤_

-- definition:
--      base case: ∀ n ∈ ℕ, zero ≤ n holds
--                 (z≤n gives he evidence that it holds)
--      inductive case: ∀ m, n ∈ ℕ, m ≤ n → suc m  ≤ suc n
--                      (s≤s takes evidence that m ≤ n holds
--                       and then gives evidence that suc m  ≤ suc n holds)

-- Implicit arguments --
-- implict arguments don't need to be written explicitly. They are
-- inferred by the typechecker.
_ : 2 ≤ 4
_ = s≤s (s≤s z≤n)   -- 0 ≤ ? → 0 ≤ 2 → 1 ≤ 3 → 2 ≤ 4

-- write the same proof explicitly
_ : 2 ≤ 4
_ = s≤s {1} {3} (s≤s {0} {2} (z≤n {2}))

-- more explicitly
_ : 2 ≤ 4
_ = s≤s  {m = 1} {n = 3} (s≤s {m = 0} {n = 2} (z≤n {n = 2}))

_ : 2 ≤ 4

-- decrease m by 1 until it hits 0.
_ : 5 ≤ 10
_ = s≤s (s≤s (s≤s (s≤s (s≤s z≤n))))

_ : 3 ≤ 10
_ = s≤s {m = 2} {n = 9}
    (s≤s {m = 1} {n = 8}
    (s≤s {m = 0} {n = 7}
    (z≤n {n = 7})))

-- # Inversion #
inv-s≤s : ∀ {m n : ℕ} → suc m ≤ suc n → m ≤ n
inv-s≤s (s≤s m≤n) = m≤n

inv-z≤n : ∀ {m : ℕ} → m ≤ zero → m ≡ zero
inv-z≤n z≤n = refl

-- # Properties of ordering relations #
--     reflexive:       ∀ n. the relation nRn holds
--     transitive:      ∀ m, n. p, (mRn ∧ nRp → mRp)
--     anti-symmetric:  ∀ m, n. mRn ∧ nRm → m ≡ n
--     total:           ∀ m, n. mRn ∨ nRm
-- ! some name for combination of common properties
--     preorder: reflexive and transitive
--     partial order: any preorder that is also anti-symmetric.
--     total order: any parital order that is also total.
--
-- To be preorder you don't need to be an equivalence relation.
--      preorder + | symmetric -> equivalence relation
--                 | antisymmetric -> partial order

-- exercise orderings
-- An example of a preorder that is not a partial order
--    reflexive and transitive relation but not anti-symmetric.
--    tons.
--    e.g
--    1. + (mod n)
--       not anti-symmetric because a + b (mod n) and b + a (mod n)
--       doesn't mean a = b. at all
--    2. The reachability relationship in any directed graph.
--       a can reach b but it's not necessarily for b to go back.
--    3. {(a, a), (a, b), (b, a), (b, b)} as preorder on {a, b}
-- An example of a partial order that is not a total order
--    e.g ⊆
--    It's partial order becauase  if a ⊆ b and b ⊆ a a = b
--    But not all sets are subset of each other. they can be disjoint.

-- Reflexivity --

≤-refl : ∀ {n : ℕ} → n ≤ n
≤-refl {zero} = z≤n
≤-refl {suc n} = s≤s ≤-refl   -- again use inductive hypothesis.


-- ! Transitivity
≤-trans : ∀ {m n p : ℕ} → m ≤ n → n ≤ p → m ≤ p
≤-trans z≤n _ = z≤n
≤-trans (s≤s m≤n) (s≤s n≤p) = s≤s (≤-trans m≤n n≤p)

-- ! Antisymmetry
≤-antisym : ∀ {m n : ℕ} → m ≤ n → n ≤ m → m ≡ n
≤-antisym z≤n z≤n = refl
≤-antisym (s≤s m≤n) (s≤s n≤m) = cong suc (≤-antisym m≤n n≤m)


-- ! Total
-- first let's define what does it mean for a relation to be total
-- if ≤ is total, either m ≤ n or n ≤ m or both.
-- if we can get a instance of the data type defined below, we proved
-- it exists.
data Total (m n : ℕ) : Set where
  forward : m ≤ n → Total m n
  flipped : n ≤ m → Total m n

-- note the above defintion create a datatype with parameter. It's the
-- same as the following indexed type:

data Total' : ℕ → ℕ → Set where
  forward' : ∀ {m n : ℕ} → m ≤ n → Total' m n
  flipped' : ∀ {m n : ℕ} → n ≤ m → Total' m n

-- it's saying, give me any m and n, I can construct either m≤n
-- with is the pattern matching in agda.
-- zero cases are trivial
-- for both arguments are suc, if m n are total, (suc m) (suc n)
-- are total too.
-- It's still a recursive call on ≤-total with m n, which if m n
-- themselves are suc the same branch will be invoke again, until
-- hit one of two base cases.
≤-total : ∀ (m n : ℕ) → Total m n
≤-total zero n = forward z≤n
≤-total (suc m) zero = flipped z≤n
≤-total (suc m) (suc n) with ≤-total m n
... | forward m≤n = forward (s≤s m≤n)
... | flipped n≤m = flipped (s≤s n≤m)


-- equivalent to this.
-- just define a helper for pattern matching.
≤-total' : ∀ (m n : ℕ) → Total m n
≤-total' zero n = forward z≤n
≤-total' (suc m) zero = flipped z≤n
≤-total' (suc m) (suc n) = go (≤-total' m n)
  where
    go : Total m n → Total (suc m) (suc n)
    go (forward m≤n) = forward (s≤s m≤n)
    go (flipped m≤n) = flipped (s≤s m≤n)


-- Monotonicity --
-- is an operator monotonic with regard to the ordering?
-- e.g is + monotonic over ≤?

-- given ordering for terms on the right side.
+-monoʳ-≤ : ∀ (n p q : ℕ)
  → p ≤ q
  -----
  → n + p ≤ n + q
+-monoʳ-≤ zero p q p≤q = p≤q
+-monoʳ-≤ (suc n) p q p≤q = s≤s (+-monoʳ-≤ n p q p≤q)

-- given ordering for terms on the left side, use associativity
-- and rewrite to simplify.
+-monoˡ-≤ : ∀ (m n p : ℕ)
  → m ≤ n
  -----
  → m + p ≤ n + p
+-monoˡ-≤ m n p m≤n rewrite +-comm m p | +-comm n p = +-monoʳ-≤ p m n m≤n

+-mono-≤ : ∀ (m n p q : ℕ)
  → m ≤ n
  → p ≤ q
  -----
  → m + p ≤ n + q
+-mono-≤ m n p q m≤n p≤q = ≤-trans (+-monoˡ-≤ m n p m≤n) (+-monoʳ-≤ n p q p≤q)

-- prove multiplication is also monotonic over ≤.
-- base case is trivial. works in a ring everything times 0 is 0.
-- inductive step. We need to somehow express multiplication in ordering even it's
-- constructor is defined with suc only.
-- we reuse monotonic + to generate the ≤ relation.
-- p + (n * p) ≤ q + (n * q) => n * p ≤ n * q ?
*-monoʳ-≤ : ∀ (n p q : ℕ) → p ≤ q → n * p ≤ n * q
*-monoʳ-≤ zero _ _ _ = z≤n
*-monoʳ-≤ (suc n) p q p≤q = +-mono-≤ p q (n * p) (n * q) p≤q (*-monoʳ-≤ n p q p≤q)

*-monoˡ-≤ : ∀ (m n p : ℕ) → m ≤ n → m * p ≤ n * p
*-monoˡ-≤ m n p m≤n rewrite *-comm m p | *-comm n p = *-monoʳ-≤ p m n m≤n

*-mono-≤ : ∀ (m n p q : ℕ) → m ≤ n → p ≤ q → m * p ≤ n * q
*-mono-≤ m n p q m≤n p≤q = ≤-trans (*-monoˡ-≤ m n p m≤n) (*-monoʳ-≤ n p q p≤q)


-- strict inequality --

infix 4 _<_

data _<_ : ℕ → ℕ → Set where
  z<n : ∀ {n : ℕ} → zero < suc n
  s<s : ∀ {m n : ℕ} → m < n → suc m < suc n

data _>_ : ℕ → ℕ → Set where
  s>z : ∀ {n : ℕ} → suc n > zero
  s>s : ∀ {m n : ℕ} → m > n → suc m > suc n

-- for indexed type you don't need to write the name anyway.
<-trans : ∀ {m n p : ℕ} → m < n → n < p → m < p
<-trans z<n (s<s n<p) = z<n
<-trans (s<s m<n) (s<s n<p) = s<s (<-trans m<n n<p)

-- trichotomy
-- if there is a property you want to prove, define what it is
-- as a data type and construct an instance of it!
data Trichotomous (m n : ℕ) : Set where
  tri< : m < n → Trichotomous m n
  tri≡ : m ≡ n → Trichotomous m n
  tri> : m > n → Trichotomous m n

-- another interpretation of the proving mechanism is:
--  we try to construct a instance of Trichotomous, to do that
--  we recursively call <-trichotomy m n.
--  if it terminates, which it does, we get a instance of the smaller
--  proof. Then we use that to construct the actual proof (the instance)
<-trichotomy : ∀ (m n : ℕ) → Trichotomous m n
<-trichotomy zero zero = tri≡ refl
<-trichotomy zero (suc n) = tri< z<n
<-trichotomy (suc m) zero = tri> s>z
<-trichotomy (suc m) (suc n) with <-trichotomy m n
... | tri< m<n = tri< (s<s m<n)
... | tri≡ m≡n = tri≡ (cong suc m≡n)
... | tri> m>n = tri> (s>s m>n)

+-monoʳ-< : ∀ (n p q : ℕ) → p < q → n + p < n + q
+-monoʳ-< zero p q p<q = p<q
+-monoʳ-< (suc n) p q p<q = s<s (+-monoʳ-< n p q p<q)

+-monoˡ-< : ∀ (m n p : ℕ) → m < n → m + p < n + p
+-monoˡ-< m n p m<n rewrite +-comm m p | +-comm n p = +-monoʳ-< p m n m<n

+-mono-< : ∀ (m n p q : ℕ) → m < n → p < q → m + p < n + q
+-mono-< m n p q m<n p<q = <-trans (+-monoˡ-< m n p m<n) (+-monoʳ-< n p q p<q)

≤-implies-< : ∀ {m n : ℕ} → suc m ≤ n → m < n
≤-implies-< (s≤s z≤n) = z<n
≤-implies-< (s≤s (s≤s n)) = s<s (≤-implies-< (s≤s n))

<-implies-≤ : ∀ {m n : ℕ} → m < n → suc m ≤ n
<-implies-≤ z<n = s≤s z≤n
<-implies-≤ (s<s n) = s≤s (<-implies-≤ n)

-- Even and odd --
-- we are using overload constructor here. Constructor names can conflict with
-- different types.
data even : ℕ → Set
data odd : ℕ → Set

data even where
  zero : even zero
  suc : ∀ {n : ℕ} → odd n → even (suc n)

data odd where
  suc : ∀ {n : ℕ} → even n → odd (suc n)

-- corecursive
o+e≡o : ∀ {m n : ℕ} → odd m → even n → odd (m + n)
e+e≡e : ∀ {m n : ℕ} → even m → even n → even (m + n)

e+e≡e zero n = n
e+e≡e (suc m) n = suc (o+e≡o m n)

o+e≡o (suc m) n = suc (e+e≡e m n)

o+o≡e : ∀ {m n : ℕ} → odd m → odd n → even (m + n)
o+o≡e .{suc m} {n} (suc {m} em) on rewrite +-comm m n = suc (o+e≡o on em)

data Bin : Set where
  ⟨⟩ : Bin
  _I : Bin → Bin
  _O : Bin → Bin

inc : Bin → Bin
inc (⟨⟩) = ⟨⟩ I
inc (n O) = n I
inc (n I) = (inc n) O
module Clean where

import           System.Directory
import           Control.Monad
import Data.Foldable

main :: IO ()
main =  getCurrentDirectory >>= getDirectoryContents >>= \xs -> do

  let xs' = do
      x <- xs
      case x of
        "Clean.hs" -> mempty
        "." -> mempty
        ".." -> mempty
        ".exrc" -> mempty
        other -> case dropWhile (/= '.') other of
                   ".alg" -> mempty
                   ".md" -> mempty
                   _ -> return x

  for_ xs' (\x -> removeFile x)
{-# LANGUAGE BinaryLiterals #-}

module AES where

import Data.Bits
import Data.Maybe
import Data.List

-- baby AES
--
-- AES is designed to replace DES.
-- DES had US government involved, and the implementation was not transparent,
-- which makes the security of the cryptosystem questionable.
-- Also DES has a small number of possible key, so it's actually vulnerable over
-- exthausted key search.
-- while AES has public implementation that everybody can study it. Also AES has
-- much larger number of keys, which makes it much more secure.
-- So far there is no report of successful attack againt AES.

-- A baby AES: simple ASE that you can write in couple lines.
-- Steps:
-- BytesSub.
--  A nonlinear substitution is performed on each entry of the matrix. This is constructed
--  by first computing the inverse of each entry as an element of F256, and then temporarily
--  treating each entry as a vector in Z(8, 2) and performing an affine transformation on it.
--  this is the only part of the encryption algorithm which is not just a computation over
--  F256, which helps break up the simple algebraic structure of the cryptosystem and makes it
--  resistant to certain kinds of cryptanalytic attacks.
--
-- ShiftRows.
--  The entries in each row are cyclically shifted a certain number of spaces to the right
--  this is done because all of other steps are only performed in individual columns, so this
--  step breaks up and mixes columns together.
--
-- MixColumns.
--  This is the big diffusion step. The 4x4 matrix is multiplied by another fixed matrix.
--  with all computation over F256.
--
-- AddRoundKey.
--  4x4 round key matrix is derived from theecret master key and just added (bitwise) to the
--  matrix
--
-- The process is repeated in 10 rounds to finally encrypt the block.

-- baby AES

-- field table with p(x) = x^4 + x + 1
fieldTableF16 =
  [ 0b0001,
    0b0010,
    0b0100,
    0b1000,
    0b0011,
    0b0110,
    0b1100,
    0b1011,
    0b0101,
    0b1010,
    0b0111,
    0b1110,
    0b1111,
    0b1101,
    0b1001
  ]

byteSubM =
  [ [1, 0, 1, 1],
    [1, 1, 0, 1],
    [1, 1, 1, 0],
    [0, 1, 1, 1]
  ]
module DiffieHellman where

dhsend :: Integer -> Integer -> Integer -> (Integer -> Integer)
dhsend p g a = \b -> (g ^ a ^ b) `mod` p

-- we both have g, the primitive element being 5.

-- me send you
-- I pick a = 6
r = dhsend 23 5 6 1

-- you send me
-- you pick a = 9
s = dhsend 23 5 9 1

-- I receive yours as 11
k1 = (s ^ 6) `mod` 23


-- notice if I call dhsend 23 5 6 s it will hang.
-- but we can rely on the fact we are working on a ring and can
-- reduce large number to smaller one, ((g^a) mod p)^b mod p takes
-- much less computation.
{-# LANGUAGE CPP #-}

module Affinecipher where

import           Data.Maybe
import           Prelude    hiding (gcd)

-- create a ring of integer modular n.
zn :: Integer -> [Integer]
zn n = take (fromInteger n) [0 .. n -1]

type Col = (Integer, Integer, Integer, Integer)

extendedEuclidean' :: Col -> Col -> (Integer, Integer)
extendedEuclidean' (_, _, s, t) (_, 0, _, _) = (s, t)
extendedEuclidean' (_, r, s, t) (q', r', s', t') =
  let c1 = (q', r', s', t')
      c2 = let r'' = r - q' * r'
            in (r' `div` r'', r'', s - q' * s', t - q' * t')
   in extendedEuclidean' c1 c2

extendedEuclidean :: Integer -> Integer -> (Integer, Integer)
extendedEuclidean a b = extendedEuclidean' (undefined, a, 1, 0) (a `div` b, b, 0, 1)

gcd :: Integer -> Integer -> Integer
gcd a b =
  let (s, t) = extendedEuclidean a b
   in a * s + b * t

-- we want to find a, b in Zn,  (a, b) = k, gcd(a, n) = 1
-- why do we want that? because in a commutative ring Zn if you have a with
-- gcd(d, n) = 1, it just saying a is an unit with inverse.
-- we don't really care about the gcd = 1 part, but we need a to be invertable.
ekgen :: Integer -> Integer -> Integer -> Maybe (Integer -> Integer)
ekgen a b n
  | gcd a n /= 1 = Nothing
  | otherwise = Just $ \x -> (a * x + b) `mod` n

-- solve y = ax + b
-- x = a'(y - b)
-- first compute inverse
dkgen :: Integer -> Integer -> Integer -> Maybe (Integer -> Integer)
dkgen a b n
  | gcd a n /= 1 = Nothing
  | otherwise = Just $ \y ->
    let (a', _) = extendedEuclidean a n
     in (a' * (y - b)) `mod` n

z26 = zn 26

ek26 = fromJust $ ekgen 11 4 26
dk26 = fromJust $ dkgen 11 4 26

#ifdef TEST

plaintext = [15, 4, 4, 15, 4, 4, 15, 14, 14, 15, 14, 14]
ciphertext = ek26 <$> plaintext
decryptedtext = dk26 <$> ciphertext

#endif

-- how many possible a?
-- recall Zn is a ring, we need gcd(a, n) = 1 means we want a to be
-- an unit.
-- it's just |Zn*| = ϕ(n)

-- cryptanalysis of affine cipher.
-- affine cipher is a linaer cipher, which makes it very vulnerble over plain
-- text attack.
-- if we known several plain text, we can make a system equations and just solve them.
module Bezouts where

-- gcd(a, b) = ax + yb
-- or the greatest common divisor of a and b can be written as the
-- integer linear combination of a and b.

-- nothing to implemnet really. it's already used in euclidean algorihthm
module BlockCipher where

-- block cipher
-- F(n, p) is a vector space, because Zp is a field
-- Z(n, m) is not necessarily a vector space.
--
-- But turns out it still have some properties of a vector space.
-- You can calculate the inverse of a matrix in Z(n, m). In a vector space
-- a matrix M has inverse iff det(M) != 0.
--
-- But in a ring it becomes det(M) is a unit of the ring.
-- Which makes perfect sense because it's exactly the same thing as saying
-- it's not zero in a field, since all elements in a field is non zero.
--
-- in a 'semi vector space' Z(n, m), we have matrix M invertable iff det(M) is a unit
-- in Zm, iff gcd(det(M), m) = 1.
--
-- Another way to phrase it is:
--  if M h has inverse matrix, det(M) must have inverse in the ring Zm.

-- hill cipher is a block cipher, meaning you encrypt a block of text at a time.
module ChineseRemainder where

-- solving system of congruences.
module CongruenceEquation where
module ContinuedFraction where
{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeFamilies #-}

module EuclideanAlgorithm where

-- euclidean algorithm in abstract algebra.
-- https://www.math.cmu.edu/~bkell/21110-2010s/extended-euclidean.html

-- Simple euclidean algorithm to compute greatest common divisor --
euclideanGCD :: Integer -> Integer -> Integer
euclideanGCD a 0 = a
euclideanGCD a b = euclideanGCD b (a `mod` b)

-- a and b are coprime if gcd(a, b) = 1 --
isCoprime :: Integer -> Integer -> Bool
isCoprime a b = 1 == euclideanGCD a b

class Monoid r => Group r where
  invA :: r -> r -- additive inverse

-- define another monoid on top of the group
class (Monoid r) => Ring r where
  (<@>) :: r -> r
  rempty :: r -- 1

-- ring --
-- a ring with no zero divisor. All fields are integral domain
-- think of the ring of integer. ab = 0 ⇔ a = 0 or b = 0
-- counter example: field R₆ is not an integral domain.
--    3 * 2 ≡ 0 (mod 4)

-- an invertible element in commutative ring is called unit.
-- an ideal of a ring is a subset of the ring if it's an additive sub group
-- that any element mutiply with e in the entire ring will still be in the
-- subgroup.
class Ring r => CommutativeRing r where
  type Ideal r
  isUnit :: r -> Bool
  leftIdealMul :: Ideal r -> r -> Ideal r
  rightIdealMul :: r -> Ideal r -> Ideal r
  generateIdeal :: r -> Ideal r -> [Ideal r]

class CommutativeRing r => IntegralDomain r

-- PID is an integral domain with it's ideals to be principle. (Can be
-- generated by a single element)
-- A ring has multiple ideals, a pid has all these ideals being able to
-- be generated by an element in those ideals.
-- Think about 1*n, 2*n in Z.
-- 1, 2 are elements that generate each ideals.
--
-- integral domain helps us to define division.
-- a | b: exists k s.t a = bk
-- bk is a factorization of x.
--
-- Note: unit refer to 1 in ring of integers.
class IntegralDomain r => PrincipleIdealDomain r

-- Integral domain defines division. Thus we have factorization.
-- If all elements have unique factorization, then we have unique
-- factorization domain.
class IntegralDomain r => UniqueFactorizationDomain r where
  isIrreducible :: r -> Bool
  factorize :: r -> [r]

-- An euclidean domain needs to be an integral domain first.
-- each ideal in euclidean domain is principle.
class (IntegralDomain r, UniqueFactorizationDomain r, PrincipleIdealDomain r) => EuclideanDomain r where
  euclidean :: r -> r -> r

-- integral domain and euclidean domain are somewhere between a ring and
-- A field is always a
class EuclideanDomain r => Field r where
  invM :: r -> r -- multiplicative inverse

-- bezouts theorem
-- gcd(a, b) = xa + yb
-- gcd can be written as linear combination of a and b.

-- use bezouts theorem and extended euclidean algorithm to solve
-- multiplicative inverse of integer modulo n.

-- first see a simple modulo arithmetics:
-- a ≡ b (mod n)
-- so a - b = nx
-- so a = nx + b
-- or p = nq + r
-- in another word, n | a - b
data Congruence = Cong Integer Integer Integer
  deriving (Show)

congruence :: Integer -> Integer -> Integer -> Maybe Congruence
congruence a b n
  | (a - b) `mod` n == 0 = Just (Cong a b n)
  | otherwise = Nothing

cong1 = congruence 4 1 3

-- and if a is a product of two numbers, we have
-- ax ≡ b (mod n)
-- so ax - b = ny
-- so b = ax - ny
-- written as b = ax + ny

-- extended euclidean algorithm:
--  if we keep track of more information of the naive euclidean algorithm, we can
--  compute the gcd as an integer linear combination of two numbers.
--    gcd(a, b) = n = xa + yb
--
-- The main idea is at

-- easily computed with the table.
--  q   r   s   t
--  --------------
--      a   1   0
--  q1  b   0   1
--  q2
--      ...
-- stop when r = 0

type Col = (Integer, Integer, Integer, Integer)

extendedEuclidean' :: Col -> Col -> (Integer, Integer)
extendedEuclidean' (_, _, s, t) (_, 0, _, _) = (s, t)
extendedEuclidean' (_, r, s, t) (q', r', s', t') =
  let c1 = (q', r', s', t')
      c2 =
        let r'' = r - q' * r'
         in (r' `div` r'', r'', s - q' * s', t - q' * t')
   in extendedEuclidean' c1 c2

extendedEuclidean :: Integer -> Integer -> (Integer, Integer)
extendedEuclidean a b = extendedEuclidean' (undefined, a, 1, 0) (a `div` b, b, 0, 1)

-- When gcd(a, b) = 1, or a, b are coprime, we have
-- 1 = xa + yb.
--
-- given a, we want to find a inverse:
--   a . a¯¹ ≡ 1 (mod b)
-- ⇔ a . a¯¹  ≡ 1 (mod b)
-- ⇔ 1 = a.a¯¹ + by
-- a, b are known, but a¯¹ and y are not known.
-- we want to solve this integer linear combination to get a¯¹.
-- 50 (mod 71), what's the inverse?

congInv :: Integer -> Integer -> Integer
congInv a n = snd (extendedEuclidean a n)

-- R*, or U(R), is the set of all invertible elements in ring R.
-- An example: U(Z) = {1, -1}
-- so in ring of integers, only 1 and -1 have multiplicative inverse.
-- note all elements have additive inverse because to be a ring it needs to be
-- a group at the first place.
module FiniteField where

-- polynomial ring.
--

class Monoid r => Group r where
  invA :: r -> r -- additive inverse

class (Monoid r) => Ring r where
  (<@>) :: r -> r -> r
  rempty :: r -- 1

class Ring r => CommutativeRing r

-- recall:
-- polynomial ring R[x] is a ring of polynomials with coefficient
-- from R.
--
-- quotient polynomial ring F[x]/(f(x)) is the polynomial modulo
-- f(x).
--
-- if f(x) is irreducible, we have F[x] is a field
-- This makes a analoguos with ring of integer Z.
-- First of all Zn is a ring.
-- if for Zp, p is prime, Zp is a field.

-- recall
-- given ring R, the set of all units is called R*
-- it happen to be a group called multiplicative of units R*.

-- finite fields --
--
-- -- multiplication in a field has inverse for all non zero
-- elements, so (F \ {0}, *) forms a group --
-- -- multiplicative group of a finite field is cyclic, that is
-- it can generate all non zero elements --
--
-- So for field F[x]/(f(x)), exists exists a polynomial x
-- that it's power generate the entire field.
-- If that's the case, we call f(x) a primitive polynomial
-- x, as the primitive element of the
data Bin = O | I deriving (Show, Enum)

-----------------------------------------------------------
-- what makes Zp[x]/(f(x)) a finite field?
-- 1. p is prime
-- 2. f(x) is irreducible
-- => we can construct a finite field Zp[x]/(f(x))
--
-- It's a set of all polynomial in Zp[x] with degree < deg(f(x))
-- = { a0 + a1x + a2x^2 + ... + an-1x^n-1 | a in Zp}.
-- We have p choices for all n coefficients.
--
-- So |Zp[x]/(f(x))| = p^n

-----------------------------------------------------------
-- for Zp[x]/(f(x)), we need p be a prime and f(x) be irreducible
-- Why do we need 2 constraints here?
--
-- 1. p be prime:
--    so Zp is a field. Then Zp[x] is a field.
-- 2. f(x) be irreducible:
--    If we just work with Zp[x], we can't have the field finite, becase
--    multiplying two polynomials increase the degree.
--    f(x) is used to constrain the degree.
--
--    how to constrain the

-----------------------------------------------------------
-- General facts about finite fields.
--
-- - The size of any finite field is a prime power.
--
-- - all finite field F with p^n elements is isomorphic to Zp[x]/f(x)
--
-- - for every prime p and n >= 1, there exists a field of order p^n
module PolynomialRing where

-- polynomial ring.

class Monoid r => Group r where
  invA :: r -> r -- additive inverse

class (Monoid r) => Ring r where
  (<@>) :: r -> r -> r
  rempty :: r -- 1

class Ring r => CommutativeRing r

class CommutativeRing r => IntegralDomain r

class IntegralDomain r => PrincipleIdealDomain r

class IntegralDomain r => UniqueFactorizationDomain r where
  isIrreducible :: r -> Bool
  factorize :: r -> [r]

class (IntegralDomain r, UniqueFactorizationDomain r, PrincipleIdealDomain r) => EuclideanDomain r where
  euclidean :: r -> r -> r

data Bin = O | I deriving (Show, Enum)

type Polynomial r = ([r], [r])

pow :: Ring r => r -> Integer -> r
pow r 0 = r
pow r n = pow (r <@> r) (n - 1)

-----------------------------------------------------------
-- define polynomial as dot product
-- [a b c] [1 0 1]
polynomial :: (Eq r, Ring r) => [r] -> [r] -> Polynomial r
polynomial _ xs | any (\x -> x /= mempty || x /= rempty) xs = error "wrong ploy"
polynomial as xs = (as, xs)

-- to evaluate a polynomial.
-- p(x) = ao + a1x + a2x^2 + a3x^3 ... + anx^n
eval :: Ring r => Polynomial r -> r
eval (as, xs) = mconcat (zipWith3 term as xs [0 ..])
  where
    term :: Ring r => r -> r -> Integer -> r
    term a x d = a <@> pow x d

-- We can prove if R is a ring, then it's polynomial ring R[x] is also a ring.
-- simply write out the full form, assume p(x) and q(x) are not zero polynomial, and
-- see if tehre product are non zero polynomial.

-----------------------------------------------------------
-- Notice,
-- the idea of irreducible elements in an integral domain means x = yz where either
-- y or z is an unit.
-- where unit is an element in ring R with multiplicative inverse. that is, ax = 1
--
-- Note, in polynomial rings, if g(x) = p(x)q(x)
--  deg(g(x)) = deg(p(x)) + deg(q(x))
-- So the only possible factors for irreducible polynomial is itself and the constant
-- polynomial.
--
-- also because we can always factoring out the constant polynomial, we can assume
-- poynomial are monic, that is, the leading coefficient is 1.

-----------------------------------------------------------
-- What are values in a polynomial ring?
-- 1. constant are polynomials too
-- 2. x is a polynomial
-- 3. 0 is the zero polynomial

-----------------------------------------------------------
-- if for R[x], R is a field, call it F with identity 1.
-- then units of F[x] can only be constant polynomial, because only constant polynomial
-- will multiple to yield one.
--
-- because for a field all non zero elements are units, so for F[x] all non constant
-- polynomials are unit.
-- Or in another word, polynomials with degree larger than one can't be unit
--
-- That means, the only possible factors of an irreducible polynomial are non zero constants.
-- e.g (x^2 - 2) is irreducible over Q[x] = 1 . (x^2 - 2)

-----------------------------------------------------------
-- concept:
-- A polynomial f(x) has a linear (degree 1) factor (x - a) iff p(a) = 0.

-----------------------------------------------------------
-- ring of integer Z and Polynomial over field F F[x] --
-- Ring of integer: Z  and
-- polynomial over field F F[x]
-- has similar algebraic properties.
--
--    Z                               F[x]
--  - they are both integral domain and euclidean domains.
--  - so no zero divisor, we can define division on them.
--  Z is integral domain           f[x] is integral domain
--  and euclidean domain           and euclidean domain
--
--  - division algorithm works (corollary from the first one.)
--  a = bq + r o <= r < |b|        a(x) = b(x)q(x) + r(x), 0 <= deg(r(x)) < deg(b(x))
--
-- - units
-- U(Z) = {1, -1}                  U(F[x]) = F* = {nonzero constant polynomials}
--
-- - ring of x mod n
-- Zn = Z/nZ ring of integer mod n F[x]/(f(x)) = ring of polynomial mod n
--
-- - prime and irreducible makes a field
-- p prime <=> Zp is a field       f(x) irreducible <=> F[x]/(f(x))l is irreducible.


-----------------------------------------------------------
-- generator polynomial and ideal

-----------------------------------------------------------
-- every euclidean domain is a principle ideal domain.
-- meaning, all ideals has a generator polynomial
-- meaning, exists a generator polynomial that repeately multiple itself generate
--          the entire ideal
-- little utility for doing the assignment.
module ShiftCipher where

import Data.Foldable
import Data.List

c = "ufimeftqnqefarfuyqeufimeftqiadefarfuyqe"

toZn :: Char -> Int
toZn c = fromEnum c - fromEnum 'a'

toChar :: Int -> Char
toChar n = toEnum (n + fromEnum 'a')

shift :: Int -> Char -> Char
shift n c = toChar $ (toZn c + n) `mod` 26

decipher :: [[Char]]
decipher = [shift n <$> c | n <- [1 ..]]

main :: IO ()
main = do
  traverse_ putStrLn (take 16 decipher)
  putStrLn "=="
  putStrLn $ decipher !! 13
module Sums where

import           Prelude hiding (sum)

-- sum of sequence
-- n
-- ∑ x^k
-- x=1

sum :: Foldable f => Num a => f a -> a
sum = foldr (+) 0

-- 1 + 2 + .. + n
sum1 n = (n * (n + 1)) / 2
sum2 n = (n * (n + 1) * (2 * n - 1)) / 6

-- arithmetic progression
arithProgress :: Int -> Int -> [Int]
arithProgress start step = start : arithProgress (start + step) step

sumArithProgress1 start end step = let n = (start - end) / step
                                    in (n * (start + end)) / 2
module Bellnumber where

-- the number of partitions of a set.
module BernouliNumber where
module Binomial where
module CantorExpansion where

-- cantor expansion of a number.
module Catalan where

-- https://www.youtube.com/watch?v=GlI17WaMrtw
-- https://en.wikipedia.org/wiki/Catalan_number

-- catlan number
--
-- n: 0   1   2   3   4   ...
-- C: 1   1   2   5   14
--
-- Definition:
--           1     (2n)     (2n)!
--    Cₙ = ------- (  )  = -------   for n >= 0.
--          n + 1  ( n)    (n+1)!n!
--
-- Propety:
--         (2n)   (2n )       1    (2n)
--    Cₙ = (  ) - (   ) =  ------- (  )
--         ( n)   (n+1)     n + 1  ( n)
--
-- One application is to count the number of possible evaluation order of
-- associative binary operations, e.g how many ways to parenthesis a chain of
-- binops.

factCPS :: Int -> (Int -> Int) -> Int
factCPS n k
  | n == 1 = k 1
  | otherwise = factCPS (n - 1) (\x -> k (x * n))

factorial :: Int -> Int
factorial = flip factCPS id

-- we can prove that a catalan number is always an integer.

catalan :: Int -> Int
catalan n = fromIntegral divident `div` fromIntegral divisor
  where
    divident = factorial (2 * n)
    divisor = factorial (n + 1) * factorial n

catalanNumbers = [catalan n | n <- [1 .. 10]]
module EulersTheorem where


module HamiltonCycles where
module Permutation where

module PigeonholePrinciple where

module StirlingNumber where

;;;; it's usually doesn't worth it to use merge sort for small list.
;; The mit algo book says the constant factor makes it not worth it, but
;; I can't find the constant part from the running time analysis.
;; Although the best case for insertion sort is θ(n), but we can't rely on
;; the best case.
;; The more convincible explaination is recursive algorihtm needs to allocate
;; extra stack frame, the allocation step makes it slower.
;; Consider a list with size n. For an insertion sort, it either swap
;; it's element or not, it's really constant time. If you use merge sort
;; you need to split the list into two lists with only one input and merge them.
;; that makes it slower.

;; Normally we perform some cut off on merge sort, as when n is smaller then
;; certain threshold we switch to insertion sort to get the best of both world.

;; we need an mutation based insertion sort that can sort any part of a list
(defun insertion-sort (xs p q)
  (declare (type sequence xs)
           (type integer p q))
  (let* ((key 0))
    (loop for j from (+ p 1) to q
          for i = (- j 1) do
          (setf key (elt xs j))
          (loop while (and (>= i p)
                           (> (elt xs i) key)) do
                (setf (elt xs (+ i 1)) (elt xs i))
                (decf i))
          (setf (elt xs (+ i 1)) key)))
  xs)

(defun merge-* (xs p q r)
  (declare (type sequence xs)
           (type number p q r))
  (let* ((n1 (+ (- q p) 1))
         (n2 (- r q))
         (lhs (loop for i from 0 to n1
                    if (= i n1) collect most-positive-double-float
                    else collect (elt xs (+ p i))))
         (rhs (loop for j from 0 to n2
                    if (= j n2) collect most-positive-double-float
                    else collect (elt xs (+ (+ q j) 1))))
         (i 0)
         (j 0))
    (loop for k from p to r do
          (if (<= (elt lhs i) (elt rhs j))
              (progn
                (setf (elt xs k) (elt lhs i))
                (incf i))
              (progn
                (setf (elt xs k) (elt rhs j))
                (incf j)))))
  xs)

(defun merge-sort-* (xs p r)
  (declare (type sequence xs)
           (type number p r))
  (let* ((q 0))
    (if (< p r)
        (if (> (- r p) 5)   ;; merge sort for large n
            (progn
              (setf q (floor (/ (+ p r) 2)))
              (merge-sort-* xs p q)
              (merge-sort-* xs (+ q 1) r)
              (merge-* xs p q r))
            (insertion-sort xs p r))))  ;; insertion sort for small n
  xs)

(defun merge-sort (xs)
  (declare (type sequence xs)
           (type number p r))
  (merge-sort-* xs 0 (- (length xs) 1)))

(let ((xs '(908 23 24 189 890 9734 310 904 8 293 3 43 45 2 3 423 4)))
  (merge-sort xs))
;; break up multiplication
;; formulate mulitplication as a divide and conquer
;; problem


;; Spliting an integer into two parts.
;; [x1 x2 ... xn] = [x1 x2 x3 ... xn/2] * 10^n/2 = [xn/2+1 xn/2+2 ... xn]
;; xy = (a*10^n/2 + b)(c * 10 n/2 + d)
;;    = (ac)10^n + (ad + bc)10n/2 + db
;; note, a, b, c, d all have n/2 digits, so n/2 input
;; we need 4 smaller multiplication to calculate the problem.
;; This forms a recursion tree.


(defstruct splited
  (a 0 :type integer)
  (b 0 :type integer)
  (n/2 0 :type integer))


(defun chop (x)
  (let* ((xstr (write-to-string x))
         (n/2 (floor (length xstr) 2))
         (a (parse-integer (subseq xstr 0 n/2)))
         (b (parse-integer (subseq xstr n/2 (length xstr)))))
    (make-splited :a a :b b :n/2 n/2)))


(defun mult-chopped (x y)
  (let* ((x1 (chop x))
         (y1 (chop y))
         (a (splited-a x1))
         (b (splited-b x1))
         (c (splited-a y1))
         (d (splited-b y1))
         (n/2 (splited-n/2 x1)))
    (if (not (= (splited-n/2 x1)
                (splited-n/2 y1)))
        (error "only support multiplying two number with the same # of digits"))
    (+ (* a c (expt 10 (* 2 n/2)))
       (* (+ (* a d) (* c b)) (expt 10 n/2))
       (* b d))))
;; We use order of growth of the running time of an algorithm to determine
;; it's complexity. (Asymptotic analysis)
;; This approach simplify the work of analyzing algorithm significantly.

;;;; Θ notation ;;;;
;;  Θ(g(n)) = { f(n) | ∃c₁, c₂ ∈ ℤ⁺ st
;;                     0 ≤ c₁g(n) ≤ f(n) ≤ c₂g(n) ∀ n ≥ n₀ }
;;  we say g(n) is an asymptotic tight bound of f(n)

;;;; O notation ;;;;
;;  O(g(n)) =  { f(n) | ∃c, n₀ st 0 ≤ f(n) ≤ cg(n) ∀ n ≥ n₀ }
;;  cg(n) is the upper bound of f(n)

;;;; Ω notation ;;;;
;; Ω(g(n)) = { f(n) | ∃c, n₀ st o ≤ cg(n) ≤ f(n) ∀ n ≥ n₀ }
;; cg(n) is the lower bound of f(n)

;;;; Them.1 f(n) == Θ(g(n)) ⇔ f(n) = O(g(n)) ∧ f(n) = Ω(g(n))
;; If cg(n) can bound f(n) above, then they must growth in the same rate.
;; because if f(n) growth faster, eventually it will be larger.
;; it's the same for cg(n) bound f(n) below.
;; so if g(n) can bound both above and below, apparently f(n) is bounded
;; by g(n). So we can analyse the complexity of f(n) by analysing g(n)

;;;; interpretation ;;;;
;; 2n² + 3n + 1 =
;; 2n² + θ(n) =
;; θ(n²)
;; read as
;; ∃ f(n) ∈ θ(n) st 2n² + 3n + 1  = 2n² + f(n)
;; ∃ g(n) ∈ θ(n²) st 2n² + f(n) = g(n)

;;;; little o
;; O(g(n)) can be not asymptotically tight. We can denote all upper bound that's not
;; asymptotically tight as o(g(n))
;; e.g 2n = o(n²), but 2n ≢ o(n).
;;;; little ω is the same concept.

;;;; exponential function grows faster then polynomial function.

;;;; Super slow growth function, iterated logrithm
;; lg*n = min {i ≥ 0 | lgⁱn ≤ 1}

;;;; How to obtain the order of growth of recurrences algorithm? ;;;;
;; three methods to find complexity of recurrence algo.
;; 1. substitition method
;; 2. recursion tree method
;; 3. master method

;;;; Substitution method
;; 1. guess a bound
;; 2. prove the bound with math induction.
;;    - you need to find a proper base case first.
;;    - this process is pretty heuristic based.

;;;;  Recursion tree
;; 1. draw the tree and do some sloppy analysis to yield a good guess.
;; 2. use substitution method to proof the guess.

;;;; Master method T(n) = aT(n/b) + f(n)  *
;; just apply three cases
;; T(n) = aT(n/b) + f(n)

;;                  log'b(a) - ε                     log'b(a)
;; case1: f(n) = O(n),  ε > 0           ⇔  T(n) = θ(n)

;;                  log'b(a)                         log'b(a)
;; case2: f(n) = O(n)                   ⇔  T(n) = θ(n          . lg(n))

;;                  log'b(a) + ε
;; case3: f(n) = O(n),   ε > 0          ⇔  T(n) = θ(f(n))
;;                   ,  af(n/b) ≤ cf(n)
;;                      for c < 1
;;                      and n large enough

;; Example
;; 1. T(n) = 9T(n/3) + n:
;;  a = 9, b = 3, f(n) = n
;;
;;   log'3(9)
;;  n         = θ(n²)
;;                     log'3(9) - ε
;;  we find f(n) = O(n             ) where ε = 1
;;  so we can apply case 1 of master theorem.
;;
;;            log'3(9)
;;  T(n) = θ(n        )  = θ(n²)
;; complexity of insertion sort 2.2

;; input: (a1, a2, ..., an)
;; output: permutation of input that (a1', a2', ..., an'), s.t
;;         a1' <= a2' ... <= an'


(defun insertion-sort (xs)
  (declare (type sequence xs))
  (let* ((bound (- (length xs) 1))
         (key 0))
    (loop for j from 1 to bound   ;; picking a card
          for i = (- j 1) do
          (setf key (elt xs j))
          ;; insetion part
          (loop while (and (>= i 0)
                           (> (elt xs i) key)) do
                (setf (elt xs (+ i 1)) (elt xs i))
                (decf i))
          (setf (elt xs (+ i 1)) key)))
 xs)

(insertion-sort '(3 2 1))
(insertion-sort #(893 32 3 12 1 22 3 23))

;;;; Prove correctness with loop invariants.
;; loop invariant P:
;; start of each iteration, the subarray xs[0..j-1] is sorted

;; initialization:  P true for j = 0, as xs[0..0] is awlays sorted.
;; maintenance:     P true for j => P true for j+1.
;; termination:     when p = len(xs)-1, P still true. and xs[0..j] == xs. proved

;; NOTE: it's all like induction but terminates.
;; NOTE: it's an incremental approach of algorihtm.
;;       on the other hand, merge sort is divide and conquer.

;;;; Algorithm analysis
;;; Some conceptes
;; -- input size --
;;   What to be considered as the input depends on each problem. For instance,
;;   for a graph algorihtm, it's probably more appropriate to consider both number
;;   of vertices and edges as the input.
;; -- running time --
;;   Steps executed. (constant amount of time to perform one step)

;;;; Define runtimes
;; we assign each step a constant cost cₙ, and see how many times they are
;; executed
;;                                                        cost     times
(defun insertion-sort-* (xs)
  (declare (type sequence xs))
  (let* ((bound (- (length xs) 1))
         (key 0))
    (loop for j from 1 to bound                          ; c1        n
          for i = (- j 1) do                             ; c2        n - 1
          (setf key (elt xs j))                          ; c3        n - 1
          (loop while (and (>= i 0)                      ; c4        ∑(j=2, n)(tⱼ)
                           (> (elt xs i) key)) do
                (setf (elt xs (+ i 1)) (elt xs i))       ; c5        ∑(j=2, n)(tⱼ - 1)
                (decf i))                                ; c6        ∑(j=2, n)(tⱼ - 1)
          (setf (elt xs (+ i 1)) key)))                  ; c7        n - 1
 xs)

;; sum them together, this is the total cost
; T(n) = c1 (n) + c2 (n - 1) + c3 (n - 1) + c4 ∑(j=2, n)(tⱼ) +
;                 c5 ∑(j=2, n)(tⱼ - 1) + c6 ∑(j=2, n)(tⱼ - 1) + c7 (n - 1)

;;;; Analysing best case and worst case running time.
;; best case, tᵢ = 1, thus all ∑ are actually constant time, T(n) is now a linear funcion
;; to n. e.g θ(n)
;; worst case, the list is reversely sorted. Thus Tn is a quadratic function of n.
;; we say insertion sort has θ(n²) complexity.

;;;; Order of growth
;; if cₙ is constant, to simply things a bit, we can just set it to 1.
;; the benefit is now we can talk about the rate of growth instead of the actual
;; growth for a specific case.
;; select nth biggest element in a sequence. in O(n)

;; TODO doesn't seems right.


;; calcualte the pivot
(defun get-pivot-idx (xs) (floor (/ (length xs) 2)))

;; move elements smaller then p to the left, others to the right.
;; the running time is O(n).
(defun partition (xs p)
  (declare (type sequence xs)
           (type integer p))
  (let ((left nil)
        (right nil))
    (loop for i from 0 to (- (length xs) 1) do
          (cond ((< (elt xs i) (elt xs p))
                 (setf left (cons (elt xs i) left)))
                ((> (elt xs i) (elt xs p))
                 (setf right (cons (elt xs i) right)))))
    (values left right)))

(defun test-partition ()
  (partition '(7 3 4 2 1 0 5) 3))

;; select a pivot, if there are eactly k - 1 elements on the left hand side,
;; that means k is the kst biggest element.
;; otherwise, if length of left > k - 1, k is in the left hand side.
;; recurse on left.
;; if lenght of left < k - 1, k is in right hand size, recurse on right hand.
(defun kselect (xs k)
  (declare (type sequence xs)
           (type integer k))
  (if (< (length xs) 5)
      (elt (sort xs #'>) (- k 1))
      (let ((p (get-pivot-idx xs)))
        (multiple-value-bind (left right) (partition xs p)
          (progn
            (cond ((eql (- k 1) (length left)) (elt xs (- k 1)))
                  ((> (length left) (- k 1)) (kselect left k))
                  ((< (length left) (- k 1))
                   (kselect right (- k (length left) 1)))))))))

(defun test-kselet ()
  (let ((ls '(7 3 5 4 1 0 2)))
    (format t "~a~%" (kselect ls 1))
    (format t "~a~%" (kselect ls 2))
    (format t "~a~%" (kselect ls 3))
    (format t "~a~%" (kselect ls 4))
    (format t "~a~%" (kselect ls 5))
    (format t "~a~%" (kselect ls 6))
    (format t "~a~%" (kselect ls 7))))

;;;; Analyse so called divide and conquer algorithm 2.3

;; the merge operator
(defun merge-* (xs p q r)
  (declare (type sequence xs)
           (type number p q r))
  (let* ((n1 (+ (- q p) 1))
         (n2 (- r q))
         (lhs (loop for i from 0 to n1
                    if (= i n1) collect most-positive-double-float
                    else collect (elt xs (+ p i))))
         (rhs (loop for j from 0 to n2
                    if (= j n2) collect most-positive-double-float
                    else collect (elt xs (+ (+ q j) 1))))
         (i 0)
         (j 0))
    (loop for k from p to r do
          (if (<= (elt lhs i) (elt rhs j))
              (progn
                (setf (elt xs k) (elt lhs i))
                (incf i))
              (progn
                (setf (elt xs k) (elt rhs j))
                (incf j)))))
  xs)

(defun merge-sort-* (xs p r)
  (declare (type sequence xs)
           (type number p r))
  (let* ((q 0))
    (if (< p r)
        (progn
          (setf q (floor (/ (+ p r) 2)))
          (merge-sort-* xs p q)
          (merge-sort-* xs (+ q 1) r)
          (merge-* xs p q r))))
  xs)

(defun merge-sort (xs)
  (declare (type sequence xs)
           (type number p r))
  (merge-sort-* xs 0 (- (length xs) 1)))


(let ((xs '(908 23 24 189 890 9734 310 904 8)))
  (merge-sort xs))


;;;; analyzing divide and conquer algorithm
;; Note the run time of a recursive algorithm needs  to be described by itself
;; since it calls itself multiple times.
;; Idea: for each iteration we break problem into subproblems,
;;       recursively solve them until hit the base case,
;;       and combine subproblem into the solution.
;; We can define the running time of merge sort as:
;; T(n) = {
;;   θ(1)                       if n ≤ c,
;;   aT(n/b) + D(n) + C(n)      otherwise.
;; }
;; where D(n): time to divide a problem to subproblems
;;       C(n): time to combine subproblems
;;       a:    number of sub problems
;;       1/b:    the size of input of subproblem relative to n.

;;;; for merge sort,
;; analysis T(n) = {
;;   θ(1)                       if n ≤ c,
;;   2T(n/2) + D(n) + C(n)      otherwise.
;; }
;; divide:        Dividing array by compute the middle index, D(n) = θ(1)
;; concuqer:      two subproblems, each has half the input size. 2T(n/2)
;; combine        Combining array by calling merge-*, C(n) = θ(n)

;;;; Why T(n) = θ(nlgn) ? Take merge sort as an example.
;; We first simplify the cost as:
;; T(n)  =  {
;;   θ(1)             if n ≤ 3,
;;   2T(n/2) + cn     otherwise
;; }
;; where cn is the cost for the cost of divide and combine.
;;         T(n) + cn                               cn
;;          +--+--+                              +--+--+
;;         /       \                            /       \
;;     T(n/2)      T(n/2)                      /         \
;;     + cn/2      + cn/2                   cn/2          cn/2
;;    /    \        /    \                 /    \        /    \
;; T(n/4) T(n/4)  T(n/4)  T(n/4)          /      \      /      \
;; +cn/4  +cn/4   +cn/4   +cn/4         +cn/4  +cn/4   +cn/4   +cn/4

;; We know:
;;  1. at i level, there are 2ⁱ nodes.
;;  2. we keep dividing till base case, e.g when i = n.
;;  3. we know at the bottom there will be n nodes. (divided to the smallest problem).
;;  4. say we have total level I,
;;      2ᴵ⁻¹ = n
;;    ⇔ I - 1 = lgn
;;    ⇔ I = lgn + 1.
;;  5. at each we have cn cost for dividing and combining
;;  6. thus total cost = T(n) = cn(lgn + 1) + cn
;;  7. thus T(n) = θ(nlgn).

;;;; ** The key of recursive algorithm get logn complexity **
;; Is because it divides problems as a tree, and tree height is (lgn + 1).

;;;; visualize how problem growth by (nlogn) and n²
;;      x             x  x  x  x
;;     / \
;;    x   x           x  x  x  x
;;   / \ / \
;;  x  xx   x         x  x  x  x

;;;; Updated merge sort
;; when n is small enough, insertion sort
;; Analysis on the compleixty of Multiplication

;; TODO karatsuba

;; note common lisp is 2 lisp, value and functions are in different namespaces.

;;;; hand written multiplication
;; assume a and b has same digit
;; grade school multiplication is really a string algorithm...
;;      54
;;    x 28
;;   -------
;;  each digit in one number needs to multply with each digit in the
;;  other one,
;;  O(n^2)


(defun mult-one (as a)
  (declare (type list as)
           (type integer a))
  (let ((result nil)
        (carry 0)
        (sa (reverse as)))
    (loop for n in sa
          for i from 0 to (length sa) do
          (let* ((product (+ carry (* n a)))
                 (r (mod product 10))
                 (q (floor product 10)))
            (if (> q 0) (setf carry q) (setf carry 0))
            (setf result (cons r result))
            (if (and (= i (- (length sa) 1)) (not (= carry 0)))
                (setf result (cons carry result)))))
    result))

;; (format t "~A~%" (mult-one '(1 2 3) 8))
;; (format t "~A~%" (mult-one '(1 2 3) 7))

(defun collect-intermediates (a b)
  (declare (type integer a)
           (type integer b))
  (let* ((as (loop for n across (write-to-string a) collect (digit-char-p n)))
         (bs (loop for n across (write-to-string b) collect (digit-char-p n)))
         (intermediates (loop for b* in (reverse bs) collect (mult-one as b*))))
    intermediates))

;; (format t "~A~%" (collect-intermediates 123 98))

(defun pad-zero (xxs)
  (declare (type sequence xxs))
  (let ((maxlen (+ (length (elt xxs (- (length xxs) 1)))
                   (- (length xxs) 1))))
    (labels ((pad-zero (xs i)
               (append (make-list (- maxlen i (length xs)) :initial-element 0)
                       xs
                       (make-list i :initial-element 0))))
      (mapcar #'(lambda (xs)
                  (parse-integer
                    (format nil "~{~A~}" xs)))
              (mapcar #'pad-zero xxs
                (loop for i from 0 to (length xss) collect i))))))


(format t "~A~%" (pad-zero (collect-intermediates 123 98)))

(defun mult-by-hand-* (a b)
  (loop for n in (pad-zero (collect-intermediates a b)) summing n))

(defun mult-by-hand (a b)
  (if (> a b) (mult-by-hand-* a b) (mult-by-hand-* b a)))

(format t "~A~%" (mult-by-hand 123 98))
#include <iostream>
#include <iostream>
#include <iostream>
#include <iostream>

// some distance metrics

double euclidean();

double manhattan();

double chebyshev();

double hamming();

double cosine();

double mahalanobis();
#include <iostream>
#include <iostream>
module PolarAxis where

-- polar coordinates
#include <iostream>
module M234Tree where

-- one step to red black tree
-- https://www.cs.purdue.edu/homes/ayg/CS251/slides/chap13b.pdf

data Tree234
  = Two Int Tree234 Tree234
  | Three Int Int Tree234 Tree234 Tree234
  | Four Int Int Int Tree234 Tree234 Tree234 Tree234
  deriving (Show, Eq)

module M23Tree where

-- 2-3 tree, yet another balance tree

-- 2-3 tree. Insertion and deletion might restructure the tree to
-- keep it balance.

-- lookup: O(logn)
-- insert: O(logn)
-- delete: O(logn)

-- Some invariants:
-- 1. all leaves are at the same depth.
-- 2. information only stored at leaves.
-- 3. keys are ordered left to right.

data Tree23
  = Two Int Int Tree23 Tree23
  | Tree Int Int Int Tree23 Tree23 Tree23
  deriving (Show, Eq)
#include <array>
#include <functional>
#include <iostream>
#include <optional>
#define Debug

// always has the largest element on the top.
// Property:
//  1. A binary heap is a complete binary tree,
//  2. Keys has to be in total order.
//       review total order: transitivity, antisymmetry, and connexivity.
//       (connex implies reflexivity)
//  3. no duplicates.
//
//  The property is based on some total ordered keys.
//
// How do you represent a tree? Use the relative index from the parent to
// find it's children!
//
//         100
//        /   \
//       19    36     smash
//      /  \  /  \      =>   100, 19, 36, 17, 3, 25, 27
//     17  3 25   1
//    / \
//   2   7
//
// operations on binary heap
//  1. insertion O(1) average, O(logn) *                    | Swim up
//      add to bottom of the tree first.
//      If it's not correct order swap; Recurse until the order is right.
//  2. extract the maximums (delete the root.) O(logn) *    | Sink down
//      replace the root with the last element in the  last level.
//      sink the root down if the order is wrong.
//      recurse until the heap property is restored.
//  3. search
//      search over the array O(n) *

// T needs to be total order.

template <typename T, size_t Size> class BinHeap {
private:
  std::array<T, Size> data;
  size_t bottom;

  inline size_t left_(size_t i) noexcept { return i * 2 + 1; };
  inline size_t right_(size_t i) noexcept { return i * 2 + 2; };

  // given node, we want to know it's parent idx, value, and
  // whether the node is left or right child of the parent.
  struct Parent {
    size_t idx;
    typename decltype(data)::reference value;
  };

  inline Parent parent_(size_t i) {
    if (i == 0)
      return {0, data.at(0)};
    size_t idx = static_cast<size_t>((i - 1) / 2);
    return {idx, data.at(idx)};
  }

  bool swim_up(T &o, size_t idx);
  void sink_down(size_t idx);

public:
  BinHeap() : data(), bottom(0) {}
  inline bool is_full() noexcept { return bottom >= data.size() - 1; };
  inline bool is_empty() noexcept { return bottom == 0; };
  inline bool in_range(size_t i) noexcept { return i < data.size(); }
  inline bool insert(T o);
  inline std::optional<T> extract() noexcept;
  inline std::optional<size_t> search(const T &o) noexcept;

#ifdef Debug
  inline void print_data() {
    for (auto &v : data) {
      std::cout << v << ", ";
    }
    std::cout << "\n";
  }
#endif
};

template <typename T, size_t Size>
inline std::optional<size_t> BinHeap<T, Size>::search(const T &o) noexcept {
  for (size_t i = 0; i <= bottom; ++i) {
    if (data[i] == o) {
      return i;
    }
  }
  return {};
}

// swim up
// T &o should be the reference to new bottom.
template <typename T, size_t Size>
bool BinHeap<T, Size>::swim_up(T &o, size_t idx) {

  Parent parent = parent_(idx);

  // keep the order invariant.
  if (parent.value < o) {
    std::swap(parent.value, o);
    return swim_up(parent.value, parent.idx);
  } else {
    return true;
  }
}

template <typename T, size_t Size>
void BinHeap<T, Size>::sink_down(size_t idx) {
  size_t left = left_(idx);
  size_t right = right_(idx);
  size_t largest = idx;

  if (in_range(left) && data[left] > data[largest]) {
    largest = left;
  }

  if (in_range(right) && data[right] > data[largest]) {
    largest = right;
  }

  if (largest != idx) {
    std::swap(data[idx], data[largest]);
    sink_down(largest);
  }
}

template <typename T, size_t Size> inline bool BinHeap<T, Size>::insert(T o) {
  if (is_empty()) {
    data[bottom] = o;
    bottom++;
    return true;
  }

  if (is_full()) {
    return false;
  }

  if (search(o)) {
    return false;
  }

  data[bottom] = o;
  bottom++;

  return swim_up(data[bottom - 1], bottom - 1);
}

// sink
template <typename T, size_t Size>
inline std::optional<T> BinHeap<T, Size>::extract() noexcept {
  if (is_empty()) {
    return {};
  }

  T top = std::move(data[0]);
  data[0] = std::move(data[bottom]);
  bottom--;

  sink_down(0);

  return top; // RVO
}

int main() {
  BinHeap<int, 10> heap{};
  heap.insert(1);
  heap.insert(3);
#ifdef Debug
  heap.print_data();
#endif

  heap.insert(2);
  heap.insert(5);
#ifdef Debug
  heap.print_data();
#endif

  heap.insert(4);

#ifdef Debug
  heap.print_data();
#endif

  heap.insert(8);
  heap.insert(12);

#ifdef Debug
  heap.print_data();
#endif

  heap.extract();
  heap.extract();
  heap.extract();

#ifdef Debug
  heap.print_data();
#endif

  return 0;
}
#include <array>
#include <iostream>

// TODO

// fenwick tree (binary index tree) BIT.
//
// Motivation:
// For an array, we normally can do two things:
//  1. modify one element
//  2. query range sum (by taking the difference between two prefix sums)
// We have O(1) for 1, but O(n) for 2.
//
// --------------------------------------------------------------------------------
// arr:   1 2 3 4 5
//  for get prefix sum of 3, we need to calculate 1 + 2 + 3.
// --------------------------------------------------------------------------------
//
// To speed up the range query, we can try to store the parital sum of elements
// instead of elements themselves in an array. This way we can have O(1) range
// query. But to modify an element, the change will propagate to all rest
// elements, so update will be O(n)
//
// --------------------------------------------------------------------------------
// arr:   1 3 6 10 15
//  for updating 3 to 4, we need to modify 6->7, 10->11, 15->16.
// --------------------------------------------------------------------------------
//
// Bit allows you good balance of the two operations. We can have O(logn) for
// both! This is particularly useful when you need frequent range query and
// array updates.
//
// For an given array, we can make another array to store it's prefix sum:
// psum: 1  3  6 10 15
//       |  |  |  |  |
// arr:  1  2  3  4  5
// This structure has both problem we had above, because whenever we do an O(1)
// operation we need to trgger the O(n) on the other array to keep everything
// update to date.
//

#define lowbit(x) ((x) & (-x))

template <typename T, size_t Size> class BitTree {
private:
  std::array<T, Size> data;

public:
  BitTree(const std::array<T, Size> &arr) : data(arr) {}
  BitTree(std::array<T, Size> &&arr) : data(std::move(arr)) {}
};
#include <iostream>


(* Only two mutable strctures in sml:
 * ref and array. This is the same as haskell.
 * *)

signature MUTABLE_STACK =
sig
  type 'a mut_stack
  val new : unit -> 'a mut_stack
  val push : 'a * 'a mut_stack -> unit
  val pop : 'a mut_stack -> 'a option
end

structure MutableStack :> MUTABLE_STACK =
struct
  type 'a mut_stack = ('a list) ref
  fun new () = ref [];
  fun push (a, s) = s := a::(!s);
  fun pop s =
    case (!s) of
         [] => NONE
       | (x::xs) => (s := xs; SOME(x))
end

structure ArrayStack =
struct
  datatype 'a mut_stack = ArrayStack of {
    arr : 'a option Array.array ref,
    ptr : int ref
  };

  fun new () = ArrayStack {
    arr = ref (Array.array (256, NONE)),
    ptr = ref 0
    };

  (* bench mark version of push
   * Can return a result from this.
   * *)
  fun push_ factor (n_alloc : int ref option) =
    fn (a, ArrayStack {arr, ptr}) =>
      if (!ptr) < Array.length (!arr) - 1 orelse (!ptr) = 0
      then
        (ptr := (!ptr) + 1;
         Array.update (!arr, !ptr, SOME(a)))
      else
        let
          val len = Array.length (!arr);
          val ls = Array.array (floor ((Real.fromInt len) * factor), NONE);
        in
          (Array.appi (fn (i, x) => Array.update (ls, i, x)) (!arr);
           ptr := (!ptr) + 1;
           arr := ls;

           print (Int.toString (!ptr)
           ^ "reallocate, "
           ^ "new length: "
           ^ Int.toString(Array.length (!arr)) ^ "\n");

           case n_alloc of
                NONE => ()
              | SOME(r) => r := (!r) + 1;
           Array.update (ls, !ptr, SOME(a)))
        end

  (* be careful about recursive polymorphic types *)
  fun push (a, b) = (push_ 1.5 NONE) (a, b);

  fun pop (ArrayStack {arr, ptr}) : 'a option =
    if (!ptr) = 0
    then NONE
    else
      let val head = Array.sub (!arr, !ptr);
      in (ptr := (!ptr) - 1; head) end
end

structure Test =
struct
  val s = ref (ArrayStack.new () : int ArrayStack.mut_stack);
  val n_alloc = SOME(ref 0);
  val seed = Random.rand (123, 234)

  fun clean () =
    (s := (ArrayStack.new () : int ArrayStack.mut_stack);
     case n_alloc of
          NONE => ()
        | SOME(r) => r := 0)

  fun test_push factor n =
      if n > 0
      then
        let
          val push = ArrayStack.push_ factor n_alloc;
        in (push (n, !s); test_push factor (n - 1)) end
      else
        case n_alloc of
             NONE => ()
           | SOME (r) =>
               print ("Total allocation: "
               ^ (Int.toString (!r))
               ^ "\n");

  fun test_pop n =
    if n > 0
    then (ArrayStack.pop (!s); test_pop (n - 1))
    else ()

  (* We want to check in a series of random operations, how frequent
   * allocation can be.
   * *)

  fun push_random factor =
    let
      val n = Random.randRange (0, 1000000) seed
    in
      (print "start\n";
       test_push factor n;
       print "end\n";
       clean ())
    end
end

#include <iostream>
#include <cassert>
#include <iostream>
#include <memory>
#include <optional>

// TODO

// tail is persistent, so we don't need to make a copy.
template <typename T> class List {
  struct Element {
    Element(T v, const std::shared_ptr<Element> &tail) : val_(v), next_(tail) {}
    T val_;
    std::shared_ptr<Element> next_;
  };

  std::shared_ptr<Element> head_;

public:
  List(){};
  List(T val, const List &tail)
      : head_(std::make_shared<Element>(val, tail.head_)) {}
  explicit List(std::shared_ptr<Element> items) : head_(items) {}
  bool is_empty() const { return !head_; }

  std::optional<T> front() const {
    if (is_empty()) {
      return {};
    }
    return head_->val_;
  }

  std::optional<List> pop_front() const {
    if (is_empty()) {
      return {};
    }
    return List(head_->next_);
  }

  List push_front(T v) const { return List(v, *this); }
};

int main(void) { return 0; }
#include <iostream>

module ConvexHull where

import Data.List

-- convex hull..
-- break problem in to smaller parts, then compose them back up.
-- Given n points in plane
-- S = {(x, y) | i = 1, 2, 3, ... n}
-- Assume no two have the samse X coordinate no two have the same y coord.

-- convex hull is the smallest polygon containing all points in ConvextHull(S).
-- TODO

type Point = (Int, Int)

-- sort points on x coordinates.
sortPoints :: [Point] -> [Point]
sortPoints = sortBy (\a b -> compare (fst a) (fst b))

merge :: [Point] -> [Point]
merge = undefined

convexHull :: [Point]
convexHull = undefined
#include <cassert>
#include <iostream>
#include <limits>
#include <type_traits>
#include <vector>

template <typename C> void print_seq(C &&container) {
  for (auto &n : container) {
    std::cout << n << " ";
  }
  std::cout << std::endl;
}

template <typename It> void print_iter(It first, It last) {
  while (first != last) {
    std::cout << *first << " ";
    ++first;
  }
  std::cout << std::endl;
}

///////////////////////////////////////////////////////////////////////////////

template <typename BidirectionalIterator, typename Comparator>
void merge(BidirectionalIterator left, BidirectionalIterator mid,
           BidirectionalIterator right, Comparator &&comp) {
  const int lhs_sz = mid - left + 1;
  const int rhs_sz = right - mid;
  const int sz = lhs_sz + rhs_sz;

  std::vector<int> lhs(lhs_sz, 0);
  std::vector<int> rhs(rhs_sz, 0);

  for (auto l = left, lhs_ptr = lhs.begin(); l < left + lhs_sz;) {
    *lhs_ptr++ = *l++;
  }

  for (auto r = mid + 1, rhs_ptr = rhs.begin(); r < mid + 1 + rhs_sz;) {
    *rhs_ptr++ = *r++;
  }

  auto l = lhs.begin(), r = rhs.begin();
  for (auto k = left; k != right + 1; ++k) {

    assert(!(l == lhs.begin() + lhs_sz && r == rhs.begin() + rhs_sz));

    // left ends
    if (l == lhs.begin() + lhs_sz && r < rhs.begin() + rhs_sz) {
      *k = *r++;
      // right ends
    } else if (l < lhs.begin() + lhs_sz && r == rhs.begin() + rhs_sz) {
      *k = *l++;
    } else {
      if (comp(*l, *r))
        *k = *l++;
      else
        *k = *r++;
    }
  }
}

template <typename BidirectionalIterator, typename Comparator>
void merge_sort_impl(BidirectionalIterator first, BidirectionalIterator last,
                     Comparator &&comp) {
  if (last - first + 1 <= 1)
    return;

  auto mid = first + std::distance(first, last) / 2;
  merge_sort_impl(first, mid, comp);
  merge_sort_impl(mid + 1, last, comp);
  merge(first, mid, last, comp);
}

template <typename BidirectionalIterator, typename Comparator>
void merge_sort(BidirectionalIterator first, BidirectionalIterator last,
                Comparator &&comp) {
  merge_sort_impl(first, last - 1, comp);
}

int main(void) {

  {
    std::cout << "merge sort " << std::endl;
    std::vector<int> v{5, 2, 9, 1, 7, 10, 3, 4, 6};
    merge_sort(v.begin(), v.end(), [](auto a, auto b) { return a < b; });
    print_seq(v);
  }

  {
    std::cout << "merge sort " << std::endl;
    std::vector<int> v{5, 2, 9, 1, 7, 10, 3, 4, 6};
    merge_sort(v.begin(), v.end(), [](auto a, auto b) { return a > b; });
    print_seq(v);
  }

  return 0;
}
#include <iostream>
#include <vector>


int main(void)
{
  {

  }
  return 0;
}
#include <array>
#define BOOST_STACKTRACE_USE_ADDR2LINE

#include <iostream>
#include <iterator>
#include <list>
#include <random>
#include <set>
#include <vector>

// #define TEST
template <typename C> void print_seq(C &&container) {
  for (auto &n : container) {
    std::cout << n << " ";
  }
  std::cout << std::endl;
}


// quick sort takes bidirectional iterators.

auto hoare_partition = [](auto start, auto end, auto &comp) {
  typename std::iterator_traits<decltype(start)>::value_type pivot =
      *(start + std::distance(start, end) / 2);

  decltype(start) i = start;
  decltype(start) j = end;

  for (;;) {
    while (comp(*i, pivot))
      i++;
    while (!comp(*j, pivot) && *j != pivot)
      j--;
    if (i >= j)
      break;
    std::swap(*i, *j);
  }
  return j;
};

auto lomuto_partition = [](auto start, auto end, auto &comp) {
  typename std::iterator_traits<decltype(start)>::value_type pivot = *(end - 1);
  decltype(start) i = start;
  for (decltype(start) j = start; j != end; ++j) {
    if (comp(*j, pivot)) {
      std::swap(*i, *j);
      i = i + 1;
    }
  }
  std::swap(*i, *(end - 1));
  return i;
};

// quick sort with custom comparator and partition scheme
template <typename BidirectionalIterator, typename Comparator,
          typename Partition>
void quick_sort_impl(BidirectionalIterator begin, BidirectionalIterator end,
                     const Partition &partition, const Comparator &comp) {
  static_assert(
      std::is_convertible_v<
          typename std::iterator_traits<decltype(begin)>::iterator_category,
          std::bidirectional_iterator_tag>,
      "quick sort takes bidirectional iterators");

  if (begin >= end)
    return;
  BidirectionalIterator p = partition(begin, end, comp);
  quick_sort_impl(begin, p, partition, comp);
  quick_sort_impl(p + 1, end, partition, comp);
}

// quick sort interface
template <typename BidirectionalIterator, typename Comparator,
          typename Partition>
void quick_sort(BidirectionalIterator begin, BidirectionalIterator end,
                const Partition &partition, const Comparator &comp) {
  quick_sort_impl(begin, end - 1, partition, comp);
}

template <typename BidirectionalIterator, typename Comparator>
void quick_sort(BidirectionalIterator begin, BidirectionalIterator end,
                const Comparator &comp) {
  quick_sort_impl(begin, end - 1, hoare_partition, comp);
}

///////////////////////////////////////////////////////////////////////////////

// we can sort this thing
struct String {
private:
  char *data_;
  size_t size_;

public:
  String(const std::string &str) {
    data_ = new char[str.size()];
    char *top = data_;
    for (auto &c : str)
      *top++ = c;
    this->size_ = str.size();
  }

  String(const char *str, size_t size) {
    data_ = new char[size];
    char *top = data_;
    for (size_t i = 0; i < size; ++i)
      *top++ = str[i];
    this->size_ = size;
  }

  String(const String &str) : String(str.data_) {}
  String(String &&str) : String(std::move(str.data_)) {}

  ~String() {
    delete[] data_;

#ifdef TEST
    std::cout << "String is destructed" << std::endl;
#endif
  }

  void swap(String &str) {
    char *tmp = this->data_;
    this->data_ = str.data_;
    str.data_ = tmp;
    this->size_ = str.size();
  }

  String &operator=(const String &str) {
    String tmp{str};
    std::swap(data_, tmp.data_);
    return *this;
  }

  String &operator=(const String &&str) {
    String tmp{str};
    std::swap(data_, tmp.data_);
    return *this;
  }

  size_t size() const { return this->size_; }
  char *data() const { return this->data_; }

  friend bool operator<(const String &s1, const String s2) {
    int i;
    for (i = 0;
         i < std::max(s1.size(), s2.size()) && s1.data_[i] == s2.data_[i]; ++i)
      ;
    return s1.data_[i] < s2.data_[i];
  }

  friend bool operator==(const String &s1, const String s2) {
    if (s1.size() != s2.size())
      return false;

    for (int i = 0; i < s1.size(); ++i) {
      if (s1.data_[i] != s2.data_[i]) {
        return false;
      }
    }
    return true;
  }

  friend bool operator<=(const String &s1, const String &s2) {
    return s1 == s2 || s1 < s2;
  }

  friend bool operator>(const String &s1, const String &s2) {
    return !(s1 <= s2);
  }

  friend bool operator>=(const String &s1, const String &s2) {
    return !(s1 < s2);
  }

  friend std::ostream &operator<<(std::ostream &os, const String &str) {
    os << "|";
    for (int i = 0; i < str.size(); ++i) {
      os << str.data()[i];
    }
    os << "|";
    return os;
  }
};

int main(void) {
  {
    std::vector<int> v{5, 2, 4, 9, 1, 3, 8};
    quick_sort(v.begin(), v.end(), [](auto a, auto b) { return a < b; });
    print_seq(v);
  }
  {
    std::array<int, 7> arr{5, 2, 4, 9, 1, 3, 8};
    quick_sort(arr.begin(), arr.end(), [](auto a, auto b) { return a < b; });
    print_seq(arr);
  }

  {
    std::vector<int> v{5, 2, 4, 9, 1, 3, 8};
    quick_sort(v.begin(), v.end(), lomuto_partition,
               [](auto a, auto b) { return a < b; });
    print_seq(v);
  }
  {
    std::array<int, 7> arr{5, 2, 4, 9, 1, 3, 8};
    quick_sort(arr.begin(), arr.end(), lomuto_partition,
               [](auto a, auto b) { return a < b; });
    print_seq(arr);
  }

  {
    std::vector<String> sv{String("zsd"), String("acds"), String("ufnd")};
    quick_sort(sv.begin(), sv.end(), lomuto_partition,
               [](auto a, auto b) { return a < b; });
    print_seq(sv);
  }

  return 0;
}
(* To link with unix, run ocamlc unix.cma % *)

open Hashtbl;;
open List;;
open Unix;;

let n = 40

(* the dp implementation, loop also uses recursion
 * It's actually quite easy to achieve the same effect as
 * a normal loop.
 * *)
let fib_dp_rec (n: int) : int =
  let a : int ref = ref 0 in
  let b : int ref = ref 1 in
  let rec loop i =
        if i > n then a
        else let tmp = !b
        in  b := !a + !b;
            a := tmp;
            loop (i + 1)
  in !(loop 0)


(* dp 2 with for loop *)
let fib_dp_loop (n: int) : int =
  let a : int ref = ref 0 in
  let b : int ref = ref 1 in
  let tmp : int = 0
  in for i = 0 to n do
    let tmp = !b in
    b := !a + !b;
    a := tmp;
  done;
  !b


(* naive recursion impelementation *)
let rec fib_rec (n : int) : int =
  if n < 2 then 1
  else fib_rec (n - 1) + fib_rec (n - 2)


(* recursion with memoization *)
let fib_rec_mem (n : int) : int =
  let cache = Hashtbl.create 20
  in  Hashtbl.add cache 0 1;
      Hashtbl.add cache 1 1;
      let rec fib_rec_mem_ (n : int) : int =
        match Hashtbl.find_opt cache n with
            Some c -> c
          | None ->
              let res = fib_rec_mem_ (n - 1) + fib_rec_mem_ (n - 2);
              in  Hashtbl.add cache n res;
                  res
      in fib_rec_mem_ n


(* iterative version *)
let fib_iter (n: int) : int =
  let rec fib_iter_ (a: int) (b : int) (n : int) : int =
    if n == 0 then b
    else fib_iter_ b (a + b) (n - 1)
  in fib_iter_ 0 1 n


(* cps transformation *)
let fib_cps (n: int) =
  let ret a b = b in
  let rec fib_cps_ a b n k =
    if n == 0 then k a b
    else fib_cps_ a b (n - 1) (fun a' b' -> k b' (a' + b'))
  in fib_cps_ 0 1 n ret


let timer name f =
  let t = Unix.gettimeofday () in
  let res = f n in
  Printf.printf "%s:, value: %d Excution time %f\n" name res (Unix.gettimeofday () -. t)


let main () =
  timer "fib_dp_rec" fib_dp_rec;
  timer "fib_dp_loop" fib_dp_loop;
  timer "fib_cps" fib_cps;
  timer "fib_rec" fib_rec;
  timer "fib_rec_mem" fib_rec_mem;
  timer "fib_iter" fib_iter


let () = let _ = main () in ()
#include <array>
#include <cinttypes>
#include <functional>
#include <iostream>
#include <vector>

// array used as a map           x  1  2  3  4  5   6   7   8   9   10
std::vector<int32_t> rod_prices{-1, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30};

// cost of r[n]: r[n] = max(p + r[n-1])

#define MAX(a, b) (a > b ? a : b)

// naive recursion
int32_t cut_rod(const std::vector<int32_t> &prices, int32_t n) {
  if (n == 0) {
    return 0;
  }

  int32_t q = INT32_MIN;
  for (int32_t i = 1; i <= n; ++i) {
    q = MAX(q, prices[i] + cut_rod(prices, n - i));
  }

  return q;
}

// memoization version
int32_t cut_rod_mem(const std::vector<int32_t> &prices, int32_t n) {
  static std::vector<int32_t> cache(prices.size(), -1);
  if (cache[n] != -1)
    return cache[n];

  if (n == 0) {
    return 0;
  }

  int32_t q = INT32_MIN;
  for (int32_t i = 1; i <= n; ++i) {
    q = MAX(q, prices[i] + cut_rod(prices, n - i));
  }

  if (cache[n] == -1) {
    cache[n] = q;
  }
  return q;
}

int32_t cut_rod_bottomup(const std::vector<int32_t> &prices, int32_t n) {
  static std::vector<int32_t> result(prices.size(), 0);
  result[0] = 0;
  for (int32_t j = 1; j <= n; ++j) {
    int32_t q = INT32_MIN;
    for (int32_t i = 1; i <= j; ++i) {
      q = MAX(q, prices[i] + result[j - i]);
    }
    result[j] = q;
  }
  return result[n];
}

#define PRINT(n, x) std::cout << n << " " #x ": " << x << std::endl;
#define PICK(i, from, to, pred, stmt)                                          \
  for (int i = from; i <= to; ++i) {                                           \
    if (pred) {                                                                \
      PRINT(i, stmt);                                                          \
    }                                                                          \
  }

int main(void) {
  PICK(i, 1, 10, i == 5 || i == 8 || i == 9, cut_rod(rod_prices, i));
  PICK(i, 1, 10, i == 5 || i == 8 || i == 9, cut_rod_mem(rod_prices, i));
  PICK(i, 1, 10, i == 5 || i == 8 || i == 9, cut_rod_bottomup(rod_prices, i));

  return 0;
}

// OUTPUT:
// 5 cut_rod(rod_prices, i): 13
// 8 cut_rod(rod_prices, i): 22
// 9 cut_rod(rod_prices, i): 25
// 5 cut_rod_mem(rod_prices, i): 13
// 8 cut_rod_mem(rod_prices, i): 22
// 9 cut_rod_mem(rod_prices, i): 25
// 5 cut_rod_bottomup(rod_prices, i): 13
// 8 cut_rod_bottomup(rod_prices,i): 22
// 9 cut_rod_bottomup(rod_prices, i): 25
import functools
import typing as t
rod_price = [-1, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30]

# cutting rod with constant cost on each cut

# it's a maximization problem.
# 1. subproblem: maximize the price by choosing the right length to cut.
# 2. guessing: we can choose from length 1 - 10
#       for f(n) we have
#       f(n - i) for 1 <= i <= 10
#       for each choice we have the corresponding gain
#       g[i] from the table
# 3. recurrence
#       dp(i) = max {
#           f(n - i) + g[i] for i in range(1, 11)
#       }
# 4. topological ordering of subproblems:
#       f(n) needs f(n - i) for i in range(1, n)
# 5. running time:
#       total number of sub problems: O(n)
#       each subproblem:              O(1)
#       O(n)


def maximum(a, b):
    return a if a > b else b


def cache(f):
    cache_ = dict()

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        if args[0] in cache_.keys():
            return cache_[args[0]]
        result = f(*args, **kwargs)
        cache_[args[0]] = result
        return result
    return wrapper


# the new revenue is prices[i] + cut_rod_(n - i, prices) - cost
def cut_rod(n, prices, cost):

    @cache
    def cut_rod_(n, prices) -> int:
        if n == 0:
            return 0
        q = -999
        for i in range(1, n+1):
            p1 = prices[i] + cut_rod_(n - i, prices) - cost
            if p1 > q:
                q = p1

        return q
    r = cut_rod_(n, prices)

    return r


def show():
    cost = 2
    dp_table = [cut_rod(i, rod_price, cost)
                for i in range(0, len(rod_price))]

    print(f"cost {cost}")
    print("{:10s} {:10s} ".format("length", "renevnue"))
    for i, r in enumerate(dp_table):
        print(f"{i:<10d} {r:<10d}")


if __name__ == "__main__":
    show()
import functools
import typing as t
rod_price = [-1, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30]

# cutting rod with solutions collected.


def maximum(a, b):
    return a if a > b else b


def cache(f):
    cache_ = dict()

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        if args[0] in cache_.keys():
            return cache_[args[0]]
        result = f(*args, **kwargs)
        cache_[args[0]] = result
        return result
    return wrapper


# return a tuple consist renvenue and the
# length of the first cut.
@cache
def cut_rod(n, prices) -> t.Tuple[int, int]:
    if n == 0:
        return 0, 0
    q = -999
    for i in range(1, n+1):
        p0, _ = cut_rod(n - i, prices)
        p1 = prices[i] + p0
        if p1 > q:
            s = i       # best thing to do is cut off length i
            q = p1
    return q, s


def show():
    dp_table = [cut_rod(i, rod_price)
                for i in range(0, len(rod_price))]

    print("{:10s} {:10s} {:10s} ".format("length", "renenue", "cutoff"))
    for i, (r, s) in enumerate(dp_table):
        print(f"{i:<10d}  {r:<10d}  {s:<10d}")


if __name__ == "__main__":
    show()

# length     renenue    cutoff
# 0           0           0
# 1           1           1
# 2           5           2
# 3           8           3
# 4           10          2
# 5           13          2
# 6           17          6
# 7           18          1
# 8           22          2
# 9           25          3
# 10          30          10
;; quickly formulate the dp problem

(defparameter *prices*
  '(-1 1 5 8 9 10 17 17 20 24 30))

(defparameter *memo* (make-hash-table))

;; memoization + recurrence.
;; each subproblem O(1)
;; it's a suffixes problem, so total number of subproblems O(n)
;; thus total running time O(n)
(defun cut-rod (n prices)
  (format t "~a~%" n)
  (cond
    ((gethash n *memo*) (gethash n *memo*))
    ((= n 0) 0)
    (t (let ((result (apply #'max
                            (loop :for i :from 1 :to n :collect
                                  (+ (elt prices i) (cut-rod (- n i) prices))))))
         (setf (gethash n *memo*) result)
         result))))
#include <iostream>

#include <chrono>
#include <functional>
#include <unordered_map>

// simple fibbonaci with dp.
// The idea of dp is to separate big problem into smaller prblems,
// solve optimal sub problems, combine solutions to solve the
// big problem.
//
// You can solve a dp problem bottom up or top down.
// Usually top-down implies a normal recursion solution, while
// bottom up will require you to construct the smallest problem then
// goes towards the final answer.
//
// By using dp we can work on looking for optimal subproblems, thus
// ignore suboptimal solutions. In this sense, dp can be think of
// as a way to shrink the possible solution space of a problem.

// dp fib is super simple, but it has several implication. it's
// uses buttom up approach. Since we know after we constructed
// the subsolution, solution for smaller problems can be ignored,
// so we can only use two variables to save the state.

// use dp to construct solution button up.
int fib_dp(int n) {
  int a = 0, b = 1, tmp;
  for (int i = 0; i < n; ++i) {
    tmp = b;
    b = a + b;
    a = tmp;
  }
  return b;
}

// use recursion, a top down approach.
// this solution has several problems:
//  1. It's not tail recursive. Because recursion will defer the
//     evaluation, stack space can be used up when input is large.
//  2. it's possible to recompute sub problems.
int fib_rec(int n) {
  if (n < 2) {
    return 1;
  }
  return fib_rec(n - 1) + fib_rec(n - 2);
}

// solve problem 2 for naive recursion.
// withotu recomputation, this version is as fast as iterative approach.
int fib_rec_mem(int n) {
  static std::unordered_map<int, int> cache{{0, 1}, {1, 1}};

  if (cache.find(n) != cache.end()) {
    return cache[n];
  }

  cache[n] = fib_rec_mem(n - 1) + fib_rec_mem(n - 2);
  return cache[n];
}

// of course we have the iterative method that everybody loves.
int fib_iter(int n) {
  static std::function<int(int, int, int)> fib_iter_ = [](int a, int b,
                                                          int n) -> int {
    if (n == 0) {
      return b;
    }
    return fib_iter_(b, a + b, n - 1);
  };

  return fib_iter_(0, 1, n);
}

// and we have cps transform
// it's trickier then most others.
int fib_cps(int n) {

  static auto ret = [](int a, int b) { return b; };
  static std::function<int(int a, int b, int n, std::function<int(int, int)>)>
      fib_cps_ = [](int a, int b, int n, auto k) -> int {
    if (n == 0) {
      return k(a, b);
    }

    return fib_cps_(a, b, n - 1,
                    [&](int a1, int b1) { return k(b1, a1 + b1); });
  };

  return fib_cps_(0, 1, n, ret);
}

#define N 40

#define START                                                                  \
  {                                                                            \
    auto start = std::chrono::system_clock::now();

#define END                                                                    \
  auto end = std::chrono::system_clock::now();                                 \
  auto elapsed =                                                               \
      std::chrono::duration_cast<std::chrono::milliseconds>(end - start);      \
  printf("time: %ld ms\n", static_cast<long int>(elapsed.count()));            \
  }

int main(void) {

  // 0ms
  START;
  printf("fib_dp: %d\n", fib_dp(N));
  END;

  // 839ms
  START;
  printf("fib_rec: %d\n", fib_rec(N));
  END;

  // 0ms
  START;
  printf("fib_rec_mem: %d\n", fib_rec_mem(N));
  END;

  // 0ms
  START;
  printf("fib_iter: %d\n", fib_iter(N));
  END;

  // 0ms
  START;
  printf("fib_cps: %d\n", fib_cps(N));
  END;

  return 0;
}

#undef N
;; edit distance problem

;; string x & y, what's the cheapest possible (character edits)
;; to turn x -> y
;; first define character edits:
;; 1. insert c
;; 2. delete c
;; 3. replace c

;; 1. subproblem = edit distance on x[i:], y[j:] for all i, j
;;    # subproblems = O(|x| |y|)
;; 2. guess (use the edit operations):
;;        x: ....
;;           i
;;        y: ....
;;           j
;;    (what to do to make the first character of x become the
;;     first charaacter of y?)
;;    choice 1: replace x[i] with y[j]
;;    choice 2: insert x with y[j]
;;    choice 3: delete x[i]
;; 3. recurrence
;;      DP(i, j) =  min {
;;          (cost of replace x[i] -> y[j]) + DP(i+1, j+1),
;;          (cost of insert x[i] with y[j]) + DP(i, j+1),
;;          (cost of delete x[i] with y[j]) + DP(i+1, j),
;;      }
;; 4. topological order (shortest path in the DAG)
;; 5. DP(0, 0)


(defparameter *x* "abcjladsfsdlj")
(defparameter *y* "uhabdkvbkd")

(defun e-delete (xs))
(defun e-insert (xs))
(defun e-replace (xs))

(defun edit-distance (xs) )
;; classic dp
;; given weigths and values of nitems, put in sack as much as
;; possible. You cannot break items.

;; 1. subproblem
;;      maximize suffixes of items [i:] & remaining capacity x <= s
;; 2. guessing
;;      is item i in subet or not 0 or 1
;; 3. reccurence
;;      DP(i) = max {
;;        DP(i + 1, x), DP(i+1, x -s) + vi
;;      }
;;
;; 4. topological order
;; 5. DP(

(defun knapsak01 ()

  )
module Knapsack01 where

-- 01knapsack problem.
-- or Thief robbing store problem.
-- In this setting the theif can either take an item or not. In this case you
-- can no longer solve it with greedy algorhtm, a dp solution is required.

-- item(th)  1   2   3   4   5   6   7
-- profit    10  5  15   7   6   18  3
-- weight    2   3   5   7   1   4   1


// https://www.radford.edu/~nokie/classes/360/dp-longest-common-subseq.html
#include <iostream>

int main(void)
{

  return 0;
}
#include <iostream>
// Notice matrix multiplications are associative. So the order of evaluation doesn't
// affect the result.
// But it does affect the cost of computation though.
//
// Imagine we want to chain multiplication of 2x3 matrix A1, 3x4 matrix A2, and 4x2 matrix A3.
// We have two possible orders:
//  case 1: (A1 x A2) x A3,
//  case 2: A1 x (A2 x A3)
// Notice the number of computation required for multiplication between matrix axb and
// matrix bxc is a . b . c
//  for case 1, we have 2.3.4 + 2.4.2 = 40 computations.
//  for case 2, we have (3.4.2) + 2.3.2 = 36 computations,
// so case 2 is more efficient.
//
// We want to generalize this process for arbitrary long chain of matrix multiplication
//
// We can solve the problem with dp.

// How do we know how many possible evaluation orders are there?
// little tool: catlan number
//            1    (2n)     (2n)!
//    Cₙ = ------- (  )  = -------   for n >= 0.
//          n + 1  ( n)    (n+1)!n!


(defpackage #:matrix-multiplication
  (:use "COMMON-LISP")
  (:shadow "*"))

(in-package #:matrix-multiplication)

;; recall subproblems for strings
;; possible choices:
;;  1. suffixes x[i:] forall i
;;  2. preffixes x[:i] forall i
;;  3. substrings x[i:j] forall i < j
;; choose one to formulate the subproblem.

(defmacro operator-overload (op &rest definitons)
  (let ((fname (read-from-string (concatenate 'string "binary" (symbol-name op)))))
    `(values
       (defun ,op (&rest ts)
         (reduce (quote ,fname) (cdr ts) :initial-value (car ts)))
       (defgeneric ,fname (a b)
         ,@(loop :for def :in definitons :collect
                 `(,@def))))))

;; optimal evalution of associative expression

;; 1. define subproblem
;;      optimal evaluation of Ai ... Aj-1  # of sub problems O(n^2)
;; 2. guess outermost multiplciation (the last operation we do)
;;    choose to split the chain at kth index.
;;    (Ai...Ak) (Ak+1 ... Aj-1)
;;     # choices = O(j - i + 1 = O(n)
;; 3. reccurence:
;;    DP(i, j) = min {
;;        DP(i, k) + DP(k, j) + (cost of Ai:k * Ak:j)
;;        for k in range(i+1, j)
;;    }
;;  time/subproblem = O(n)
;; 4. total time: O(n^3)
;; 5. topological order: increasing substring size

;;  A1 A2 A3 A4 A5 A6
;;  i-------k-------j


;; we don't care about the value of the matrix
(defclass matrix ()
  ((n :type integer
      :initarg :n
      :accessor n
      :initform 0)
   (m :type integer
      :initarg :m
      :accessor m
      :initform 0)))

(defmethod print-object ((obj matrix) stream)
  "print the matrix"
  (print-unreadable-object (obj stream :type t)
    (with-accessors ((m m) (n n))
      obj
      (format stream "n: ~a, m: ~a" n m))))

(defmethod mmult ((a matrix) (b matrix))
  (with-accessors ((an n) (am m) ) a
    (with-accessors ((bn n) (bm m)) b
      (assert (= am bn))
      (make-instance 'matrix :n an :m bm))))

(defmethod cost ((o matrix))
  "we want to minimize this"
  (with-accessors ((m m) (n n)) o
    (* m n)))


(operator-overload *
                   (:method ((a number) (b number)) (cl:+ a b))
                   (:method ((a matrix) (b matrix)) (mmult a b)))

(defparameter *ms*
  (list (make-instance 'matrix :n 2 :m 3)
        (make-instance 'matrix :n 3 :m 2)))

(defun flattern (xs)
  (labels ((rec (xs acc)
             (cond ((null xs) acc)
                   ((atom xs) (cons xs acc))
                   (t (rec (car xs) (rec (cdr xs) acc))))))
    (rec xs nil)))


(defparameter *memo* (make-hash-table))

(defun parenthesization (xs)
  (declare (type (sequence matrix) xs))
  (let ((sz (length xs)))
    (cond
      ((<= sz 1) (cost (car xs)))
      (t
       (apply #'min
              (flattern
                (loop :for len :from 2 :to sz :collect
                      (loop :for i :from 0 :to (- len 1)
                            :with j = (- (+ i len) 1)
                            :collect
                            (loop :for k :from i :to (- j 1) :collect
                                  (let* ((ik (subseq xs i k))
                                         (kj (subseq xs k j)))
                                    (+ (parenthesization ik)
                                       (parenthesization kj)
                                       (* (cost (apply #'* ik))
                                          (cost (apply #'* kj))))))))))))))


;; todo debug. output behaves right but not quite
;;      memoizartion in lisp.
module MatrixChain where

-- catlan number
--            1    (2n)     (2n)!
--    Cₙ = ------- (  )  = -------   for n >= 0.
--          n + 1  ( n)    (n+1)!n!
--

#include <iostream>
#include <limits>
#include <vector>

// TODO

// to find a minimum cost from a source to sink in a multistage graph.
// a multistage graph is a directed graph with a node with in degree 0 known as
// source, and a node with out degree 0 as sink.
// typically we have k-stage where k is then number of stage of the graph.
//
// A property of multistage set is that vertexes are partitioned into k sets.
// when visiting a node in set ki, we know nodes in k-1 must be visited already.

// we use 2d vector to represent the graph as adjacent table.
// index is the node, the vector contains nodes it connected to and the weight
// of the edge.
// An assumption is veretices are orderd by stage. e.g idx 0 is the source and
// idx size() - 1 is the sink.

struct stage_graph {
  std::vector<std::vector<std::pair<int, int>>> g;
  int k;
};

void pprint(const std::vector<std::pair<int, int>> &v) {
  for (auto &[i, w] : v) {
    std::cout << "(" << i << ", " << w << ")"
              << ", ";
  }
  std::cout << "\n";
}

#define MAX 10000
#define min(a, b) (a > b ? b : a)

std::pair<int, int> find_min(int j, const stage_graph &graph, int *cost) {

  int r = -1;
  int c = MAX;

  for (auto &[v, w] : graph.g[j]) {
    int cd = c;
    c = min(c, w + cost[v]);
    r = c == cd ? r : v;
  }
  std::cout << "j: " << j << "r: " << r << "c: " << c << std::endl;
  return {r, c};
}

std::vector<int> multistage(const stage_graph &graph) {
  int n = graph.g.size();
  int k = graph.k;
  int cost[n];
  int d[n];
  std::vector<int> p(k, 0);
  for (int i = 0; i < n; ++i) {
    cost[i] = 0;
  }

  for (int j = n - 1; j != 0; --j) { // exclude sink

    // find vertex r s.t (j, r) in graph, and c(j, r) + cost(r) is minimal.
    auto [r, c] = find_min(j, graph, cost);
    cost[j] = c;
    d[j] = r;
  }

  p[1] = 1;
  p[k - 1] = n;
  for (int j = 1; j < k - 2; ++j) {
    p[j] = d[p[j - 1]];
  }
  return p;
}

#define TEST
#ifdef TEST
stage_graph graph = {.g =
                         {
                             {{1, 1}, {2, 2}, {3, 5}}, // 0

                             {{4, 4}, {5, 11}},         // 1
                             {{4, 9}, {5, 5}, {6, 16}}, // 2
                             {{6, 2}},                  // 3

                             {{7, 18}}, // 4
                             {{7, 13}}, // 5
                             {{7, 2}},  // 6

                             // 7
                         },
                     .k = 4};

int main(void) {

  std::cout << "grap: " << std::endl;
  for (auto v : graph.g) {
    pprint(v);
  }

  std::vector<int> path = multistage(graph);

  std::cout << "path: " << std::endl;
  for (auto v : path) {
    std::cout << v << ", ";
  }
  std::cout << "\n";

  return 0;
}

#endif
#include <iostream>
#include <functional>
#include <iostream>
#include <limits>
#include <vector>

// Problem:
// We have a country has weird coin values like 1, 5, 11.
// Given a price of some merchants be n, find a combination
// that gives n with 1, 5, 11 that requires the least amount of
// coins.

// Attempt:
// 1. We can just brute force, but the time complexity will be
//    very bad.
// 2. We can try to use a greedy algorithm. Imagine if we have coins
//    with value 1, 5, 10, and each time we choose the largest
//    possible coin until we reach the price.
//    This doesn't work for 1, 5, 11 though. Imagine to get 15,
//    if we choose 11 first, we have  11 + 1 + 1 + 1, 4 coins,
//    but if we choose a smaller value, 5, then it will be
//    5 + 5 + 5, 3 coins.
//    The reason a greedy algorithm doesn't work here is because
//    it's lack of a overview of the problem.

// dp idea:
//   define cost function f(n), n is the input
//   the goal is to minimize f(15).
//   now, at n = 15, we have 3 choices: 1, 5, 11
//   corresponds to subproblem with size 14, 10, 4 respectively.
//   So now we need to find minimize the cost of these input, namely
//
//      min(f(14), f(10), f(4)).
//
//   thus the cost of f(15):
//
//      f(15) = min(f(14), f(10), f(4)) + 1
//
//   do this recursively until the procedure finish.
//   let's see

#define min(a, b) (a > b ? b : a)
#define N 15

// a very common scheme on these competetive programming problem is to use array
// as a map from integer to some value.
// It's very fast and simple to use. it will almost never be the same case in a
// real world problem though.

void spare_cash1() {

  int f[256];
  int cost;
  f[0] = 0;

  for (int i = 1; i <= N; ++i) {
    cost = INT32_MAX;

    // min(f(n - 1), f(n - 5), f(n - 11)) + 1
    if (i - 1 >= 0)
      cost = min(cost, f[i - 1] + 1);
    if (i - 5 >= 0)
      cost = min(cost, f[i - 5] + 1);
    if (i - 11 >= 0)
      cost = min(cost, f[i - 11] + 1);
    f[i] = cost;

    printf("f(%d) = %d\n", i, f[i]);
  }
}

// recursive solution.
void spare_cash2() {

  static std::vector<int> cache{};
  cache.resize(15);
  std::fill(cache.begin(), cache.end(), -1);
  cache[0] = 0;

  std::function<int(int)> rec = [&](int n) -> int {
    int cached = cache[n - 1];
    if (cached != -1) {
      printf("f(%d) = %d\n", n, cached);
      return cached;
    }

    int cost = INT8_MAX;
    if (n - 1 >= 0)
      cost = min(cost, rec(n - 1) + 1);
    if (n - 5 >= 0)
      cost = min(cost, rec(n - 5) + 1);
    if (n - 11 >= 0)
      cost = min(cost, rec(n - 11) + 1);

    printf("f(%d) = %d\n", n, cost);
    cache[n - 1] = cost;
    return cost;
  };

  rec(N);
}
// output:
// f(1) = 1
// f(2) = 2
// f(3) = 3
// f(4) = 4
// f(5) = 1
// f(6) = 2
// f(7) = 3
// f(8) = 4
// f(9) = 5
// f(10) = 2
// f(11) = 1
// f(12) = 2
// f(13) = 3
// f(14) = 4
// f(15) = 3

// we construct best solution from 1 to 15.

// 1. Why it's better than brute force? Because it only check cases of
//    f(n - 1) f(n - 5) f(n - 11). A brute force solution will require to
//    check all combinations.
// 2. Why it's better then greedy algorithm?
//    The final solution is made from sub optimal solutions. At f(n) it knows
//    min(f(n - 1) f(n - 5) f(n - 11)) will give it the best choice.
//    Greedy algorithm knows nothing about how good a choice is. It just follows
//    one rule and one rule only.

// core idea is to formulate the problem recursively.
// Although normally they can be solved iteratively.

int main(void) {
  spare_cash1();
  printf("\n");
  spare_cash2();
  return 0;
}
module SpareCash where

-- first let's review the essense of dynamic programming.
-- dynamic programming is a technique for optimization problem.
-- You care about

-- again, you have possible currency value 1, 5, 11, you want
-- to make up to n dolloars with the least amount of cashes.

-- this time let's apply 5 easy steps for dp.
-- f(n) = min(f(n - 1), f(n - 5), f(n - 11))


spareCash :: Integer -> Integer
spareCash 0 = 0
spareCash n = minimum (case [ spareCash (n - i) | i <- filter (n>=) [1, 5, 11]] of
                       [] -> pure 0
                       xs -> xs) + 1


run = spareCash 15

-- oh that was quick, damn

-- let me try to solve it bottom up.
(defun substring ()
  )
;; Latex text adjustment

;; how to solve:
;; 1. subproblems: suffixes workds [i:]
;; 2. guess where to start 2nd line #choices <= n-1 = O(n)
;; 3. recurrence:
;;     DP(i) = min{
;;       DP(j) + badness(i, j) forall j in range(i+1, n+1)
;;     }
;; 4. check topological order
;; 5. total time: O(n^2)  // (number of subproblems * running time for subproblem)
;; 6. original problem DP(0)

;; use parent pointer to remember the best guess.
;; like backtrace.

;; todo

(defparameter *works*
  (concatenate
    'string
    "sdl laj al klajsdf alks aslkdfd s iojwe awbrbk hker asidj awei"
    " k ioa iowe hwef nq lkaj foiua aiosudf aiosud oifausd hafshakd"
    "o asdj dif anwefn oi sd fajsd oipfe ls oaiusdo nkadwoei oiu jsd"))

(defparameter *page-width* 40)


;; where to cut the line to fit the document best?

(defun badness (str pw tw)
  "badness of a substring"
  )


(defun text-justification ()

  )
#include <iostream>

// euclidean traveling salesman problem.

// Traveling salesman problem is NP hard, we are looking for a constraint version of the
// problem: finding the shortest closed bitonic tour.
//
// Bitonic means after the graph is formed. any vertical line cuts the graph at most twice.


// The problem
// The problem of finding the shortest closed bitonic tour
// can be though as finding the shortest open bitonic tour: the tour that
// doesn't connect the last vertex with the starting vertex. And finding the shortest
// open bitonic tour itself can be solved by finding the shortest path with one node
// less, this recursively go down until hit the base case: only one edge left.
// PS: if there are only two points, the shortest open bitonic tour is just the line
//     connects them.

// Given n points
// We first label each points with an index from 0 to n-1. We can define the shortest
// path function C, so for two given points i, j, we have C(i, j) as the shortest
// open bitonic tour.

// Formulate the problem:
// IF we want to find the shortest closed bitonic tour for 5 points, with the funcitoon
// C defined above, the shortest tour is written as C(0, 5).
//
// we can list optimal solutions for all subproblems:
//
// C(0, 1)
// C(0, 2) C(1, 2)
// C(0, 3) C(1, 3) C(2, 3)
// C(0, 4) C(1, 4) C(2, 4) C(3, 4)
//
// Notice  C(0, 5) is just C(x, 4) + edge from 3 to 4. We formulate this relation as:
//  C(0, 4) = min(C(0, 4), C(1, 4), C(2, 4)) + (edge 4, 5)
//
// More generally, for a graph with n points, we have
//
//  C(0, n-1) = min(C(i, n-2)) + (edge of n-1 and n-2) forall 0 <= i <= n-1
//  C(0, 1) = a constant (just the line between 0 and 1)

// Notice overlapping subproblems. e.g For the example above, C(0, 2) needs to be solved
// four times.
// To make an efficient implementation, we can use memoization techniques to cache C(0, n) in
// a table. Whenever we're trying to solve C, search in the cache first.


int bitonic_shortest_tour() {
}


int main(void) {

  return 0;
}

// https://codeforces.com/problemset/problem/996/A

#include <inttypes.h>
#include <iostream>

#define TEST

// bills = 1 + min(f(n - 1), f(n - 5), f(f - 10), f(n - 20), f(n - 100))

#define MIN(a, b) (a > b ? b : a)

int get_min(int n) {
  int f[1024];
  int c = 0;
  f[0] = 0;

  for (int i = 1; i <= n; ++i) {
    c = INT32_MAX;
    if (i >= 1) {
      c = MIN(c, f[i - 1] + 1);
    }
    if (i >= 5) {
      c = MIN(c, f[i - 5] + 1);
    }
    if (i >= 10) {
      c = MIN(c, f[i - 10] + 1);
    }
    if (i >= 20) {
      c = MIN(c, f[i - 20] + 1);
    }
    if (i >= 100) {
      c = MIN(c, f[i - 100] + 1);
    }

    f[i] = c;
  }

  return c;
}

int main(void) {
  std::ios_base::sync_with_stdio(false);

  int n;
  std::cin >> n;
  std::cout << get_min(n) << std::endl;

  return 0;
}
#include <cstdio>
#include <vector>

int main() {

  std::vector<long> d;
  d.push_back(100);
  d.push_back(20);
  d.push_back(10);
  d.push_back(5);
  d.push_back(1);

  long n;
  scanf("%ld", &n);
  long cnt(0);
  for (long p = 0; p < d.size(); p++) {
    cnt += (n / d[p]);
    n %= d[p];
  }
  printf("%ld\n", cnt);

  return 0;
}
#include <stddef.h>
#include <stdlib.h>

typedef struct Bucket {
  int num;
  int *ptrs;
} Bucket;

int* delete_nth(size_t szin, int order[szin], int max_e, size_t *szout) {
  Bucket buffer[szin];
}
#include <stdlib.h>

static int isodd(int v) {
  return v & 0x1;
}

int find_outlier(const int *values, size_t count) {
  const int flag = isodd(values[0]);
  for (size_t i = 1; i < count; i++) {
    if (flag ^ isodd(values[i])) {
      if (i == 1 && (flag ^ isodd(values[i + 1])))
        return values[0];
      return values[i];
    }
  }
  return 0;
}

int main(void) { return 0; }
#include <ctype.h>
#include <stdlib.h>
#include <string.h>

char *change(const char *str_in) {
  const int sz = 26;
  char *buffer = (char *)malloc(sizeof(char) * sz);
  memset(buffer, '0', sz);
  while (*str_in != '\0') {
    if (*str_in >= 'a' && *str_in <= 'z') {
      buffer[*str_in - 'a'] = '1';
    } else if (*str_in >= 'A' && *str_in <= 'Z') {
      buffer[*str_in - 'A'] = '1';
    }
    str_in++;
  }
  return buffer;
}

char *change1(const char *str_in) {
  char *r = (char *)malloc(27), c;
  memset(r, '0', 26);
  while ((c = *str_in++))
    if (isalpha(c))
      r[(c | 32) - 'a'] = '1';
  return r;
}

#include <stdio.h>
int main(void) {
  const char *a = "a *** bZ";
  printf("%s\n", change1(a));
  return 0;
}
#include <cstring>
#include <deque>
#include <iostream>
#include <limits>
#include <string>
#include <vector>

enum class Tag { LB = 0, RB, ADD, MINUS, MUL, DIV, NUM, NEG };

struct Token {
  std::string val;
  Tag tag;
};

static bool is_op(const Token &t) {
  return t.tag == Tag::ADD || t.tag == Tag::DIV || t.tag == Tag::MUL ||
         t.tag == Tag::MINUS || t.tag == Tag::NEG;
}

std::vector<Token> lexer(const std::string &input) {
  std::vector<Token> v;
  int pos = 0;

  auto num = [&pos, &input]() -> Token {
    std::vector<char> buf;

    while (std::isdigit(input[pos])) {
      buf.push_back(input[pos]);
      pos++;
    }
    if (input[pos] == '.') {
      buf.push_back('.');
      pos++;

      while (std::isdigit(input[pos])) {
        buf.push_back(input[pos]);
        pos++;
      }
    }

    pos--;
    return Token{std::string(buf.begin(), buf.end()), Tag::NUM};
  };

  while (pos < input.size()) {
    char a = input[pos];

    if (a == ' ') {

    } else if (a == '(') {
      v.push_back(Token{"(", Tag::LB});

    } else if (a == ')') {
      v.push_back(Token{")", Tag::RB});

    } else if (a == '*') {
      v.push_back(Token{"*", Tag::MUL});

    } else if (a == '/') {
      v.push_back(Token{"/", Tag::DIV});

    } else if (a == '+') {
      v.push_back(Token{"+", Tag::ADD});

    } else if (a == '-') {
      // handle head
      auto p = v.back();
      if (is_op(p) || p.tag == Tag::LB || p.tag == Tag::NEG) {
        v.push_back(Token{"-", Tag::NEG});

      } else {
        // parse as minus
        v.push_back(Token{"-", Tag::MINUS});
      }
    } else {
      v.push_back(num());
    }

    pos++;
  }
  return v;
}

static int prec(const Token &t) {
  switch (t.tag) {
  case Tag::NEG:
    return 3;
  case Tag::MUL:
  case Tag::DIV:
    return 2;
  case Tag::ADD:
  case Tag::MINUS:
    return 1;
  default:
    return -1;
  }
}

std::vector<Token> infix_to_postfix(const std::vector<Token> &s) {
  std::vector<Token> stack;
  std::vector<Token> out;

  for (auto it = s.begin(); it != s.end(); ++it) {
    switch (it->tag) {
    case Tag::NUM:
      out.push_back(*it);
      break;

    case Tag::LB:
      stack.push_back(*it);
      break;

    case Tag::NEG:
      stack.push_back(*it);
      break;

    case Tag::RB: {
      while (stack.size() > 0 && stack.back().tag != Tag::LB) {
        out.push_back(stack.back());
        stack.pop_back();
      }

      stack.pop_back();
    }

    break;

    default: {
      if (prec(*it) > prec(stack.back())) {
        stack.push_back(*it);
      } else {
        while (stack.size() > 0 && prec(*it) <= prec(stack.back())) {
          out.push_back(stack.back());
          stack.pop_back();
        }
        stack.push_back(*it);
      }
    }
    }
  }

  while (stack.size() != 0) {
    out.push_back(stack.back());
    stack.pop_back();
  }

  return out;
}

double eval(std::vector<Token> &stack) {
  switch (stack.back().tag) {
  case Tag::ADD: {
    stack.pop_back();
    auto v1 = eval(stack);
    auto v2 = eval(stack);
    return v2 + v1;
  }
  case Tag::MINUS: {
    stack.pop_back();
    auto v1 = eval(stack);
    auto v2 = eval(stack);
    return v2 - v1;
  }
  case Tag::MUL: {
    stack.pop_back();
    auto v1 = eval(stack);
    auto v2 = eval(stack);
    return v2 * v1;
  }
  case Tag::DIV: {
    stack.pop_back();
    auto v1 = eval(stack);
    auto v2 = eval(stack);
    return v2 / v1;
  }
  case Tag::NEG: {
    stack.pop_back();
    auto v = eval(stack);
    return -v;
  }

  case Tag::NUM: {
    double val = std::atof(stack.back().val.c_str());
    stack.pop_back();
    return val;
  }
  default:
    return 0;
  }
}

double calc(std::string expression) {
  auto braced_expression = "(" + expression + ")";
  auto tokens = lexer(braced_expression);
  auto postfix_stack = infix_to_postfix(tokens);

  std::cout << expression << std::endl;

  for (auto &e : postfix_stack) {
    std::cout << e.val << ",   tag: " << static_cast<int>(e.tag) << std::endl;
  }

  auto val = eval(postfix_stack);
  std::cout << val << std::endl;
  return val;
}

int main(void) {
  std::cout << "so:\n" << calc("-7 * -(6 / 3)") << "\n" << std::endl;

  std::cout << "so:\n"
            << calc("2 + 3 * 4 / 3 - 6 / 3 * 3 + 8") << "\n"
            << std::endl;

  std::cout << "so:\n"
            << calc("-63 + 17 - 98 - -53 * 91 * 5 / -53 * -4") << "\n"
            << std::endl;

  std::cout << "so:\n" << calc("-53 * 91 * 5 / -53 * -4") << "\n" << std::endl;

  std::cout << "so:\n" << calc("-53 * 91 * 5 / -53 * -4") << "\n" << std::endl;

  std::cout << "so:\n" << calc("98 - -1 / -53 * -4") << "\n" << std::endl;

  return 0;
}
#define ASSERT_PRINT_(xs)                                                      \
  do {                                                                         \
    std::cout << ": ";                                                         \
    for (auto v : xs) {                                                        \
      std::cout << v << " ";                                                   \
    }                                                                          \
    std::cout << "\n";                                                         \
    assert(xs == result);                                                      \
  } while (0);

#include <algorithm>
#include <cassert>
#include <cstdlib>
#include <functional>
#include <iostream>
#include <iterator>
#include <numeric>
#include <vector>

namespace util {
auto acc = [](int a, auto b) { return a + b.size(); };

}

static int capacity;
static std::vector<int> log{};
static std::vector<std::vector<int>> queues;
static std::vector<int> cabin{};
static bool is_up = true;
static decltype(queues)::iterator current;

auto get_range() {
  auto first = is_up ? current + 1 : queues.begin();
  auto last = is_up ? queues.end() : current - 1;
  return std::make_tuple(first, last);
}

int get_floor() { return std::distance(queues.begin(), current); }

void rotate() { is_up = !is_up; }

// step towards the direction
void step() {
  if (is_up) {
    current++;
  } else {
    current--;
  }
}

bool is_same_direction(int src, int dest) {
  if (cabin.size() == 0) {
    return false;
  }

  if (is_up) {
    return dest > src;
  } else {
    return dest < src;
  }
}

void back_to_ground() {
  current = queues.begin();
  is_up = true;
  log.push_back(get_floor());
}

// deliver ppl
void offboard() {
  int floor = get_floor();
  auto it = std::remove(cabin.begin(), cabin.end(), floor);
  cabin.erase(it, cabin.end());
}

// ppl up
void onboard() {
  int floor = get_floor();
  auto first = current->begin();
  auto last = current->end();
  auto pred = [=](auto n) { return is_same_direction(floor, n); };

  std::copy_if(first, last, std::back_inserter(cabin), pred);

  auto iter = std::remove_if(first, last, pred);
  current->erase(iter, current->end());
}

// people waiting ahead to on/off
int waiting_along_n() {
  int in_cabin = cabin.size();
  auto [first, last] = get_range();

  int in_building = std::accumulate(first, last, 0, util::acc);

  return in_building + in_cabin;
}

int waiting_n() {
  int n = std::accumulate(queues.begin(), queues.end(), 0, util::acc);
  return n;
}

bool is_finished() {
  bool cabin_empty = cabin.size() == 0;
  bool building_empty = waiting_n() == 0;
  return cabin_empty && building_empty;
}

// step till the other side
int step_across() {
  for (; waiting_along_n() != 0; step())
    ;
  return get_floor();
}

// step till next need
int step_n(int n) {
  for (int i = 0; i < n; ++i) {
    step();
  }
  return get_floor();
}

// the
typename std::iterator_traits<decltype(current)>::difference_type
shortest_next_hop() {
  int floor = get_floor();
  std::vector<int> buffer{};

  auto pred = [=](int n) {
    return (is_up && n > floor) || (!is_up && n < floor);
  };

shortest_cabin : {
  auto first = cabin.begin();
  auto last = cabin.end();
  std::copy_if(first, last, std::back_inserter(buffer), pred);
}

shortest_building : {
  auto [first, last] = get_range();
  for (; first != last; ++first) {
    auto floor = std::distance(queues.begin(), first);
    for (auto v : *first) {
      if (pred(v)) {
        buffer.push_back(floor);
        continue;
      }
    }
  }
}

  auto bfirst = buffer.begin();
  auto bend = buffer.end();
  return is_up ? *std::min_element(bfirst, bend) - floor
               : floor - *std::max_element(bfirst, bend);
}

// find next floor
void advance() {
  if (is_finished()) {
    current = queues.begin();
    is_up = true;
    return;
  }

  if (waiting_along_n() == 0) {
    rotate();
  }

  if (cabin.size() == 0) {
    step_across();

  } else {
    auto n = shortest_next_hop();
    step_n(n);
  }
}

std::vector<int> the_lift(std::vector<std::vector<int>> queues, int capacity) {
  ::queues = queues;
  ::capacity = capacity;
  cabin.reserve(capacity);
  current = queues.begin();

  while (!is_finished()) {
    offboard();
    onboard();
    advance();
  }

  return log;
}

int main(void) {
  std::vector<std::vector<int>> queues;
  std::vector<int> result;
  // queues = {{}, {}, {5, 5, 5}, {}, {}, {}, {}};
  queues = {{2}, {3}, {5, 5, 5}, {}, {}, {}, {4}};
  result = {0, 2, 5, 0};
  ASSERT_PRINT_(the_lift(queues, 5));

  /* queues = {{}, {}, {1, 1}, {}, {}, {}, {}}; */
  /* result = {0, 2, 1, 0}; */
  /* ASSERT_PRINT_(the_lift(queues, 5)); */

  /* queues = {{}, {}, {}, {}, {2}, {3}, {}}; */
  /* result = {0, 5, 4, 3, 2, 1, 0}; */
  /* ASSERT_PRINT_(the_lift(queues, 5)); */

  return 0;
}
#include <algorithm>
#include <cassert>
#include <functional>
#include <iostream>
#include <numeric>
#include <vector>

#define DEBUG

enum class Direction { Up, Down };

static Direction direction = Direction::Up;

static int capacity;
static std::vector<int> cabin{};
static std::vector<std::vector<int>>::iterator current_floor;

static void rotate() {
  if (direction == Direction::Up)
    direction = Direction::Down;
  else
    direction = Direction::Up;
}

static void step() { // move in the same direction.
  if (direction == Direction::Up)
    ++current_floor;
  else
    --current_floor;
}

static int acc(int a, std::vector<int> b) { return a + b.size(); };

static int get_floor(const std::vector<std::vector<int>> &queues) {
  std::vector<std::vector<int>>::const_iterator current_floor = ::current_floor;
  return std::distance(queues.cbegin(), current_floor);
}

static auto pick(int floor) {
  return [=](int n) {
    if (cabin.size() >= capacity)
      return false;

    return direction == Direction::Up ? n > floor : n < floor;
  };
}

static int ppl_in_building(const std::vector<std::vector<int>> &queues) {
  return std::accumulate(queues.cbegin(), queues.cend(), 0, acc);
}

auto ppl_ahead_in_building = [](const std::vector<std::vector<int>> &queues,
                                auto fn) {
  std::vector<std::vector<int>>::const_iterator current_floor = ::current_floor;
  int floor = get_floor(queues);

  switch (direction) {
  case Direction::Down:
    return fn(std::make_reverse_iterator(current_floor) + 1, queues.crend(),
              pick(floor), floor);

  case Direction::Up:
  default:
    return fn(current_floor + 1, queues.cend(), pick(floor), floor);
  }
};

static int waiting_ahead_n(const std::vector<std::vector<int>> &queues) {
  int n = ppl_ahead_in_building(
      queues, [](auto first, auto last, auto pick, auto floor) {
        int in_building = std::accumulate(first, last, 0, acc);
        int in_cabin = std::count_if(cabin.cbegin(), cabin.cend(), pick);
        return in_building + in_cabin;
      });
  return n;
}

// pick closest same direction in cabin ,
// pick cloesst same direction in building ahead.
// min of these two.
static int next_stop(const std::vector<std::vector<int>> &queues) {
  return ppl_ahead_in_building(
      queues, [=](auto first_, auto last, auto pick, auto floor) {
        auto first = first_ - 1; // count the current one too.

        std::vector<int> buffer{};
        for (int i = 1; first != last; ++first, ++i) {

          int floor_ = direction == Direction::Up ? floor + i : floor - i;

#ifdef DEBUG
          assert(floor >= 0 && floor < queues.size());
#endif
          // collect ppl want to go in same direction
          if (first->begin() != first->end()) {
            for (auto iter = first->begin(); iter != first->end(); ++iter) {
              int diff = *iter - floor_;

              if (direction == Direction::Up && *iter > floor_ ||
                  direction == Direction::Down && *iter < floor_) {
                buffer.push_back(floor_);
              }
            }
          } else {
          }
        }

        std::copy_if(cabin.cbegin(), cabin.cend(), std::back_inserter(buffer),
                     pick);

        return direction == Direction::Up
                   ? *std::min_element(buffer.begin(), buffer.end()) - floor
                   : floor - *std::max_element(buffer.begin(), buffer.end());
      });
}

// call after current_floor iterator stop at a floor.
void arrive(std::vector<std::vector<int>> &queues) {
  int floor = std::distance(queues.begin(), current_floor);

  // off
  cabin.erase(std::remove(cabin.begin(), cabin.end(), floor), cabin.end());

  // on
  auto pickup = [=]() {
    std::copy_if(current_floor->cbegin(), current_floor->cend(),
                 std::back_inserter(cabin), pick(floor));
    current_floor->erase(std::remove_if(current_floor->begin(),
                                        current_floor->end(), pick(floor)),
                         current_floor->end());
  };
  if (current_floor->size() > 0) {
    int old_cabin_size = cabin.size();
    pickup();

    if (cabin.size() == old_cabin_size) { // nobody get picked up. rotate.
      rotate();
      pickup();
    }
  }
}

static void try_rotate(const std::vector<std::vector<int>> &queues) {
  if (waiting_ahead_n(queues) == 0) {
    rotate();
  }
}

static bool should_back_to_ground(std::vector<std::vector<int>> &queues) {
  return cabin.size() == 0 && ppl_in_building(queues) == 0;
}

void depart(std::vector<std::vector<int>> &queues) {
  if (should_back_to_ground(queues)) {
    direction = Direction::Up;
    current_floor = queues.begin();
    return;
  }

  try_rotate(queues);

  if (cabin.size() == 0) {

    for (; waiting_ahead_n(queues) != 0; step())
      ;
    arrive(queues);

  } else { // cabin not empty

    int floor = get_floor(queues);
    int diff = next_stop(queues);

    for (; diff > 0; --diff, step())
      ;
    arrive(queues);
  }
}

inline static bool running(const std::vector<std::vector<int>> &queues) {
  std::vector<std::vector<int>>::const_iterator current_floor = ::current_floor;
  int floor = std::distance(queues.begin(), current_floor);
  return waiting_ahead_n(queues) != 0 || floor != 0;
}

std::vector<int> the_lift(std::vector<std::vector<int>> queues, int capacity) {
  ::capacity = capacity;
  std::vector<int> lift_log = {};
  current_floor = queues.begin();
  cabin.reserve(capacity);

  do {
    lift_log.push_back(std::distance(queues.begin(), current_floor));
    depart(queues); //@
  } while (running(queues));
  lift_log.push_back(std::distance(queues.begin(), current_floor));

  return lift_log;
}

#define ASSERT_PRINT_(xs)                                                      \
  do {                                                                         \
    std::cout << ": ";                                                         \
    for (auto v : xs) {                                                        \
      std::cout << v << " ";                                                   \
    }                                                                          \
    std::cout << "\n";                                                         \
    assert(xs == result);                                                      \
  } while (0);

int main(void) {
  std::vector<std::vector<int>> queues;
  std::vector<int> result;
  /* queues = {{}, {}, {5, 5, 5}, {}, {}, {}, {}}; */
  /* result = {0, 2, 5, 0}; */
  /* ASSERT_PRINT_(the_lift(queues, 5)); */

  /* queues = {{}, {}, {1, 1}, {}, {}, {}, {}}; */
  /* result = {0, 2, 1, 0}; */
  /* ASSERT_PRINT_(the_lift(queues, 5)); */

  queues = {{}, {}, {}, {}, {2}, {3}, {}};
  result = {0, 5, 4, 3, 2, 1, 0};
  ASSERT_PRINT_(the_lift(queues, 5));
  return 0;
}
#include <array>
#include <iostream>
#include <string>
#include <vector>

// APP_PASSIVE_OPEN, APP_ACTIVE_OPEN, APP_SEND, APP_CLOSE, APP_TIMEOUT, RCV_SYN,
// RCV_ACK, RCV_SYN_ACK, RCV_FIN, RCV_FIN_ACK

enum class State {
  CLOSED = 0,
  LISTEN,
  SYN_SENT,
  SYN_RCVD,
  ESTABLISHED,
  CLOSE_WAIT,
  LAST_ACK,
  FIN_WAIT_1,
  FIN_WAIT_2,
  CLOSING,
  TIME_WAIT,
  ERROR,
};

std::array<std::string, 12> states{"CLOSED",   "LISTEN",      "SYN_SENT",
                                   "SYN_RCVD", "ESTABLISHED", "CLOSE_WAIT",
                                   "LAST_ACK", "FIN_WAIT_1",  "FIN_WAIT_2",
                                   "CLOSING",  "TIME_WAIT",   "ERROR"};

State step(State s, std::string &event) {
  switch (s) {
  case State::CLOSED:
    if (event == "APP_PASSIVE_OPEN") {
      return State::LISTEN;

    } else if (event == "APP_ACTIVE_OPEN") {
      return State::SYN_SENT;
    }
    break;

  case State::LISTEN:
    if (event == "RCV_SYN") {
      return State::SYN_RCVD;

    } else if (event == "APP_SEND") {
      return State::SYN_SENT;

    } else if (event == "APP_CLOSE") {
      return State::CLOSED;
    }
    break;

  case State::SYN_RCVD:
    if (event == "APP_CLOSE") {
      return State::FIN_WAIT_1;

    } else if (event == "RCV_ACK") {
      return State::ESTABLISHED;
    }
    break;

  case State::SYN_SENT:
    if (event == "RCV_SYN") {
      return State::SYN_RCVD;

    } else if (event == "RCV_SYN_ACK") {
      return State::ESTABLISHED;

    } else if (event == "APP_CLOSE") {
      return State::CLOSED;
    }
    break;

  case State::ESTABLISHED:
    if (event == "APP_CLOSE") {
      return State::FIN_WAIT_1;

    } else if (event == "RCV_FIN") {
      return State::CLOSE_WAIT;
    }
    break;

  case State::FIN_WAIT_1:
    if (event == "RCV_FIN") {
      return State::CLOSING;

    } else if (event == "RCV_FIN_ACK") {
      return State::TIME_WAIT;

    } else if (event == "RCV_ACK") {
      return State::FIN_WAIT_2;
    }

    break;

  case State::CLOSING:
    if (event == "RCV_ACK") {
      return State::TIME_WAIT;
    }
    break;

  case State::FIN_WAIT_2:
    if (event == "RCV_FIN") {
      return State::TIME_WAIT;
    }

    break;

  case State::TIME_WAIT:
    if (event == "APP_TIMEOUT") {
      return State::CLOSED;
    }
    break;

  case State::CLOSE_WAIT:
    if (event == "APP_CLOSE") {
      return State::LAST_ACK;
    }
    break;

  case State::LAST_ACK:
    if (event == "RCV_ACK") {
      return State::CLOSED;
    }
    break;

  default:
    break;
  }

  return State::ERROR;
}

std::string traverse_TCP_states(const std::vector<std::string> &events) {
  State state{State::CLOSED};

  for (auto e : events) {
    state = step(state, e);
  }

  return states[static_cast<int>(state)];
}

int main(void) {
  using vs = std::vector<std::string>;

  vs test1 = {"APP_ACTIVE_OPEN", "RCV_SYN_ACK", "RCV_FIN"};
  vs test2 = {"APP_PASSIVE_OPEN", "RCV_SYN", "RCV_ACK"};
  vs test3 = {"APP_ACTIVE_OPEN", "RCV_SYN_ACK", "RCV_FIN", "APP_CLOSE"};
  vs test4 = {"APP_ACTIVE_OPEN"};
  vs test5 = {"APP_PASSIVE_OPN", "RCV_SYN", "RCV_ACK", "APP_CLOSE", "APP_SEND"};

  std::cout << traverse_TCP_states(test1) << std::endl;
  std::cout << traverse_TCP_states(test2) << std::endl;
  std::cout << traverse_TCP_states(test3) << std::endl;
  std::cout << traverse_TCP_states(test4) << std::endl;
  std::cout << traverse_TCP_states(test5) << std::endl;
  return 0;
}
#include <iostream>

template <int x> struct factorial {
  const static unsigned long long value = x * factorial<x-1>::value;
};
template <> struct factorial<0> { const static unsigned long long value = 1; };


int main(void)
{
  unsigned long long a = factorial<20>::value;
  std::cout << a << std::endl;
  return 0;
}
module Main ( main) where


main :: IO ()
main = undefined
module Kyu1.BecomeImmortal where

elderAge :: Integer -> Integer -> Integer -> Integer -> Integer
elderAge = error "For the Elder!"


-- testing --------------------------------------------------------------------
{-# LANGUAGE FlexibleInstances    #-}
{-# LANGUAGE InstanceSigs         #-}
{-# LANGUAGE RankNTypes           #-}
{-# LANGUAGE ScopedTypeVariables  #-}
{-# LANGUAGE UndecidableInstances #-}

module Kyu1.PeanoAndChurch where

import           Data.List

type ISO a b = (a -> b, b -> a)
-- See https://www.codewars.com/kata/isomorphism

symm :: ISO a b -> ISO b a
symm (ab, ba) = (ba, ab)

substL :: ISO a b -> (a -> b)
substL = fst

substR :: ISO a b -> (b -> a)
substR = snd

liftISO2 :: ISO a b -> ISO (a -> a -> a) (b -> b -> b)
liftISO2 (ab, ba) =
  (\f -> \b1 b2 -> ab $ f (ba b1) (ba b2),
  \g -> \a1 a2 -> ba $ g (ab a1) (ab a2))

-- A Natural Number is either Zero,
-- or a Successor (1 +) of Natural Number.
-- We have (+)/(*) on Natural Number, or (-) it.
-- Since Natrual Number do not have negative, forall x, 0 - x = 0.
-- We also have pow on Natrual Number
-- Since Haskell is lazy, we also have infinity

class Nat n where
  zero :: n
  successor :: n -> n
  nat :: a -> (n -> a) -> n -> a -- Pattern Matching
  iter :: a -> (a -> a) -> n -> a -- Induction
  plus, minus, mult, pow :: n -> n -> n
  inf :: n
  inf = successor inf
  divide :: n -> n -> n
  l `divide` r | l == 0 && r == 0 = undefined
  l `divide` r | l < r = 0
  l `divide` r | otherwise = successor $ (l `minus` r) `divide` r
  -- notice (l `divide` 0) when l is not 0 will return inf
  isoP :: ISO n Peano -- See below for the definition of Peano
  isoP = (iter zero successor, iter zero successor)
  toP :: n -> Peano
  toP = substL isoP

instance {-# OVERLAPPABLE #-} Nat n => Show n where
  show = show . toP

instance {-# OVERLAPPABLE #-} Nat n => Eq n where
  l == r = toP l == toP r

instance {-# OVERLAPPABLE #-} Nat n => Ord n where
  l `compare` r = toP l `compare` toP r

instance {-# OVERLAPPABLE #-} Nat n => Num n where
  abs = id
  signum = nat zero (const 1)
  fromInteger 0 = zero
  fromInteger n | n > 0 = successor $ fromInteger (n - 1)
  (+) = plus
  (*) = mult
  (-) = minus

-- We can encode Natrual Number directly as Algebraic Data Type(ADT).
data Peano = O | S Peano deriving (Show, Eq, Ord)

-- Remember, 0 - x = 0 for all x.
instance Nat Peano where

-- Peano is very similar to a basic data type in Haskell - List!
-- O is like [], and S is like :: (except it lack the head part)
-- When we want to store no information, we can use (), a empty tuple
-- This is different from storing nothing (called Void in Haskell),
-- as we can create a value of () by using (),
-- but we cannot create a value of Void.

-- Notice how you can implement everything once you have isoP,
-- By converting to Peano and using Nat Peano?
-- Dont do that. You wont learn anything.
-- Try to use operation specific to list.
instance Nat [()] where

-- Instead of defining Nat from zero, sucessor (and get Peano),
-- We can define it from Pattern Matching
newtype Scott = Scott { runScott :: forall a. a -> (Scott -> a) -> a }
instance Nat Scott where
  -- Other operation on Scott numeral is sort of boring,
  -- So we implement it using operation on Peano.
  -- You shouldnt do this - I had handled all the boring case for you.
  plus = substR (liftISO2 isoP) plus
  minus = substR (liftISO2 isoP) minus
  mult = substR (liftISO2 isoP) mult
  pow = substR (liftISO2 isoP) pow

-- Or from induction!
newtype Church = Church { runChurch :: forall a. (a -> a) -> a -> a }
instance Nat Church where
  -- Try to implement the calculation (except minus) in the primitive way.
  -- Implement them by constructing Church explicitly.
  -- So plus should not use successor,
  -- mult should not use plus,
  -- exp should not use mult.I
{-# LANGUAGE LambdaCase          #-}
{-# LANGUAGE Rank2Types          #-}
{-# LANGUAGE ScopedTypeVariables #-}
module Kyu1.ScottEncoding where

import           Prelude    hiding (concat, curry, foldl, foldr, fst, length,
                             map, null, snd, take, uncurry, zip, (++))
import           Test.Hspec


newtype SMaybe a = SMaybe { runMaybe :: forall b. b -> (a -> b) -> b }
newtype SList a = SList { runList :: forall b. b -> (a -> SList a -> b) -> b }
newtype SEither a b = SEither { runEither :: forall c. (a -> c) -> (b -> c) -> c }
newtype SPair a b = SPair { runPair :: forall c. (a -> b -> c) -> c }

toPair :: SPair a b -> (a,b)
toPair (SPair f) = f (,)

fromPair :: (a,b) -> SPair a b
fromPair (a, b) = SPair (\f -> f a b)

fst :: SPair a b -> a
fst (SPair f) = f const

snd :: SPair a b -> b
snd (SPair f) = f (const id)

swap :: SPair a b -> SPair b a
swap (SPair f) = SPair (f . flip)

curry :: (SPair a b -> c) -> (a -> b -> c)
curry f = \a b -> f (SPair (\f' -> f' a b))

uncurry :: (a -> b -> c) -> (SPair a b -> c)
uncurry f = \(SPair f') -> f' f

toMaybe :: SMaybe a -> Maybe a
toMaybe (SMaybe f) = f Nothing Just

fromMaybe :: Maybe a -> SMaybe a
fromMaybe = \case
  Just a  -> (SMaybe (\_ g -> g a))
  Nothing -> (SMaybe const)

isJust :: SMaybe a -> Bool
isJust (SMaybe f) = f False (const True)

isNothing :: SMaybe a -> Bool
isNothing = not . isJust

catMaybes :: SList (SMaybe a) -> SList a
catMaybes (SList f) = f nil' (\(SMaybe f') l ->
  let rest = (catMaybes l)
   in f' rest (flip cons rest))

toEither :: SEither a b -> Either a b
toEither (SEither f) = f Left Right

fromEither :: Either a b -> SEither a b
fromEither = \case
  Right r -> (SEither (\_ b -> b r))
  Left l  -> (SEither (\a _ -> a l))

isLeft :: SEither a b -> Bool
isLeft (SEither f) = f (const True) (const False)

isRight :: SEither a b -> Bool
isRight = not . isLeft

partition :: SList (SEither a b) -> SPair (SList a) (SList b)
partition (SList f) = f (SPair (\f' -> f' nil' nil'))
  (\(SEither e) l' ->
    let SPair p = partition l'
     in p (\la lb ->
       e (\a -> (SPair (\f' -> f' (cons a la) lb)))
         (\b -> (SPair (\f' -> f' la (cons b lb))))))

toList :: SList a -> [a]
toList (SList f) = f [] (\a l -> a : toList l)

fromList :: [a] -> SList a
fromList = \case
  []     -> nil'
  (x:xs) -> cons x (fromList xs)

nil' :: SList a
nil' = (SList (\b _ -> b))

cons :: a -> SList a -> SList a
cons a b = SList (\_ f -> f a b)

concat :: SList a -> SList a -> SList a
concat (SList f) l = f l (\a l' ->
  cons a (concat l' l))

null :: SList a -> Bool
null (SList f) = f True (const . const False)

length :: SList a -> Int
length (SList f) = f 0 (\_ l -> 1 + (length l))

map :: (a -> b) -> SList a -> SList b
map f (SList la)= la nil' (\a l -> cons (f a) (map f l))

zip :: SList a -> SList b -> SList (SPair a b)
zip (SList la) (SList lb) = la nil' (\a l ->
  lb nil' (\b l' ->
    cons (SPair (\f -> f a b)) (zip l l')))

foldl :: (b -> a -> b) -> b -> SList a -> b
foldl f b l = foldr (\b g a -> g (f a b)) id l b

foldr :: (a -> b -> b) -> b -> SList a -> b
foldr f b  (SList l) = l b (\a l' -> f a (foldr f b l'))

take :: Int -> SList a -> SList a
take n (SList l) = l nil'
  (\a l' ->
    case n of
      0 -> nil'
      _ -> cons a (take (n - 1) l'))

-- testing --------------------------------------------------------------------
spec :: Spec
spec = do
  describe "The Maybe type" $ do
    it "can be castto Prelude.Maybe" $ do
      toMaybe (SMaybe const) `shouldBe` (Nothing :: Maybe Int)
      toMaybe (SMaybe $ \_ f -> f 4) `shouldBe` Just 4
    it "can be cast from Prelude.Maybe" $ do
      runMaybe (fromMaybe (Nothing)) 0 (+1) `shouldBe` 0
      runMaybe (fromMaybe (Just 4)) 0 (+1) `shouldBe` 5
  describe "The list type" $ do
    it "can be cast to []" $ do
      toList (SList const) `shouldBe` ([] :: [Int])
      toList (SList $ \_ f -> f 1 (SList $ \_ g -> g 2 (SList const))) `shouldBe` [1,2]
    it "can be cast from []" $ do
      runList (fromList []) 0 reduce `shouldBe` 0
      runList (fromList [1,2]) 0 reduce `shouldBe` 21
  describe "The Either type" $ do
    it "can be cast to Prelude.Either" $ do
      toEither (SEither $ \f _ -> f 3) `shouldBe` (Left 3 :: Either Int String)
      toEither (SEither $ \_ f -> f "hello") `shouldBe` (Right "hello" :: Either Int String)
    it "can be cast from Prelude.Either" $ do
      runEither (fromEither (Left 3)) show id `shouldBe` "3"
      runEither (fromEither (Right "hello" :: Either Int String)) show id `shouldBe` "hello"
  describe "The pair type" $ do
    it "can be cast to (,)" $ do
      toPair (SPair $ \f -> f 2 "hi") `shouldBe` (2, "hi")
    it "can be cast from (,)" $ do
      runPair (fromPair (2, "hi")) replicate `shouldBe` ["hi", "hi"]

reduce :: Num a => a -> SList a -> a
reduce i sl = i + 10 * runList sl 0 reduce
{-# LANGUAGE OverloadedStrings #-}
module Kyu1.SimpleInteractiveInterpreter where


import           Control.Monad.Trans.State
import qualified Data.HashMap.Strict       as HM
import           Text.Parsec



type Name = String


data Expr
  = Let Name Expr Expr
  | Var String
  | BinOp Name Expr Expr
  | UnaryOp Name Expr
  | Number Float
  | Fn Name [Name] Expr
  | Call Name [Expr]
  deriving (Show, Eq, Ord)

data Interpreter
type Result = Maybe Double


newInterpreter :: Interpreter
newInterpreter = undefined

input :: String -> Interpreter -> Either String (Result, Interpreter)
input _ _ = Left "Not implemented"
module Kyu2.ExpressionTranspiler where

transpile :: String -> Either String String
transpile = undefined
module RegExpParser (RegExp(..),parseRegExp) where
import           Data.Foldable (for_)
import           Test.Hspec
import           Text.Printf   (printf)


data RegExp = Normal Char       -- ^ A character that is not in "()*|."
            | Any               -- ^ Any character
            | ZeroOrMore RegExp -- ^ Zero or more occurances of the same regexp
            | Or RegExp RegExp  -- ^ A choice between 2 regexps
            | Str [RegExp]      -- ^ A sequence of regexps.
            deriving (Show, Eq)

parseRegExp :: String -> Maybe RegExp
parseRegExp = undefined

-- testing --------------------------------------------------------------------

validate :: [(String,Maybe RegExp)] -> Spec
validate exs = for_ exs $ \ (input,output) -> do
  it (printf "should return %s given %s as input" (show output) (show input)) $ do
    parseRegExp input `shouldBe` output

spec :: Spec
spec = do
  describe "Precedence examples" $ do
    validate [ ( "ab*", Just (Str [Normal 'a', ZeroOrMore (Normal 'b')]) )
             , ( "(ab)*", Just ( ZeroOrMore (Str [Normal 'a', Normal 'b'])) )
             , ( "ab|a", Just (Or (Str [Normal 'a',Normal 'b']) (Normal 'a')) )
             , ( "a(b|a)", Just (Str [Normal 'a',Or (Normal 'b') (Normal 'a')]) )
             , ( "a|b*", Just (Or (Normal 'a') (ZeroOrMore (Normal 'b'))) )
             , ( "(a|b)*", Just (ZeroOrMore (Or (Normal 'a') (Normal 'b'))) )
             ]
  describe "The other examples" $ do
    validate [ ( "a", Just (Normal 'a') )
             , ( "ab", Just (Str [ Normal 'a', Normal 'b']) )
             , ( "a.*", Just (Str [ Normal 'a', ZeroOrMore Any ]) )
             , ( "(a.*)|(bb)", Just (Or (Str [Normal 'a', ZeroOrMore Any]) (Str [Normal 'b', Normal 'b'])) )
             ]
  describe "Invalid examples" $ do
    validate [ ( "", Nothing )
             , ( "(", Nothing )
             , ( ")(", Nothing )
             , ( "*", Nothing )
             ]
  describe "Complex examples" $ do
    validate [ ( "((aa)|ab)*|a", Just (Or (ZeroOrMore (Or (Str [Normal 'a',Normal 'a']) (Str [Normal 'a',Normal 'b']))) (Normal 'a')) )
             , ( "((a.)|.b)*|a", Just (Or (ZeroOrMore (Or (Str [Normal 'a',Any]) (Str [Any,Normal 'b']))) (Normal 'a')) )
             ]
{-# LANGUAGE LambdaCase #-}
module Kyu3.Isomorphism where


import           Data.Void
-- A type of `Void` have no value.
-- So it is impossible to construct `Void`,
-- unless using undefined, error, unsafeCoerce, infinite recursion, etc
-- And there is a function
-- absurd :: Void -> a
-- That get any value out of `Void`
-- We can do this becuase we can never have void in the zeroth place.

-- so, when are two type, `a` and `b`, considered equal?
-- a definition might be, it is possible to go from `a` to `b`,
-- and from `b` to `a`.
-- Going a roundway trip should leave you the same value.
-- Unfortunately it is virtually impossible to test this in Haskell.
-- This is called Isomorphism.

type ISO a b = (a -> b, b -> a)

-- given ISO a b, we can go from a to b
substL :: ISO a b -> (a -> b)
substL = fst

-- and vice versa
substR :: ISO a b -> (b -> a)
substR = snd

-- There can be more than one ISO a b
isoBool :: ISO Bool Bool
isoBool = (id, id)

isoBoolNot :: ISO Bool Bool
isoBoolNot = (not, not)

-- isomorphism is reflexive
refl :: ISO a a
refl = (id, id)

-- isomorphism is symmetric
symm :: ISO a b -> ISO b a
symm (a, b) = (b, a)

-- isomorphism is transitive
trans :: ISO a b -> ISO b c -> ISO a c
trans (f, f') (g, g') = (g . f, f' . g')

-- We can combine isomorphism:
isoTuple :: ISO a b -> ISO c d -> ISO (a, c) (b, d)
isoTuple (ab, ba) (cd, dc) =
  (\(a, c) -> (ab a, cd c), \(b, d) -> (ba b, dc d))

isoList :: ISO a b -> ISO [a] [b]
isoList (ab, ba) = (fmap ab, fmap ba)

isoMaybe :: ISO a b -> ISO (Maybe a) (Maybe b)
isoMaybe (ab, ba) = (fmap ab, fmap ba)

isoEither :: ISO a b -> ISO c d -> ISO (Either a c) (Either b d)
isoEither (ab, ba) (cd, dc) = (to, from)
  where
    to = \case
      Left a  -> Left (ab a)
      Right c -> Right (cd c)
    from = \case
      Left b  -> Left (ba b)
      Right d -> Right (dc d)

isoFunc :: ISO a b -> ISO c d -> ISO (a -> c) (b -> d)
isoFunc (ab, ba) (cd, dc) =
  (\ac -> cd . ac . ba, \bd -> dc . bd . ab)

-- Going another way is hard (and is generally impossible)
isoUnMaybe :: ISO (Maybe a) (Maybe b) -> ISO a b
isoUnMaybe (mab, mba) = (ab, ba)
  where
    ab a = case mab (Just a) of
             Just b  -> b
             Nothing ->
               case mab Nothing of
                 Nothing -> error "oh jee"
                 Just b  -> b
    ba b = case mba (Just b) of
             Just a  -> a
             Nothing ->
               case mba Nothing of
                 Nothing -> error "oh jee"
                 Just a  -> a
-- Remember, for all valid ISO, converting and converting back
-- Is the same as the original value.
-- You need this to prove some case are impossible.

-- We cannot have
-- isoUnEither :: ISO (Either a b) (Either c d) -> ISO a c -> ISO b d.
-- Note that we have
isoEU :: ISO (Either [()] ()) (Either [()] Void)
isoEU = (f, f')
  where
    f = \case
      Right () -> Left []
      Left xs  -> Left $ () : xs

    f' = \case
      Left []     -> Right ()
      Left (_:xs) -> Left xs

-- where (), the empty tuple, has 1 value, and Void has 0 value
-- If we have isoUnEither,
-- We have ISO () Void by calling isoUnEither isoEU
-- That is impossible, since we can get a Void by substL on ISO () Void
-- So it is impossible to have isoUnEither

-- And we have isomorphism on isomorphism!
isoSymm :: ISO (ISO a b) (ISO b a)
isoSymm = (iab, iba)
  where
    iab (ab, ba) = (ba, ab)
    iba (ba, ab) = (ab, ba)
module Kyu3.ScreenLockingPatterns where

import Data.Ix

data Vertex = A | B | C | D | E | F | G | H | I
  deriving (Show, Read, Eq, Ord, Enum, Bounded, Ix)


countPatternFrom :: Vertex -> Int -> Int
countPatternFrom = undefined
module Kyu4.ConwaysGameOfLife where

import           Data.List
import           Data.Maybe
import           Test.HUnit
import           Test.Hspec


getGeneration :: [[Int]] -> Int -> [[Int]]
getGeneration start gen = foldl (.) id (replicate gen step) $ start

step = trim . play . expand

expand :: [[Int]] -> [[Int]]
expand xss = margin ++ ((\xs -> [0] ++ xs ++ [0]) <$> xss) ++ margin where
  margin = [replicate ((+2) . length . fromMaybe [] $ xss !? 0) 0]

trim :: [[Int]] -> [[Int]]
trim xss = transpose . trim' . transpose . trim' $ xss where
  trim' xss = let t = (length . fromMaybe [] $ xss !? 0)
               in dropWhileTail (== replicate t (0 :: Int))
                . dropWhile ( == replicate t 0) $ xss
  dropWhileTail pred = reverse . (dropWhile pred) . reverse

play :: [[Int]] -> [[Int]]
play xss = (annotate $ fmap annotate xss) >>= \(i, xs) -> return $ do
  (j, x) <- xs
  let overpop = check xss i j > 3; underpop = check xss i j < 2
  return $ case x of
             0 -> if check xss i j == 3 then 1 else 0
             _ -> if overpop || underpop then 0 else 1
 where
   annotate = zipWith (,) [0..]

-- num of adjecent living cells
check :: [[Int]] -> Int -> Int -> Int
check xss i j = sum . fmap (fromMaybe 0)
    $ [idx i' j' | i' <- [i-1..i+1] , j' <- [j-1..j+1], (i', j') /= (i, j)]
  where
    idx i j = xss !? i >>= \ys -> ys !? j >>= \e -> return e

xs !? i = if i < length xs && i >= 0 then Just (xs !! i) else Nothing


-- testing --------------------------------------------------------------------
gliders = [[[1,0,0],
            [0,1,1],
            [1,1,0]],
           [[0,1,0],
            [0,0,1],
            [1,1,1]],
           [[1,0,1],
            [0,1,1],
            [0,1,0]],
           [[0,0,1],
            [1,0,1],
            [0,1,1]]
          ]

twoGliders = [[[1,1,1,0,0,0,1,0],
               [1,0,0,0,0,0,0,1],
               [0,1,0,0,0,1,1,1]],
              [[1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1]]
             ]

fPentomino = [[0, 1, 0], [0, 1, 1], [1, 1, 0]]

main = hspec spec
spec = do
  describe ("Glider\n" ++ htmlize (gliders !! 0)) $ do
    it "Glider 0" $ do
      assertLife (gliders !! 0) 0 (gliders !! 0)
    it "Glider 1" $ do
      assertLife (gliders !! 0) 1 (gliders !! 1)
    it "Glider 2" $ do
      assertLife (gliders !! 0) 2 (gliders !! 2)
    it "Glider 3" $ do
      assertLife (gliders !! 0) 3 (gliders !! 3)
    it "Glider 40" $ do
      assertLife (gliders !! 0) 40 (gliders !! 0)

  describe ("Two Gliders\n" ++ htmlize (twoGliders !! 0)) $ do
    it "Two Gliders 100" $ do
      assertLife (twoGliders !! 0) 16 (twoGliders !! 1)

assertLife start gen expected = do
    let actual = getGeneration start gen
        errorMsg = intercalate "\n" ["expected:", htmlize expected, "got:" , htmlize actual]

    assertBool errorMsg (actual == expected)


htmlize :: [[Int]] -> String
htmlize = concatMap ((++ "\n") . concatMap cell)
  where cell n = if n > 0 then "#" else "0"
-- <Square into Squares. Protect trees!>

module Kyu4.SquareIntoSquares where

import           Test.Hspec

-------------------------------------------------
-- primitive attempt.
-------------------------------------------------
-- fold is the cloest thing you can get compare to a loop with break.
-- the accumulator can also be used to control the default return value.

decompose :: Integer -> Maybe [Integer]
decompose n = decompose' n (n * n)

decompose' :: Integer -> Integer -> Maybe [Integer]
decompose' n r
  | r == 0 = return [n]
  | otherwise = foldl f Nothing [n - 1, n - 2 .. 1]
  where
    f b i =
      let x = r - i ^ 2
       in if x >= 0
            then case b of
              Nothing -> (decompose' i x)
              _       -> (++) <$> (decompose' i x) <*> b
            else Nothing

{-
It is asking about how to get { (ai)i∈z | ∑ai^2 = n^2 }, where (ai) is a
strictly increasing sequence.
This sequence can be regarded as solving a pythagorean n-tuple.
paper for solving pythagorean n-tuple: https://arxiv.org/pdf/1201.2145.pdf
-}


-- testing --------------------------------------------------------------------
spec :: Spec
spec =
  it "should work for some small examples" $ do
    decompose 11 `shouldBe` Just [1, 2, 4, 10]
    decompose 50 `shouldBe` Just [1, 3, 5, 8, 49]
    decompose 4 `shouldBe` Nothing

{-# LANGUAGE TemplateHaskell #-}
module Kyu4.TemplateHaskellTuplemaker where

import Language.Haskell.TH

-- | Creates a lambda that takes `n` arguments and
-- | returns an n-tuple of those arguments.
tuple :: Int -> Q Exp
tuple 0 = undefined
tuple 1 = undefined
tuple n = undefined
module Kyu5.Beeramid where
import           Test.Hspec

beeramid :: Double -> Double -> Int
beeramid bonus price
  | bonus < price && bonus < 0  = 0
  | otherwise = length
  $ takeWhile (<= bonus / price) (scanl (\acc y -> acc + y^2) 1 [2..])


-- testing --------------------------------------------------------------------
-- `spec` of type `Spec` must exist
spec :: Spec
spec = do
  it "finds the levels" $ do
    beeramid 9    2   `shouldBe` 1
    beeramid 10   2   `shouldBe` 2
    beeramid 11   2   `shouldBe` 2
    beeramid 21   1.5 `shouldBe` 3
    beeramid 454  5   `shouldBe` 5
    beeramid 455  5   `shouldBe` 6
    beeramid 4    4   `shouldBe` 1
    beeramid 3    4   `shouldBe` 0
    beeramid 0    4   `shouldBe` 0
    beeramid (-1) 4   `shouldBe` 0

-- the following line is optional for 8.2
main = hspec spec
-- <Memoized Fibonacci>

module Kyu5.MemorizeFibonacci where
import Test.Hspec
import Test.QuickCheck

-- Problem Context

-- The Fibonacci sequence is traditionally used to explain tree recursion.

-- fibonacci 0 = 0
-- fibonacci 1 = 1
-- fibonacci n = fibonacci (n-1) + fibonacci (n-2)

-- This algorithm serves welll its educative purpose but it's tremendously
--  inefficient, not only because of recursion, but because we invoke
-- the fibonacci function twice, and the right branch of recursion (i
-- .e. fibonacci(n-2)) recalculates all the Fibonacci numbers already
-- calculated by the left branch (i.e. fibonacci(n-1)).

-- This algorithm is so inefficient that the time to calculate any Fibonacci
-- number over 50 is simply too much. You may go for a cup of coffee
-- or go take a nap while you wait for the answer. But if you try it
-- here in Code Wars you will most likely get a code timeout before any answers.

-- For this particular Kata we want to implement the memoization solution
-- . This will be cool because it will let us keep using the tree recursion
-- algorithm while still keeping it sufficiently optimized to get an answer very rapidly.

-- The trick of the memoized version is that we will keep a cache data
-- structure (most likely an associative array) where we will store the
-- Fibonacci numbers as we calculate them. When a Fibonacci number is
-- calculated, we first look it up in the cache, if it's not there, we
-- calculate it and put it in the cache, otherwise we returned the cached number.

-- Refactor the function into a recursive Fibonacci function that using
-- a memoized data structure avoids the deficiencies of tree recursion
-- Can you make it so the memoization cache is private to this function?

-- 2019-11-21
-------------------------------------------------------------
-- first attempt
-------------------------------------------------------------
import Data.Map as M
import Data.Maybe
import Control.Monad.Trans.State
import Control.Applicative (liftA2)

type FibCacheState = State (M.Map Int Integer, Int) (Maybe Integer)

-- each time you run the state it take s and compute new value
initCache :: M.Map Int Integer
initCache = M.fromList [(0, 0), (1, 1)]

fib :: FibCacheState
fib = state $
  \(cache, n) ->
    let n' = length cache - 1
     in if n <= n'  -- fib(n) cached, retrived it.
           then (M.lookup n cache, (cache, n))
        else let (left, (leftcache, _)) = runState fib (cache, n-2)
                 (right, (rightcache, _)) = runState fib (leftcache, n-1)
                 res = liftA2 (+) left right
                 newcache =
                   case M.lookup n rightcache of
                     Nothing -> M.insert n (fromMaybe 0 res) rightcache
                     _ -> rightcache

                in (res, (newcache, n))

fibonacci :: Int -> Integer
fibonacci n = fromMaybe 0 $ evalState fib (initCache, n)



-------------------------------------------------------------
-- best practice
-------------------------------------------------------------

fibonacci' :: Int -> Integer
fibonacci' n = fibs !! n
  where fibs = 0 : zipWith (+) fibs (tail fibs)

-- testing --------------------------------------------------------------------

spec :: Spec
spec = do
  it "Fixed tests" $ do
    fibonacci 70 `shouldBe` 190392490709135
    fibonacci 60 `shouldBe` 1548008755920
    fibonacci 50 `shouldBe` 12586269025
-- <Build a pile of Cubes>

-- Your task is to construct a building which will be a pile of n cubes.
-- The cube at the bottom will have a volume of n^3, the cube above will
--  have volume of (n-1)^3 and so on until the top which will have a volume of 1^3.

-- You are given the total volume m of the building. Being given m can you find the
--  number n of cubes you will have to build?

-- The parameter of the function findNb (find_nb, find-nb, findNb) will be an
--  integer m and you have to return the integer n such
-- as n^3 + (n-1)^3 + ... + 1^3 = m if such a n exists or -1 if there is no such n.
module Kyu6.BuildAPileOfCubes where

import           Data.Foldable         (for_)
import           Data.List             (permutations)
import           System.Random
import           Test.Hspec
import           Test.Hspec.QuickCheck
import           Test.QuickCheck
import           Text.Printf           (printf)



----------------------------------------
-- first attempt
----------------------------------------
-- This solution gives timeout. Need to optimize it.
-- [TODO: In cpp version recurison throws segfault after calling large number.]
findNb' :: Integer -> Integer
findNb' = f 0 1
  where
    f :: Integer -> Integer -> Integer -> Integer
    f _ _ 0 = 0
    f acc n m
      | acc > m = -1
      | acc == m = n - 1
      | otherwise = f (acc + n ^3) (n+1) m

----------------------------------------
-- second attempt
----------------------------------------
-- notice m = ( n(n+1) / 2 )^2 = ∑n^3
-- n = ⌊√( ⌊√(m)⌋ * 2)⌋
-- This is the correct approach.
-- all other solutions are some variations
-- of doing math.

findNb :: Integer -> Integer
findNb m = if m == m' then r else -1
  where fsqrt = floor . sqrt . fromIntegral
        r = fsqrt (fsqrt m * 2)
        m' = div (r * (r + 1)) 2 ^ 2

-- testing --------------------------------------------------------------------


spec :: Spec
spec = do
  describe "Solution" $ do
    testFindNb 4183059834009 2022
    testFindNb 24723578342962 ((-1))
    testFindNb 135440716410000 4824
    testFindNb 40539911473216 3568
  where
    testFindNb :: Integer -> Integer -> Spec
    testFindNb m r =
      it (printf "m %i " m) $
        findNb m `shouldBe` r
-- <CamelCase Method>
-- Write a function that takes a string of braces, and determines if the order
-- of the braces is valid. It should return true if the string is valid, and
-- false if it's invalid.

-- This Kata is similar to the Valid Parentheses Kata, but introduces new
-- characters: brackets [], and curly braces {}. Thanks to @arnedag for the idea!

-- All input strings will be nonempty, and will only consist of parentheses,
--  brackets and curly braces: ()[]{}.
-- What is considered Valid?

-- A string of braces is considered valid if all braces are matched with
-- the correct brace.
module Kyu6.CamelCaseMethod where

import Data.Char
import Test.Hspec
import Test.Hspec.QuickCheck
import Test.QuickCheck
import Text.Printf (printf)


-- 2019-11-19
----------------------------------------
-- first attempt
----------------------------------------
camelCase :: String -> String
camelCase str = concat $  -- why not use (x:xs) ??
  (\(x, y) -> (toUpper <$> x) ++ y) . splitAt 1 <$> words str

camelCaseRefactor :: String -> String
camelCaseRefactor str = concat $ (\(x:xs) -> toUpper x:xs) <$> words str

----------------------------------------
-- bestPractice
----------------------------------------
camelCase' :: String -> String
camelCase' = concatMap (\(x:xs) -> toUpper x:xs) . words

----------------------------------------
-- monad version
----------------------------------------
camelCase'' :: String -> String
camelCase'' str = do
  x:xs <- words str
  toUpper x:xs

-- testing --------------------------------------------------------------------

spec :: Spec
spec = do
  it "test case" $
    camelCase "test case" `shouldBe` "TestCase"
  it "camel case method" $
    camelCase "camel case method" `shouldBe` "CamelCaseMethod"
  it "say hello" $
    camelCase "say hello " `shouldBe` "SayHello"
  it " camel case word" $
    camelCase " camel case word" `shouldBe` "CamelCaseWord"
module Kyu6.DecipherThis where
import           Data.Char
import           Test.Hspec
import           Test.Hspec.QuickCheck
import           Test.QuickCheck
import           Text.Printf           (printf)


decipherThis :: String -> String
decipherThis = unwords . fmap decipher1 . words

decipher1 :: String -> String
decipher1 word =
    case count word of
      0 -> []
      1 -> chead : []
      2 -> chead : cend : []
      _ -> chead : cend : (init . tail) t ++ c1 : []
  where
    count = (+ 1) . length . (dropWhile isDigit)
    t = dropWhile isDigit word
    chead = chr $ (read $ takeWhile isDigit word :: Int)
    c1 = head $ t
    cend = last word

-- testing --------------------------------------------------------------------

spec :: Spec
spec = do
  describe "Basic Tests" $
    it "should work with basic tests" $ do
      decipherThis "65 119esi 111dl 111lw 108dvei 105n 97n 111ka" `shouldBe` "A wise old owl lived in an oak"
      decipherThis "84eh 109ero 104e 115wa 116eh 108sse 104e 115eokp" `shouldBe` "The more he saw the less he spoke"
      decipherThis "84eh 108sse 104e 115eokp 116eh 109ero 104e 104dare" `shouldBe` "The less he spoke the more he heard"
      decipherThis "87yh 99na 119e 110to 97ll 98e 108eki 116tah 119esi 111dl 98dri" `shouldBe` "Why can we not all be like that wise old bird"
      decipherThis "84kanh 121uo 80roti 102ro 97ll 121ruo 104ple" `shouldBe` "Thank you Piotr for all your help"
-- <Find the odd int>
--
-- Given an array, find the int that appears an odd number of times.
-- There will always be only one integer that appears an odd number of times.

module Kyu6.FindTheOddInt (findOdd) where

import Data.Bits (xor)
import Data.List
import Data.List (permutations)
import Data.Foldable (for_)
import Test.Hspec
import Test.Hspec.QuickCheck
import Test.QuickCheck
import Text.Printf (printf)


-- 2019-11-19
--  Given a list, find the [Int] that appears an
--  odd number of times. The tests will always
--  provide such a number, and the list will
--  always contain at least one element.
-----------------------------------------------
-- first version
-----------------------------------------------
findOdd'' :: [Int] -> Int
findOdd'' = fst <$> head . filter (odd.snd) . table
  where
    f a t =
      case lookup a t of
        Nothing -> (a, 1) : t
        Just _ ->
          fmap (\(x, n) ->
            if x == a then (x, n + 1) else (x, n)) t
    table :: [Int] -> [(Int, Int)]
    table = foldr f [(0, 0)]

-----------------------------------------------
-- smart version
-----------------------------------------------

findOdd' :: [Int] -> Int
findOdd' = foldr1 xor
-- Note foldr1 has no base case
-- only apply to non empty structure.


-----------------------------------------------
-- list compherhension version
-----------------------------------------------
findOdd :: [Int] -> Int
findOdd xs = head [ x | x <- xs, odd . length . filter (==x) $ xs]

-----------------------------------------------
-- map version
-----------------------------------------------
findOddMap :: [Int] -> Int
findOddMap = head . map head . filter (odd.length) . group . sort

-- testing --------------------------------------------------------------------

spec :: Spec
spec = do
  prop "works for singleton lists" $ \x ->
    findOdd [x] `shouldBe` x
  prop "works for lists with three elements" $ \x y ->
    x /= y ==> do
      findOdd [x, y, y] `shouldBe` x
      findOdd [y, x, y] `shouldBe` x
      findOdd [y, y, x] `shouldBe` x
  prop "works for lists with five elements" $ \x y ->
    x /= y
      ==> let perms = permutations [x, x, x, y, y]
           in for_ perms $ \xs -> findOdd xs `shouldBe` x

-- Remark: OneOdd's Arbitrary instance makes sure that there
-- is exactly one element that appears an odd number of times
-- prop "works for lists that contain exactly one oddly numbered element
-- " $ \(OneOdd x xs) -> findOdd xs `shouldBe` x
module Kyu6.HexagonBeamMaxSum where

import           Debug.Trace
import           Prelude               hiding ((!!))
import qualified Prelude               ((!!))
import           Test.Hspec
import           Test.Hspec.QuickCheck
import           Test.QuickCheck
import           Text.Printf           (printf)


data Hex = Hex
  { hn   :: Int,
    hseq :: [Int]
  }

maxHexagonBeam :: Int -> [Int] -> Int
maxHexagonBeam n lst = maximum $ f <$> transforms
  where
    f = maxsum $ Hex n lst
    transforms =
      [ \hex r c -> (r, c),
        rotateLeftTrans,
        rotateRightTrans
      ]

type CoordTransform = Hex -> Int -> Int -> (Int, Int)

rotateLeftTrans :: CoordTransform
rotateLeftTrans hex r c
  | r < n = if c < n then (c, r) else (c, n - 1 - gap)
  | c < n - 1 =
    ( revGap + revIdx,
      if r + c >= rowSz hex
        then r - c + ((rowSz hex) - r - 1)
        else r
    )
  | c == n - 1 = (r, c)
  | otherwise = (r + gap, (colSz hex r) - c + revIdx)
  where
    (_, pc) = if r < n then (r, r) else (r, n - 1)
    n = hn hex
    gap = abs $ pc - c
    revIdx = r - n
    revGap = (abs $ n - gap)

rotateRightTrans :: CoordTransform
rotateRightTrans hex r c =
  let (r', c') = rotateLeftTrans hex r c
      upperBound = rowSz hex - 1
   in (upperBound - r', c')

maxsum :: Hex -> CoordTransform -> Int
maxsum hex tranform =
  traceShow hexCoordTable $
  maximum . concat $ (fmap . fmap) getVal hexCoordTable
  where
    getVal (r, c) = hex !! tranform hex r c
    hexCoordTable = do
      r' <- [0 .. rowSz hex]
      return [(r', c') | c' <- [0 .. colSz hex r']]

(!!) :: Hex -> (Int, Int) -> Int
hex !! pos = hseq hex Prelude.!! (traceShow (getIdx hex pos) $ (getIdx hex pos))

getIdx :: Hex -> (Int, Int) -> Int
hex `getIdx` pos = pre + col `mod` (length . hseq) hex
  where
    (row, col) = pos
    pre = sum $ colSz hex <$> [0 .. row]

rowSz :: Hex -> Int
rowSz hex = hn hex * 2 - 1

colSz :: Hex -> Int -> Int
colSz hex row
  | row <= n = n + row
  | otherwise = (rowSz hex) - (row + 1 - n)
  where
    n = hn hex

-- testing --------------------------------------------------------------------

spec :: Spec
spec = do
  it "Sample tests" $ do
    maxHexagonBeam 2 [5, 8, 3, 8] `shouldBe` 24
    maxHexagonBeam 3 [1, 3, 5, 7] `shouldBe` 23
    maxHexagonBeam 4 [2, 4, 6, 8] `shouldBe` 34
    maxHexagonBeam 5 [1, 0, 4, -6] `shouldBe` 9
    maxHexagonBeam 5 [2] `shouldBe` 18
-- <Valid Braces>
module Kyu6.ValidBrace where
import           Test.Hspec
import           Test.Hspec.QuickCheck
import           Test.QuickCheck
import           Text.Printf           (printf)

-- 2019-11-19
--------------------------------------
-- first attempt
--------------------------------------
-- Note
-- head is opposite to last bc they return element
-- tail is opposite to init bc they return list
-- very wierd
pair :: Char -> Char -> Bool
pair '(' ')'=True
pair '[' ']'=True
pair '{' '}'=True
pair _ _     = False

validBraces :: String -> Bool
validBraces as = go as []
  where go [] [] = True
        go [] _ = False
        go (x:xs) [] = go xs [x]
        go (x:xs) acc =
          if pair (last acc) x
             then go xs (init acc)
          else go xs (acc ++ [x])

--------------------------------------
-- clever solution
--------------------------------------
-- Note
-- Use fold flexibly can reduce a lot of works.
validBraces' :: String -> Bool
validBraces' s = "" == foldr collapse [] s
  where collapse '(' (')':xs) = xs
        collapse '[' (']':xs) = xs
        collapse '{' ('}':xs) = xs
        collapse x xs         = x:xs

-- testing --------------------------------------------------------------------

spec :: Spec
spec =
  it "should work for some examples" $ do
    validBraces "()" `shouldBe` True
    validBraces "[([)" `shouldBe` False
    validBraces "())({}}{()][][" `shouldBe` False
    validBraces "({})[({})]" `shouldBe` True
-- <Even or Odd>
module Kyu7.EvenOrOdd where
import Test.Hspec
import Test.QuickCheck



-- for test suit set up
evenOrOdd :: Integral a => a -> String
evenOrOdd a = if mod a 2 == 0 then "Even" else "Odd"

-- testing --------------------------------------------------------------------
spec :: Spec
spec = do
  it "Evens:" $ do
    evenOrOdd 2 `shouldBe` "Even"
    evenOrOdd 0 `shouldBe` "Even"
  it "Odds" $ do
    evenOrOdd 7 `shouldBe` "Odd"
    evenOrOdd 1 `shouldBe` "Odd"
-- <Highest and Lowest>
module Kyu7.HighestAndLowest where
import Test.Hspec
import Test.QuickCheck


--------------------------------------------
-- first attempt
--------------------------------------------
-- (read a :: Int) to convert string into int
highAndLow :: String -> String
highAndLow str = show (foldr max (minBound :: Int) list) ++
                 " " ++ show (foldr min (maxBound :: Int) list)
  where
    split :: Eq a => a -> [a] -> [[a]]
    split d [] = []
    split d s = let (x, y) = span (/=d) s
                 in x : split d (drop 1 y)
    list = (read <$> split ' ' str) :: [Int]

--------------------------------------------
-- better version
--------------------------------------------
-- words tokenize string by space
-- max min take two args and return the bigger one.
-- maximum and minimum are max and min you want.
highAndLow' :: String -> String
highAndLow' str = show (maximum ns) ++ " " ++ show (minimum ns)
  where ns = (map read $ words str) :: [Int]

-- testing --------------------------------------------------------------------
spec :: Spec
spec =
  it "4 5 29 54 4 0 -214 542 -64 1 -3 6 -6" $
    highAndLow "4 5 29 54 4 0 -214 542 -64 1 -3 6 -6" `shouldBe` "542 -214"
-- <Make a function that does arithmetic!>
module Kyu7.MakeAFunctionThatDoesArithmetic where
import Test.Hspec
import Test.QuickCheck


data Operation = Add | Divide | Multiply | Subtract deriving (Eq, Show, Enum, Bounded)

----------------------------------------------------
-- first attempt
----------------------------------------------------
arithmetic :: Fractional a => a -> a -> Operation -> a
arithmetic a b operator =
  case operator of
    Add -> a + b
    Divide -> a / b
    Multiply -> a * b
    _ -> a - b


----------------------------------------------------
-- better solutions
----------------------------------------------------
-- By deriving from enum type, fromEnum give order of
-- data in data constructor.
arithmetic' :: Fractional a => a -> a -> Operation -> a
arithmetic' a b operator = a `op` b
  where op = [(+), (/), (*), (-)] !! fromEnum operator


-- testing --------------------------------------------------------------------
spec :: Spec
spec =
  it "should work with example tests" $ do
    arithmetic 5 2 Add `shouldBe` 7
    arithmetic 8 2 Subtract `shouldBe` 6
    arithmetic 5 2 Multiply `shouldBe` 10
    arithmetic 8 2 Divide `shouldBe` 4
-- <Credit Card Mask>
module Kyu7.Maskify (maskify) where
import           Test.Hspec
import           Test.QuickCheck


-----------------------------------------------
-- first version
-----------------------------------------------

maskify :: String -> String
maskify str =
  let l = length str - 4
   in fmap (const '#') (take l str) ++ drop l str

-----------------------------------------------
-- better version
-----------------------------------------------
-- Same idea, but with replicate
-- replicate repeat const second argument n times
-- into [].
maskify' :: String -> String
maskify' str = replicate l '#' ++ drop l str
  where l = length str - 4

-- testing --------------------------------------------------------------------
spec :: Spec
spec = do
  it "should mask the credit card" $ maskify "4556364607935616" `shouldBe` "############5616"
  it "should mask another number" $ maskify "64607935616" `shouldBe` "#######5616"
  it "should mask a short number" $ maskify "616" `shouldBe` "616"
  it "should mask a single character" $ maskify "1" `shouldBe` "1"
  it "should mask an empty string" $ maskify "" `shouldBe` ""
  it "should mask your pet" $ maskify "Skippy" `shouldBe` "##ippy"
  it "should mask batman" $
    maskify "Nananananananananananananananana Batman!" `shouldBe` "####################################man!"
  it "shouldn't change the length" $
    property $ \x ->
      length x == length (maskify x)
-- <Ones and Zeros>
module Kyu7.OnesAndZeros (toNumber) where
import Test.Hspec
import Test.QuickCheck


-- 2019-11-18
-----------------------------------------------
-- first version
-----------------------------------------------
toNumber' :: [Int] -> Int
toNumber' list =
  let rl = reverse list
      go sum exp (x:xs) =
        if x == 0
           then go sum (exp + 1) xs
        else go (sum + 2^exp) (exp + 1) xs
      go sum _ [] = sum
   in go 0 0 rl

-- whenever got a sum as accumulatory try to use fold

-----------------------------------------------
-- Good practise
-----------------------------------------------
toNumber :: [Int] -> Int
toNumber = foldl f 0
  where f acc n = 2*acc + n

-- NOTE:
-- Say we have [a, b, c]
-- think foldl as:
-- (f (f (f 0 a)
--    b)
--  c)

-- foldr:
-- (f a
--   (f b
--     (f c 0)))

-- Lazy eval, so the outmost expression will be evaluated first.
-- This is also why we don't need reverse.

-----------------------------------------------
-- side notes
-----------------------------------------------
-- NOTE:
-- foldl avoid thunk generated by lazy eval,
-- save some stack space when processing long list.

foldl'' _ z [] = z
foldl'' f z (x:xs) =
  let z' = f z x
   in seq z' $ foldl'' f z' xs  -- seq a -> b -> b will reduce a then return b

-- NOTE:
-- foldr is better for f that is lazy on the second arg.
-- foldl will not start to eval till reach the end of the list, create huge thunk.

-- testing --------------------------------------------------------------------

spec :: Spec
spec =
  it "example tests" $ do
    toNumber [0, 0, 0, 1] `shouldBe` 1
    toNumber [0, 0, 1, 0] `shouldBe` 2
    toNumber [1, 1, 1, 1] `shouldBe` 15
    toNumber [0, 1, 1, 0] `shouldBe` 6
module Kyu8.FakeBinary where
import           Test.Hspec
import           Test.QuickCheck


-- Given a string of digits, you should replace any digit below 5 with '0' and any digit 5 and above with '1'.
-- Return the resulting string.

fakeBin :: String -> String
fakeBin xs = f <$> xs
  where
    f x | (read (x : "") :: Integer) < 5 = '0'
      | otherwise = '1'

fakeBin' :: String -> String
fakeBin' = fmap (\c -> if c < '5' then '0' else '1')

-- testing --------------------------------------------------------------------



newtype Number = Number String deriving (Eq, Show)

instance Arbitrary Number where
  arbitrary = Number `fmap` listOf (choose ('0', '9'))

spec :: Spec
spec = do
  it "works for empty strings" $
    fakeBin "" `shouldBe` ""

  it "only returns 0 and 1" $
    property $ \(Number xs) ->
      fakeBin xs `shouldSatisfy` all (`elem` "01")

  it "works for some examples" $ do
    fakeBin "45385593107843568" `shouldBe` "01011110001100111"
    fakeBin "509321967506747" `shouldBe` "101000111101101"
    fakeBin "366058562030849490134388085" `shouldBe` "011011110000101010000011011"
pub mod square_into_squares_protect_trees;

fn decompose(n: i64) -> Option<Vec<i64>> {
    let res = decomp1(n, n * n);
    res.map(|xs| {
        let len = xs.len();
        xs.into_iter().take(len - 1).collect::<Vec<_>>()
    })
}

fn decomp1(n: i64, remain: i64) -> Option<Vec<i64>> {
    println!("n {}, remain {}", n, remain);
    if remain == 0 {
        return Some(vec![n]);
    }

    for i in (1..n).rev() {
        if remain - i ^ 2 >= 0 {
            let r = decomp1(i, remain - i ^ 2);
            match r {
                Some(mut v) => {
                    println!("HEHEEHE {:?}", v);
                    v.push(n);
                    return Some(v);
                }
                _ => (),
            }
        }
    }
    None
}

fn testing(n: i64, exp: Option<Vec<i64>>) -> () {
    assert_eq!(decompose(n), exp)
}

#[test]
fn tests_decompose() {
    testing(50, Some(vec![1, 3, 5, 8, 49]));
    testing(44, Some(vec![2, 3, 5, 7, 43]));
    testing(625, Some(vec![2, 5, 8, 34, 624]));
    testing(5, Some(vec![3, 4]));
}
pub fn max_hexagon_beam(n: u8, seq: &[i32]) -> i32 {
    let hex = Hex { n: n as usize, seq };
    println!("seq: {:?}, n: {:?}", seq, n);
    let result = *[
        hex.maxsum(Box::new(|r: usize, c: usize| (r, c))),
        hex.maxsum(hex.rotate_left()),
        hex.maxsum(hex.rotate_right()),
    ]
    .iter()
    .max()
    .unwrap();
    println!("result {}", result);
    result
}

struct Hex<'a> {
    n: usize,
    seq: &'a [i32],
}

type CoordTransform = Box<dyn Fn(usize, usize) -> (usize, usize)>;

trait HexCoordTransform {
    fn rotate_left(&self) -> CoordTransform;
    fn rotate_right(&self) -> CoordTransform;
}

impl HexCoordTransform for Hex<'_> {
    // row_size = 7, n = 4
    //      (r, r)
    //         2p  4   6   8  /  +----- c == 4
    //         \             /  /
    //       2  \4p  6   8  / 2
    //           \         /
    //     4   6  \8p  2  / 4   6
    //             \     /
    //    8   2   4 \ 6p/  8   2   4.
    //  -------------\-/----------------
    //      6   8   2 x 4p  6   8. ----- r == n (r == 4)
    //               / \
    //        2   4 / 6 \ 8p  2
    //             /     \
    //          4 / 6   8 \ 2p
    //                        \__(r, n -1) == (r, 3)

    fn rotate_left(&self) -> CoordTransform {
        let n = self.n; // 4 n-1 = 3
        let row_sz = self.row_sz();
        Box::new(move |r: usize, c: usize| {
            let (_, pc) = if r < n { (r, r) } else { (r, n - 1) };
            let gap = ((pc as i32) - (c as i32)).abs() as usize;
            if r < n {
                if c < n {
                    (c, r)
                } else {
                    (c, n - 1 - gap)
                }
            } else {
                let rev_idx = r - n;
                if c < n - 1 {
                    let rev_gap = (n as i32 - gap as i32).abs() as usize;
                    (
                        rev_gap + rev_idx,
                        if r + c >= row_sz {
                            r - c + (row_sz - r - 1)
                        } else {
                            r
                        },
                    )
                } else if c == n - 1 {
                    (r, c)
                } else {
                    let col_sz = Hex::col_sz_static(n, r);
                    (r + gap, col_sz - c + rev_idx)
                }
            }
        })
    }

    // symetric about horizontal diagonal.
    fn rotate_right(&self) -> CoordTransform {
        let n = self.n;
        let row_sz = Hex::row_sz_static(n);
        let upper_bound = row_sz - 1;
        let rotate_left = self.rotate_left();
        Box::new(move |r: usize, c: usize| {
            let (ra, ca) = rotate_left(r, c);
            assert!(upper_bound >= ra);
            (upper_bound - ra, ca)
        })
    }
}

impl Hex<'_> {
    // generic max
    fn maxsum(&self, f: CoordTransform) -> i32 {
        let mut buf: Vec<i32> = {
            let mut x = Vec::new();
            x.resize(self.row_sz(), 0);
            x
        };
        let mut subbuf = buf.clone();
        for r in 0..self.row_sz() {
            for c in 0..self.col_sz(r) {
                let coord = f(r, c);
                subbuf.push(self.val(coord));
            }
            buf[r] = subbuf.iter().sum();
            subbuf.resize(self.row_sz(), 0);
        }
        *buf.iter().max().unwrap()
    }

    fn val(&self, pos: (usize, usize)) -> i32 {
        self.seq[self.idx(pos)]
    }

    fn idx(&self, pos: (usize, usize)) -> usize {
        let (row, col) = pos;
        let pre = (0..row) // til last row
            .map(|r| self.col_sz(r) as usize)
            .sum::<usize>();
        (pre + col as usize) % self.seq.len() as usize
    }

    fn row_sz(&self) -> usize {
        Hex::row_sz_static(self.n)
    }

    fn col_sz(&self, row: usize) -> usize {
        Hex::col_sz_static(self.n, row)
    }

    fn row_sz_static(n: usize) -> usize {
        n * 2 - 1
    }

    fn col_sz_static(n: usize, row: usize) -> usize {
        let row_sz = Hex::row_sz_static(n);
        if row < n {
            n + row
        } else {
            row_sz - (row + 1 - n)
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_examples() {
        let tests: Vec<(u8, Vec<i32>, i32)> = vec![
            (2, vec![5, 8, 3, 8], 24),
            (2, vec![-995], -1990),
            (2, vec![8, 12, 33, 24, 92, 5, 47, 16, 0, 13], 149),
            (3, vec![1, 3, 5, 7], 23),
            (4, vec![2, 4, 6, 8], 34),
            (5, vec![1, 0, 4, -6], 9),
            (5, vec![2], 18),
            (6, vec![11, 12, -13, 14, 15], 110),
            (8, vec![-100, 100, 50, -50, 75, -75], 800),
            (7, vec![9, 8, 7, 6, 5, 6, 7, 8, -6], 83),
            (10, vec![1, 2, 3, 4, 5], 64),
            (20, vec![18, -24, 65, -1, 99, 33, -42], 1489),
            (92, vec![324, -90, 28, -331, 24, 55, 94, -101], 1031),
        ];
        for (n, seq, expected) in tests.iter() {
            let result = max_hexagon_beam(*n, seq);
            assert_eq!(result, *expected, "n = {}, seq = {:?}", n, seq);
        }
    }
}
pub mod hexagon_beam_max_sum;
mod kyu6;
mod kyu4;

fn main() {
    println!("Hello, world!");
}
// https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/

#include <iostream>
#include <vector>
using namespace std;


// Input: nums = [5,7,7,8,8,10], target = 8
// Output: [3,4]

// the problem reduce to find the upper bound and the lower bound of an
// instance in a sorted array with binary search.
//
// Steps:
//  use normal binary search.
//    when comparing the mid elemnt with the target element and decide in what
//    case we should do r = mid,
//      (nums[mid] >= target ⇒ r = mid) ⇒ find the lower bound.
//      (nums[mid] > target ⇒ r = mid) ⇒ find the upper bound.
//
// TODO proof

class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
      int lb = lower_bound(nums, target);
      int ub = upper_bound(nums, target) - 1;
      if (lb == nums.size() || nums[lb] != target) {
        return {-1, -1};
      }
      return {lb, ub};
    }

    template <typename Comp>
    int bound(vector<int>& nums, int target, Comp comp) {
      int l = 0, r = nums.size();
      int mid;

      while (l < r) {
        mid = (l + r) / 2;
        if (comp(nums[mid], target)) {
          r = mid;
        } else {
          l = mid + 1;
        }
      }
      return l;
    }

    int lower_bound(vector<int>&nums, int target) {
      return bound(nums, target, [](auto a, auto b) {
          return a >= b;
          });
    }

    int upper_bound(vector<int>&nums, int target) {
      return bound(nums, target, [](auto a, auto b) {
          return a > b;
          });
    }
};


int main(void)
{
  Solution solution;

  {
    vector<int> v{5, 7, 7, 8, 8, 10};
    auto res = solution.searchRange(v, 8);

    for (auto& n : res) {
      std::cout << n << " ";
    }
    std::cout << std::endl;
  }

  {
    vector<int> v{5, 7, 7, 8, 8, 10};
    auto res = solution.searchRange(v, 6);

    for (auto& n : res) {
      std::cout << n << " ";
    }
    std::cout << std::endl;
  }

  {
    vector<int> v{};
    auto res = solution.searchRange(v, 0);

    for (auto& n : res) {
      std::cout << n << " ";
    }
    std::cout << std::endl;
  }

  return 0;
}
// https://leetcode.com/problems/sqrtx/

#include <iostream>


class Solution {
public:
    int mySqrt(int x) {
      if (x == 0) return x;
      int l = 1;
      int r = x;

      while (l <= r) {
        int mid = l + (r - 1) / 2;
        int sqrt = x / mid;
        if (sqrt == mid) {
          return mid;
        } else if (mid > sqrt) {
          r = mid - 1;
        } else {
          l = mid + 1;
        }
      }
      return r;
    }

    // with newton iteration method
    int mySqrt1(int x) {
      long s = x;
      while (s * s > x) {
        s = (s + x / s) / 2;
      }
      return s;
    }
};
#include <iostream>
#include <vector>
#include <cassert>

using namespace std;

// problem:
//   binary search in a rotated array.
// this is testing your case analysis. Because there is still ascending order,
// a rotated array can be considered as two parts
// [...rotated part, ...ordered part]

// [2, 5, 6, 0, 0, 1, 2], 0

class Solution {
public:
    bool search(vector<int>& nums, int target) {
      int l = 0, r = nums.size() - 1;
      while (l <= r) {
        int mid = (l + r) / 2;
        if (nums[mid] == target) return true;

        // in continous seq, can't tell which side is ascending
        if (nums[l] == nums[mid]) ++l;
        else if (nums[mid] <= nums[r]) {
          // right interval is ascending
          if (target > nums[mid] && target <= nums[r]) l = mid + 1;
          else r = mid - 1;
        } else {
          // left interval is ascending
          if (target >= nums[l] && target < nums[mid]) r = mid - 1;
          else l = mid + 1;
        }
      }
      return false;
    }
};

int main()
{
  Solution solution;

  {
    vector<int> v{2, 5, 6, 0, 0, 1, 2};
    auto res = solution.search(v, 0);
    assert(res);
    std::cout << res << std::endl;
  }

  {
    vector<int> v{2, 5, 6, 0, 0, 1, 2};
    auto res = solution.search(v, 3);
    assert(!res);
    std::cout << res << std::endl;
  }
}
#include <cassert>
#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
  int singleNumber(vector<int> &nums) {
    int result = 0;
    for (auto &v : nums) {
      result ^= v;
    }
    return result;
  }
};

int main(void) {
  Solution solution;

  {
    std::vector<int> v{2, 2, 1};
    int result = solution.singleNumber(v);
    std::cout << result << std::endl;
    assert(!(result ^ 1));
  }

  {
    std::vector<int> v{4, 1, 2, 1, 2};
    int result = solution.singleNumber(v);
    std::cout << result << std::endl;
    assert(!(result ^ 4));
  }
  return 0;
}
#include <cassert>
#include <iostream>

class Solution {
public:
  uint32_t reverseBits(uint32_t n) {
    uint32_t result = 0;
    for (int i = 0; i < sizeof(uint32_t) * 8; ++i) {
      result <<= 1;
      result += n & 1;
      n >>= 1;
    }
    return result;
  }
};

int main(void) {
  Solution solution;

  {
    uint32_t n = 0b00000010100101000001111010011100;
    uint32_t result = solution.reverseBits(n);
    std::cout << result << std::endl;
    assert((result ^ 0b00111001011110000010100101000000) == 0);
  }

  {
    uint32_t n = 0b11111111111111111111111111111101;
    uint32_t result = solution.reverseBits(n);
    std::cout << result << std::endl;
    assert((result ^ 0b10111111111111111111111111111111) == 0);
  }

  return 0;
}

#include <cassert>
#include <iostream>
#include <string>
#include <vector>
using namespace std;

class Solution {
public:
  int maxProduct(vector<string> &words) {
    // TODO

  }
};

void test_cases(auto solution) {
  {
    std::vector<std::string> words{"abcw", "baz",  "foo",
                                   "bar",  "xtfn", "abcdef"};
    auto result = solution.maxProduct(words);
    std::cout << result << std::endl;
    assert(result == 4);
  }

  {
    std::vector<std::string> words{"a", "ab", "abc", "d", "cd", "bcd", "abcd"};
    auto result = solution.maxProduct(words);
    std::cout << result << std::endl;
    assert(result == 4);
  }
}

int main() {
  Solution solution;
  test_cases(solution);
}
#include <cassert>
#include <iostream>
#include <vector>
using namespace std;
template <typename C> void print_seq(C &&container) {
  for (auto &n : container) {
    std::cout << n << " ";
  }
  std::cout << std::endl;
}

namespace just_count {
// simply count
class Solution {
public:
  vector<int> countBits(int n) {
    std::vector<int> result;
    for (int i = 0; i <= n; ++i) {
      result.push_back(count(i));
    }
    return result;
  }

  int count(int n) {
    int counter = 0;
    while (n) {
      if (n & 1) {
        ++counter;
      }
      n >>= 1;
    }
    return counter;
  }
};
} // namespace just_count

namespace dp {
// use dp to solve it.
// n is a funciton of i that returns number of 1s in the binary form of i.
//   if i == 0, n(i) = 0
//   if i is odd, n(i) = n(i - 1) + 1
//   if i is even, n(i) = n(i >> 1)
// with base case 0, we can induce the solution for all i.
class Solution {
public:
  vector<int> countBits(int n) {
    std::vector<int> dp(n + 1, 0);
    for (int i = 1; i <= n; ++i) {
      dp[i] = i & 1 ? dp[i - 1] + 1 : dp[i >> 1];
    }
    return dp;
  }
};

} // namespace dp

int test_cases(auto solution) {

  {
    int n = 2;
    auto result = solution.countBits(n);

    print_seq(result);
    assert(result == (std::vector<int>{0, 1, 1}));
  }

  {
    int n = 5;
    auto result = solution.countBits(n);

    print_seq(result);
    assert(result == (std::vector<int>{0, 1, 1, 2, 1, 2}));
  }

  return 0;
}

int main(void) {
  {
    using namespace just_count;
    Solution solution;
    test_cases(solution);
  }

  {
    using namespace dp;
    Solution solution;
    test_cases(solution);
  }
  return 0;
}
#include <iostream>
#include <cassert>

// xxxx10
class Solution {
public:
    bool isPowerOfFour(int n) {

      // TODO
    }
};


int main(void)
{

  Solution solution;

  {
    int n = 16;
    int result = solution.isPowerOfFour(n);
    std::cout << result << std::endl;
    assert(result);
  }

  {
    int n = 5;
    int result = solution.isPowerOfFour(n);
    std::cout << result << std::endl;
    assert(!result);
  }

  {
    int n = 1;
    int result = solution.isPowerOfFour(n);
    std::cout << result << std::endl;
    assert(result);
  }


  return 0;
}
#include <cassert>
#include <iostream>

//   0 0 1 0
// ^ 0 1 0 1
// ----------
//   0 1 1 1
//
// x xor y (x ^ y):
//   return 1 when either x or y is 1, otherwise return 0
//   in another word, return 1 whenever x and y are differetn
// use case:
//   1. use xor to toggle bit
//   2. use xor to get positions in two numbers that are different

class Solution {
public:
  int hammingDistance(int x, int y) {
    int difference = x ^ y;
    int n = 0;
    while (difference) {
      n += difference & 1;
      difference >>= 1;
    }
    return n;
  }
};

int main() {
  Solution solution;

  {
    int x = 0b001, y = 0b100;
    int res = solution.hammingDistance(x, y);
    std::cout << res << std::endl;
    assert(res == 2);
  }
}
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <cassert>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

// find the longest common subsequence
// t1 = a b c d e
// t2 = a c e
// The table represent the function encoded by the 2D array.
// Notice the diagnal line represents when index of t1 and t2 are the same.
// We can think traverse over j as incrementing t2 but keey at the same position
// in t1.
// i is the other way around.
//   | _ a b c d e
// --+-----------
// _ | 0 0 0 0 0 0
// a | 0 1 1 1 1 1
// c | 0 1 1 2 2 1
// e | 0 1 1 1 2 3
//
// if text1[i][j] == text2[i][j], we can increment the longest subsequence by 1
// otherwise we remain the same maximum subsequence of where we came from.
//
// Very common technique is to pad 0 in boundaries to be base cases.

class Solution {
public:
  int longestCommonSubsequence(string text1, string text2) {
    int m = text1.size(), n = text2.size();
    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1, 0));

    for (int i = 0; i < m; ++i) {
      for (int j = 0; j < n; ++j) {
        if (text1[i - 1] == text2[j - 1]) {
          dp[i][j] = dp[i - 1][j - 1] + 1;
        } else {
          dp[i][j] = std::max(dp[i][j - 1], dp[i - 1][j]);
        }
      }
    }

    return dp[m][n];
  }
};

int test_case(auto solution) {
  std::vector<std::pair<std::pair<std::string, std::string>, int>> problems{
      {{"abcde", "ace"}, 3}, {{"abc", "abc"}, 3}, {{"abc", "def"}, 0}};

  for (auto &[ts, a] : problems) {
    auto result = solution.longestCommonSubsequence(ts.first, ts.second);
    std::cout << result << std::endl;
    assert(result == a);
  }

  return 0;
}

int main(void) {
  Solution solution;
  test_case(solution);
  return 0;
}
#include <iostream>
#include <vector>

using namespace std;
#include <cassert>
#include <iostream>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <vector>

using namespace std;

// give a string and a dictionary, return true if s can be segmented into space
// separated sequence of one or more dictionary words.

namespace sol1 {

class Solution {
public:
  bool wordBreak(string s, vector<string> &wordDict) {
    std::vector<int> dp(s.size() + 1, false);
    int n = s.size();
    dp[0] = true;

    for (int i = 1; i <= n; ++i) {
      for (auto &word : wordDict) {
        int len = word.size();
        if (i >= len && word == s.substr(i - len, len)) {
          dp[i] = dp[i] || dp[i - len];
        }
      }
    }
    return dp[n];
  }
};

} // namespace sol1

int test_case(auto solution) {

  {
    std::vector<std::string> dict{"leet", "code"};
    auto result = solution.wordBreak("leetcode", dict);
    std::cout << result << std::endl;
    assert(result);
  }

  {
    std::vector<std::string> dict{"apple", "pen"};
    auto result = solution.wordBreak("applepen", dict);
    std::cout << result << std::endl;
    assert(result);
  }

  {
    std::vector<std::string> dict{"cats", "dog", "sand", "and", "cat"};
    auto result = solution.wordBreak("catsandog", dict);
    std::cout << result << std::endl;
    assert(!result);
  }

  return 0;
}

int main(void) {
  {
    using namespace sol1;
    Solution solution;
    test_case(solution);
  }

  return 0;
}
#include <iostream>
#include <vector>

using namespace std;
#include <cassert>
#include <iostream>
#include <vector>

using namespace std;

// dp[n] = max(dp[i - 1], dp[i - 2] + nums[i - 1])
class Solution {
public:
  int rob(vector<int> &nums) {
    if (nums.empty())
      return 0;
    int n = nums.size();
    std::vector<int> dp(n + 1, 0);
    dp[1] = nums[0];
    for (int i = 2; i <= n; ++i)
      dp[i] = std::max(dp[i - 1], nums[i - 1] + dp[i - 2]);
    return dp[n];
  }
};

int main(void) {

  Solution solution;

  {
    std::vector<int> v{1, 2, 3, 1};

    auto result = solution.rob(v);
    std::cout << result << std::endl;
    assert(result == 4);
  }
  return 0;
}
#include <cassert>
#include <iostream>
#include <vector>

using namespace std;

// in a 0 1 matrix
// find largest square containing only 1s.

// 0 0 1 0      0 0 1 0
// 0 1 1 1      0 1 1 1
// 1 1 1 1  =>  1 1 2 2
// 0 1 1 1      0 1 2 3
//
// 0 1 1 1      0 1 1 1
// 0 1 1 1      0 1 2 2
// 1 1 1 1  =>  1 1 2 3
// 0 1 0 1      0 1 0 1
//
// dp[i][j] represents the are of square that with it as bottom right coner.
// dp[i][j] = mat[i][j] == 0 ? 0 :
//                (dp[i - 1][j - 1] && dp[i -1][j] && dp[i][j - 1]) ?
//                  mat[i][j] + dp[i-1][j-1]

class Solution {
public:
  int maximalSquare(vector<vector<char>> &matrix) {
    int m = matrix.size(), n = m ? matrix[0].size() : 0;
    int max = INT32_MIN;

    std::vector<std::vector<int>> dp(m, std::vector<int>(n, 0));
    for (int i = 0; i < m; ++i) {
      for (int j = 0; j < n; ++j) {
        if (matrix[i][j] == '1') {
          dp[i][j] = (i - 1 < 0 || j - 1 < 0)
                         ? 1
                         : std::min(dp[i - 1][j - 1],
                                    std::min(dp[i][j - 1], dp[i - 1][j])) +
                               1;
        }
        max = std::max(max, dp[i][j]);
      }
    }
    return max * max;
  }
};

int main(void) {
  Solution solution;
  {
    std::vector<std::vector<char>> mat{{'1', '0', '1', '0', '0'},
                                       {'1', '0', '1', '1', '1'},
                                       {'1', '1', '1', '1', '1'},
                                       {'1', '0', '0', '1', '0'}};

    auto result = solution.maximalSquare(mat);
    std::cout << result << std::endl;
    assert(result == 4);
  }

  {
    std::vector<std::vector<char>> mat{{'0', '1'}, {'1', '0'}};

    auto result = solution.maximalSquare(mat);
    std::cout << result << std::endl;
    assert(result == 1);
  }

  return 0;
}
#include <cassert>
#include <cmath>
#include <iostream>
#include <queue>
#include <unordered_set>
#include <vector>

using namespace std;

// cutting problem
// n = Sum(ps) where ps = list of perfect number

namespace dp_solution {

// solve with dp
// dp[i] be the minimum number of perfect square numbers needed to form i.
// dp[i] = min(dp[i - 2], dp[i - 4], ...) + 1

class Solution {
public:
  int numSquares(int n) {
    if (n <= 0) return 0;
    std::vector<int> dp(n + 1, INT32_MAX);
    dp[0] = 0; // base case

    for (int i = 1; i <= n; ++i) {
      for (int j = 1; j * j <= i; ++j) {
        dp[i] = std::min(dp[i], dp[i - j * j] + 1);
      }
    }
    return dp[n];
  }
};
} // namespace dp_solution

namespace bfs_solution {
// solution with breath first search
class Solution {
public:
  int bfs(int n) {
    std::queue<std::pair<int, int>> q;
    int num, height, i;
    std::unordered_set<int> visited;
    q.push({n, 0});
    while (!q.empty()) {
      num = q.front().first;
      height = q.front().second;
      q.pop();

      if (num == 0)
        return height;
      if (visited.find(num) != visited.end())
        continue;
      int l = sqrt(num);
      for (int i = l; i >= 1; --i) {
        q.push({num - i * i, height + 1});
      }
    }
    return 0;
  }

  int numSquares(int n) { return bfs(n); }
};

} // namespace bfs_solution

int test_case(auto solution) {

  {
    // 4 + 4 + 4
    int n = 12;
    int result = solution.numSquares(n);
    assert(result == 3);
  }

  {
    // 9 + 4
    int n = 13;
    int result = solution.numSquares(n);
    assert(result == 2);
  }
  return 0;
}

int main(void) {

  {
    using namespace dp_solution;
    Solution solution;
    test_case(solution);
  }

  {
    using namespace bfs_solution;
    Solution solution;
    test_case(solution);
  }
  return 0;
}
#include <cassert>
#include <iostream>
#include <vector>
using namespace std;
template <typename C> void print_seq(C &&container) {
  for (auto &n : container) {
    std::cout << n << " ";
  }
  std::cout << std::endl;
}

using namespace std;

// find the length of the longest strictly increasing subsequence.
namespace dp_sol {

// dp[n]: longest subsequence up to index n.
// set all dp[n] = 1;
// for dp[i] dp[j] where j < i, if dp[j] < dp[i], dp[i] = min(dp[i], dp[j] + 1)
// why I spent so long on this?
class Solution {
public:
  int lengthOfLIS(vector<int> &nums) {
    int n = nums.size();
    int max = 1;
    std::vector<int> dp(n, 1);

    for (int i = 1; i < n; ++i) {
      for (int j = i; j >= 0; --j) {
        if (nums[j] < nums[i]) {
          dp[i] = std::max(dp[i], dp[j] + 1);
        }
        max = std::max(max, dp[i]);
      }
    }

    return max;
  }
};
} // namespace dp_sol
namespace bin_sol {

// lower_bound to
class Solution {
public:
  int lengthOfLIS(vector<int> &nums) {
    std::vector<int> result;
    for (int i = 0; i < nums.size(); ++i) {
      auto it = std::lower_bound(result.begin(), result.end(), nums[i]);
      if (it != result.end())
        *it = nums[i];
      else
        result.push_back(nums[i]);
    }
    return result.size();
  }
};
} // namespace bin_sol

void test_case(auto solution) {
  std::vector<std::pair<std::vector<int>, int>> inputs{

      {{10, 9, 2, 5, 3, 7, 101, 18}, 4}, {{0, 1, 0, 3, 2, 3}, 4},
      {{7, 7, 7, 7, 7, 7, 7}, 1},        {{4, 10, 4, 3, 8, 9}, 3},
      {{1, 3, 6, 7, 9, 4, 10, 5, 6}, 6}, {{0}, 1}};

  for (auto &[nums, a] : inputs) {
    auto result = solution.lengthOfLIS(nums);
    std::cout << "result: " << result << ", expected: " << a << std::endl;
    assert(result == a);
  }
}

int main() {

  {
    using namespace dp_sol;
    Solution solution;
    test_case(solution);
  }

  {
    using namespace bin_sol;
    Solution solution;
    test_case(solution);
  }
}
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <cassert>
#include <iostream>
#include <numeric>
#include <vector>

using namespace std;

class Solution {
public:
  int numberOfArithmeticSlices(vector<int> &nums) {
    if (nums.size() < 3)
      return 0;
    std::vector<int> dp(nums.size(), 0);
    for (int i = 2; i < nums.size(); ++i) {
      if (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2])
        dp[i] = dp[i - 1] + 1;
    }
    return std::accumulate(dp.begin(), dp.end(), 0);
  }
};

int main(void) {
  Solution solution;

  {
    std::vector<int> v{1, 2, 3, 4};
    auto result = solution.numberOfArithmeticSlices(v);
    std::cout << result << std::endl;
    assert(result = 3);
  }

  {
    std::vector<int> v{1, 2, 3, 8, 9, 10};
    auto result = solution.numberOfArithmeticSlices(v);
    std::cout << result << std::endl;
    assert(result = 2);
  }

  return 0;
}
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <cassert>
#include <iostream>
#include <vector>

// another 2d dynamic programming

using namespace std;

// use dp top left to bottom right, and then bottom right to top left again
//
// also you can use depth first searth
class Solution {
public:
  vector<vector<int>> updateMatrix(vector<vector<int>> &mat) {
    int m = mat.size(), n = m ? mat[0].size() : 0;
    std::vector<std::vector<int>> dp(m, std::vector<int>(n, INT32_MAX - 1));

    for (int i = 0; i < m; ++i) {
      for (int j = 0; j < n; ++j) {
        if (mat[i][j] == 0) {
          dp[i][j] = 0;
        } else {
          if (i > 0)
            dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);
          if (j > 0)
            dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);
        }
      }
    }

    for (int i = m - 1; i >= 0; --i) {
      for (int j = n - 1; j >= 0; --j) {
        if (mat[i][j] != 0) {
          if (i < m - 1)
            dp[i][j] = std::min(dp[i][j], dp[i + 1][j] + 1);
          if (j < n - 1)
            dp[i][j] = std::min(dp[i][j], dp[i][j + 1] + 1);
        }
      }
    }
    return dp;
  }
};

int main(void) {

  Solution solution;

  {
    std::vector<std::vector<int>> m{{0, 0, 0}, {0, 1, 0}, {0, 0, 0}};
    auto result = solution.updateMatrix(m);

    std::vector<std::vector<int>> ans = {{0, 0, 0}, {0, 1, 0}, {0, 0, 0}};
    assert(result == ans);
  }

  {
    std::vector<std::vector<int>> m{{0, 0, 0}, {0, 1, 0}, {1, 1, 1}};
    auto result = solution.updateMatrix(m);

    std::vector<std::vector<int>> ans = {{0, 0, 0}, {0, 1, 0}, {1, 2, 1}};
    assert(result == ans);
  }
  return 0;
}
#include <cassert>
#include <iostream>
#include <vector>

// 2d dynamic programming
// dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) - nums[i][j]

using namespace std;

class Solution {
public:
  int minPathSum(vector<vector<int>> &grid) {
    const int m = grid.size(), n = grid[0].size();
    std::vector<std::vector<int>> dp(m, std::vector<int>(n, 0));

    for (int i = 0; i < m; ++i) {
      for (int j = 0; j < n; ++j) {
        dp[i][j] = (i == 0 && j == 0) ? grid[i][j]
                   : (i == 0)         ? dp[i][j - 1] + grid[i][j]
                   : (j == 0)
                       ? dp[i - 1][j] + grid[i][j]
                       : std::min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
      }
    }
    return dp[m - 1][n - 1];
  }
};

int main() {
  Solution solution;

  {
    std::vector<std::vector<int>> m{{1, 3, 1}, {1, 5, 1}, {4, 2, 1}};
    auto result = solution.minPathSum(m);
    std::cout << result << std::endl;
    assert(result == 7);
  }

  {
    std::vector<std::vector<int>> m{{1, 2, 3}, {4, 5, 6}};
    auto result = solution.minPathSum(m);
    std::cout << result << std::endl;
    assert(result == 12);
  }
}
#include <iostream>
#include <vector>

using namespace std;
#include <cassert>
#include <iostream>
#include <vector>

using namespace std;

// dp[n] = dp[n - 1] + dp[n - 2]

class Solution {
public:
  int climbStairs(int n) {
    if (n <= 2)
      return n;
    std::vector<int> dp(n + 1, 1);
    for (int i = 2; i <= n; ++i)
      dp[i] = dp[i - 1] + dp[i - 2];
    return dp[n];
  }
};

int main(void) {

  Solution solution;
  {
    int n = 2;
    auto result = solution.climbStairs(n);
    std::cout << n << std::endl;
    assert(result == 2);
  }

  return 0;
}
#include <iostream>
#include <vector>

using namespace std;
#include <cassert>
#include <iostream>
#include <string>
#include <vector>
template <typename C> void print_seq(C &&container) {
  for (auto &n : container) {
    std::cout << n << " ";
  }
  std::cout << std::endl;
}

using namespace std;
// 1 <= n < 25
// dp[i]: number of ways to decode at position i
// This problem looks like dp, but it's really about case analysis..
// So many edge cases to consider.
namespace sol1 {
class Solution {
public:
  int numDecodings(string s) {
    if (s.size() == 1)
      return valid(s.begin(), s.end());
    if (s[0] <= '0' || s[0] > '9')
      return 0;

    std::vector<int> dp(s.size(), 0);
    dp[0] = 1;

    dp[1] = valid(s.begin(), s.begin() + 2) ? s[1] != '0' ? 2 : 1
            : s[1] != '0'                   ? 1
                                            : 0;

    for (int i = 2; i < s.size(); ++i) {
      if (valid(s.begin() + i - 1, s.begin() + i + 1)) { // last two are valid
        dp[i] = (s[i] != '0') ? dp[i - 1] + dp[i - 2] : dp[i - 2];
      } else {
        dp[i] = (s[i] != '0')                               ? dp[i - 1]
                : (valid(s.begin() + i - 2, s.begin() + i)) ? dp[i - 2] - 1
                                                            : 0;
      }
    }
    return dp[s.size() - 1];
  }

  template <typename Iter> bool valid(Iter first, Iter last) {
    assert(last - first <= 2);
    if (*first == '0')
      return false;
    int n = std::stoi(std::string(first, last));
    return n > 0 && n <= 26;
  }

  template <typename Iter> bool valid(Iter index) {
    int n = *index;
    return n > 0 && n <= 26;
  }
};
} // namespace sol1

namespace sol2 {
class Solution {
public:
  int numDecodings(string s) {
    int n = s.length();
    if (n == 0)
      return 0;
    int prev = s[0] - '0';
    if (!prev)
      return 0;
    if (n == 1)
      return 1;
    std::vector<int> dp(n + 1, 1);

    for (int i = 2; i <= n; ++i) {
      int cur = s[i - 1] - '0';
      if ((prev == 0 || prev > 2) && cur == 0) {
        return 0;
      }

      if ((prev < 2 && prev > 0) || prev == 2 && cur < 7) {
        if (cur) {
          dp[i] = dp[i - 2] + dp[i - 1];
        } else {
          dp[i] = dp[i - 2];
        }
      } else {
        dp[i] = dp[i - 1];
      }
      prev = cur;
    }
    return dp[n];
  }
};
} // namespace sol2

int test_case(auto solution) {

  std::vector<std::pair<std::string, int>> cases{
      {"12", 2},    {"22", 2}, {"226", 3}, {"06", 0},   {"10", 1},
      {"0", 0},     {"1", 1},  {"27", 1},  {"2101", 1}, {"1123", 5},
      {"10011", 0}, {"30", 0}, {"301", 0}, {"13904", 0}};

  for (auto &[s, a] : cases)

  {
    std::cout << "[test] str: " << s << ", expect: " << a << std::endl;
    auto result = solution.numDecodings(s);
    std::cout << result << std::endl;
    assert(result == a);
  }

  return 0;
}

int main(void) {

  {
    using namespace sol1;
    Solution solution;
    test_case(solution);
  }

  {
    using namespace sol2;
    Solution solution;
    test_case(solution);
  }
  return 0;
}
#include <iostream>
#include <vector>

// given n items, each item has value v and weight w.
// given a knapsack with capacity W,
// Ask: what items should we take to maximize the value in the knapsack.
//
// Two variations:
//  1. complete knapsack: one can cut an item by fraction
//  . 0 1 knapsack: items are atomic, you either take an item or not.
//
// State transition matrix.
//
// dp[i][j]: maximum value when ith item is not greter then j.
//          (total remaining knapsack capacity)
// dp[i][j] | j=1  j=2  j=3  j=4  j=5
// ---------+--------------------------
//   i=0    |
//   i=1    |
//   i=2    |
//   i=3    |
//   i=4    |

int knapsack01_naive(std::vector<int> weights, std::vector<int> values, int n,
                     int w) {}

int knapsack01_space_compressed(std::vector<int> weights,
                                std::vector<int> values, int n, int w) {}

int main(void) { return 0; }
// https://leetcode.com/problems/candy/

#include <iostream>
#include <vector>
#include <numeric>
using namespace std;

// Another allocation algorithm
// Problem:
//   1. Make sure child with higher rating get more candies then it's neighbour,
//   2. Make sure total candies usage is minimum.
//
// Steps:
//   1. make sure all child have at least one candy.
//   2. make sure each child with higher rating in the left hand size has one
//      more candy.
//      traverse from left to right,
//      update rating by comparing current child with it's left neighbour.
//      if current child has higher rating, it needs to have at least
//      one more candy than it's left child.
//   3. make sure each child with higher rating in the right hand side  has one
//      more candy.
//      traverse from right to left, if left child's rating is not graeter then
//      current, update left child = right child + 1
//
// Proof:
//   P1: by traverse from left to right, we ensure all elements with higher
//       rating then it's left have at least one more candy.
//       by traverse from right to left, we ensure all elements with higher
//       rating then it's right has at least one more candy.
//
//       In case two consecutive elements in a row, we only need to increment
//       once.

class Solution {
public:
    int candy(vector<int>& ratings) {
      int size = ratings.size();
      if (size < 2) {
        return size;
      }

      // initialize vector with size n to 1 never use initializer list...
      vector<int> candies(size, 1);

      for (int i = 1; i < size; ++i) {
        if (ratings[i] > ratings[i - 1]) {
          candies[i] = candies[i -  1] + 1;
        }
      }

      for (int i = size - 1; i > 0; --i) {
        if (ratings[i] < ratings[i - 1]) {
          candies[i - 1] = max(candies[i - 1], candies[i] + 1);
        }
      }

      return accumulate(candies.begin(), candies.end(), 0);
    }
};

int main() {

  Solution solution;

  {
    vector<int> ratings {1, 0, 2};
    int res = solution.candy(ratings);
    std::cout << res << std::endl;
  }

  {
    vector<int> ratings {1, 2, 2};
    int res = solution.candy(ratings);
    std::cout << res << std::endl;
  }


  return 0;
}
// https://leetcode.com/problems/non-overlapping-intervals/

#include <iostream>
#include <tuple>
#include <vector>

using namespace std;


// Problem:
//   input of intervals [begin, end]. how to remove intervals to make all
//   intervals in the vector non overlapping
// Steps:
//   1. sort base on the end value.
//   2. traverse over all begins, for
//      interval_i = [begin_i, end_i], interval_j = [begin_j, end_j],
//      let current_incterval = interval_I
//      if begin_j > end_i, if so, remove interval_j
//      else current_inverval = interval_j and go for the next iteration
//
// Proof:
//   Because it's sorted base on starting interval:
//    1. if removing the next interval that begins within the previous interval
//       guarantee an overlap,
//    2. if we don't need to remove the next interval we can guarantee there
//       is no overlap up to current interval.
//    By indcution once we repeat the process for the whole vector we have
//    no overlap.
//

class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
      sort(intervals.begin(), intervals.end(), [](auto x, auto y) {
          return x[1] < y[1];
          });
      int num = 0;
      int prev = intervals[0][1];

      for (int i = 1; i < intervals.size(); ++i) {
        if (intervals[i][0] < prev) {
          ++num;
        } else {
          prev = intervals[i][1];
        }
      }

      return num;
    }
};

int main(void)
{
  Solution solution;
  {
    vector<vector<int>> v{{1, 2}, {2, 3}, {3, 4}, {1, 3}};
    auto r = solution.eraseOverlapIntervals(v);
    std::cout << r << std::endl;
  }

  return 0;
}
// https://leetcode.com/problems/assign-cookies/

/* Input: g = [1,2,3], s = [1,1] */
/* Output: 1 */
/* Explanation: You have 3 children and 2 cookies. The greed factors of 3
 * children are 1, 2, 3. */
/* And even though you have 2 cookies, since their size is both 1, you could
 * only make the child whose greed factor is 1 cotent. */
/* You need to output 1.n */

#include <iostream>
#include <vector>

// Allocation problem
// Solution:
//   Sort children and cookies in ascending order. Try to feed the first child
//   with the first cookie, if doesn't work try the next cookie.
//   Each step choose the smallest possible cookie, then eventually we get
//   the smallest amount of cookies needed to feed all children.

using namespace std;

class Solution {
public:
  int findContentChildren(vector<int> &g, vector<int> &s) {
    sort(g.begin(), g.end());
    sort(s.begin(), s.end());
    int gi, si;
    for (gi = 0, si = 0; gi < g.size() && si < s.size(); ++si) {
      if (g[gi] <= s[si]) {
        ++gi;
      }
    }
    return gi;
  }
};


int main(void)
{
  Solution solution;

  {
    vector<int> g {1, 2, 3};
    vector<int> s {1, 1};
    int r1 = solution.findContentChildren(g, s);
    cout << r1 << endl;
  }

  {
    vector<int> g {1, 2};
    vector<int> s {1, 2, 3};
    int r1 = solution.findContentChildren(g, s);
    cout << r1 << endl;
  }


  return 0;
}
#include <iostream>
#include <vector>

using namespace std;
#include "417-data-only.h"
#include <cassert>
#include <csignal>
#include <iostream>
#include <set>
#include <unordered_map>
#include <vector>
using namespace std;
#define DEBUG

#ifdef DEBUG
int total = 0;
int memoized = 0;
int indent_num = 0;

void indent(bool inc) {
  if (inc)
    indent_num++;
  for (int i = 0; i < indent_num; ++i)
    std::cout << "    ";
}

void unindent() { indent_num--; }

template <typename C> void print_grid(C &&container) {
  if (container.empty()) {
    std::cout << "empty" << std::endl;
    return;
  }
  for (auto &n : container) {
    for (auto &s : n)
      std::cout << s << " ";
    std::cout << std::endl;
  }
  std::cout << std::endl;
}
#endif

// with root n, we consider there is an edge if any nodes next to it has
// value smaller or equals to heights[n].
// dfs to find all nodes in the graph
// We can simply use memoization and store flow set already computed.

namespace sol1 {
class Solution {
  // TODO handle loop case!
  // pruning is really annoying.
public:
  unsigned int can_reach_pacific = 0b011;
  unsigned int can_reach_atlantic = 0b101;
  unsigned int blocked = 0b001;
  unsigned int loop = 0b100;
  unsigned int in_progress = 0b010;

  std::vector<int> direction{-1, 0, 1, 0, -1};
  std::vector<std::vector<unsigned int>> state;

  vector<vector<int>> pacificAtlantic(vector<vector<int>> &heights) {
    int m = heights.size();
    int n = m ? heights[0].size() : 0;
    std::vector<std::vector<int>> result;
    state = std::vector<std::vector<unsigned int>>(
        m, std::vector<unsigned int>(n, 0));

    for (int i = 0; i < m; ++i) {
      for (int j = 0; j < n; ++j) {
        std::vector<std::vector<bool>> visited(m, std::vector<bool>(n, false));

        auto flow = dfs(heights, visited, i, j);
        if (flow == 0b111)
          result.push_back({i, j});
      }
    }
    return result;
  }

  unsigned int dfs(std::vector<std::vector<int>> &heights,
                   std::vector<std::vector<bool>> &visited, int i, int j) {
    const int m = heights.size(), n = m ? heights[0].size() : 0;

    if (visited[i][j]) {
      if (state[i][j] == in_progress)
        return in_progress; // to signal the caller.
      else
        return state[i][j] || blocked;
    }

    visited[i][j] = true;

    // handle loop later.
    if (state[i][j] != 0 && state[i][j] != loop) {
      return state[i][j];
    }

    unsigned int flow;
    assert(state[i][j] == loop || state[i][j] == 0);
    state[i][j] |= in_progress; // mark as in progress 0b110

    // marki possible loops.
    // if more then two neighbours have the same height, mark later ones
    // as loop.
    for (int k = 0, h = 0; k < 4; ++k) {
      int x = i + direction[k], y = j + direction[k + 1];
      if (x >= 0 && x < m && y >= 0 && y < n &&
          heights[x][y] == heights[i][j]) {
        ++h;
        state[x][y] |= h > 1 ? loop : 0;
      }
    }

    // recursively test if neighbours can reach eitehr ocean.
    for (int k = 0; k < 4; ++k) {
      int x = i + direction[k], y = j + direction[k + 1];
      auto mask = (x < 0 || y < 0)     ? can_reach_pacific
                  : (x >= m || y >= n) ? can_reach_atlantic
                  : (heights[x][y] <= heights[i][j])
                      ? dfs(heights, visited, x, y)
                      : blocked;

      // handle loop
      // mask can be loop | in_progress
      // state can only be loop or 0
      if (mask & in_progress && state[i][j] & loop) {
        mask = blocked;
        visited[i][j] = false; // traverse this node again later
      }
      flow |= mask;
    }
    state[i][j] = flow;
    return flow;
  }
};

} // namespace sol1

namespace sol2 {
// search from oceans to peaks
// this solution is much clearer
class Solution {
public:
  std::vector<int> direction{-1, 0, 1, 0, -1};

  vector<vector<int>> pacificAtlantic(vector<vector<int>> &heights) {
    if (heights.empty() || heights[0].empty())
      return {};
    const int m = heights.size(), n = heights[0].size();
    std::vector<std::vector<int>> result;

    std::vector<std::vector<bool>> can_reach_pacific(
        m, std::vector<bool>(n, false));
    std::vector<std::vector<bool>> can_reach_atlantic(
        m, std::vector<bool>(n, false));

    for (int i = 0; i < m; ++i) {
      dfs(heights, can_reach_pacific, {i, 0});
      dfs(heights, can_reach_atlantic, {i, n - 1});
    }

    for (int i = 0; i < n; ++i) {
      dfs(heights, can_reach_pacific, {0, i});
      dfs(heights, can_reach_atlantic, {m - 1, i});
    }

    for (int i = 0; i < m; ++i) {
      for (int j = 0; j < n; ++j) {
        if (can_reach_pacific[i][j] && can_reach_atlantic[i][j])
          result.push_back({i, j});
      }
    }
    return result;
  }

  void dfs(const std::vector<std::vector<int>> &heights,
           std::vector<std::vector<bool>> &can_reach,
           std::pair<int, int> root) {
    auto &[i, j] = root;
    if (can_reach[i][j]) {
      return;
    }
    can_reach[i][j] = true;
    for (int k = 0; k < 4; ++k) {
      int x = i + direction[k], y = j + direction[k + 1];
      if (x >= 0 && x < heights.size() && y >= 0 && y < heights[0].size() &&
          heights[i][j] <= heights[x][y]) {
        dfs(heights, can_reach, {x, y});
      }
    }
  }
};
} // namespace sol2

void test1(auto solution) {
  std::vector<std::vector<int>> heights{{1, 2, 2, 3, 5},
                                        {3, 2, 3, 4, 4},
                                        {2, 4, 5, 3, 1},
                                        {6, 7, 1, 4, 5},
                                        {5, 1, 1, 2, 4}};

  std::vector<std::vector<int>> paths = solution.pacificAtlantic(heights);

  print_grid(paths);
  std::vector<std::vector<int>> ans = {{0, 4}, {1, 3}, {1, 4}, {2, 2},
                                       {3, 0}, {3, 1}, {4, 0}};
  assert(ans == paths);
}

void test2(auto solution) {
  std::vector<std::vector<int>> heights{{2, 1}, {1, 2}};
  std::vector<std::vector<int>> paths = solution.pacificAtlantic(heights);

  print_grid(paths);
  std::vector<std::vector<int>> ans = {{0, 0}, {0, 1}, {1, 0}, {1, 1}};
  assert(ans == paths);
}

void test3(auto solution) {
  std::vector<std::vector<int>> heights{{1, 2, 3, 4},    //
                                        {12, 13, 14, 5}, //
                                        {11, 16, 15, 6}, //
                                        {10, 9, 8, 7}};  //
  std::vector<std::vector<int>> paths = solution.pacificAtlantic(heights);

  print_grid(paths);
  std::vector<std::vector<int>> ans{{0, 3}, {1, 0}, {1, 1}, {1, 2}, {1, 3},
                                    {2, 0}, {2, 1}, {2, 2}, {2, 3}, {3, 0},
                                    {3, 1}, {3, 2}, {3, 3}};
  assert(ans == paths);
}

void test4(auto solution) {
  std::cout << "Big island: " << std::endl;
  std::vector<std::vector<int>> heights BIG_ISLAND;
  std::vector<std::vector<int>> paths = solution.pacificAtlantic(heights);
  print_grid(paths);
}

void test5(auto solution) {
  std::cout << "Big island1: " << std::endl;
  std::vector<std::vector<int>> heights BIG_ISLAND1;
  std::vector<std::vector<int>> paths = solution.pacificAtlantic(heights);
  print_grid(paths);
}

void test6(auto solution) {
  std::vector<std::vector<int>> heights{{1, 1}, {1, 1}, {1, 1}};
  std::vector<std::vector<int>> paths = solution.pacificAtlantic(heights);
  std::cout << std::endl;
  print_grid(paths);
  std::vector<std::vector<int>> ans = {{0, 0}, {0, 1}, {1, 0},
                                       {1, 1}, {2, 0}, {2, 1}};
  assert(ans == paths);
}

void test7(auto solution) {
  std::cout << "test 7" << std::endl;
  std::vector<std::vector<int>> heights{
      {10, 10, 10}, {10, 1, 10}, {10, 10, 10}};
  std::vector<std::vector<int>> paths = solution.pacificAtlantic(heights);
  std::cout << std::endl;
  print_grid(paths);
  std::vector<std::vector<int>> ans = {{0, 0}, {0, 1}, {0, 2}, {1, 0},
                                       {1, 2}, {2, 0}, {2, 1}, {2, 2}};
  assert(ans == paths);
}

int main() {
  using namespace sol2;
  // using namespace sol2;

  Solution solution;
  test1(solution);
  test2(solution);
  test3(solution);
  test4(solution);
  test5(solution);

  // loop case
  test6(solution);
  test7(solution);
}
#include <iostream>
#include <vector>
using namespace std;

template <typename C> void print_grid(C &&container) {
  if (container.empty()) {
    std::cout << "empty" << std::endl;
    return;
  }
  for (auto &n : container) {
    for (auto &s : n)
      std::cout << s << " ";
    std::cout << std::endl;
  }
  std::cout << std::endl;
}

// use the so called backtracking technique. We can mutate the state of the
// graph when we visiting a nodes, and set it's value back after the recursion
// is finished.

class Solution {
public:
  vector<vector<int>> permute(vector<int> &nums) {
    std::vector<std::vector<int>> result;
    backtracking(nums, 0, result);
    return result;
  }

  void backtracking(std::vector<int> &nums, int level,
                    std::vector<std::vector<int>> &result) {
    if (level == nums.size() - 1) {
      result.push_back(nums);
      return;
    }

    for (int i = level; i < nums.size(); ++i) {
      std::swap(nums[i], nums[level]); // modify the node
      backtracking(nums, level + 1, result);
      std::swap(nums[i], nums[level]); // change it back
    }
  }
};

int main() {
  Solution solution;

  {
    std::vector<int> nums{1, 2, 3};
    auto result = solution.permute(nums);
    print_grid(result);
  }

  {
    std::vector<int> nums{1, 0};
    auto result = solution.permute(nums);
    print_grid(result);
  }
}
#include <iostream>
#include <vector>
using namespace std;
#include <cassert>
#include <iostream>
#include <stack>
#include <vector>

using namespace std;

// https://leetcode.com/problems/number-of-provinces/
//    1 2 3
// 1 [1 1 0]
// 2 [1 1 0]
// 3 [0 0 1]

namespace stack_based {

class Solution {
public:
  int findCircleNum(vector<vector<int>> &isConnected) {
    int m = isConnected.size();
    int n = m ? isConnected[0].size() : 0;
    assert(m == n);
    int province_count = 0;

    for (int i = 0; i < m; ++i) {
      for (int j = 0; j < n; ++j) {
        if (isConnected[i][j]) {
          ++province_count;
          isConnected[i][j] = 0;

          std::stack<int> s;
          s.push(i);
          while (!s.empty()) {
            auto e = s.top();
            s.pop();
            for (int k = 0; k < m; ++k) {
              if (isConnected[e][k]) {
                isConnected[e][k] = 0;
                s.push(k);
              }
            }
          }
        }
      }
    }
    return province_count;
  }
};
} // namespace stack_based

namespace recursion_based {
class Solution {
public:
  int findCircleNum(vector<vector<int>> &isConnected) {
    int m = isConnected.size();
    int n = m ? isConnected[0].size() : 0;
    assert(m == n);
    int province_count = 0;

    for (int i = 0; i < m; ++i) {
      for (int j = 0; j < m; ++j) {
        if (isConnected[i][j]) {
          ++province_count;
          dfs(isConnected, i);
        }
      }
    }
    return province_count;
  }

  void dfs(std::vector<std::vector<int>> &isConnected, int root) {
    int m = isConnected.size();

    for (int k = 0; k < m; ++k) {
      if (isConnected[root][k]) {
        isConnected[root][k] = 0;
        dfs(isConnected, k);
      }
    }
  }
};
} // namespace recursion_based

void test_case(auto solution) {

  {
    std::vector<std::vector<int>> v = {{1, 1, 0}, {1, 1, 0}, {0, 0, 1}};
    auto res = solution.findCircleNum(v);
    std::cout << res << std::endl;
    assert(res == 2);
  }

  {
    std::vector<std::vector<int>> v = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};
    auto res = solution.findCircleNum(v);
    std::cout << res << std::endl;
    assert(res == 3);
  }
}

int main(void) {

  {
    using namespace stack_based;
    Solution solution;
    test_case(solution);
  }

  {
    using namespace recursion_based;
    Solution solution;
    test_case(solution);
  }

  return 0;
}
#include <cassert>
#include <iostream>
#include <stack>
#include <vector>
// https://leetcode.com/problems/max-area-of-island/
using namespace std;

// find the maximum are of an island in a grid
// island looks like this
// island must be 4 connected
// [[0,0,1,0,0,0,0,1,0,0,0,0,0],
//  [0,0,0,0,0,0,0,1,1,1,0,0,0],
//  [0,1,1,0,1,0,0,0,0,0,0,0,0],
//  [0,1,0,0,1,1,0,0,1,0,1,0,0],
//  [0,1,0,0,1,1,0,0,1,1,1,0,0],
//  [0,0,0,0,0,0,0,0,0,0,1,0,0],
//  [0,0,0,0,0,0,0,1,1,1,0,0,0],
//  [0,0,0,0,0,0,0,1,1,0,0,0,0]]

namespace stack_based {

class Solution {
public:
  std::vector<int> direction{-1, 0, 1, 0, -1};
  int maxAreaOfIsland(vector<vector<int>> &grid) {
    int m = grid.size();
    int n = m ? grid[0].size() : 0;
    int max_area = 0;

    for (int i = 0; i < m; ++i) {
      for (int j = 0; j < n; ++j) {
        if (grid[i][j]) {
          int local_area = 1;
          grid[i][j] = 0;

          std::stack<std::pair<int, int>> island;
          island.push({i, j});
          while (!island.empty()) {
            auto adjacents = get_neighbours(grid, island.top());
            island.pop();
            for (auto &n : adjacents) {
              grid[n.first][n.second] = 0;
              ++local_area;
              island.push(n);
            }
          }
          max_area = std::max(max_area, local_area);
        }
      }
    }
    return max_area;
  }

  std::vector<std::pair<int, int>>
  get_neighbours(std::vector<std::vector<int>> &grid,
                 std::pair<int, int> &node) {
    // (direciotn[i], direction[i + 1]) specify the neighbor location
    constexpr static int direction[5] = {-1, 0, 1, 0, -1};

    std::vector<std::pair<int, int>> result;
    auto &[r, t] = node;
    for (int i = 0; i < 4; ++i) {
      int x = r + direction[i];
      int y = t + direction[i + 1];
      if (x >= 0 && x < grid.size() && y >= 0 && y < grid[0].size() &&
          grid[x][y] == 1) {
        result.push_back({x, y});
      }
    }
    return result;
  }
};

} // namespace stack_based

namespace recursion_based {
class Solution {
public:
  std::vector<int> direction{-1, 0, 1, 0, -1};

  int maxAreaOfIsland(vector<vector<int>> &grid) {
    if (grid.empty() || grid[0].empty())
      return 0;
    int max_area = 0;
    for (int i = 0; i < grid.size(); ++i) {
      for (int j = 0; j < grid[0].size(); ++j) {
        if (grid[i][j] == 1) {
          max_area = std::max(max_area, dfs(grid, i, j));
        }
      }
    }
    return max_area;
  }

  int dfs(std::vector<std::vector<int>> &grid, int r, int t) {

    if (grid[r][t] == 0)
      return 0;
    grid[r][t] = 0;
    int area = 1;
    for (int i = 0; i < 4; ++i) {
      int x = r + direction[i], y = t + direction[i + 1];
      if (x >= 0 && x < grid.size() && y >= 0 && y < grid[0].size())
        area += dfs(grid, x, y);
    }
    return area;
  }
};
} // namespace recursion_based

int test_case(auto solution) {

  {
    std::vector<std::vector<int>> island{
        {0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
        {0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0},
        {0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0}};
    int v = solution.maxAreaOfIsland(island);
    std::cout << v << std::endl;
    assert(v == 6);
  }

  {
    std::vector<std::vector<int>> island{{0, 0, 0, 0, 0, 0, 0, 0}};
    int v = solution.maxAreaOfIsland(island);
    std::cout << v << std::endl;
    assert(v == 0);
  }

  {
    std::vector<std::vector<int>> island{{1, 1}, {1, 0}};
    int v = solution.maxAreaOfIsland(island);
    std::cout << v << std::endl;
    assert(v == 3);
  }

  return 0;
}

int main(void) {
  {
    using namespace stack_based;
    Solution solution;
    test_case(solution);
  }

  {
    using namespace recursion_based;
    Solution solution;
    test_case(solution);
  }
  return 0;
}
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <cassert>
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

// k select. find the kth largest element in an unsorted array.
//
// Input: nums = [3,2,1,5,6,4], k = 2
// Output: 5

template <typename C> void print_seq(C &&container) {
  for (auto &n : container) {
    std::cout << n << " ";
  }
  std::cout << std::endl;
}

// solution with quick select
namespace quick_select_sol {
class Solution {
public: /* quick_select */
  int lomuto_partition(vector<int> &nums, int l, int r) {
    int pivot = nums[r];
    int i = l;

    for (int j = l; j <= r; ++j) {
      // swap
      if (nums[j] > pivot) {
        swap(nums[i++], nums[j]);
      }
    }
    swap(nums[i], nums[r]);
    return i;
  }

  int quick_select(vector<int> &nums, int l, int r, int k) {
    int m = lomuto_partition(nums, l, r);
    int nth = m + 1;

    if (nth > k) {
      return quick_select(nums, l, m - 1, k);
    } else if (nth < k) {
      return quick_select(nums, m + 1, r, k);
    } else {
      return m;
    }
  }

  int findKthLargest(vector<int> &nums, int k) {
    int mid = quick_select(nums, 0, nums.size() - 1, k);
    return nums[mid];
  }
};
} // namespace quick_select

namespace priority_queue_sol {

// or you can just use stl's priority queue
class Solution {
public:
  int findKthLargest(vector<int> &nums, int k) {
    std::priority_queue<int> q;
    for (auto &n : nums)
      q.push(n);
    for (; k > 1; --k)
      q.pop();
    return q.top();
  }
};

} // namespace priority_queue

template <typename S> void test_cases(S solution) {
  {
    vector<int> v{3, 2, 1, 5, 6, 4};
    int res = solution.findKthLargest(v, 2);
    std::cout << res << std::endl;
    assert(res == 5);
    std::cout << "done" << std::endl;
  }

  // 6 5 5 4 3 3 2 2 1
  //       |
  {
    vector<int> v{3, 2, 3, 1, 2, 4, 5, 5, 6};
    int res = solution.findKthLargest(v, 4);
    std::cout << res << std::endl;
    assert(res == 4);
    std::cout << "done" << std::endl;
  }
}

int main(void) {
  {
    using namespace quick_select_sol;

    std::cout << "[quick select]: " << std::endl;
    Solution solution;
    test_cases(solution);
  }

  {
    using namespace priority_queue_sol;
    std::cout << "[priority queue]: " << std::endl;
    Solution solution;
    test_cases(solution);
  }

  return 0;
}
#include <iostream>
#include <queue>
#include <unordered_map>
#include <vector>

using namespace std;
using namespace std;
template <typename C> void print_seq(C &&container) {
  for (auto &n : container) {
    std::cout << n << " ";
  }
  std::cout << std::endl;
}

// given an array, find the first k most frequent numbers
//
// Input: nums = [1,1,1,1,2,2,3,4], k = 2
// Output: [1, 2]
//
// steps:
//   use bucket sorts.

class Solution {
public:
  vector<int> topKFrequent(vector<int> &nums, int k) {

    std::unordered_map<int, int> counts;
    for (auto &n : nums) {
      ++counts[n];
    }

    auto comp = [](auto a, auto b) { return a.second < b.second; };

    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>,
                        decltype(comp)>
        pq(comp);

    for (auto &n : counts) {
      pq.push(n);
    }

    std::vector<int> result;

    while (k >= 1) {
      result.emplace_back(pq.top().first);
      pq.pop();
      --k;
    }
    return result;
  }
};

int main(void) {
  Solution solution;

  {
    vector<int> v{1, 1, 1, 2, 2, 3};
    int k = 2;
    auto res = solution.topKFrequent(v, k);
    print_seq(res);
  }

  {
    vector<int> v{1};
    int k = 1;
    auto res = solution.topKFrequent(v, k);
    print_seq(res);
  }

  {
    vector<int> v{2, 1, 1, 3, 2, 2, 2, 1};
    int k = 1;
    auto res = solution.topKFrequent(v, k);
    print_seq(res);
  }

  return 0;
}
#include <cassert>
#include <cstring>
#include <functional>
#include <iostream>
#include <limits>
#include <vector>

using namespace std;
template <typename C> void print_seq(C &&container) {
  for (auto &n : container) {
    std::cout << n << " ";
  }
  std::cout << std::endl;
}

template <typename It> void print_iter(It first, It last) {
  while (first != last) {
    std::cout << *first << " ";
    ++first;
  }
  std::cout << std::endl;
}

//////////////////////////////////////////////////////////////////////////////
// merge sort
// recursively divide array into half until it's small enough to be solved
// in one step.
// Then merge small, merged arrays.
// two partitions should always side by side
// note it's very hard to implement in place merge sort, you need to copy
// elements, which is a little bit unfortunate.

template <typename T>
void merge(vector<T> &nums, int left, int mid, int right) {
  const int lhs_sz = mid - left + 1;
  const int rhs_sz = right - mid;
  const int sz = right - left + 1;

  assert(lhs_sz + rhs_sz == sz);

  vector<int> lhs(lhs_sz + 1, 0);
  vector<int> rhs(rhs_sz + 1, 0);
  // guard.
  // note this doesn't work for descending order.
  lhs[lhs_sz] = INT32_MAX;
  rhs[rhs_sz] = INT32_MAX;

  for (int i = 0; i < lhs_sz; ++i) {
    lhs[i] = nums[left + i];
  }

  for (int i = 0; i < rhs_sz; ++i) {
    rhs[i] = nums[mid + 1 + i];
  }
  int i = 0, j = 0, k = 0;

  for (k = 0; k < sz; ++k) {
    if (lhs[i] < rhs[j])
      nums[k + left] = lhs[i++];
    else
      nums[k + left] = rhs[j++];
  }
}

template <typename T> void merge_sort(vector<T> &nums, int left, int right) {
  if (right - left + 1 <= 1)
    return;
  int mid = left + (right - left) / 2; // get mid without overflow.
  merge_sort(nums, left, mid);
  merge_sort(nums, mid + 1, right);
  merge(nums, left, mid, right);
}

int main(void) {
  {
    std::cout << "merge sort " << std::endl;
    vector<int> v{5, 2, 9, 1, 7, 10, 3, 4, 6};
    merge_sort(v, 0, v.size() - 1);
    print_seq(v);
  }
  return 0;
}
#include <cassert>
#include <cstring>
#include <functional>
#include <iostream>
#include <vector>

using namespace std;
template <typename C> void print_seq(C &&container) {
  for (auto &n : container) {
    std::cout << n << " ";
  }
  std::cout << std::endl;
}

template <typename It> void print_iter(It first, It last) {
  while (first != last) {
    std::cout << *first << " ";
    ++first;
  }
  std::cout << std::endl;
}

//////////////////////////////////////////////////////////////////////////////
// quicksort:
//   given array A, left, right be lower and upper bound of range to sort
//   steps:
//     1. pick a pivot where left < p < right
//     2. the pivot partitioned A into two parts,
//        move elements e < A[p] to one side, otherwise the other side.
//     3. recursively apply quicksort to sub ranges.
// performance of quick sort depends on the partition algorithm choosed. There
// are many variations for paritioning.
//
// - choice of pivot

// Hoare partition scheme
// this is the original partition scheme used by tony hoare.
//
// In early version of quick sorts, left most element is usually chosen
// as the pivot element. (which gives the worst case in sorted array)
// To avoid this problem, we can pick the pivot randomly.
// This versoin uses median, which only avoid worst case in sorted array.
// NOTE: it's not necessary for the pivot to be at the middle position.
auto hoare_partition = [](auto &nums, int left, int right) {
  int pivot = nums[left];
  int i = left;
  int j = right;

  for (;;) {
    while (nums[i] < pivot)
      i++;
    while (nums[j] > pivot)
      j--;
    if (i >= j)
      break;
    swap(nums[i], nums[j]);
  }
  return j;
};

// Lomuto paritition scheme
// it mantains two indicies nums[i], nums[j]. i = j = left at the beginning.
// scan the array by advancing j.
// do nothing when nums[j] >= pivot,
// swap the value of nums[i] and nums[j] when nums[j] < pivot
// this brings numbers smaller than pivot to the left and numbers larger then
// the pivot to the right.
// [claim] when j = right - 1, i points to the last number that bigger then the
//         pivot.
// [claim] if we swap the pivot and nums[i] after the loop finished, we have
//             (forall e in nums[0:i-1], e < pivot)
//         and (forall e in nums[i:right] e > pivot)
// set the first
//
// lomuto paritition makes more  swap than hoare's partition, because each
// time nums[i] get swaped
auto lomuto_partition = [](auto &nums, int left, int right) {
  int pivot = nums[right]; // choose
  int i = left;
  for (int j = left; j <= right; ++j) {
    if (nums[j] < pivot) {
      swap(nums[j], nums[i]);
      ++i;
    }
  }
  swap(nums[i], nums[right]);
  return i;
};

template <typename T, typename Partition>
void quick_sort(vector<T> &nums, int left, int right, Partition partition) {
  if (left >= right)
    return;
  int p = partition(nums, left, right);     // return the index of the partition
  quick_sort(nums, left, p - 1, partition); // note we don't need mid
  quick_sort(nums, p + 1, right, partition);
}

// quick sorts
template <typename T> void quick_sort(vector<T> &nums, int left, int right) {
  quick_sort(nums, left, right, hoare_partition);
}

int main(void) {
  {
    std::cout << "quick sort [hoare partition]" << std::endl;
    vector<int> v{5, 2, 9, 1, 7, 10, 3};
    quick_sort(v, 0, v.size() - 1);
    print_seq(v);

    v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    quick_sort(v, 0, v.size() - 1);
    print_seq(v);
  }

  {
    std::cout << "quick sort [lomuto paritition]" << std::endl;
    vector<int> v{5, 2, 9, 1, 7, 10, 3};
    quick_sort(v, 0, v.size() - 1, lomuto_partition);
    print_seq(v);

    v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    quick_sort(v, 0, v.size() - 1, lomuto_partition);
    print_seq(v);
  }

  return 0;
}
#include <cassert>
#include <cstring>
#include <functional>
#include <iostream>
#include <vector>

using namespace std;
template <typename C> void print_seq(C &&container) {
  for (auto &n : container) {
    std::cout << n << " ";
  }
  std::cout << std::endl;
}

template <typename It> void print_iter(It first, It last) {
  while (first != last) {
    std::cout << *first << " ";
    ++first;
  }
  std::cout << std::endl;
}

//////////////////////////////////////////////////////////////////////////////
// bubble sort
template <typename T> void bubble_sort(vector<int> &nums, int n) {
  bool swapped;
  for (int i = 1; i < n; ++i) {
    swapped = false;
    for (int j = 1; j < n - i + 1; ++j) {
      swap(nums[j], nums[j - 1]);
      swapped = true;
    }
    if (!swapped)
      break;
  }
}

//////////////////////////////////////////////////////////////////////////////
// insertion sort
template <typename T> void selection_sort(vector<int> &nums, int n) {
  int mid;
  for (int i = 0; i < n - 1; ++i) {
    mid = i;
    for (int j = i + 1; j < n; ++j) {
      if (nums[j] < nums[mid]) {
        mid = j;
      }
    }
    swap(nums[mid], nums[i]);
  }
}

//////////////////////////////////////////////////////////////////////////////
// insertion sort
//   performs is good for small input, so it's often used as the base
//   case of merge sort or quick sort.
// steps:
//   two loops. The outer loop iterate over the array,
//   the inner loop loops from the current index backwards to the beginning and
//   swap with elements that is bigger then it, until it's bigger then the
//   previous element.
template <typename T> void insertion_sort(vector<T> &nums, int n) {
  for (int i = 0; i < n; ++i) {
    for (int j = i; j > 0 && nums[j] < nums[j - 1]; --j) {
      swap(nums[j], nums[j - 1]);
    }
  }
}
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
#include <iostream>
#include <vector>

using namespace std;
// https://leetcode.com/problems/linked-list-cycle-ii/

#include <iostream>

using namespace std;

/**
 * Definition for singly-linked list.
 */
struct ListNode {
  int val;
  ListNode *next;
  ListNode(int x) : val(x), next(NULL) {}
};

// floyd tortoise and hare cycle detection algorithm
// advance pointer with different speed check if they meet.
//
// 1. use a fast pointer that skip 2 nodes per step, and a slow pointer that
//    skip one element per step.
// 2. if fast reach the end, there is no loop.
// 3. if fast and slow pointers meet, there is a loop
// 4. the distance from where fast and slow pointer meet to the start of the
//    loop is the distance from the starting point to the start of the loop.
//    [lemma] leave slow pointer where it is, put fast pointer  at the
//            beginning of the list, advance both pointers one step at a time
//            eventually they meet at the start of the loop.

class Solution {
public:
  ListNode *detectCycle(ListNode *head) {
    ListNode *slow = head;
    ListNode *fast = head;

    // detect loop
    do {
      if (!fast || !fast->next)
        return nullptr;
      fast = fast->next->next;
      slow = slow->next;
    } while (fast != slow);

    // find the cycle.

    fast = head;
    while (fast != slow) {
      fast = fast->next;
      slow = slow->next;
    }

    return fast;
  }
};

int main(void) {
  Solution solution;

  return 0;
}
// https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/

#include <iostream>
#include <iterator>
#include <vector>

// two pointesr problem
// It's ascking for a sum of two number l, r, we can move two pointers from
// two end of the array and check the sum until they overlap.
// Because the array is sorted, n[l] < n[r]. Thus if n[l] + n[r] < target,
// we need a slightly bigger number, thus l++.
// Conversely if sum > target, we need to remove the bigger numer thus r--;
//
// Claim: the targe sum must be one of combination of l, r

using namespace std;

class Solution {
public:
  vector<int> twoSum(vector<int> &numbers, int target) {

    int l = 0;
    int r = numbers.size() - 1;

    while (l < r) {
      int sum = numbers[l] + numbers[r];
      if (sum == target)
        break;
      if (sum < target)
        ++l;
      else
        --r;
    }

    return {l + 1, r + 1};
  }
};

int main(void) {

  Solution solution;

  {
    vector<int> v{2, 7, 11, 15};
    auto res = solution.twoSum(v, 9);

    for (auto &n : res) {
      std::cout << n << " " << std::endl;
    }
  }

  {
    vector<int> v{2, 3, 4};
    auto res = solution.twoSum(v, 6);

    for (auto &n : res) {
      std::cout << n << " " << std::endl;
    }
  }

  {
    vector<int> v{-1, 0};
    auto res = solution.twoSum(v, -1);

    for (auto &n : res) {
      std::cout << n << " " << std::endl;
    }
  }
  return 0;
}
// https://leetcode.com/jummy233/

#include <iostream>
#include <string>
#include <vector>

using namespace std;

// Input: s = "ADOBECODEBANC", t = "ABC"
// Output: "BANC"

// Problem:
//   two string S, T find the length of the shortest substring of S
//   that contains all characters in T.
//
// sliding window for range search

class Solution {
public:
  string minWindow(string s, string t) {
    vector<bool> flag(128, false);
    vector<int> chars(128, 0);

    int min_l = 0, min_r = s.size() + 1;

    // load info from the search string
    for (int i = 0; i < t.size(); ++i) {
      ++chars[t[i]];
      flag[t[i]] = true;
    }

    // scan the string
    for (int count = 0, l = 0, r = 0; r < s.size(); ++r) {

      if (flag[s[r]]) {
        if (--chars[s[r]] >= 0)
          ++count;
      }

      while (count == t.size()) {
        if (r - l + 1 < min_r) {
          min_l = l;
          min_r = r - l + 1;
        }
        if (flag[s[l]] && ++chars[s[l]] > 0)
          --count;
        ++l;
      }
    }
    return min_r > s.size() ? "" : s.substr(min_l, min_r);
  }
};

int main(void) {

  Solution solution;

  {
    string s{"ADDBEC0DEBANC"};
    string t{"ABC"};

    string res = solution.minWindow(s, t);
    std::cout << res << std::endl;
  }
  return 0;
}
// https://leetcode.com/problems/merge-sorted-array/

#include <iostream>
#include <vector>

using namespace std;

// Steps:
//  get
//    1. the pointer points the end of the first array;
//    2. two pointers points to the end of valid arrays, m-1, n-1
//  comparing n1[m-1] with n2[n-1], put the bigger one to the end of the pos,
//  decrement pos.
//  decrement m and n;
//
// Claim:
//   [1] at beginning:
//     1. bigger element at the end of n1 and n2 is the biggest element of
//        all elements.
//     2. n1[pos] is the biggest elment
//
//   [2] at each time we choose an element to put at the end:
//      1. we decrement the pointer to the larger element, and update it
//         to the previous element,
//            as argmaxmax(n1[m-1], n2)[n-1]) - 1
//          The problem remained is still the same problem.
//
//   [3] at the end
//      The algorihtm stops when both m and n points to 0.
//      invariant in [3] holds inductively, so at the end elements in n1 is
//      in increasing order.

class Solution {
public:
  void merge(vector<int> &nums1, int m, vector<int> &nums2, int n) {
    int pos = m + n - 1;
    m--;
    n--;
    while (m >= 0 && n >= 0) {
      nums1[pos--] = nums1[m] > nums2[n] ? nums1[m--] : nums2[n--];
    }
    while (n >= 0) {
      nums1[pos--] = nums2[n--];
    }
  }
};

int main(void) {
  Solution solution;

  {
    vector<int> v1{1, 2, 3, 0, 0, 0};
    vector<int> v2{2, 5, 6};
    solution.merge(v1, 3, v2, 3);
    for (auto &n : v1) {
      std::cout << n << " ";
    }
    std::cout << std::endl;
  }

  {
    vector<int> v1{1};
    vector<int> v2{};
    solution.merge(v1, 1, v2, 0);
    for (auto &n : v1) {
      std::cout << n << " ";
    }
    std::cout << std::endl;
  }

  {
    vector<int> v1{0};
    vector<int> v2{1};
    solution.merge(v1, 0, v2, 1);
    for (auto &n : v1) {
      std::cout << n << " ";
    }
    std::cout << std::endl;
  }
  return 0;
}
#include <cstring>
#include <algorithm>
#include <iostream>

// given an array of non duplicate integers, find the number of pairs
// that sum up to 0.

// it's an example of not obvious enumeration.
int num_sum_to_0(int *a, size_t n, int max) {
  int res = 0;
  bool met[max * 2];
  std::memset(met, 0, sizeof(met));

  for (int i = 0; i < n; ++i) {
    if (met[max - a[i]])
      res++;
    met[max + a[i]] = 1;
  }
  return res;
}

#define SIZE(xs) (sizeof(xs) / sizeof(xs[0]))

int main(void) {

  int a1[] = {1, 2, 5, -2, 3, -3, 9, 2};
  int a2[] = {-1, 2, -392, -2, 392, -4, 87, 1, 123, 3};

  int v1 = num_sum_to_0(a1, SIZE(a1), *std::max_element(a1, a1 + SIZE(a1)));
  std::cout << v1 << std::endl;

  int v2 = num_sum_to_0(a2, SIZE(a2), *std::max_element(a2, a2 + SIZE(a2)));
  std::cout << v2 << std::endl;

  return 0;
}
#include <iostream>
#include <iostream>

// commonly used in bfs and dfs.
module BfsDfsFGPuzzle where

-- https://www.nmattia.com/posts/2016-07-31-bfs-tree.html
-- Puzzle:
--  given number x0 and target xf, and two functions
--   f(x) = 2x + 1,
--   g(x) = 3x + 1
--  Give minimal number of applications of f and g that you need in order
--  to reach xf from x0, or state that one cannot reach from xf from x0
--  e.g
--    1. for xf = 4, x0 = 1
--       xf = 4 = 3 . 1 + 1 = g(1) = g(x0)
--    2. xf = 10, x0 = 1
--       xf = 10 = 3.3 + 1 = g(3) = g(2.1+1) = g.f(1) = g.f(x0)
--    3. it's impossible to reach xf= 8 from x0 = 1
-- How to solve?
--   You have two options each time, so essentailly you want to encode the solution
--   in a binary tree and bfs over it.


f x = 2 * x + 1
g x = 3 * x + 1

-- keep l and r lazy so we can have infinite trees. only l and r matters because
-- they are recursively defined

data Tree = T { depth :: !Integer
              , value :: !Integer
              , l     :: Tree
              , r     :: Tree       -- to have infinite trees.
              }
              deriving Show


-- generate a tree to play with

mkTree :: Integer -> Tree
mkTree = go 0
  where
    go d v = T { depth = d
               , value = v
               , l = go (d + 1) (f v)
               , r = go (d + 1) (g v)
               }


-- side note, a complete binary tree.

completeBinaryTree :: Tree
completeBinaryTree = go 0 1
  where
    go d v = T { depth = d
               , value = v
               , l = go (d + 1) (2 * v)
               , r = go (d + 1) (2 * v + 1)
               }


-- O(1) enqueue and dequeue.
-- The natural next step might be breaking out a state monad
-- and writer monad, but not necessary here.

data Queue a = Queue { front :: [a]
                     , back  :: [a]
                     }



-- tile the nodes
-- use lazyness to get priority queue ...

bfs :: Tree -> [Tree]
bfs root =
  let
    nodes = root : children
    children = concatMap (\t -> [l t, r t]) nodes
   in nodes


distance :: Integer -> Integer -> Maybe Integer
distance x0 xf = go nodes
  where
    nodes = bfs $ mkTree x0
    go (t:ts)
      | value t == xf = Just $ depth t
      | value t > 4 * xf = Nothing
      | otherwise = go ts
# using bfs on unweighted graph to simulate weighted graph and
# to find the shortest path.


import collections as c
import typing as t
import uuid


class Node:
    def __init__(self, name="dummy"):
        self.pred: t.Optional['Node'] = None
        self.name: str = name
        self.is_airport: bool = False

        if name == "dummy":
            # dummies have unique nodes
            self.name = self.name + " " + str(uuid.uuid4())

    def add_pred(self, node: 'Node'):
        """
        add node as the predecessor
        """
        self.pred = node

    def traceback(self, goal: 'Node' = None) -> t.List['Node']:
        path = [self]
        pred = self.pred

        def stopping(v):
            if goal is not None and pred is None:
                raise RuntimeError(
                    f"node {self} has no predecessor " +
                    " and is not the starting node")

            return v is None if goal is None else v == goal

        while not stopping(pred):
            path.append(pred)
            pred = pred.pred
        path.append(goal)
        return path

    def __hash__(self):
        """
        Node will be unique by their name on a set
        """
        return hash(self.name)

    def __str__(self):
        return f"<Node {self.name}>"

    def __eq__(self, other):
        """
        Although if two nodes have the same name we consider them
        equal, only the one in the graph matters.
        """
        return self.name == other.name

    __repr__ = __str__


class Graph(c.UserDict):
    def __init__(self, nodes: t.List):
        super().__init__()

        for n in nodes:
            self.__setitem__(Node(n), set())

    def add_edge(self, node1: Node, node2: Node, weight=0):
        """
        Never add nodes here. Nodes need to exists before adding edges.
        """

        # node1_adjacents: t.Set = self.get(node1)
        node1_adjacents: t.Set = self[node1]
        if node1_adjacents is None:
            raise KeyError(f"node not in graph. Node: {node1}")
        if node2 not in self:
            raise KeyError(f"node not in graph. Node: {node2}")
        if weight == 0:
            if node2 not in node1_adjacents:
                node1_adjacents.add(node2)
        else:
            dummy = node1
            while weight != 0:
                dummy = self.add_dummy(dummy)
                weight -= 1
            assert weight == 0
            self.add_edge(dummy, node2)

    def add_dummy(self, node: Node) -> Node:
        """
        Add dummy nodes to simulate the distance.
        """
        dummy = Node()
        self[dummy] = set()
        self.add_edge(node, dummy)
        return dummy


def bfs(g: Graph, s: Node, e: Node):
    queue = [s]
    visited = [s]

    while queue != []:
        v = queue.pop(0)
        for u in g[v]:
            if u not in visited:
                u.pred = v
                visited.append(u)
                queue.append(u)
            if u == e:
                return u.traceback(s)
    return []


if __name__ == "__main__":
    g = Graph([1, 2, 3, 4])

    g.add_edge(Node(1), Node(3), weight=10)
    g.add_edge(Node(2), Node(3), weight=3)
    g.add_edge(Node(3), Node(4), weight=3)
    g.add_edge(Node(1), Node(4), weight=30)

    print("graph: ")
    __import__('pprint').pprint(g)

    visited = bfs(g, Node(1), Node(4))
    print("shortest path: ")
    __import__('pprint').pprint(visited)
// src:
//    MIT algorithm book chapter 22

// A different way of thinking about breath first search.
// 1. white: default for all nodes at the beginning
// 2. black: nodes that are not connected with white
// 3. gray: the remainnig (connected both black and white)
//
// It's not necessary to acutally color the node though.
//
// Practice the standard solution.
// The speed and familarity is very important for these basic algorithms.

#include <algorithm>
#include <deque>
#include <iostream>
#include <vector>

using graph_t = std::vector<std::vector<int>>;

std::string graph_str = R"( graph
                             0 - 1 - 3
                             | / |
                             2 - 5 - 7 - 8 - 9
                             |   |   |
                             4   6 - 10 - 11 - 12 - 13 - 14 - 15 )";

graph_t graph = {
    {1},        {0, 2, 3},  {1, 3, 4, 5},      // 0 - 2
    {1, 2, 5},  {2},        {2, 3, 6, 7},      // 3 - 5
    {5, 10},    {5, 8, 10}, {7, 9},       {8}, // 6 - 9
    {6, 7, 11}, {10, 12},   {11, 13},          // 10 - 12
    {12, 14},   {13, 15},   {14}               // 13 - 15
};

std::string tree_str = R"(  tree
                                     0
                                   /   \
                                  1     2
                                 / \   / \
                                3   4 5   6
                               / \
                              7   8
                             /
                            9                 )";

graph_t tree = {{1, 2}, {0, 3, 4}, {0, 5, 6}, {1, 7, 8}, {1},
                {2},    {2},       {3, 9},    {3},       {7}};

std::vector<int> bfs(graph_t graph, int root) {
  std::deque<int> queue;
  std::vector<int> visited;
  queue.push_back(root);
  visited.push_back(root);

  while (queue.size() != 0) {
    int v = queue.front();
    queue.pop_front();
    for (auto &u : graph[v]) {
      auto it = std::find(visited.begin(), visited.end(), u);
      if (it == visited.end()) {
        visited.push_back(u);
        queue.push_back(u);
      }
    }
  }

  return visited;
}

std::vector<int> dfs(graph_t graph, int root) {
  std::vector<int> stack;
  std::vector<int> visited;

  stack.push_back(root);
  visited.push_back(root);

  while (stack.size() != 0) {
    int v = stack.back();
    stack.pop_back();
    for (auto &u : graph[v]) {
      auto it = std::find(visited.begin(), visited.end(), u);
      if (it == visited.end()) {
        stack.push_back(u);
        visited.push_back(u);
      }
    }
  }

  return visited;
}

void print_vec(const std::vector<int> &vec) {
  for (auto n : vec) {
    std::cout << n << ", ";
  }
  std::cout << "\n";
}

int main(void) {
  std::vector<int> res;
  std::cout << graph_str << std::endl;
  std::cout << "bfs with queue, start from 5" << std::endl;
  res = bfs(graph, 5);
  print_vec(res);
  std::cout << "dfs with stack, start from 5" << std::endl;
  res = dfs(graph, 5);
  print_vec(res);

  std::cout << "===================================" << std::endl;

  std::cout << tree_str << std::endl;
  std::cout << "bfs with queue, start from 0" << std::endl;
  res = bfs(tree, 0);
  print_vec(res);
  std::cout << "dfs with stack, start from 0" << std::endl;
  res = dfs(tree, 0);
  print_vec(res);

  return 0;
}
// src:
//    MIT algorithm book chapter 22

// A different way of thinking about breath first search.
// 1. white: default for all nodes at the beginning
// 2. black: nodes that are not connected with white
// 3. gray: the remainnig (connected both black and white)
//
// It's not necessary to acutally color the node though.
//
// Practice the standard solution.
// The speed and familarity is very important for these basic algorithms.

#include <algorithm>
#include <deque>
#include <iostream>
#include <vector>

using graph_t = std::vector<std::vector<int>>;

std::string graph_str = R"( graph
                             0 - 1 - 3
                             | / |
                             2 - 5 - 7 - 8 - 9
                             |   |   |
                             4   6 - 10 - 11 - 12 - 13 - 14 - 15 )";

graph_t graph = {
    {1},        {0, 2, 3},  {1, 3, 4, 5},      // 0 - 2
    {1, 2, 5},  {2},        {2, 3, 6, 7},      // 3 - 5
    {5, 10},    {5, 8, 10}, {7, 9},       {8}, // 6 - 9
    {6, 7, 11}, {10, 12},   {11, 13},          // 10 - 12
    {12, 14},   {13, 15},   {14}               // 13 - 15
};

std::string tree_str = R"(  tree
                                     0
                                   /   \
                                  1     2
                                 / \   / \
                                3   4 5   6
                               / \
                              7   8
                             /
                            9                 )";

graph_t tree = {{1, 2}, {0, 3, 4}, {0, 5, 6}, {1, 7, 8}, {1},
                {2},    {2},       {3, 9},    {3},       {7}};

std::vector<int> bfs(graph_t graph, int root) {
  std::deque<int> queue;
  std::vector<int> visited;
  queue.push_back(root);
  visited.push_back(root);

  while (queue.size() != 0) {
    int v = queue.front();
    queue.pop_front();
    for (auto &u : graph[v]) {
      auto it = std::find(visited.begin(), visited.end(), u);
      if (it == visited.end()) {
        visited.push_back(u);
        queue.push_back(u);
      }
    }
  }

  return visited;
}

std::vector<int> dfs(graph_t graph, int root) {
  std::vector<int> stack;
  std::vector<int> visited;

  stack.push_back(root);
  visited.push_back(root);

  while (stack.size() != 0) {
    int v = stack.back();
    stack.pop_back();
    for (auto &u : graph[v]) {
      auto it = std::find(visited.begin(), visited.end(), u);
      if (it == visited.end()) {
        stack.push_back(u);
        visited.push_back(u);
      }
    }
  }

  return visited;
}

void print_vec(const std::vector<int> &vec) {
  for (auto n : vec) {
    std::cout << n << ", ";
  }
  std::cout << "\n";
}

int main(void) {
  std::vector<int> res;
  std::cout << graph_str << std::endl;
  std::cout << "bfs with queue, start from 5" << std::endl;
  res = bfs(graph, 5);
  print_vec(res);
  std::cout << "dfs with stack, start from 5" << std::endl;
  res = dfs(graph, 5);
  print_vec(res);

  std::cout << "===================================" << std::endl;

  std::cout << tree_str << std::endl;
  std::cout << "bfs with queue, start from 0" << std::endl;
  res = bfs(tree, 0);
  print_vec(res);
  std::cout << "dfs with stack, start from 0" << std::endl;
  res = dfs(tree, 0);
  print_vec(res);

  return 0;
}
;; yet another version in common lisp

(defparameter *graph-str*
  "
  0 - 1 - 3
  | / |
  2 - 5 - 7 - 8 - 9
  |   |   |
  4   6 - 10 - 11 - 12 - 13 - 14 - 15
  ")

(defparameter *graph*
  '((1) (0 2 3) (1 3 4 5)  ;; 0 - 2
        (1 2 5) (2) (2 3 6 7)  ;; 3 - 5
        (5 10) (5 8 10) (7 9) (8)  ;; 6 - 9
        (6 7 11) (10 12) (11 13)  ;; 10 - 12
        (12 14) (13 15) (14)         ;; 13 - 15
        ))

;; dfs: find a topological order of the graph.
(defun dfs (graph root)
  (let* ((visited `(,root))
         (stack `(,root)))
    (loop while stack do
          (let ((v (pop stack)))
            (loop for u in (elt graph v) do
                  (if (not (member u visited))
                      (progn
                        (setf visited (append visited `(,u)))
                        (push u stack))))))
    visited))

;; to mutate outside world you need to use macro.
(defmacro dequeue (queue)
  "common lisp can't mutate parameter, so this sort of mutation operations
   are normally made as macro"
  (let ((v (gensym)))
    `(let ((,v (car (last ,queue))))
       (setf ,queue (butlast ,queue))
       ,v)))

(defmacro enqueue (queue x)
  `(setf ,queue (cons ,x ,queue)))

;; bfs: find all nodes reachable from the starting point.
(defun bfs (graph root)
  (let* ((visited `(,root))
         (queue `(,root)))
    (loop while queue do
          (let ((v (dequeue queue)))
            (loop for u in (elt graph v) do
                  (if (not (member u visited))
                      (progn
                        (setf visited (append visited `(,u)))
                        (enqueue queue u))))))
    visited))


(format t "~%dfs: ~a~%" (dfs *graph* 0))
(format t "~%bfs: ~a~%" (bfs *graph* 0))
module BfsDfs where

import Debug.Trace

type Graph = [[Integer]]

graph :: Graph
graph =
  [ [1],
    [0, 2, 3],
    [1, 3, 4, 5], -- 0 - 2
    [1, 2, 5],
    [2],
    [2, 3, 6, 7], -- 3 - 5
    [5, 10],
    [5, 8, 10],
    [7, 9],
    [8], -- 6 - 9
    [6, 7, 11],
    [10, 12],
    [11, 13], -- 10 - 12
    [12, 14],
    [13, 15],
    [14] -- 13 - 15
  ]



dfs :: Graph -> Integer -> [Integer]
dfs graph root = loop [root] [root]
  where
    loop :: [Integer] -> [Integer] -> [Integer]
    loop visited [] = visited
    loop visited (x:xs) =
      let adjs = graph !! (fromIntegral x)
          unVisisted = (filter (flip notElem visited) adjs)
          visited' = visited <> unVisisted
          stack' = unVisisted <> xs
       in loop visited' stack'

run = dfs graph 5

bfs :: Graph -> Integer -> [Integer]
bfs graph root = loop [root] [root]
  where
    loop :: [Integer] -> [Integer] -> [Integer]
    loop visited [] = visited
    loop visited queue =
      let adjs = graph !! (fromIntegral . last) queue
          unVisited = (filter (flip notElem visited) adjs)
          visited' = visited <> unVisited
          queue' = take (length queue - 1) queue <> unVisited
       in loop visited' queue'

run1 = bfs graph 5
import typing as t
# iterative algorithm for implementing bfs dfs.
# note: if it's a imperative programming language, it's better
#       just to use a stack or queue based implementation.
#       it's simple and robust, hard to make error.

# graph
graph_str = r"""
 0 - 1 - 3
     | / |
     2 - 5 - 7 - 8 - 9
     |   |   |
     4   6 - 10 - 11 - 12 - 13 - 14 - 15
"""

# a hash table with index as the key.
graph = [[1], [0, 2, 3], [1, 3, 4, 5],  # 0 - 2
         [1, 2, 5], [2], [2, 3, 6, 7],  # 3 - 5
         [5, 10], [5, 8, 10], [7, 9], [8],  # 6 - 9
         [6, 7, 11], [10, 12], [11, 13],  # 10 - 12
         [12, 14], [13, 15], [14]          # 13 - 15
         ]

# note this tree doesn't demonstrate the difference between bfs and dfs
# very well.
# the reason is the tree is skewd to the left, for out dfs it will pop the
# right node first, which is the short tree and easily hit the bottom.
tree_str = r"""
  tree
               0
             /   \
            1     2
           / \   / \
          3   4 5   6
         / \
        7   8
       /
      9
     /
    10
"""


tree = [[1, 2], [0, 3, 4], [0, 5, 6], [1, 7, 8],
        [1], [2], [2], [3, 9], [3], [7, 10],
        [9]
        ]

# for this tree dfs wil go all the way to the right subtree first
tree_str1 = r"""
  tree
               0
             /   \
            1     2
           / \   / \
          3   4 5   6
         / \         \
        7   8         11
       /               \
      9                 12
     /                   \
    10                    13
"""
tree1 = [[1, 2], [0, 3, 4], [0, 5, 6], [1, 7, 8],
         [1], [2], [2, 11], [3, 9], [3], [7, 10],
         [9], [6, 12], [11, 13], [12]
         ]


# create a traversal of the graph.
def dfs(graph, root) -> t.List[int]:
    visited = []
    stack = []
    visited.append(root)
    stack.append(root)
    while stack != []:
        v = stack.pop()
        for u in graph[v]:
            if u not in visited:
                visited.append(u)
                stack.append(u)
    return visited


def bfs(graph, root) -> t.List[int]:
    visited = []
    queue = []
    visited.append(root)
    queue.append(root)
    while queue != []:
        v = queue.pop(0)
        for u in graph[v]:
            if u not in visited:
                visited.append(u)
                queue.append(u)
    return visited


def main():
    print("graph test")
    print(graph_str)
    print("breath fisrt search (queue implemented), from 5")
    print(bfs(graph, 5))
    print("depth fisrt search (stack implemented), from 5")
    print(dfs(graph, 5))

    print("\n" + "=" * 30 + "\n")

    print("tree test")
    print(tree_str)
    print("breath fisrt search (queue implemented), from 0")
    print(bfs(tree, 0))
    print("depth fisrt search (stack implemented), from 0")
    print(dfs(tree, 0))

    print("\n" + "=" * 30 + "\n")

    print("deep tree test")
    print(tree_str1)
    print("breath fisrt search (queue implemented), from 0")
    print(bfs(tree1, 0))
    print("depth fisrt search (stack implemented), from 0")
    print(dfs(tree1, 0))


if __name__ == "__main__":
    main()

# result
r"""
graph test

 0 - 1 - 3
     | / |
     2 - 5 - 7 - 8 - 9
     |   |   |
     4   6 - 10 - 11 - 12 - 13 - 14 - 15

breath fisrt search (queue implemented), from 5
[5, 2, 3, 6, 7, 1, 4, 10, 8, 0, 11, 9, 12, 13, 14, 15]
depth fisrt search (stack implemented), from 5
[5, 2, 3, 6, 7, 8, 10, 11, 12, 13, 14, 15, 9, 1, 0, 4]

==============================

tree test

  tree
               0
             /   \
            1     2
           / \   / \
          3   4 5   6
         / \
        7   8
       /
      9
     /
    10

breath fisrt search (queue implemented), from 0
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
depth fisrt search (stack implemented), from 0
[0, 1, 2, 5, 6, 3, 4, 7, 8, 9, 10]

==============================

deep tree test

  tree
               0
             /   \
            1     2
           / \   / \
          3   4 5   6
         / \         \
        7   8         11
       /               \
      9                 12
     /                   \
    10                    13

breath fisrt search (queue implemented), from 0
[0, 1, 2, 3, 4, 5, 6, 7, 8, 11, 9, 12, 10, 13]
depth fisrt search (stack implemented), from 0
[0, 1, 2, 5, 6, 11, 12, 13, 3, 4, 7, 8, 9, 10]
"""
(defpackage :graph-coloring
  :use :cl)
(defpackage :sudoku
  :use :cl)

;;; sovling sudoku with graph coloring

(defun sudoku ())

(defpackage #:tank-problem
  (:use "COMMON-LISP"))

(in-package #:tank-problem)
;u some fishies
;; Some pair of fish fight if they are in the same tank.
;; put fish in two tanks so they don't fight.

;; use bfs for testing if a graph is bipartite.
;; coloring the graph layer by layer

;; why does this work?
;; if you can color each layers with different color, the graph
;; looks like a tree, you can move odd index layer to one side, even index
;; layers to another.

;; if you have an edge from an odd index and connecet to another odd index,
;; you have a cycle. What should you color the target node, odd color or
;; even color?

(defmacro init-hash-table (xs)
  `(let ((m (make-hash-table)))
     (loop for kv in ,xs do
           (setf (gethash (car kv) m) (cdr kv)))
     m))

(defmacro enqueue (x xs) `(push ,x ,xs))

(defmacro dequeue (xs)
  (let ((v (gensym)))
    `(let ((,v (car (last ,xs))))
       (setf ,xs (butlast ,xs))
       ,v)))

(defparameter *fish-fight-graph*
  (init-hash-table
    '((a . (b c))
      (b . (a d))
      (c . (a d))
      (d . (b c e f))
      (e . (d g h))
      (f . (d g h))
      (g . (f e))
      (h . (f e)))))

(defparameter *bird-graph*
  (init-hash-table
    '((a . (b c))
      (b . (a f g))
      (c . (a d))
      (d . (e))
      (e . (d f g))
      (g . (b e))
      (f . (b e)))))

;; output
;; (C . 1) (A . 0) (D . 0) (F . 0) (G . 0) (B . 1) (E . 1)

(defparameter *fish-fight-counter-example-graph*
  (init-hash-table
    '((a . (b c))
      (b . (a d c))
      (c . (a d b))
      (d . (b c e f))
      (e . (d g h))
      (f . (d g h))
      (g . (f e))
      (h . (f e)))))

;; output nil

(defun bipartite-* (graph root)
  "if the graph is biartite, return the coloring"
  (let* ((queue `(,root))
         (visited `(,root))
         (color-table
           (let ((keys (remove-duplicates
                         (append
                           (loop for k being the hash-keys in graph)
                           (apply #'append
                                  (loop for v being the hash-values in graph
                                        collect v)) ))))
             (mapcar (lambda (n) (cons n -1)) keys)))
         (color 0))
    (labels ((set-color (node color) (setf (cdr (assoc node color-table)) color))
             (next-color (n) (mod (+ n 1) 2)))
      (set-color root color)
      (block done (loop while queue do
               (let ((v (dequeue queue)))
                 ;; u's color should be the reverse of v's color.
                 (setf color (next-color (cdr (assoc v color-table))))
                 (loop for u in (gethash v graph) do
                       (if (not (member u visited))
                         (progn
                           (push u visited)
                           (enqueue u queue)
                           (set-color u color))
                         (when (not (equal (cdr (assoc u color-table)) color))
                           (return-from done nil))))))
             color-table))))

(defun bipartite (graph)
  "find a node with no in degree as the starting node"
  (bipartite-* graph (car (loop for k being the hash-keys in graph collect k))))
#include <iostream>

// Knuth
#include <algorithm>
#include <deque>
#include <iostream>
#include <memory>
#include <unordered_map>
#include <vector>

// How to represent graph.
// 1. adjacent matrix
//    pros:     easy to write, quick query
//    cons:     super bad space complexity O(mn)
//              not extensible.
// 2. adjacent table (hard to write)
// 3. linked front star (...invented by some acmer, I can't find any offical
// name)

// different types of graphs
// 0. GRAPH
//    a graph is denoted as G(V, E)
//    where V = {vetexes}
//          E = {edges}

// 1. DIRECTED / UNDIRECTED GRAPH, SIMPLE ? MULTI GRAPH
//
//   A-----B---------E
//   \     |\       /|
//    \    | \     / |
//     \   |  \   /  |
//      \  |   \ /   |
//        C.    D----F
//        this is a simple graph,
//        no self looping, no vertex has multiple edges.
//
//    +----+      +--+
//    A    B --- C  |
//    +----+      +--+  and this is a multigraph.

// -- a little exercise:
// Imagine a padlock start with 00. You can move 1 up to make 0
// a 1, 1 down to make 0 a 9.
// There are dead combinations that if padlock is in those state
// it is permanently locked. Find the minimum # of moves to reach
// a target combination without trigger dead combination
// :dead combination: [10, 90, 12], target 11
//
// solution:
//   1. first encode the initial state as a graph.
//      start from 00, there are 4 possible next states.
//        10
//         |
//    09--00--01
//         |
//        90
//
//   2.
//        10  11*
//         |  |
//    09--00--01--02
//         |  |
//        90  91

struct PadLockNode {
  unsigned d0 = 0;
  unsigned d1 = 0;
  unsigned steps = 0;
  static std::vector<std::pair<int, int>> dead_combinations;

  PadLockNode(unsigned d0, unsigned d1, int steps)
      : d0(d0), d1(d1), steps(steps + 1) {}
  PadLockNode() : d0(0), d1(0), steps(0) {}

  bool discovered_ = false;

  void set_dead_combination(const std::vector<std::pair<int, int>> combs) {
    // when there is dead combination just trim it.
    dead_combinations = combs;
  }

  bool is_allowed(std::pair<int, int> p) {
    auto pred = [&](auto dp) {
      return p.first == dp.first && p.second == dp.second;
    };
    auto first = dead_combinations.begin(), last = dead_combinations.end();
    auto e = std::find_if(first, last, pred);
    return e == dead_combinations.end();
  }

  auto adjacents() -> std::vector<PadLockNode> {
    std::vector<PadLockNode> buffer{};
    std::pair<int, int> pairs[4]{{(d0 + 1) % 10, d1},
                                 {(d0 - 1) % 10, d1},
                                 {d0, (d1 + 1) % 10},
                                 {d0, (d1 - 1) % 10}};
    for (auto p : pairs) {
      if (is_allowed(p)) {
        buffer.push_back(PadLockNode(p.first, p.second, steps));
      }
    }
    return buffer;
  }
};

std::vector<std::pair<int, int>> PadLockNode::dead_combinations{};

// do a breath first search
int find_parlock_target_bfs(PadLockNode root, int td0, int td1) {
  std::deque<PadLockNode> q;
  root.discovered_ = true;

  q.push_back(root);
  while (q.size() > 0) {

    auto v = q.front();
    q.pop_front();

    if (v.d0 == td0 && v.d1 == td1) {
      return v.steps;
    }

    for (auto w : v.adjacents()) {
      if (!w.discovered_) {
        w.discovered_ = true;
        q.push_back(w);
      }
    }
  }
  return -1;
}

void test_find_parlock_target() {
  std::cout << "---------------------" << std::endl;
  auto root = PadLockNode();
  root.set_dead_combination({{1, 0}, {9, 0}, {1, 2}});

  auto answer = find_parlock_target_bfs(root, 1, 1);
  std::cout << "minial steps: " << answer << std::endl;

  root = PadLockNode();
  root.set_dead_combination({{1, 0}, {0, 1}, {1, 2}});

  answer = find_parlock_target_bfs(root, 1, 1);
  std::cout << "minial steps: " << answer << std::endl;
}

// 2. REPRESENTATION OF GRAPH
//   1. nodes
//      Graph is a more generalized linked list, so just
//      create linked list nodes with some variations.
//      (next points to a list of nodes etc.)
//
//   2. adjacent lists, a list holds all vetexes, another holds
//      all edges.
//
//         C..
//         |  \..
//         |     \
//         A ---- B
//         |
//         |
//         D
//
//      V = [A, B, C, D]
//      E = [AB, AC, AD, CB]
//
//      This approach is more compact, but harder to traverse.
//      These is probably the closest implementation to the
//      G(V, E) definition.
//
//   3. dictionary

static std::unordered_map<char, std::vector<char>> dict_graph{
    {'A', {'B', 'C', 'D'}},
    {'B', {'A', 'C'}},
    {'C', {'A', 'B'}},
    {'D', {'A'}} // undirected graph with dictionary.
};

//   4. adjacency matrix
//      1. undirected unweighted.
//
//         C..
//         |  \..
//         |     \
//         A ---- B
//         |
//         |
//         D
//
//           A B C D
//         A 0 1 1 1
//         B 1 0 1 0
//         C 1 1 0 0
//         D 1 0 0 0
// ----------------------------------
//      2. directed unweighted
//
//         C<.
//         |  \..
//         V     \
//         A <--> B
//         |
//         V
//         D
//
//           A B C D
//         A 0 1 1 1
//         B 1 0 1 0
//         C 0 0 0 0
//         D 0 0 0 0
// ----------------------------------
//      3. undirected weighted
//
//         C.. 7
//       2 |  \..
//         |     \
//         A ---- B
//         |  1
//       9 |
//         D
//
//           A B C D
//         A _ 1 2 9
//         B 1 _ 7 _
//         C 2 7 _ _
//         D 9 _ _ _      :_ is inf
// ----------------------------------
//       4.  directed weighted
//
//         C<. 7
//       2 |  \..
//         V     \
//         A <--> B
//         |  1
//       9 V
//         D
//
//           A B C D
//         A 0 1 2 9
//         B 1 0 2 0
//         C 0 0 0 0
//         D 0 0 0 0
//
// THis is a undirected graph representation with
// adjecent matrix.
enum AdjNode { A = 0, B = 1, C, D };
static std::array<std::array<int, 4>, 4> adjmatrix{{
    {0, 1, 1, 1},
    {1, 0, 1, 0},
    {1, 1, 0, 0},
    {1, 0, 0, 0},
}};

char adjnode_char(AdjNode a) {
  switch (a) {
  case A:
    return 'A';
  case B:
    return 'B';
  case C:
    return 'C';
  case D:
    return 'D';
  }
}

// show if a is connected with b.
void adj_connected(AdjNode a) {
  std::cout << adjnode_char(a) << " -> { ";

  for (int i = A; i <= D; ++i) {
    if (adjmatrix[a][i] == 1) {
      std::cout << adjnode_char(static_cast<AdjNode>(i)) << ",";
    }
  }
  std::cout << " }"
            << "\n";
}

void test_adj_connected() {
  std::cout << "---------------------" << std::endl;
  adj_connected(A);
  adj_connected(B);
  adj_connected(C);
  adj_connected(D);
}

// 3. LOOPS IN GRAPH
//    1. cyclic graph
//      B -> E -> F -> G -> B
//      A -> B -> C -> D -> A
//      E -> F -> G -> E
//      B -> E -> G -> B
//      are cyclic
//      cyclic graph can implies the traversing
//      never end. That's why we normally neeed to
//      mark a node as visited to avoid doint
//      repeative work.
//
//      A --- B---E
//      |     |\  |\
//      |     | \ | \
//      D --- C  .G--F
//
//    2. acyclc graph
//      on the other hand, some graph don't have any
//      cycle at all, thus traverse will always terminate.
//      list and binary tree are two examples.
//
//      A -- B -- E -- F -- G
//           |
//           C -- D
//
//    3. walk, trail, path, cycle and circuit.
//      These are different names refer to different path
//      in a graph one can take.
//
//      Two predicates are important here.
//      e := edge can be repeated
//      v := vertex can be repeated
//
//      Given this graph:
//
//      A --- B---E
//      |     |\  |\
//      |     | \ | \
//      D --- C  .G--F
//
struct Walk {
  //      walk: e && v
  //        A -> B -> C -> B -> E
  bool need_closed = false;
  bool edge_can_repeat = true;
  bool vertex_can_repeat = true;
};

struct Trail {
  //      trail: !e && v
  //        E -> F -> G -> E -> B
  bool need_closed = false;
  bool edge_can_repeat = false;
  bool vertex_can_repeat = true;
};

struct Path {
  //      path: !e && !v
  //        A -> B -> E -> F
  bool need_closed = false;
  bool edge_can_repeat = false;
  bool vertex_can_repeat = false;
};

struct Circuit : public Trail {
  //      circuit: closed && !e && v
  bool need_closed = true;
};

struct Cycle : public Path {
  //      cycle: closed && !e && !v
  bool need_closed = true;
};

// 4. Some lemmas
//    1. Degree
//      degree of a vertex is the # of edges it's adjacent to.
//      denoted as deg(v)
//      a vertex of a directed graph has in degree deg-(v)
//      and out degree deg+(v)
//
//    note now you have three objects on the table.
//      Vertexes, Edges, and Degrees.
//
struct Node_D { // a node of directed graph.
  std::vector<Node_D *> adjacents_to;
  std::vector<Node_D *> adjacents_from;
  int deg_in() { return adjacents_from.size(); }
  int deg_out() { return adjacents_to.size(); }
  int deg() { return deg_in() + deg_out(); }
};

//    2. handshaking theorem
//        Edges and degrees are closely related by this lemma:
//        For undirected graph, each edge contribute to degree twice,
//
//            A == B
//
//          For a undirected graph,
//            Sum(deg(v)) =  2 |E|
//            v in V
//          This implies:
//            1. sum of degree is always even
//            2. known num of edges we know the sum of degrees.
struct Graph_D {
  std::vector<Node_D *> nodes;
  int sum_of_deg() { return nodes.size(); }
};

struct Node_N {
  std::vector<Node_N *> adjacents;
  int deg() { return adjacents.size(); }
};

struct Graph_N {
  std::vector<Node_N *> nodes;
  int sum_of_deg() { return nodes.size() * 2; }
};

//      3. lemma of handshaking theorem:
//        An undirected graph has even # of vertices of odd degrees.
//        Proof:
//          Let V1, V2 be the sets of vertices with even and odd degrees
//          respectively. we know Veven, Vodd can't overlap.
//          V = V1 union V2,
//
//          By handshaking  theorem,
//
//               Sum(deg(V)) = 2|E|
//           =>  2|E| = Sum(deg(Veven)) + Sum(deg(Vodd))
//
//           Sum(deg(V1)) must be even,
//             [proof:
//              let v1 in Veven, we know deg(v1) = 2k for k in Z.
//              => Sum(deg(Veven)) = Sum(2 . h) = 2 Sum(h) for h in Z.
//              done.
//             ]
//
//           So 2 | Sum(deg(Vodd))
//           let v2 in Vodd, deg(v2) is odd.
//           Sum(deg(v2)) = Sum(2k + 1) = Sum(2k) + Sum(1)
//           => 2 | Sum(1)
//           => There are even number of vertices with odd degree.

//      4. Complete graph
//        A complete graph is a simple graph that each vertex connected
//        with all other vertexes.
//
//            x ---- x
//
//            x ----- x
//             \     /
//              \   /
//               \ /
//                x
//
//        |E| = n(n+1) / 2
//

//     5. Hyper cube
//        n-dimensional analogus of a square
//
//
//           x------x          x----x
//          /|     /|          |    |
//         x-+----x |          |    |
//         | |    | |          x----x Q2
//         | x----+-x
//         |/     |/
//         x------x   Q3
//            | projects to 2d
//            V  (they bascially looks the same...)
//           x-----x
//          / \   / \
//         /   \ /   \
//        x-----x-----x
//         \   / \   /
//          \ /   \ /
//           x-----x
//
//       denoted as Qn
//
//       2^n vertices, each represent a n bit string.
//
//       |E| = 2^n
//
//

int main(void) {
  test_find_parlock_target();
  test_adj_connected();
  return 0;
}

module Maze where

import           Data.Maybe (fromJust)
-- https://jelv.is/blog/Generating-Mazes-with-Inductive-Graphs/
-- Not like tree and list, graph is not a inductive type.
-- It's defined as G(V, E) a big set of stuffs.
-- We can't very nicely represent it with algebraic data type directly.
-- How do you represent a graph in a pure language?

{-@ tying the knot
    The first big problem of representing graph is how do you
    represent cyclic reference.
    A technic to represent cyclic data structure with lazyniess.
    We use the simplest circular graph: doubly linked list as
    an example.
 @-}

-- first some demonstration of tying the know
-- x needs y needs x. perfectly ok because they are evaluated
-- only when needed.
cyclic = let x = 0 : y
             y = 1 : x
          in x

cyclic3 = let x = 0 : y <> z
              y = 1 : z <> x
              z = 3 : x <> y
           in x

data DList a = DLNode (DList a) a (DList a)

mkDList :: [a] -> DList a
mkDList [] = error "must have at least one element"
mkDList xs = let (first,last) = go last xs first
             in  first
  where go :: DList a -> [a] -> DList a -> (DList a, DList a)
        go prev []     next = (next,prev)
        -- tight the know here
        go prev (x:xs) next = let this        = DLNode prev x rest
                                  (rest,last) = go this xs next
                              in  (this,last)


takeF :: Integer -> DList a -> [a]
takeF 0 _                 = []
takeF n (DLNode _ x next) = x : takeF (n-1) next

takeR :: Integer -> DList a -> [a]
takeR 0 _                 = []
takeR n (DLNode prev x _) = x : takeR (n-1) prev

--         2<.
--         |  \..
--         V     \
--         1 <--> 4
--         |
--         V
--         3

{-@ inductive graph @-}
-- we can decompose a graph into it's node, it's context (it's in edge and
-- out edge), and the rest of the graph.
data Context a = Context [a] a [a]
data Graph a = Empty
             | (Context a) :& Graph a

-- to represent the context of 1 for the directed graph above.
context1 = Context [2, 4] 1 [3, 4]

isEmpty :: Graph a -> Bool
isEmpty Empty = True
isEmpty _     = False

-- to pattern match a graph we need to decompose a graph into one
-- context and the rest of the graph, so we can work on one node at a
-- time.
matchAny :: Graph a -> (Context a, Graph a)
matchAny = undefined

-- pattern match on a node.
ghead :: Graph a -> a
ghead g | isEmpty g = error "empty graph"
ghead g = case matchAny g of
            (Context _ node _, _) -> node


-- our goal is to patter match on the graph. But we cannot directly do this
-- because there is no one good starting point, since every nodes can be the
-- root node.

main :: IO ()
main = undefined
module LowestCommonAncestor where
(defpackage #:matching-bipartite
  (:use :common-lisp))

(in-package #:matching-bipartite)

;; https://en.wikipedia.org/wiki/Matching_(graph_theory)#:~:text=A%20perfect%20matching%20is%20a,term%20complete%20matching%20is%20used.
;; Matching is a graph theory term for saying an set of edges without common
;; vertices.

;; Finding a matching in a bipartite graph can be seen as a network flow problem.

;; 1. maximal matching: matching M that is not a subset of any other matching.
;; 2. maximum matching: matching M that contains largest possible number of edges.
;; 3. perfect matching: matches all vertices in a graph.
module Kruskal where

module Prim where

-- prim algorithm is a greedy method to find the minial spanning tree in a graph.
--
-- Minimal spanning tree is a connected weighted undirected graph that contains
-- all vertices, and edges being the subset of the original graph, while the sum
-- of weights of edges is minimum.
--
-- collapse vertexes
-- the example graph
-- https://en.wikipedia.org/wiki/Kruskal%27s_algorithm#:~:text=Kruskal's%20algorithm%20finds%20a%20minimum,finds%20a%20minimum%20spanning%20tree.&text=It%20is%20a%20greedy%20algorithm,to%20the%20minimum%20spanning%20forest.
--
-- Process:
--  1. choose arbirary starting point as root from the graph,
--  2. grow the tree by on edge. find the minimum weight edge and transfer it to the tree.
--  3. repeat until all vertices are in the tree.


import Data.List

data Node = Node String Int deriving (Show, Eq)

type Graph = [(String, [Node])]

graph :: Graph
graph =
  [ ("A", [Node "B" 7, Node "D" 5]),
    ("B", [Node "A" 7, Node "D" 9, Node "E" 7, Node "C" 8]),
    ("C", [Node "B" 8, Node "E" 5]),
    ("D", [Node "A" 5, Node "B" 9, Node "E" 15, Node "F" 6]),
    ("E", [Node "D" 15, Node "B" 7, Node "C" 5, Node "F" 8, Node "G" 9]),
    ("G", [Node "F" 11, Node "E" 9])
  ]



-- | prim algorithm to find the minimal spanning tree.
prim :: Graph -> Graph
prim = undefined
module SteinerTree where

module RoundSquareTree where

module RoundSquareTree where

-- or block forest
module SAT where
-- sat solver with strongly connected component.

-- TODO
(defpackage :sat2
  :use :cl)

;;; 2 satisifiability


(defun sat-2 ()
  )

(defpackage #:kosaraju
  (:use "COMMON-LISP"))

(in-package #:kosaraju)
;;;; Strongly connected components.

;; it's not necessarily for you to be able to reach all nodes in a
;; graph from a single starting point.
;; if a directed acyclic graph has multiple strongly connected components,
;; you need to do multiple dfs from  0-in degree nodes.

;; scc is a equivalence class over "mutually reachable" (say Reach) equivalence
;; relation
;; this just means ssc has
;; 1. reflexivity     Reach(a, a)
;; 2. transitivity    Reach(a, b) Reach(b, c) <=> Reach(a, c)
;; 3. symmetric       Reach(a, b) <=> Reach(b, a)

;; main idea of kosaraju ssc:
;;  1. do dfs twice
;;  2. the first dfs push post order traversal of all nodes into a stack.
;;  3. create transpose graph Gt
;;  4. pop element from the stack, dfs from the element on Gt to collect
;;     strongly connected components.

;; strongly connected components themselves generates a new graph, where
;; each scc themselves are considered as a node.

(defmacro init-hash-table (xs)
  `(let ((m (make-hash-table)))
     (loop :for kv :in ,xs do
           (setf (gethash (car kv) m) (cdr kv)))
     m))


;; there are three strongly connected components here.
;; (a b e), (c d h) (f g)
(defparameter *graph*
  (init-hash-table
    '((a . (b))
      (b . (e f c))
      (c . (d g))
      (d . (c h))
      (e . (a f))
      (f . (g))
      (g . (f))
      (h . (g d)))))

(defparameter *graph-1*
  (init-hash-table
    '((3 . (0))
      (0 . (1))
      (1 . (2))
      (2 . (3 4))
      (4 . (5))
      (5 . (6))
      (6 . (4))
      (7 . (8 6))
      (8 . nil))))


;; if we do dfs on the graph above from a, we have
;; (format t "~%dfs a: ~a"  (dfs *graph* 'a))
;; (A B E F C D G H)
;; starting from a you can reach all nodes.
;;
;; but if you start from d you get
;; (format t "~%dfs d: ~a" (dfs *graph* 'd))
;; (D C H G F)
;; starting from d you can not go back to ssc with a in it.
;; why? because you can only go from ssc with a to ssc with d
;; but not vice vera.

(defun all-nodes (graph)
  (remove-duplicates
    (append
      (loop :for k :being :the :hash-keys :in graph :collect k)
      (apply #'append (loop :for v :being :the :hash-values :in graph
                            :collect v)))))


(defun transpose-graph (g)  ;; compute transpose graph
  (let ((m (make-hash-table)))
    (maphash
      (lambda (k v)
        (dolist (n v)
          (setf (gethash n m)
                (cons k (gethash n m))))) g) m))


(defun dfs-tree (graph root &optional visited)
  (let* ((visited visited)
         (result nil)
         (stack `(,root)))
    (loop :while stack do
          (let ((v (pop stack)))
            (dolist (u (gethash v graph))
                  (if (not (member u visited))
                      (progn
                        (push u stack))))
            (pushnew v visited)
            (pushnew v result)))
    ;; return both full visited and newly added nodes
    (values visited result)))


(defun dfs-forest (graph root)
  "keep dfs until find all roots"
  (let* ((stack nil)
         (visited `(,root))
         (unvisited (all-nodes graph)))
    (loop :while (not (null unvisited)) do
          (multiple-value-bind (v s) (dfs-tree graph root visited)
            (push s stack)
            (setf visited v))
          (setf unvisited (set-difference unvisited visited)
                root (car unvisited)))
    (reverse (apply #'append (reverse stack)))))


(defun ssc-kosaraju-* (graph root)
  "O(V+E) uses two dfs"
  (let* ((stack (dfs-forest graph root))
         (transposed (transpose-graph graph))
         (result nil)
         (visited nil))
    (loop :while stack do
          (let* ((n (pop stack)))
            (multiple-value-bind (v connected)
              (dfs-tree transposed n visited)
              (setf visited v
                    stack (remove-if #'(lambda (k) (member k connected)) stack))
              (push connected result))))
    result))


(defun ssc-kosaraju (graph)
  (ssc-kosaraju-* graph (car (loop :for k :being :the :hash-keys :in graph
                                   :collect k))))

(defun print-hash (m)
  (maphash (lambda (k v)
             (progn
               (write (list k v))
               (format t "~%")))
           m))
module StronglyConnectedComponent where
-- TODO

-- A directed graph is strongly connected if every vertex is reachable
-- from other vetex.
--
-- The set of all scc parition an arbitrary directed graph.

-- Finding strongly connected components with tarjan's algorithm.


newtype Vertex = Vertex String deriving (Show, Eq)
type Neighbours = (Vertex, [(Vertex, Weight)])

type Weight = Int
type Graph = [Neighbours]

instance Ord Vertex where
  compare _ _ = EQ
module Tarjan where

;; trajan ssc only need one dfs

(defmacro init-hash-table (xs)
  `(let ((m (make-hash-table)))
     (loop for kv in ,xs do
           (setf (gethash (car kv) m) (cdr kv)))
     m))


;; there are three strongly connected components here.
;; (a b e), (c d h) (f g)
(defparameter *graph*
  (init-hash-table
    '((a . (b))
      (b . (e f c))
      (c . (d g))
      (d . (c h))
      (e . (a f))
      (f . (g))
      (g . (f))
      (h . (g d)))))

(defparameter *graph-1*
  (init-hash-table
    '((3 . (0))
      (0 . (1))
      (1 . (2))
      (2 . (3 4))
      (4 . (5))
      (5 . (6))
      (6 . (4))
      (7 . (8 6))
      (8 . nil))))

;; remove uncessary edges for all scc.

;; pick a node and do dfs, it will gives a traversal
;; of nodes it can reach.
;; once dfs meet the root again, also add it into the traversal.
;; in the final traversal output, there will be even number of
;; root nodes, each enclose one strongly connected component.
;; pick the longest sub string that starts from a even ith root,
;; this is the maximal scc.
;; collect nodes from the graph, preserve edges that conencets
;; nodes in the scc according to the order of the traveral, and edges
;; that connects to other scc.
;; remove edges that are not following the order.

;; bellman ford is commonly compared with dijkstra.
;; bellman ford is
;; 1. slower
;; 2. can handle negative weights.
;; 3. allows for flexibility of weights changes.

;; O(VE)
;; worst case when it's a complete graph, it will be O(E^3)..

;; bellman ford can take at most V -1 iterations, and it guarantee when
;; the algorithm terminates, it gives the shortest path.

;; If there is a negative cycle in the graph, then there is no shortest
;; path. We expect bellman ford detect negative cycle for us.

;; note:
;; we do v-1 iterations, and relax all nodes at each iterations.
;; At ith iteration we get the shortest path between s to v for v in
;; G with at most i edges!

;; https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/
;; https://www.youtube.com/watch?v=obWXjtg0L64


(defpackage #:bellmanford
  (:use "COMMON-LISP")
  (:shadow ">")
  (:shadow "<"))

(in-package #:bellmanford)

(defmacro operator-overload (op &rest definitons)
  (let ((fname (read-from-string (concatenate 'string "binary" (symbol-name op)))))
    `(values
       (defun ,op (&rest ts)
         (reduce (quote ,fname) (cdr ts) :initial-value (car ts)))
       (defgeneric ,fname (a b)
         ,@(loop :for def :in definitons :collect
                 `(,@def))))))

(defmacro init-hash-table (xs)
  `(let ((m (make-hash-table)))
     (dolist (kv ,xs)
       (setf (gethash (car kv) m) (cdr kv)))
     m))

;; define nodes we will be using
(defclass node ()
  ((name
     :type symbol :initarg :name
     :accessor name :initform nil)
   (distance
     :type number :initarg :distance
     :accessor distance :initform most-positive-fixnum)
   (predecessor
     :type node :initarg :predecessor
     :accessor predecessor :initform nil)))

(defmethod print-object ((obj node) stream)
  "print the node"
  (print-unreadable-object (obj stream :type t)
    (with-accessors ((name name)
                     (distance distance))
      obj
      (format stream "<~a,~a>" name distance))))

;; overload the operator

(operator-overload >
                   (:method ((a number) (b number)) (cl:> a b))
                   (:method ((a node) (b node)) (cl:> (distance a) (distance b))))

(operator-overload <
                   (:method ((a number) (b number)) (cl:< a b))
                   (:method ((a node) (b node)) (cl:< (distance a) (distance b))))


(defmacro new-node (a &optional distance)
  `(cons ,a (make-instance 'node :name ,a
                           :distance (or ,distance most-positive-fixnum))))


;; todo unfinished

;; ok graph
(defparameter *graph-1*
  (init-hash-table
    '((#\s . ((#\e . 8) (#\a . 10)))
      (#\a . ((#\c . 2)))
      (#\b . ((#\a . 1)))
      (#\c . ((#\b . -2)))
      (#\d . ((#\a . -4) (#\c . -1)))
      (#\e . ((#\d . 1))))))


(defmacro alphabet (a z)
  `(loop :for i :from 0 to (- (char-code ,z) (char-code ,a))
         :collect (code-char (+ i (char-code ,a)))))

(defparameter *graph-info-1*
  (init-hash-table
    (loop :for n in (cons #\s (alphabet #\a #\e)) :collect
          (new-node n))))

;; negative cycle graph



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; bellman ford

(defmacro relaxf (u v w)
  "relax adjacent nodes. u is the current node"
  `(when (> (distance ,v) (+ (distance ,u) ,w))
     (setf (distance ,v) (+ ( distance ,u) ,w))
     (setf (predecessor ,v) ,u)))


(defmacro foreach-edges ((graph table) (u v w) &body body)
  "pass graph info and current node, work on u v w directly"
  `(macrolet ((u* (n table) `(gethash ,n ,table))
              (v* (m table) `(gethash (car ,m) ,table))
              (w* (m) `(cdr ,m)))
     (maphash (lambda (n adjs)
                (dolist (edge adjs)
                  ,@(nsubst `(u* n ,table) u
                            (nsubst `(v* edge ,table) v
                                    (nsubst '(w* edge) w body)))))
              graph)))


(defun bellman-ford (graph info s)
  "bellman-ford shortest path"
  (declare (type hash-table graph) (type hash-table info))
  (setf (distance (gethash s info)) 0)
  (let ((vertex-number (loop :for _ :being :the :hash-keys :in info :sum 1)))
    (dotimes (i (- vertex-number 1))
      (foreach-edges (graph info) (u v w)
        (relaxf u v w)))
    (block cycle  ;; if keep looping get shorter path we have a negative cycle.
           (foreach-edges (graph info) (u v w)
             (when (> (distance v) (+ (distance u) w)) (return-from cycle nil)))
           (loop :for v :being :the :hash-values :in info :collect v))))


; (format t "~a" (bellman-ford *graph* *graph-info* #\s))
; result:
; (#<NODE <s,0>> #<NODE <a,5>> #<NODE <b,5>> #<NODE <c,7>> #<NODE <d,9>>
;  #<NODE <e,8>>)

(defun print-hash (m)
  (maphash (lambda (k v)
             (progn
               (write (list k v))
               (format t "~%")))
           m))

;; prove correctness.

;; Lemma:
;; 1. if d(u) is not infinity, it's the length of some path from s to u.
;; 2. if there is a path from s to u with at most i edges, then d(u) is the most
;;    length of the shortest path from s to u with at most i edges.

;; proof:
;; lemma 1. prove by induction.
;; base case:       when i = 0 s is a path to s itself with lenght 0.
;; inductive step:  let u be one vertex that is i-1 edges away. v be i away, u be
;;                  the predecessor of v.
;;                  d(v) =

;; lemma 2. induction again.
;;  base case d(s) = 0 is the shortest path of i = 0
;;  inductive step;  let u be the predecessor of v which is ith edges away.
;;                   by inductive hypothesis d(u) is the shortest path for i-1
;;                   d(v) = d(u) + w, which is also the shortest path.
module BellmanFord where

-- based on `relax` operation.
-- Not like dijkstra, it supports negative weight.
;; dijkstra works with the shortest path.
;; O(VlogV + E) // dominated by E in lots of cases.
(defpackage #:dijkstra
  (:use "COMMON-LISP")
  (:shadow ">")
  (:shadow "<"))

(in-package #:dijkstra)

(defmacro init-hash-table (xs)
  `(let ((m (make-hash-table)))
     (dolist (kv ,xs)
       (setf (gethash (car kv) m) (cdr kv)))
     m))

;; min heap
(defclass min-heap ()
  ((data
     :type list
     :initarg :data
     :accessor data
     :initform (make-array 256 :adjustable t :fill-pointer 0))))

(defmethod print-object ((obj min-heap) stream)
  "print the min-heap"
  (print-unreadable-object (obj stream :type t)
    (with-accessors ((data data))
      obj
      (format stream "~%minheap data: ~a" data))))

(defun left-child (i)
  (declare (type integer i))
  (+ (* 2 i) 1))

(defun right-child (i)
  (declare (type integer i))
  (+ (* 2 i) 2))

(defun parent (i)
  (floor (cond ((= i 0) 0)
               ((= (mod i 2) 0) (/ (- i 2) 2))
               (t (/ (- i 1) 2)))))

(defmethod is-empty ((o min-heap)) (= (length (data o)) 0))

(defmethod swimup ((o min-heap) i)
  "i is the index of the element to swim up"
  (with-accessors ((data data)) o
    (when (< (elt data i) (elt data (parent i)))
      (rotatef (elt data i) (elt data (parent i)))
      (swimup o (parent i)))))

(defmethod sinkdown ((o min-heap) i)
  "sink down while keep the order invariant"
  (with-accessors ((data data))
    o
    (macrolet ((elt-or-nil (seq i)
                 `(if (>= ,i (length ,seq)) nil (elt ,seq ,i))))
      (let* ((largest-idx i) (e (elt-or-nil data i))
             (left-idx (left-child i))
             (left (elt-or-nil data left-idx))
             (right-idx (right-child i))
             (right (elt-or-nil data right-idx)))
        (when e
          (when (and left (> e left)) (setf largest-idx left-idx))
          (when (and right (> e right)) (setf largest-idx right-idx))
          (when (not (= largest-idx i))
            (rotatef (elt data largest-idx) (elt data i))
            (sinkdown o i)))))))

(defmethod insert-heap ((o min-heap) e)
  "insert into the bottom of the heap then swimup"
  (with-accessors ((data data)) o
    (let ((was-empty (is-empty o)))
      (vector-push-extend e data)
      (when (not was-empty) (swimup o (- (length data) 1))))))

(defmethod extract-heap ((o min-heap))
  "extract the min element, move bottom to top and sinkdown"
  (with-accessors ((data data)) o
    (when (not (is-empty o))
      (let ((top (elt data 0))
            (bottom (vector-pop data)))
        (when (not (is-empty o)) (setf (elt data 0) bottom))
        (sinkdown o 0)
        top))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; dijkstra

;; test
; (defparameter *m* (make-instance 'min-heap))
; (let ((xs '(8 3 12 5 1)))
;   (loop for i in xs do
;         (insert-heap *m* i)))

;; define nodes we will be using
(defclass node ()
  ((name
     :type symbol :initarg :name
     :accessor name :initform nil)
   (distance
     :type number :initarg :distance
     :accessor distance :initform most-positive-fixnum)
   (predecessor
     :type node :initarg :predecessor
     :accessor predecessor :initform nil)))

(defmethod print-object ((obj node) stream)
  "print the node"
  (print-unreadable-object (obj stream :type t)
    (with-accessors ((name name)
                     (distance distance))
      obj
      (format stream "<~a,~a>" name distance))))


;; overload the operator
;; todo make it a macro

(defmacro operator-overload (op &rest definitons)
  (let ((fname (read-from-string (concatenate 'string "binary" (symbol-name op)))))
    `(values
       (defun ,op (&rest ts)
         (reduce  (quote ,fname) (cdr ts) :initial-value (car ts)))
       (defgeneric ,fname (a b)
         ,@(loop :for def :in definitons :collect
                 `(,@def))))))

(operator-overload >
                   (:method ((a number) (b number)) (cl:> a b))
                   (:method ((a node) (b node)) (cl:> (distance a) (distance b))))

(operator-overload <
                   (:method ((a number) (b number)) (cl:< a b))
                   (:method ((a node) (b node)) (cl:< (distance a) (distance b))))


;; undirected weighted graph. nodes info is stored in the
;; corresponding info table.
;; (2 . 7) means edge to 2 has weight 7.
(defparameter *graph-1*
  (init-hash-table
    '((1 . ((2 . 7) (3 . 9) (6 . 14)))
      (2 . ((1 . 7) (3 . 10) (4 . 15)))
      (3 . ((1 . 9) (2 . 10) (6 . 2) (4 . 11)))
      (4 . ((2 . 15) (3 . 11) (5 . 6)))
      (5 . ((6 . 9) (4 . 6)))
      (6 . ((1 . 14) (3 . 2) (5 . 9))))))

(defmacro new-node (a &optional distance)
  `(cons ,a (make-instance 'node :name ,a
                           :distance (or ,distance most-positive-fixnum))))

;; define graph
(defparameter *graph-1-all-nodes*
  (init-hash-table
    (loop :for i :from 1 :to 6 :collect (new-node i))))


;; lemma. the relaxation operation maintains the invaraint
;; that d[v] >= δ(s, v) for all v ∈ V.
(defmacro relaxf (u v w)
  "relax adjacent nodes. u is the current node"
  `(when (> (distance ,v) (+ (distance ,u) ,w))
     (setf (distance ,v) (+ (distance ,u) ,w))
     (setf (predecessor ,v) ,u)))

(defun backtrace (n)
  "once find the target, collecting the result back til the source"
  (let ((xs nil)
        (v n))
    (loop :while v :do
          (push v xs)
          (setf v (predecessor v)))
    xs))

(defun dijkstra (graph info s d)
  "shortest path
   graph: a weighted graph.
   info:  node indexed by node names
   s:     name of the starting node
   d:     name of the target node
   "
  (declare (type hash-table graph) (type hash-table info))
  (setf (distance (gethash s info)) 0)
  (let ((visited `(,s))   ; avoid visit visited nodes.
        (queue (make-instance 'min-heap)))
    (insert-heap queue (gethash s info))

    (block done
           (loop :while queue :do
                 (let* ((u (extract-heap queue))
                        (adjacents (gethash (name u) graph)))

                   ;; return if find the target
                   (when (equal (name u) d) (return-from done (backtrace u)))

                   (dolist (a adjacents)
                     (macrolet ((v () `(gethash (car a) info)))
                       (relaxf u (v) (cdr a))
                       (when (not (member (car a) visited))
                         (push (car a) visited)
                         (insert-heap queue (v))))))))))

(defun print-hash (m)
  (maphash (lambda (k v)
             (progn
               (write (list k v))
               (format t "~%")))
           m))

(dijkstra *graph-1* *graph-1-all-nodes* 1 5)
{-# LANGUAGE CPP                 #-}
{-# LANGUAGE RankNTypes          #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# OPTIONS_GHC -Wno-deferred-type-errors #-}
{-# OPTIONS_GHC -Wincomplete-patterns #-}

module Dijkstra where

import           Control.Monad.ST
import           Data.Foldable
import           Data.List
import           Data.Maybe
import           Data.STRef


-- ------------------------------------------------------------------------------
-- little priority queue.
-- ------------------------------------------------------------------------------


-- we maintain a mean heap of Vertex': each nodes and their distance
-- to starting node.
data SkewHeap a = Empty | SkewNode a (SkewHeap a) (SkewHeap a) deriving (Show, Eq)

instance Functor SkewHeap where
  fmap f Empty              = Empty
  fmap f (SkewNode x h1 h2) = SkewNode (f x) (fmap f h1) (fmap f h2)

instance Applicative SkewHeap where
  pure x = SkewNode x Empty Empty
  (<*>) = error "no"

instance (Ord a) => Semigroup(SkewHeap a) where
  heap1@(SkewNode x1 l1 r1) <> heap2@(SkewNode x2 l2 r2)
    | x1 <= x2 = SkewNode x1 (heap2 <> r1) l1
    | otherwise = SkewNode x2 (heap1 <> r2) l2
  Empty <> heap = heap
  heap <> Empty = heap

instance (Ord a) => Monoid (SkewHeap a) where
  mempty = Empty

instance Foldable SkewHeap where
  foldr _ b Empty            = b
  foldr f b (SkewNode x l r) = f x (foldr f (foldr f b l) r)


extractMin :: (Ord a) => SkewHeap a -> Maybe (a, SkewHeap a)
extractMin Empty            = Nothing
extractMin (SkewNode x l r) = Just (x, l <> r)


-- filter a skew heap
heapDeleteBy :: forall a. (Ord a)
             => (a -> Bool) -- whether delete the node if hit the key
             -> SkewHeap a
             -> Maybe ([a], SkewHeap a)
heapDeleteBy pred h = runST $ do
  ref <- newSTRef []
  h' <- go (\x -> modifySTRef ref (x:)) h
  acc <- readSTRef ref
  return $ Just (acc, h')
  where
    go :: (Monad m) => (a -> m ()) -> SkewHeap a -> m (SkewHeap a)
    go _ Empty              = pure Empty
    go modify t@(SkewNode x l r) =
      if pred x
         then modify x >> (<>) <$> go modify l <*> go modify r
         else do
           l' <- go modify l
           SkewNode x l' <$> go modify r


-- update a vertex that satisfied the preidcate.
heapModify :: Ord a => (a -> Bool) -> (a -> a) -> SkewHeap a -> SkewHeap a
heapModify pred f h = case heapDeleteBy pred h of
                        Nothing       -> h
                        Just (xs, h') -> mconcat (fmap (pure . f) xs) <> h'


-- ------------------------------------------------------------------------------
-- adjacent table
-- ------------------------------------------------------------------------------


newtype Vertex = Vertex String deriving (Show, Eq)

instance Ord Vertex where
  compare _ _ = EQ

type Neighbours = (Vertex, [(Vertex, Weight)])

type Weight = Int
type Graph = [Neighbours]

-- vertex augmented with distance and path info.
data Vertex' = Vertex' { vertex   :: Vertex
                       , distance :: Int   -- distance from the source vertex.
                       , prev     :: Maybe Vertex
                       }
                       deriving (Show, Eq)

instance Ord Vertex' where
  compare a b = compare (distance a) (distance b)

type Vertex'Table = [Vertex']

showVertex'Table = foldr (\e b -> show e ++ "\n" ++ b) ""

initTable :: Vertex -> Graph -> Vertex'Table
initTable (Vertex s) = map f
  where
    f (v@(Vertex lbl), _) = Vertex' { vertex = v
                                    , distance = if lbl == s then 0 else maxBound :: Int
                                    , prev = Nothing
                                    }


-- ------------------------------------------------------------------------------
-- Dijkstra
-- ------------------------------------------------------------------------------


-- Dijkstra is greedy algorithm, it always takes the next shortest path. This
-- sometimes doesn't yield the best solution.
-- For example, a path:
--      +-1-x--2--x-+
--    A              B
--      +-----2-----+
-- The path below is shorter, but dijkstra algorithm will try the above one first.

dijkstra :: Vertex -> Graph -> Vertex'Table
dijkstra v graph = search [] queue
  where
    queue = foldl' (<>) Empty (fmap pure (initTable v graph))
    search :: Vertex'Table -> SkewHeap Vertex' -> Vertex'Table
    search table queue | queue == Empty = table
      | otherwise = fromJust $ do
        (v, queue') <- extractMin queue
        adjs <- lookup (vertex v) graph
        let dv = distance v
            relax h uk uv e =
              if dv + uv < distance e
                 then e { distance = dv + uv, prev = Just (vertex v) }
                 else e
            f h (uk, uv) =
              heapModify ((uk ==) . vertex) (relax h uk uv) h
            queue'' = foldl' f queue' adjs
        return (search (v : table) queue'')


-- ------------------------------------------------------------------------------
-- Testing
-- ------------------------------------------------------------------------------


#define TEST
#ifdef TEST

-- test input
-- A E D C B
testHeadModify :: IO ()
testHeadModify = do
  let h1 = heapModify (pred "B") (\e -> e { distance = 10 }) queue
      h2 = heapModify (pred "C") (\e -> e { distance = 8 }) h1
      h3 = heapModify (pred "D") (\e -> e { distance = 3 }) h2
      h4 = heapModify (pred "E") (\e -> e { distance = 2 }) h3
  print h4
  let Just (a, xs) = extractMin h4
  print a
  let Just (a, xs') = extractMin xs
  print a
  let Just (a, xs) = extractMin xs'
  print a
  let Just (a, xs') = extractMin xs
  print a
  let Just (a, xs) = extractMin xs'
  print a
 where
   pred l = (\(Vertex v) -> v == l) . vertex
   v = Vertex "A"
   queue = foldl' (<>) Empty (fmap pure (initTable v graph))

-- tester
--  A-6--B
--  |   /| \ 5
--  1  2 |  C
--  | /  | / 5
--  D-1- E

graph :: Graph
graph = [ (Vertex "A", [ (Vertex "B", 6)
                       , (Vertex "D", 1)])
        , (Vertex "B",  [ (Vertex "A", 6)
                        , (Vertex "D", 2)
                        , (Vertex "E", 2)
                       ])
        , (Vertex "C", [ (Vertex "B", 5)
                        , (Vertex "E", 5)
                       ])
        , (Vertex "D", [ (Vertex "A", 1)
                       , (Vertex "B", 2)
                       , (Vertex "E", 1)])
        , (Vertex "E", [ (Vertex "D", 1)
                       , (Vertex "B", 2)
                       , (Vertex "C", 5)])
        ]

testDijkstra :: IO ()
testDijkstra = do
  let s = Vertex "A"
      q = dijkstra s graph
  putStr (showVertex'Table q)

-- -- output
-- Vertex' {vertex = Vertex "C", distance = 7, prev = Just (Vertex "E")}
-- Vertex' {vertex = Vertex "B", distance = 3, prev = Just (Vertex "D")}
-- Vertex' {vertex = Vertex "E", distance = 2, prev = Just (Vertex "D")}
-- Vertex' {vertex = Vertex "D", distance = 1, prev = Just (Vertex "A")}
-- Vertex' {vertex = Vertex "A", distance = 0, prev = Nothing}

#endif
module MinCycle where
#include <iostream>

template <typename T> struct Return { using type = T; };

// Type level list.
// params:
//   @...Ts: list of types for constructing the list.
// operations:
//   @type:   List<typename...>,
//     return the list type itself.
//   @size:   size_t
//     return the size of elements in ...Ts.
//   @append: typename... -> List<typename...>
//     append the list with another varadict type list.
//   @apply:  template <typename> typename F -> F<Ts...>
//     apply type operator F on ...Ts
template <typename... Ts> struct List {
  // varadic ...Ts includes on or more, and it's already recursive by itself.
  // there is no need to define a ADT style list.

  using type = List<Ts...>;
  static constexpr size_t size = sizeof...(Ts);

  template <typename... Us> using append = List<Ts..., Us...>;

  // apply F with Ts...
  template <template <typename...> typename F> using apply = F<Ts...>;
};

template <typename... Ts> using List_t = typename List<Ts...>::type;

using Nil = List<>;

template <typename T> using IsNil = typename std::is_same<T, Nil>::type;

// Get the head of a list
// @param:
//   typename:  List<typename...>
// @operations:
//   type: typename,  get the head of the list.
template <typename> struct Head {};
template <> struct Head<List<>> { using type = Nil; };
template <typename T, typename... Ts> struct Head<List<T, Ts...>> {
  using type = T;
};

// Get the tail of a list
// @param:
//   typename:  List<typename...>
// @operations:
//   type: List<typename...>,  get the tail of the list.
template <typename...> struct Tail {};
template <> struct Tail<List<>> { using type = Nil; };
template <typename T, typename... Ts> struct Tail<List<T, Ts...>> {
  using type = List<Ts...>;
};

// Concat two lists.
// @params:
//   List<typename...>: first list
//   List<typename...>: second list
// @operations:
//   type: List<typename...>, the concated list.
template <typename, typename> struct Concat {};
template <typename... Ts, typename... Us>
struct Concat<List<Ts...>, List<Us...>> {
  using type = typename List<Ts...>::template append<Us...>;
};

// Map over a type level list.
// @params:
//  F:  template <typename> typename,  function
//  XS: List<typename...>
// @operations:
//  type: Get the list;
template <template <typename> typename F, typename XS> struct Map {};
template <template <typename> typename F, typename... Ts>
struct Map<F, List<Ts...>> : List<typename F<Ts>::type...> {};

template <template <typename> typename Pred, typename XS,
          typename Base = List<>>
// default type parameter can introduce local binding.
struct Filter : Base {};

template <template <typename> typename Pred, typename Base, typename T,
          typename... Ts>
struct Filter<Pred, List<T, Ts...>, Base> {
  using type = std::conditional_t<
      Pred<T>::value,
      Filter<Pred, typename Base::template concat<T>::type, Ts...>,
      Filter<Pred, Base, Ts...>>;
};

// Left fold on a type level list.
// @params:
//   Op: template <typename, typename> typename,
//     A binary operation, takes acc as the first argument and a element in the
//     list as the second argument. Op :: a -> b -> a
//   Acc: typename
//     Accumulator. It cab be a single value for base case.
//   XS: List<typename...>
//     A type level list.
// @operations;
//   type: Acc::type
template <template <typename, typename> typename Op, typename Acc, typename XS>
struct FoldeL : Return<Acc> {};
template <template <typename, typename> typename Op, typename Acc, typename T,
          typename... Ts>
struct FoldeL<Op, Acc, List<T, Ts...>>
    : FoldeL<Op, typename Op<Acc, T>::type, List<Ts...>> {};

// Check if element is in the type level list.
// @params:
//   E:                     element to test.
//   XS: List<typename...>  list to test.
//
// @operations:
//   value: bool,  the test result.
template <typename E, typename XS> struct Elem {};
template <typename E, typename... Ts>
struct Elem<E, List<Ts...>> : std::bool_constant<(std::is_same_v<Ts> || ...)> {
};

// Return a List<typename ...> with no duplicated elements.
// @params:
//    Input: List<typename...>
// @operations:
//    type: List<typename...>
template <typename Input> class Unique {
  // use private type alias for local declaration.
private:
  template <typename Acc, typename E>
  struct Add : std::conditional_t<Elem<E, Acc>::value, Acc,
                                  typename Acc::template concat<E>> {};

public:
  using type = typename FoldeL<Add, List<>, Input>::type;
};

#define typeof(TYPE) static_assert(sizeof(TYPE) == -1)

// using t = Tail<List<int>>;
// typeof(t::type);
#include "template-list.hpp"
#include <iostream>

// TODO

// template topological sort
// get a total ordered list (topological order) from a graph without cycle (a
// DAG). note a DAG might have multiple topological ordering.
//
// A topological orerding can be useful for scheduling dependencies. So notable
// examples: dependeneis management of makefiles, resolving symbols in
// linkers...
//
// Given a graph:
// 5 -> 11, 7 -> 11, 7 -> 8
// 3 -> 8, 3 -> 10
// 11 -> 2, 11 -> 9, 11 -> 10, 8 -> 9
//
// Possible topological order:
//  5 7 3 11 8 2 9 10
//  3 5 7 8 11 2 9 10
//  ...
//  All verteices are reached after their dependencies are reached.
//
// Typical topo sort running type O(|V| + |E|).
//
// Two algorithms:
//    1. Kahn's algorithm
//    2. DFS
//

// Some list utility

// declare the graph.
template <typename...> struct Graph;

template <typename N> struct NodeWrapper {
  void operator()() { return N(); }
};

// Edge of a graph. An edge consists two nodes.
// @params:
//   Node1: typename, the first node
//   Node2: typename, the second node.
// @operations:
//   Out: typename, get the out node (first node.)
//   In:  typename, get the in node (second node.)
template <typename> struct Edge {};
template <typename Node1, typename Node2>
struct Edge<auto (*)(Node1)->auto (*)(Node2)->void> {
  using Out = Node1;
  using In = Node2;
};

// Get out node of an edge
template <typename Edge> struct GetOut { using type = typename Edge::Out; };

// Get in node of an edge
template <typename Edge> struct GetIn { using type = typename Edge::In; };

// The graph.
// @param:
//  Links: typename..., links of the graph. node it should be of type
//    auto(*)(a) -> auto(*)(b)
// @operations:
template <typename... Links> class Graph {
private:
  using Edges = typename Unique<List<Edge<Links>...>>::type;

  using OutNodes = typename Map<GetOut, Links...>::type;
  using InNodes = typename Map<GetIn, Links...>::type;

  // all nodes.
  using Nodes = typename Unique<typename Concat<InNodes, OutNodes>::type>::type;
  static constexpr size_t number_of_nodes = Nodes::size;

  // find dependencies.
  // Node -> { Node, List<Node> }

  template <typename N> class GetNodeDescedants {
  private:
    template <typename Edge>
    //  get all edges with `Node` as the out end.
    struct DependencyP : std::is_same<N, typename GetOut<Edge>::type> {};
    using NodeDescendants = typename Filter<DependencyP, Edges>::type;

  public:
    struct type { // mult value return
      using Node = N;
      using Descendants = typename Map<GetIn, NodeDescendants>::type;
    };
  };

  // bind node descedants. List<{Node, Descendants}>
  using NodeDescendants = typename Map<GetNodeDescedants, Nodes>::type;

  // we need to make sure the graph is a DAG, so there should be a loop check.
  // sorting
  template <typename Node> class SortNodes {};
};

#define graph(...)                                                             \
  Graph<__VA_ARGS__> {}

#define node(node_) auto (*)(NodeWrapper<node_>)
#define link(link_) link_->void

void Parsec() { puts("parsec"); }
void Ast() { puts("Ast.hs"); }
void Parser() { puts("Parser.hs"); }
void LLVMhs() { puts("llvm-hs"); }
void Codegen() { puts("Codegen.hs"); }
void Object() { puts("object"); }
(defpackage #:topological-sort
  (:use "COMMON-LISP")
  (:shadow "+"))

(in-package #:topological-sort)


;; find topological order of a directed acyclic graph (DAG problem)
;; it's useful for many scheduling algorithms

(defmacro init-hash-table (xs)
  `(let ((m (make-hash-table)))
     (dolist (kv ,xs)
       (setf (gethash (car kv) m) (cdr kv)))
     m))

;; topological sort works on a directed acyclic graph.
(defparameter *dependencies*
  (init-hash-table '((tar . nil)
                     (coreutils . (libbz2 libselinux1))
                     (dpkg . (coreutils tar multiarch-support))
                     (multiarch-support . nil)
                     (libselinux1 . (multiarch-support)))))

;; this gives you a topo order directly.

(defun dfs (graph root)
  (let* ((visited `(,root))
         (stack `(,root)))
    (loop :while stack :do
          (let ((v (pop stack)))
            (dolist (u (gethash v graph))
              (when (not (member u visited))
                (pushnew u visited)
                (push u stack)))))
    (reverse visited)))

(defun toposort-dfs (graph)
  "find a node with no in degree as the starting node"
  (let* ((non-zero-indegrees
           (remove-duplicates
             (apply #'append
                    (loop :for v :being :the :hash-values :in graph
                          :collect v))))
         (allnodes
           (remove-duplicates
             (append
               (loop :for k :being :the :hash-keys :in graph :collect k)
               non-zero-indegrees)))

         (zero-indegrees (set-difference allnodes non-zero-indegrees)))
    (dfs graph (car zero-indegrees))))


(format t "~a~%" (toposort-dfs *dependencies*))
(defpackage #:traveling-salesman-approx
  (:use :common-lisp))

(in-package #:traveling-salesman-approx)

;; Technique: constant approximation:
;;   assume optimal solution has value v, and you want your algorithm
;;   to give a solution within a constant factor of v. like cv.
;; constant approximation for traveling salesman is also NP hard..

;; approximation algorithm
;; https://www.youtube.com/watch?v=zM5MW5NKZJg

(defun traveling-salesman ()

  )
module ActivitySelecting where

import Control.Monad
import Data.List
import Debug.Trace

type Activity = (Int, Int)

sf :: [Activity]
sf =
  [ (3, 5),
    (3, 8),
    (0, 6),
    (5, 9),
    (1, 4),
    (8, 11),
    (8, 12),
    (5, 7),
    (12, 14),
    (6, 10),
    (2, 13)
  ]

-- select the tighest fit among activities.
-- fix the finishing point, the first task with larger starting point
-- is the task you want to schedule.


selectActivities sf = nub (mconcat [[a, b] | (a, b) <- select sf])
  where
    select :: [Activity] -> [Activity]
    select sf = trace (show sf1) $ go 0 0 []
      where
        sf1 = sortBy (\a b -> compare (snd a) (snd b)) sf
        s = fst . (sf1 !!)
        f = snd . (sf1 !!)
        go i j result
          | j == length sf1 =  result
          | s j >= f i = go j (j + 1) ((i, j) : result)
          | otherwise = go i (j + 1) result

run = selectActivities sf

selectActivitiesReverse sf = nub (mconcat [[a, b] | (a, b) <- select sf])
  where
    select :: [Activity] -> [Activity]
    select sf = trace (show sf1) $ go 0 0 []
      where
        sf1 = sortBy (\b a -> compare (snd a) (snd b)) sf
        s = fst . (sf1 !!)
        f = snd . (sf1 !!)
        go i j result
          | j == length sf1 = result
          | f j < s i = go j (j + 1) ((i, j) : result)
          | otherwise = go i (j + 1) result

run1 = selectActivitiesReverse sf
sf = [(3, 5), (3, 8), (0, 6), (5, 9), (1, 4), (8, 11),
      (8, 12), (5, 7), (12, 14), (6, 10), (2, 13)]

# we first state the problem as a dp optimization problem
# then we realize it doesn't need to be dp, because each
# time when we need to make a decision, we only need to choose
# the optimal one, and the result will be proven to be optimal.

# we sort the activity based on their finished time. This ensure
# several properties:
# 1. the first task should always be considered. since it will
#    take the smallest time.
# 2. we can be sure the next non overlapping interval is the
#    best solution.


# primitive
def activity_selection(sf):
    sf1 = list(sorted(sf, key=lambda x: x[1]))
    __import__('pprint').pprint(sf1)
    s = [s_ for (s_, _) in sf1]
    f = [f_ for (_, f_) in sf1]
    result = []
    n = len(f)
    i = 0
    for j in range(n):
        if s[j] >= f[i]:
            result.append((i, j))
            i = j
    return result


# 1. Select the last to start;
# Selecting the last activity to start is isomorphic to selecting the first
# activity to finish.
# For the first activity to start case, we have a set of intervals
# {a1, a2 ... an }, with ai = [si, fi), and we find the last activity that is
# compatible with previous previous activities. If we reverse the order of
# si and fi, and create an interval {b1, b2 ... bn} with bi = [fi, si].
# We can solve this reversed problem with the same algorithm and get exactly
# the same result.

def activity_selection_reverse(sf):
    sf1 = list(reversed(sorted(sf, key=lambda x: x[0])))
    __import__('pprint').pprint(sf1)
    f = [s_ for (s_, _) in sf1]
    s = [f_ for (_, f_) in sf1]

    result = []
    n = len(f)
    i = 0
    for j in range(n):
        if s[j] <= f[i]:
            result.append((i, j))
            i = j
    return result

# 2.
#   - least duration from compatible activities
#       s  0  4  5
#       f  5  7  9
#      (4, 7) has the least duration 3. So it will be picked directly as
#      solution.
#      but by choosing (0, 5) (5, 9) we can fit 2 tasks.
#   - overlaps the fewest other remaining activities
#       s  0 5 6 7 8 12
#       f  6 7 8 8 9 13
#       (12, 13) has the least overlap and will be choosen at the beginning.
#       But it's clearly not optimal
#   - selecting the compatible remaining activity with the earliest start time.
#       s  0   4  5
#       f  11  7  9
#     once (0, 11) is choosen no other tasks can fit anymore


if __name__ == "__main__":

    print("last start solution")
    r = activity_selection(sf)
    print(f"result: {r}")

    print()

    print("first finished")
    r1 = activity_selection_reverse(sf)
    print(f"result: {r1}")
schedules = [(1, 4), (2, 5), (5, 7), (10, 12), (6, 9), (13, 14)]

# each time we have a overlapping we know a new room is needed.


def sort(xs):
    return list(sorted(xs, key=lambda x: x[0]))


def allocate(xs):
    sorted_xs = sort(xs)
    result = 0

    i = 0
    for j in range(len(schedules)):
        if sorted_xs[j][0] < sorted_xs[i][1]:
            i = j
            result += 1
    return result


allocate(schedules)
#include <iostream>
#include <vector>

// https://leetcode.com/problems/assign-cookies/
using namespace std;

class Solution {

// Proof:
//   The quesion is asking how to allocate cookies to maximize the
//   content children.
//   If we content children from the most greedy one to the least greedy
//   one, we wil content the most amount of children.
// Initial:
//   Input: two vectors. vector g contains the gredy level, vector s contains
//          the cookie size
//   We first sort
// Maintain:
// Finish:
public:
  int findContentChildren(vector<int> &g, vector<int> &s) {
  }
};
module HuffmanCodes where


huffman :: String -> String
huffman = undefined
module Kingsgame where

import Data.List
import Debug.Trace

-- https://vijos.org/p/1779
-- a king playing game with ministers. He writes an integer
-- on both left hand and write hand of every ministers and himself, and
-- arrange everybody to stand in a queue. Then he will give each minister
-- bonus, the amount a minister can get is the same as the sume of all left
-- hand integers of people in front of him divided by his right hand integere.
-- the king doesn't want to make someone get too much bouns, so he wants to find
-- an order to minimize the maximum bonus.
-- What should the king do?

-- It's a simple optmization algorihtm that can be solved with greedy method pretty
-- elegantly.

-- Idea: If we try to swap two people the award gets smaller, then we do the swap.
--
-- let ai bi be the integer on the left hand and the right hand.
-- let s = sum of all left hand integers.
-- For person ai, the bounus will be:
--    s / bi
-- for person ai+1 the bonous will be:
--    (s . ai) / bi+1
--
-- If we swap ai and ai+i, the cost will be
--    s / bi+1
--  and
--    (s . ai) / bi
--
-- We can determine if we should swap these two people by the following criteria:
--    max (s / bi, (s . ai) / bi+1) < max (s / bi+1, (s . ai) / bi)
--
-- simply we can get
--    max(bi+1, ai+1 . bi) < max(bi, ai+1 . bi+1)

data M = M
  { ma :: Int,
    mb :: Int
  }
  deriving (Eq, Show)

instance Ord M where
  M a b <= M a' b'
    | a == b && a' == b' = True
    | otherwise = max b' (a * b) < max b (a' * b')

-- trick: one catch for take, it take n element instead of nth element.
-- If input is an index you need to add 1.

-- trick: use let binding to introduce intermediate values, so we can trace them
-- individually.

-- trick: let binding is actually good for readablity.
maxReward :: [M] -> Int
maxReward ms =
  let s n = sum . take (n + 1) . fmap ma $ ms
      reward n =
        let s' = s n
            b' = mb (ms !! n)
         in s' `div` b'
      rewards = fmap reward [0 .. length ms - 1]
   in maximum rewards

input = [M 1 1, M 2 3, M 7 4, M 4 6]

ordered = sort input
module Knapsack where

import           Data.List
import           Debug.Trace
import           Text.Printf

-- fractional knapsack problem.
-- or Thief robbing store problem. In this setting you are allowed to grab
-- a fraction of the item, which makes it possible to be solved with a greedy
-- algorithm.

-- item(th)  1   2   3   4   5   6   7
-- profit    10  5  15   7   6   18  3
-- weight    2   3   5   7   1   4   1

-- the solution is super simple, just take the most valuable until there
-- are not more same item or no more weight.

data I = I Double Double
  deriving Show

capacity = 15

items = [I 10 2, I 5 3, I 15 5, I 7 7, I 6 1, I 18 4, I 3 1]

knapsack :: [I] -> Double -> Double
knapsack is weight = go byprofit 0 0
 where
  profitKey (I a _) (I b _) = compare a b
  byprofit = sortBy (flip profitKey) is
  go :: [I] -> Double -> Double -> Double
  go [] p _ = p
  go ((I p' w') : xs) p w =
    trace (printf "profit %.2f weight %.2f" p w) $ -- use trace + printf to debug.
    if w + w' > weight
      then
        let wfrac = (weight - w) / w'
            pfrac = wfrac * p'
        in  pfrac + p
      else go xs (p + p') (w + w')

profit = knapsack items capacity
;; you want to sell some metals. The buyer has a
;; maximum weight limit.
;; sell the most expensive metal as much as you can to
;; maximize the profit.

;; this is just another fractional knapsack problem.
;; given i differnet metals each weigth k with prices c
;; we want to Max(Sum(k_i * c_i))


(defparameter *weight-limit* 100)
(defparameter *metals_k_c*
  '((20 . 30)
    (40 . 10)
    (14 . 45)
    (100 . 1)
    (23 . 15)))

;; sort by price, then grab the most valuabel along the way
;; until no longer fit.
(defun sell-metal (info weight-limit)
  (labels ((by-price (a b) (> (cdr a) (cdr b))))
    (let ((sorted (sort (copy-seq info) #'by-price))
          (weight 0)
          (result nil))
      (loop :while sorted :do
        (let ((m (pop sorted)))
          (if (> (+ weight (car m)) weight-limit)
              (progn
                (let ((diff (- weight-limit weight)))
                  (setf weigth weight-limit)
                  (push (cons diff (cdr m)) result)
                  (setf sorted nil)))
              (progn
                (setf weight (+ weight (car m)))
                (push m result)))))
      result)))

(sell-metal *metals_k_c* 102)
(sell-metal *metals_k_c* 35.5)
;; shortest job first is actually a classical example for greedy algorithm.

;; we want to minimize the average of the completion time.

;; NOTE we assume all jobs are known ahead of the time.
(defparameter *jobs*
  '((a . 23)
    (b . 56)
    (c . 4)
    (d . 12)
    (e . 98)
    (f . 1)
    (g . 2)))


;; we know each time if we choose the shortest job, we can minimize the overall
;; completion time.


(defun shortest-job-first (jobs)
  (labels ((by-length (a b)
             (< (cdr a) (cdr b))))
    (sort (copy-seq jobs) #'by-length)))

(defun accumulate (xs)
  (let ((order (copy-seq xs)))
    (loop :for i :from 1 :to (- (length order) 1) :do
          (setf (cdr (elt order i)) (+ (cdr (elt order i))
                                       (cdr (elt order (- i 1))))))
    order))

;; it mutates somehow...
(accumulate (shortest-job-first *jobs*))


;; How to prove this is the minimal average completion time you can get?
;; simply prove by contradiction.
;; Assume you complete all jobs with an order that task p1 with longer
;; runtime start earily than task p2.
;; then you just need to find a way to prove there is a better way to
;; decrase the aeverage time.
;; this is always possible, just formulate the runtime and prove
;; swap them gives a better average.
;; solve the dual to get the solution
#include <iostream>

// karmarkar's algorithm for solving linear programming problems.
// It has a crazy running time
// O(n^3.5L^2logLloglogL)
// oh gee.

module MaxBipartiteMaching where

-- solving problems that doesn't looks like a network flow problem
-- with network flow.

;; maximum bipartite matching problem.

;; A match in a bipartite graph is a set of edges chosen
;; in such a way that no two edges share and endpoint.

;; A maximum matching is a match of maximum size.

;;;; MBP (maximum bipartite mactch) and network flow.
;; the problem can be solve by finding the maximum flow in a flow
;; network.

;; A bipartite graph can be thought as a flow network with multiple
;; sinks and sources.
;; We can add super sink and super source to turn the problem into a
;; single sink single source problem.


;; steps
;; 1. Convert the bipartite graph into a single source single sink
;;    flow network.
;; 2. Find the maximum flow with ford-fulkerson.
;;    The maximum flow is the bipartite matching we are looking for.


(defmacro init-hash-table (xs)
  `(let ((m (make-hash-table)))
     (dolist (kv ,xs)
       (setf (gethash (car kv) m) (cdr kv)))
     m))


(defparameter *bipartite-graph*
  (init-hash-table
    '((a . (2 3))
      (b . nil)
      (c . (1 4))
      (d . (3))
      (e . (3 4))
      (f . (6))
      (nil . (5)))))


(defun make-network (bipartite)
  "first make the binary matching network
   note the original bipartite graph doesn't have capacity,
   but they have implicit 1. Because you can either connect to
   another node or not.

   A flow network contains (u f . c)
   where u is the node name, f is the current flow, and c is the
   capacity.
   "
  (let ((left nil)
        (right nil)
        (s* nil)
        (t* nil))
    (maphash
      (lambda (k v)
        (push k left)
        (setf right (remove-duplicates (append v right))))
      bipartite)
    (setf left (remove nil left) right (remove nil right))
    (dolist (n left) (push n s*))
    (dolist (n right) (push n t*))
    (setf (gethash 's bipartite) s*
          (gethash 't bipartite) t*)
    (loop :for k :being :the :hash-keys :in bipartite :using (hash-value v)
          :do
          (setf (gethash k bipartite)
                (mapcar (lambda (x) (cons x (cons 0 1))) v)))
    bipartite))


;; residual network
;;
;; cf(u, v) = {
;;    c(u, v) - f(u, v)  if (u, v) in E
;;    c(v, u)            if (v, u) in E     unsend
;;    0                  otherwise
;; }


(defun make-residual-network (graph)
  "make the residual network")

(defun augmenting-path (residual-network)
  "finding the augmenting path")

(defun edges (graph)
  "return a list of all edges")

(defun residual-capacity (edge)
  "calculate the residual capacity")

;; for ford fulkerson algorithms, all intermediate flows
;; corresponds to the matchings.
;; if there is a flow across an internal edge, then it belongs
;; to the matching.
;; In the residual network there will be a corresponding flow
;; that goes from sink to source.


(defun edmonds-karp (graph)
  "run edmonds karp (ford fulkerson)"
  (let ((gf (make-residual-graph graph))
        (f 0))
    (loop :while (augmenting-path gf) :do
          (let ((b (apply #'min (mapcar #'residual-capacity (edges graph)))))
            ;; sete ef = f + f' where f' = { b if (u,v) in P 0 otherwise}
            )))
  f)


(defun print-hash (m)
  (maphash (lambda (k v)
             (progn
               (write (list k v))
               (format t "~%")))
           m))


;; a specialization of furd-fulkerson.
;; find augmenting path with bfs

;; ford fulkerson algorithm to find the maximum flow.
;; f(u, v) <- for all (u, v)
;; while an augmenting path P in residual network Gf exists,
;; do augment f by cf(P)

;; invaraints to maintain:
;; 1. capacity constraints
;; 2. skew symmetry
;; 3. flow conservation

(defpackage #:edmondskarps
  (:use "COMMON-LISP"))

(in-package #:edmondskarps)


(defmacro init-hash-table (xs)
  `(let ((m (make-hash-table)))
     (dolist (kv ,xs)
       (setf (gethash (car kv) m) (cdr kv)))
     m))


(defparameter *flownetwork*
  (init-hash-table
    '()
    ))


(defmacro enqueue (xs x) `(setf ,xs (cons ,x ,xs)))

(defmacro dequeue (xs)
  `(let ((x (last ,xs)))
    (setf ,xs (butlast ,xs))))


(defun make-residual-network (flow-network)
  "return the residual network of a given flow network"
  )


module EdmondsKarp where

-- capacity constraint.
-- skew symmetric.
-- flow conservation.

type Capacity = Integer

type Flow = Integer

type Graph = [(String, [(String, Integer)])]

graph =
  [ ("Vancouver", [("Edmonton", 16), ("Calgary", 13)]),
    ("Edmonton", [("Saskatoon", 12)]),
    ("Calgary", [("Edmonton", 4), ("Regina", 14)]),
    ("Saskatoon", [("Calgary", 9), ("Winnipeg", 20)]),
    ("Regina", [("Saskatton", 7), ("Winnipeg", 4)])
  ]


edmondsKarp :: [Graph] -> Integer
edmondsKarp = undefined
#include <iostream>
module Smv where
-- https://towardsdatascience.com/svm-implementation-from-scratch-python-2db2fc52e5c2

import Linear
import Data.CSV

-- supervised learing algorithm
-- binary classification problem.


module Iterativelog where

import           Debug.Trace


-- iterative logrithm (log star)
-- goes down very fast, so the running time growth very slow.

logStar :: Double -> Double ->  Int
logStar n b = logStar' n b 0
  where
    logStar' n b count | n > 1.0 = logStar' (logBase b n) b (count + 1)
      | otherwise = count

logStar10 :: Double -> Int
logStar10 = flip logStar 10.0

logStar2 :: Double -> Int
logStar2 = flip logStar 2.0

l = logStar10 1000

l' = logStar10 (10^40)

l'' = logStar10 (10^100)
#include "monotonic-iter.hpp"
#include <iostream>
#include <vector>

void monotonic_queue_test() {
  std::vector<int> vec{1, 3, 6, 2, 5, 1, 7, 5, 3, 9, 12};

  auto [mit, mend] = make_monotonic_queue_iterators(vec.begin(), vec.end(), 4,
                                                    monotonic_decreasing());

  for (auto it = mit; it != mend; ++it) {
    auto q = *it;
    for (auto &v : q) {
      std::cout << v << ", ";
    }
    std::cout << "\n";
  }
}

void monotonic_stack_test() {
  std::vector<int> vec{50, 30, 10, 5, 3, 1, 20};

  auto [mit, mend] = make_monotonic_stack_iterators(vec.begin(), vec.end(),
                                                    monotonic_decreasing());

  for (auto it = mit; it != mend; ++it) {
    auto s = *it;
    for (auto &v : s) {
      std::cout << v << ", ";
    }
    std::cout << "\n";
  }
}

int main(void) {
  std::cout << "==== queue ====" << std::endl;
  monotonic_queue_test();

  std::cout << "==== stack ====" << std::endl;
  monotonic_stack_test();
  return 0;
}
#pragma once

#include <assert.h>
#include <deque>
#include <functional>
#include <iostream>
#include <stack>
#include <type_traits>
#include <vector>

// Monotonic queue for sliding window problems.
// find the biggest value in a subsequence
//
// O(n) for querying extrema in an interval. It's better then ST table and segment tree.
//
// The idea is to maintain a deque, and only include elements that are
// `possible` to be the biggest (smallest) value in the subsequence.

struct monotonic_increasing {};
struct monotonic_decreasing {};

template <typename Tag, typename = void>
struct is_monotonic_iterator_tag : std::false_type {};

template <typename Tag>
struct is_monotonic_iterator_tag<
    Tag, std::void_t<std::enable_if_t<
             std::conjunction_v<std::is_same<Tag, monotonic_increasing>,
                                std::is_same<Tag, monotonic_decreasing>>>>>
    : std::true_type {};

template <typename Iter, typename Comp> class monotonic_queue_iterator {
private:
  using T = typename std::iterator_traits<Iter>::value_type;
  std::deque<T> queue;
  size_t win_size;
  Iter first;

  Comp comp;

public:
  using difference_type = void;
  using value_type = std::deque<T>;
  using pointer = std::deque<T> *;
  using reference = std::deque<T> &;
  using const_reference = const std::deque<T> &;
  using iterator_category = std::input_iterator_tag;

  // initialize the first window.
  explicit constexpr monotonic_queue_iterator(Iter first, size_t window_size,
                                              const Comp &comp)
      : win_size(window_size), first(first), comp(comp) {
    auto it = first;
    auto max_it = it;

    for (size_t i = 0; i < win_size; ++i) {
      std::cout << *it << std::endl;
      if (comp(*it, *max_it)) {
        max_it = it;
      }

      if (i < win_size - 1)
        ++it;
    }

    queue.push_back(*max_it);

    if (max_it != it) {
      queue.push_back(*it);
    }
  }

  explicit constexpr monotonic_queue_iterator(Iter first, size_t win_size,
                                              monotonic_decreasing g)
      : monotonic_queue_iterator(
            first, win_size,
            [](const auto &a, const auto &b) { return a > b; }) {}

  explicit constexpr monotonic_queue_iterator(Iter first, size_t win_size,
                                              monotonic_increasing g)
      : monotonic_queue_iterator(
            first, win_size,
            [](const auto &a, const auto &b) { return a < b; }) {}

  constexpr inline friend bool
  operator==(const monotonic_queue_iterator &self,
             const monotonic_queue_iterator &other) noexcept {
    return self.win_size == other.win_size && self.first == other.first;
  }

  constexpr inline friend bool
  operator!=(const monotonic_queue_iterator &self,
             const monotonic_queue_iterator &other) noexcept {
    return !(self == other);
  }

  constexpr inline monotonic_queue_iterator<Iter, Comp> operator++() {
    auto it = ++first;
    std::advance(it, win_size - 1);

    auto qit = queue.rbegin();
    while (!queue.empty() && qit != queue.rend() && *qit < *it) {
      qit++;
    }

    queue.erase(qit.base(), queue.end());
    queue.push_back(*it);

    return *this;
  }

  constexpr inline monotonic_queue_iterator<Iter, Comp> operator++(int) {
    monotonic_queue_iterator tmp(*this);
    ++this;
    return tmp;
  }

  constexpr inline const_reference operator*() const noexcept { return queue; }
  constexpr inline const_reference operator*() noexcept { return queue; }

  constexpr pointer operator->() noexcept {
    return std::addressof(operator*());
  }
};

template <typename Iter, typename Comp, typename Tag,
          typename std::enable_if_t<is_monotonic_iterator_tag<Tag>::value>>
constexpr decltype(auto) make_monotonic_queue_iterators(Iter begin, Iter end,
                                                        size_t window_size,
                                                        Tag tag) {
  return std::make_pair(
      monotonic_queue_iterator{begin, window_size, tag},
      monotonic_queue_iterator{end - window_size + 1, window_size, tag});
}

template <typename Iter, typename Comp>
constexpr decltype(auto) make_monotonic_queue_iterators(Iter begin, Iter end,
                                                        size_t window_size,
                                                        const Comp &comp) {
  return std::make_pair(
      monotonic_queue_iterator{begin, window_size, comp},
      monotonic_queue_iterator{end - window_size + 1, window_size, comp});
}

template <typename Iter, typename Comp>
constexpr decltype(auto) make_monotonic_queue_iterators(Iter begin, Iter end,
                                                        size_t window_size) {
  return std::make_pair(
      monotonic_queue_iterator{begin, window_size, monotonic_decreasing()},
      monotonic_queue_iterator{end - window_size + 1, window_size,
                               monotonic_decreasing()});
}

template <typename C, typename Comp>
constexpr decltype(auto) make_monotonic_queue_iterators(C container,
                                                        size_t window_size,
                                                        const Comp &comp) {

  return std::make_pair(
      monotonic_queue_iterator{std::begin(container), window_size, comp},
      monotonic_queue_iterator{std::end(container) - window_size + 1,
                               window_size, comp});
}

template <typename Iter, typename Tag>
monotonic_queue_iterator(Iter, size_t, Tag) -> monotonic_queue_iterator<
    Iter, std::function<bool(typename std::iterator_traits<Iter>::value_type,
                             typename std::iterator_traits<Iter>::value_type)>>;

template <typename Iter>
monotonic_queue_iterator(Iter, size_t) -> monotonic_queue_iterator<
    Iter, std::function<bool(typename std::iterator_traits<Iter>::value_type,
                             typename std::iterator_traits<Iter>::value_type)>>;

// monotonic stack
// to solve NGE (next greater element) problem in O(n)
// find the next greater element for all elements.
// stack top is always the closest to the new element. If the new element is
// bigger then the stack top, then it's the NGE of it.

template <typename Iter, typename Comp> class monotonic_stack_iterator {
private:
  using T = typename std::iterator_traits<Iter>::value_type;
  using stack = std::vector<T>;
  Comp comp;
  stack data;
  Iter first;

public:
  using difference_type = void;
  using pointer = stack *;
  using reference = stack &;
  using const_reference = const stack &;
  using value_type = T;
  using iterator_category = std::input_iterator_tag;

  constexpr monotonic_stack_iterator(Iter first, const Comp &comp)
      : comp(comp), data(), first(first) {}

  constexpr monotonic_stack_iterator(Iter first, monotonic_decreasing tag)
      : monotonic_stack_iterator(
            first, [](const auto &a, const auto &b) { return a > b; }) {}

  constexpr monotonic_stack_iterator(Iter first, monotonic_increasing tag)
      : monotonic_stack_iterator(
            first, [](const auto &a, const auto &b) { return a < b; }) {}

  constexpr friend bool operator==(const monotonic_stack_iterator &self,
                                   const monotonic_stack_iterator &other) {
    return self.first == other.first;
  }

  constexpr friend bool operator!=(const monotonic_stack_iterator &self,
                                   const monotonic_stack_iterator &other) {
    return !(self == other);
  }

  constexpr monotonic_stack_iterator<Iter, Comp> operator++() {
    auto it = first++;
    if (data.empty()) {
      data.push_back(*it);
      return *this;
    }

    while (!data.empty() && comp(*it, data.back())) {
      data.pop_back();
    }

    data.push_back(*it);
    return *this;
  }

  constexpr monotonic_stack_iterator<Iter, Comp> operator++(int) {
    monotonic_stack_iterator tmp(*this);
    ++this;
    return tmp;
  }

  constexpr const_reference operator*() { return data; }
  constexpr const_reference operator*() const { return data; }
};

template <typename Iter>
monotonic_stack_iterator(Iter) -> monotonic_stack_iterator<
    Iter, std::function<bool(typename std::iterator_traits<Iter>::value_type,
                             typename std::iterator_traits<Iter>::value_type)>>;

template <typename Iter, typename Tag>
monotonic_stack_iterator(Iter, Tag) -> monotonic_stack_iterator<
    Iter, std::function<bool(typename std::iterator_traits<Iter>::value_type,
                             typename std::iterator_traits<Iter>::value_type)>>;

template <typename Iter, typename Comp>
constexpr decltype(auto) make_monotonic_stack_iterators(Iter begin, Iter end,
                                                        const Comp &comp) {
  return std::pair(monotonic_stack_iterator{begin, comp},
                   monotonic_stack_iterator{end + 1, comp});
}

template <typename Iter, typename Comp, typename Tag,
          typename std::enable_if_t<is_monotonic_iterator_tag<Tag>::value>>
constexpr decltype(auto) make_monotonic_stack_iterators(Iter begin, Iter end,
                                                        Tag tag) {
  return std::pair(monotonic_stack_iterator{begin, tag},
                   monotonic_stack_iterator{end + 1, tag});
}
#include <iostream>
#include <string_view>
#include <vector>
#include <numeric>
#include <type_traits>

// prefix sum on n dimensional array.

// given matrix:
// 1 2 4 3
// 5 1 2 4
// 6 3 5 9

// The prefix sum is:
// 1  3  7  10
// 6  9  15 22
// 12 18 29 45


template <typename T>
void print_vec(std::string_view msg, const std::vector<T> &vec) {
  std::cout << msg;
  for (auto & v: vec) {
    std::cout << v << " ";
  }
  std::cout << std::endl;
}

// template prefix sum.
template <typename InIter, typename OutIter>
OutIter prefix_sum(InIter first, InIter last, OutIter out) {
  if (first == last) return out;

  auto sum = *first;
  *out = sum;

  while (++first != last) {
    sum = std::move(sum) + *first;
    *++out = sum;
  }

  return ++out;
}

// principle of inclusion/exclusion.
// bascially:
// |A υ B υ C| = |A| + |B| + |C| - |A ∩ B| - |B ∩ C| - |C ∩ A| + |A ∩ B ∩ C|

int main(void)
{
  std::vector<int> vec {5, 3, 4, 8, 10, 2, 19, 7};
  std::vector<int> out {};

  std::partial_sum(std::begin(vec), std::end(vec), std::back_inserter(out));
  print_vec("stl partial sum: ", out);

  out = {};
  prefix_sum(std::begin(vec), std::end(vec), std::back_inserter(out));
  print_vec("prefix sum: ", out);


  return 0;
}
// 1. tree can be encoded in linear from
// 2. with array and certain indexing decipline we can random access
//    an n-ary tree
// 3. for a parse tree we can encode them in as polish, reverse
//    polish, or infix tree, and they represent three travsersal
//    of the tree respectively.
//
// Note: infix to post fix: shunting yard.

#include <functional>
#include <iostream>
#include <sstream>
#include <stack>
#include <string>
#include <unordered_map>
#include <vector>

std::unordered_map<std::string, std::function<double(double, double)>> ops = {
    {"+", [](double a, double b) { return a + b; }},
    {"-", [](double a, double b) { return a - b; }},
    {"*", [](double a, double b) { return a * b; }},
    {"/", [](double a, double b) { return a / b; }},
};

double reverse_polish_eval(std::vector<std::string> tokens) {
  std::stack<std::string, std::vector<std::string>> stack{};

  for (auto &tok : tokens) {
    if (ops.find(tok) != ops.end()) {
      double v1 = std::stod(stack.top());
      stack.pop();
      double v2 = std::stod(stack.top());
      stack.pop();
      auto op = ops[tok];
      stack.push(std::to_string(op(v2, v1)));
    } else {
      stack.push(tok);
    }
  }

  return std::stod(stack.top());
}

std::vector<std::string> split(std::string input) {
  std::vector<std::string> vec{};
  std::stringstream ss;

  bool up = false;

  input.append(";");
  for (auto &v : input) {
    if (v == '\n' || v == '\r' || v == ' ') {
      up = true;
      continue;
    } else {
      if (up) {
        vec.push_back(ss.str());
        ss.str("");
      }
      ss << v;
    }
  }

  return vec;
}

int main(void) {

  auto v = split("7 2 3 + -");
  auto r = reverse_polish_eval(v);
  std::cout << "value is: " << r << std::endl;

  return 0;
}
(* SECD invented by john peter ladin in 1964
 * stands for Stack Environment Control Dump.
 * It's an stack based abstract machine intended as a
 * target for * functional languages compilers.
 *
 *
 * *)



module type Stack = sig
  type 'a t
  val empty : unit -> 'a t
  val is_empty : 'a t -> bool
  val pop : 'a t -> 'a t
  val push : 'a -> 'a t -> 'a t
  val peek : 'a t -> 'a
end

(* presistent stack *)
module ListStack = struct
  type 'a t = 'a list
  let empty () = []
  let is_empty s = s = []
  let pop = function
    | x::xs -> xs
    | [] -> failwith "Empty"
  let push x s = x::s
  let peek = function
    | x::xs -> x
    | [] -> failwith "Empty"
end

module L = ListStack
(* unfication algorithm *)

type id = string

(* dummy syntax tree
 * It can be type expression for type inference or
 * be term expression for pattern matching.
 * *)
type term =
  | Var of id
  | Term of id * term list

(* invariants for substitution *)
type substitution = (id * term) list

(* check if a variable occurs in a term *)
let rec occurs (x : id) (t : term) : bool =
  match t with
  | Var y -> x = y
  | Term (_, s) -> List.exists (occurs x) s

(* substitue term for all occurrences of variables x in term t *)
let rec subst (s : term) (x : id) (t : term) : term =
  match t with
  | Var y -> if x = y then s else t
  | Term (f, u) -> Term (f, List.map (subst s x) u)

(* apply a substitution right to left *)
let apply (s : substitution) (t : term) : term =
  List.fold_right (fun (x, u) -> subst u x) s t

(* unify one pair *)
let rec unify_one (s : term) (t : term) : substitution =
  match (s, t) with
  | (Var x, Var y) -> if x = y then [] else [(x, y)]
  | (Term (f, sc), Term (g, tc)) ->
      if f = g && List.length sc = List.length tc
      then unit (List.combine sc tc)
      else failwith "not unifiable: head symbol conflict"
  | (Var x, (Term (_, _) as t)) | ((Term (_, _) as t, Var x)) ->
      if occurs x t
      then failwith "not unifiable: circularity"
      else [(x, t)]

    and unify (s : (term * term) list) : substitution =
      match s with
      | [] -> []
      | (x, y) :: t ->
          let t2 = unify t in
          let t1 = unify_one (apply t2 x) (apply t2 y) in
          t1 @ t2
;; randomized select.


(* test some continuations *)

(* straightforward continuation *)
let rec sum1 s =
  match s with
      [] -> 0
    | x::xs -> x + (sum1 xs)

(* tail recursion *)
let rec sum2 s =
  let rec sum' s a =
    match s with
        [] -> a
      | x::xs -> sum' xs (a + x) in
  sum' s 0

(* using continuation *)
(* (\a2 (\a1 -> (\a0 -> (id 0) + a0) (x1 + a1)) (x2 + a2)) x3
 * => (\a1 -> (\a0 -> (id 0) + a0) (x1 + a1)) (x2 + x3)
 * => (\a0 -> (id 0) + a0) (x1 + (x2 + x3))
 * => (id 0) + (x1 + (x2 + x3))
 * => 0 + x1 + x2 + x3
 *
 * which is equivalent to
 * (\x -> x) . (\a -> x1 + a) . (\x -> x2 + a)l ...
 *
 * Although it's tail recursion, it needs to remember the closure of the
 * previous continuation, so it doesn't really save any sapce comparing with
 * straight recurison.
 *)
let rec sum3 s =
  let rec sum' s k =
    match s with
        [] -> k 0
      | x::xs -> sum' xs (fun a -> k (x + a))
  in sum' s (fun x -> x)

  (* stack overflow direclty *)
let rec inf = 0::inf in
  sum1 inf

  (* no problem *)
let rec inf = 0::inf in
  sum2 inf

  (* Will not stack overflow at least.
   * but will keep running until no more memory left
   * *)
let rec inf = 0::inf in
  sum3 inf


(* some more examples *)

let rec fold_right1 (f : 'a -> 'b -> 'b) (s : 'a list) (b : 'b) : 'b =
  match s with
     [] -> b
   | x::xs -> f x (fold_right1 f xs b)

(* no stack allocatin at all, since they are tail eliminated.
 * But now we have to store the closure somewhere.
 * It's still deferred calculation.
 * *)
let rec fold_right2 (f : 'a -> 'b -> 'b) (s : 'a list) (b : 'b) : 'b =
  let rec fold_right' s k =
    match s with
       [] -> k b
     | x::xs -> fold_right' xs (fun a -> k (f x a))
  in fold_right' s (fun x -> x)

(* strasen algorithm
 * Use some quite non straight forward tricks to reduce the running
 * time of matrix multiplication frm O(N^3) to O(N^2.8)...
 * TODO
 * *)
module Manacher where

module ACAutomata where

-- trie + kmp.
#include <iostream>
#include <iostream>

// TODO
#include <iostream>

// TODO
module Kmp1 where

import           Data.Array (Array, bounds, listArray, (!))

-- Knuth Morris Pratt algorithm.
{-@ Motivation:
  A brute force searching for the position of a substring pat
  in a given string txt has time complexity O(k.n) where k is
  the length of pat, n is the length of the text.
  If k and n are close then basically you have O(n^2).

  KMP has two stages: build jump table and match.
  building the table is O(k), and matching is O(n). Thus
  the final worse case complexity is O(k) + O(n), this can
  be considered as linear.

  Jump table is also called longest prefix suffix (lps). It
  stores the lenght of the maximum proper prefix that is also
  a sufix. (can't be the entire string)

  Jump table of s ::= {x | x is proper prefix of s &&
                           x is proper suffix of s   }
@-}

-- e.g
-- Jump table of string pat = "abxab":
--  a  b  x  a  b
--  0  0  0  1  2
--
-- Jump table of string pat = "aaabcaa":
--  a  a  a  b  c  a  a
--  0  0  0  0  0  1  2

data Table a = Table
 { word      :: Array Int a
 , jumpTable :: Array Int Int
 , len       :: Int
 }

type MatchState = Int

-- build kmp table O(n)
build :: Eq a => [a] -> Table a
build pattern = table
  where
    len = length pattern
    table = Table
      { word      = listArray (0, len - 1) pattern
      , jumpTable = listArray (-1, len - 1) $ (-2) : genJump (-1) 0
      , len       = len
      }

    pred a b c =  len == a ||
              word table ! b /= word table ! c

    genJump _ 0 =
      let o = if pred 1 0 1 then -1 else -2
          later = genJump (-1) 1
       in o : later

    genJump lastMPJump i =
      let ch = word table ! i
          findJ j
            | j == -2 = -2
            | word table ! (j + 1) == ch = j
            | j == -1 = -2
            | otherwise = findJ (jumpTable table ! j)
          j = findJ lastMPJump

          o = if pred (i + 1) (i + 1) (j + 2)
                 then j + 1
                 else jumpTable table ! (j + 1)

          later  = genJump (j+1) (i+1)
       in o:later

matchOne :: Eq a => Table a -> MatchState -> a -> (Bool, MatchState)
matchOne table j s
  | hasFind  = (j + 1 == len table, j + 1)
  | otherwise = matchOne table (1 + (jumpTable table ! (j - 1))) s
  where
    hasFind = j < 0 || j < len table && s == word table ! j

match :: Eq a => Table a -> [a] -> [Int]
match table str = [ 0 | len table == 0 ] ++ go (1 - len table) 0 str
  where
        go _ _ [] = []
        go i j (x:xs) = case matchOne table j x of
                             (False, j') -> go (i + 1) j' xs
                             (True, j')  -> i : go (i + 1) j' xs

-- with the jump table created, we can start to match for pattern.
-- still use "abxab" as an example, the jump table is
--  |a b x a b
--  |0 0 0 1 2
--  case:
--     |abxababxab
--     |abxab       -> [0]
--    1. the first match matched unitl index 4, so we look up the jump
--       table [4] to know how many characters to jump.
--    2. In this case is 2, this means we should align pat[2]
--       with the next character
--     |abxababxab
--     |   abxab
--    3. Try to match again, now we match successfully until pat[1].
--       jumptable[1] = 0, so align pat[0] with the next char.
--     |abxababxab
--     |     abxab  -> [0, 5]
--    4. Find another match, end.
module Nfa2dfa where

-- TODO

-- converting from non deterministic finite automato to
-- deterministic finite automata.

#include <iostream>

// TODO
#include <iostream>

// TODO
module SuffixArray where

-- suffix array
module SuffixAutomaton where


#include <iostream>

template <typename T> class Trie {};

int main(void) { return 0; }
module Trie where

-- trie is also an automata.
module Zfunction where

-- extension of KMP.

module Fingertree where

-- probably the most widely used functional data structure.
--
-- Checkout the Complexity:
--  because the depth of finger tree normally is small, Ologn can
-- be regarded as const time for most of the time.
--      operation                       normal        amortized
-- head :: Seq a -> a                    O(1)           O(1)
-- tail :: Seq a -> Seq a                O(logn)        O(1)
-- cons :: a -> Seq a -> Seq a           O(logn)        O(1)
-- last :: Seq a -> a                    O(1)           O(1)
-- init :: Seq a -> Seq a                O(logn)        O(1)
-- snoc :: Seq a -> a -> Seq a           O(logn)        O(1)
-- (++) :: Seq a -> Seq a -> Seq a       O(logn)        O(logn)
-- (!!) :: Seq a -> Int -> a             O(logn)        O(logn)
--
-- Ok I spent way too long to draw this, and it's not 100% correct...
-- A finger tree looks like:
-- where the head and the tail can be accessed in constant time.
-- http://www.staff.city.ac.uk/~ross/papers/FingerTree.html

data Digit a = One a | Two a a | Tree a a a | Four a a a a

data Node a = Node2 a a | Node3 a a a

data FingerTree a = Empty
                  | Unit a
                  | More (Digit a) (FingerTree (Node a)) (Digit a)
module RBTree where


{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE DerivingVia        #-}

module TreeZipper where

import qualified Control.Monad (ap)
import           GHC.Generics  (Generic)

{-@ Zipper for tree
    Zipper for list is simple, but how does it work for a  tree?
    For a list zipper, our element is a node, and the context is the
    left hand side and the right hand size of the node. like this:
    x x x x _ x x x x
            ^
    where ^ points to our focus. This is simple because a focus can only
    have one possible predecessor and one successor.

    Now imagine a tree as an element and one hole cotext.
             a                          a
           /   \                      /   \
          b      e                   b     e
        /   \        ->        +   /   \
       c     d              c     _     d
     / ^\     \           / ^ \          \
    x    x     x         x     x          x

    where c is the current focus. How do we encode this as focus and
    context?
    c is the left child of b, and it has a sibling tree d.
    First, to get the full context, we must know the sibling d.
    And because we want to access c's children, the entire c tree should be kept.
@-}

data BinaryTree a = Leaf
                  | Branch a (BinaryTree a) (BinaryTree a)
  deriving (Eq, Ord)

instance Show a => Show (BinaryTree a) where
  show t = ":-" <> prettyPrintTree t 0

prettyPrintTree ::  Show a => BinaryTree a -> Int -> String
prettyPrintTree Leaf _ = " _"
prettyPrintTree (Branch node left right) spaces =
  " " ++ show node ++ "\n" ++
  indent ++ ":-" ++ prettyPrintSub left ++
  indent ++ ":-" ++ prettyPrintSub right
  where
    indent = fill (spaces + 4)
    prettyPrintSub sub = prettyPrintTree sub (spaces + 4) <> "\n"
    fill = flip replicate ' '

instance Functor BinaryTree where
  fmap _ Leaf           = Leaf
  fmap f (Branch x l r) = Branch (f x) (fmap f l) (fmap f r)


-- | The breadcum type for the focus
-- for the following tree, We have TreeLeft x l as the context of b
--      x
--     / \
--    b   (l ...)
data TreeDirection a = TreeLeft a (BinaryTree a)
                     | TreeRight a (BinaryTree a)
                     deriving Show

instance Functor TreeDirection where
  fmap f (TreeLeft x t)  = TreeLeft (f x) (fmap f t)
  fmap f (TreeRight x t) = TreeLeft (f x) (fmap f t)

type TreeDirections a = [TreeDirection a]
-- you might wonder, if each tree direction only give you the parent node,
-- how can you go up further?
-- THe answer is a tree ziper doesn't only hold one tree direction, but a list of
-- it, which sort records how you end up to the current subtree.
-- If you follow the tree direction back, finally you will back to the root.
--                a
--             /    \
--            b       e
--          / 1 \      \
--        c      d      g
--             / 2 \
--            l     m
-- Take the tree above as an example. Say ou started from a, and goes left.
-- At this moment you have  (TreeZipper (tree b) [(TreeLeft a (tree e))]).
-- Now say you go right, so the focus is d you have
--  (TreeZipper (tree d) [(TreeRight b (tree c)) , (TreeLeft a (tree e))])
-- This list of tree diretions maintain the history of moveing down the tree,
-- with the context at that node. With these information you can easily go
-- back up and visit other nodes.

data TreeZipper a = TreeZipper (BinaryTree a) (TreeDirections a)
data MaybeTreeZipper a = IsTZ (TreeZipper a)
                       | NotTZ
                       deriving Show

instance (Show a) => Show (TreeZipper a) where
  show (TreeZipper t bs) = "TreeZipper" <> "\n" <> show t <> "\n" <> show bs

instance Functor TreeZipper where
  fmap f (TreeZipper t bs) =  TreeZipper (fmap f t) ((fmap . fmap) f bs)

toMaybe :: MaybeTreeZipper a -> Maybe (TreeZipper a)
toMaybe (IsTZ t) = Just t
toMaybe NotTZ    = Nothing

fromMaybe :: Maybe (TreeZipper a) -> MaybeTreeZipper a
fromMaybe (Just t) = IsTZ t
fromMaybe Nothing  = NotTZ

-- help guard operation from a normal tree zipper to maybe treezipper.
asMaybeTreeZipper :: (TreeZipper a -> MaybeTreeZipper a) -> MaybeTreeZipper a -> MaybeTreeZipper a
asMaybeTreeZipper _ NotTZ    = NotTZ
asMaybeTreeZipper f (IsTZ t) =  f t

isRoot :: TreeZipper a -> Bool
isRoot (TreeZipper _ []) =  True
isRoot _                 = False

isLeaf :: TreeZipper a -> Bool
isLeaf (TreeZipper Leaf _) = True
isLeaf _                   = False

fromTree :: BinaryTree a -> TreeZipper a
fromTree t = TreeZipper t []

toTree :: TreeZipper a -> BinaryTree a
toTree z = case toRoot z of
             IsTZ (TreeZipper t _) -> t

moveLeft :: TreeZipper a -> MaybeTreeZipper a
moveLeft (TreeZipper (Branch x l r) bs) = IsTZ $ TreeZipper l (TreeLeft x r : bs)
moveLeft (TreeZipper Leaf _) = NotTZ

moveRight :: TreeZipper a -> MaybeTreeZipper a
moveRight (TreeZipper (Branch x l r) bs) = IsTZ $ TreeZipper r (TreeRight x l : bs)
moveRight (TreeZipper Leaf _) = NotTZ

moveUp :: TreeZipper a -> MaybeTreeZipper a
moveUp (TreeZipper t ((TreeLeft x l) : bs)) = IsTZ $  TreeZipper (Branch x l t) bs
moveUp (TreeZipper _ []) = NotTZ

modify :: (a -> a) -> TreeZipper a -> TreeZipper a
modify f (TreeZipper (Branch x l r) bs) = TreeZipper (Branch (f x) l r) bs
modify _ (TreeZipper Leaf bs)           = TreeZipper Leaf bs

set :: a -> TreeZipper a -> TreeZipper a
set a = modify (const a)

attach :: BinaryTree a -> TreeZipper a -> TreeZipper a
attach t (TreeZipper Leaf bs) = TreeZipper t bs
attach _ z                    = z

toRoot :: TreeZipper a -> MaybeTreeZipper a
toRoot (TreeZipper t []) = IsTZ $ TreeZipper t []
toRoot z                 = case moveUp z of
                             IsTZ z' -> toRoot z'
                             NotTZ   -> IsTZ  z

tree = Branch 5
  (Branch 7
    Leaf
    (Branch 3 Leaf Leaf))
  (Branch 10
    (Branch 6 Leaf Leaf)
    Leaf)

z = fromTree tree
module Zipper where

{-@ Zipper
    using zipper to change the focus.
    zipper allows you to traverse the cursor along some data structure
    in a effcient way.

    Imagine a list [1, 2, 3, 4, 5], cursor on 3
    we can view it as: [1, 2] 3 [4, 5], meaning we currently
    focus on 3

    MultiwayTreeZipper is commonly used to represent tree like data like
    DOM, json. etc..

    Motivation:
    Note moving the focus is not a problem in imperative languages at all.
    Take C++ as an example, you have pointer or reference, so you can point
    to what ever element at whatever time you like. If an element is hidden
    in a data structure, once you find it you can create a pointer point to
    that element, then you can refer to the same element with constant time
    all the time.

    But it's not true for immutable data structure. If you have a
    deeply nested haskell tree, and you want to modify a leave node to some
    other value. To do that you need to find the leave by traversing to there,
    copy the entire tree, and substitue that node with modified value.

    Can you do better in haskell? Turns out not really as good as pointer,
    because that's literately the smallest cost you can get for element
    accessing. But there are something you can do to minimize the cost.
    zipper is designed to avoid a full copy of the old tree, and control the
    access time down to constant/logrhtmic time.
@-}



-- implement a list zipper.
-- note, for list [1, 2, 3, 4, 5, 6], you have
-- ListZipper [3, 2, 1] 4 [5, 6]
-- the reason why ls is reversed is that you can access from the element
-- closer to cursor from the beginning, behave like a list.
data ListZipper a = ListZipper [a] a [a] deriving (Eq, Show)

lefts :: ListZipper a -> [a]
lefts (ListZipper l _ _) = l

rights :: ListZipper a -> [a]
rights (ListZipper _ _ r) = r

-- A common pattern is to define your own maybe. This void newtype
-- wrapping and unwrapping.
-- In case if you need to use maybe related function, just provide
-- a map to maybe.
data MaybeListZipper a = IsZ (ListZipper a) | IsNotZ
  deriving (Eq, Show)

-- isZ :: ListZipper a -> MaybeListZipper a
-- isZ = MListsZipper . Just

-- isNotZ :: MaybeListZipper a
-- isNotZ = MListsZipper Nothing

instance Functor ListZipper where
  fmap f (ListZipper l x r) =
    ListZipper (fmap f l) (f x) (fmap f r)

instance Applicative ListZipper where
  pure a = ListZipper (repeat a) a (repeat a)
  (ListZipper l x r) <*> (ListZipper l' x' r') =
    ListZipper (l <*> l') (x x') (r <*> r')

-- list zipper acutally can be implemented more efficiently
-- with an finger tree or something.
toList :: ListZipper a -> [a]
toList (ListZipper l x r) = reverse l <> (x : r)

toListZ :: MaybeListZipper a -> [a]
toListZ IsNotZ  = []
toListZ (IsZ l) = toList l

fromList :: [a] -> MaybeListZipper a
fromList []     = IsNotZ
fromList (x:xs) = IsZ $ ListZipper [] x xs

toMaybe :: MaybeListZipper a -> Maybe (ListZipper a)
toMaybe IsNotZ   = Nothing
toMaybe (IsZ lz) = Just lz

-- function version of constructor. people always make this for some reasons.
-- might be a smart constructor, but since in this case it doesn't check anything
-- it's just a shorthand.
zipper :: [a] -> a -> [a] -> ListZipper a
zipper = ListZipper

fromMaybe :: Maybe (ListZipper a) -> MaybeListZipper a
fromMaybe Nothing   = IsNotZ
fromMaybe (Just ls) = IsZ ls

asZipper :: (ListZipper a -> ListZipper a) -> MaybeListZipper a -> MaybeListZipper a
asZipper f = asMaybeZipper (IsZ . f)

asMaybeZipper :: (ListZipper a -> MaybeListZipper a) -> MaybeListZipper a -> MaybeListZipper a
asMaybeZipper _ IsNotZ  = IsNotZ
asMaybeZipper f (IsZ z) = f z

-- modify the focus
withFocus :: (a -> a) -> ListZipper a -> ListZipper a
withFocus f (ListZipper l x r) = ListZipper l (f x) r

setFocus :: a -> ListZipper a -> ListZipper a
setFocus = withFocus . const

-- nice syntatic sugar. with this you can write a .= 20.
(.=) :: ListZipper a -> a -> ListZipper a
(.=) = flip setFocus

hasLeft :: ListZipper a -> Bool
hasLeft (ListZipper l _ _) = not (null l)

hasRight :: ListZipper a -> Bool
hasRight (ListZipper _ _ r) = not (null r)

-- find from the left and gives you a new zipper focus on the
-- target found.
-- Note: left part has reversed order.
findLeft :: (a -> Bool) -> ListZipper a -> MaybeListZipper a
findLeft p (ListZipper ls x rs) =
  case break p ls of
    (_, []) -> IsNotZ
    (r', x':l') ->
      IsZ (ListZipper l' x' $ reverse r' <> (x : rs))

findRight :: (a -> Bool) -> ListZipper a -> MaybeListZipper a
findRight p (ListZipper l x r) =
  case break p r of
    (_, [])     -> IsNotZ
    (l', x':r') -> IsZ (ListZipper (reverse l' <> (x : l)) x' r')

-- move the zipper left. If no element to the left then wrap.
moveLeftLoop :: ListZipper a -> ListZipper a
moveLeftLoop (ListZipper [] x r) =
  let (x', r') = foldl (\(p, q) z -> (z, p : q)) (x, []) r
   in ListZipper r' x' []
moveLeftLoop (ListZipper (l:ls) x r) = ListZipper ls l (x:r)

-- dual to moveLeftLoop
moveRightLoop :: ListZipper a -> ListZipper a
moveRightLoop (ListZipper l x []) =
  let (x', l') = foldl (\(p, q) z -> (z, p: q)) (x, []) l
   in ListZipper [] x' l'
moveRightLoop (ListZipper l x (r:rs)) = ListZipper (x:l) r rs

-- move one left.
moveLeft :: ListZipper a -> MaybeListZipper a
moveLeft (ListZipper [] _ _)     =  IsNotZ
moveLeft (ListZipper (l:ls) x r) = IsZ (ListZipper ls l (x:r))

-- move one right.
moveRight :: ListZipper a -> MaybeListZipper a
moveRight (ListZipper _ _ [])     = IsNotZ
moveRight (ListZipper l x (r:rs)) = IsZ (ListZipper (x:l) r rs)

-- swap with left element of the cursor.
swapLeft :: ListZipper a -> MaybeListZipper a
swapLeft (ListZipper [] _ _)     = IsNotZ
swapLeft (ListZipper (l:ls) x r) = IsZ $ ListZipper (x:ls) l r

-- dual of swapLeft
swapRight :: ListZipper a -> MaybeListZipper a
swapRight (ListZipper _ _ [])     = IsNotZ
swapRight (ListZipper l x (r:rs)) = IsZ $ ListZipper l r (x:rs)

dropLefts :: ListZipper a -> ListZipper a
dropLefts (ListZipper _ x r) = ListZipper [] x r

dropRights :: ListZipper a -> ListZipper a
dropRights (ListZipper l x _) = ListZipper l x []

-- move left N element. If it's negate move to the right.
moveLeftN :: Int -> ListZipper a -> MaybeListZipper a
moveLeftN n z | n == 0 = IsZ z
  | n < 0 = moveRightN (negate n) z
  | otherwise = asMaybeZipper (moveLeftN (n - 1)) (moveLeft z)

-- dual of moveLeftN
moveRightN :: Int -> ListZipper a -> MaybeListZipper a
moveRightN n z | n == 0 = IsZ z
  | n < 0 = moveLeftN (negate n) z
  | otherwise = asMaybeZipper (moveRightN (n - 1)) (moveRight z)

-- move left n elements. If can't move by n, return the maxium -- number m that the cursor can be moved.
moveLeftN' :: Int -> ListZipper a -> Either Int (ListZipper a)
moveLeftN' n z = moveLeftN'' n z 0
  where
    moveLeftN'' n' z' q | n == 0 = Right z'
      | n < 0 = moveRightN' (negate n') z'
      | otherwise = case moveLeft z' of
                      IsZ zz -> moveLeftN'' (n' - 1) zz (q + 1)
                      IsNotZ -> Left q

moveRightN' :: Int -> ListZipper a -> Either Int (ListZipper a)
moveRightN' n z = moveRightN'' n z 0
  where
    moveRightN'' n' z' q | n' == 0 = Right z
      | n' < 0 = moveLeftN' (negate n') z'
      | otherwise = case moveRight z' of
                      IsZ z'' -> moveRightN'' (n' - 1) z'' (q + 1)
                      IsNotZ  -> Left q

-- index in the zipper.
-- if i > a, move to the right by (i - a)
-- if i <= a, move  to the right
-- [_ _ _ _ _ _ _ _]
--        ^
--            i      : case i > a
--    i              : case i < a
--
nth :: Int -> ListZipper a -> MaybeListZipper a
nth i z
  | i < 0 = IsNotZ
  | otherwise = case moveLeftN' i z of
                  Left a                   -> moveRightN (i - a) z
                  Right (ListZipper l _ _) -> moveLeftN (length l) z

index :: ListZipper a -> Int
index (ListZipper l _ _) = length l

end :: ListZipper a -> ListZipper a
end z = case moveRight z of
          IsNotZ -> z
          IsZ z' -> end z'

start :: ListZipper a -> ListZipper a
start z = case moveLeft z of
            IsNotZ -> z
            IsZ z' -> start z'


{-@ Zipper vs lens
    Zipper and lens looks very similar, but there are good for
    different use cases.

    Lens allows you to compose lens together to access in nested
    data structure, but it can only access the data it "points" to,
    you can't not access the surrouding of the focus.

    Zipper, on the other hand, gives you the ability to access the
    surroudings. In the list zipper case, you can access what's before
    and what's after. Lens doesn't allow you to do that.

    Again, a simple pointer beat all of these, you can pin on one exact
    data with almost no overhead, and do arithmetic on that pointer to
    access the surroundings. Of course if it's not an array but some other
    more complicated data structures, the cost will be higher.
@-}

{-@ Algebra of zipper
    First we know algebraic data type is called algebraic because
    you can do algebra to work out the size of the type.

    - Maybe a -> Nothing | Just a -> 1 + a
    - Either Void a -> _ | Right a -> 0 + a, you can not have Left case.
    - (Void, a) -> 0 * a = 0, this type is not constructable.
      ...

    So take a look at this
    - Either x (x, x)  ->  (x + (x * x))
      d/dx(x + (x * x))  = (1 + (2 * x))
      (1 + (2 * x)) -> Maybe (Bool, x)


    - (Either x x, Either x x) -> (x + x) * (x + x)
      d/dx (x + x) * (x + x) = 8x
      8x -> Maybe bool -> (Bool, x)

    - (x, x, x) -> (x * x * x)
      d/dx (d^3) = 3x^2 -> (Maybe bool, x, x)

    Enough. the point is everytime you differetiante the datatype you
    get a thing that looks like a zipper.

@-}

-- https://www.youtube.com/watch?v=HqHdgBXOOsE
-- https://en.wikibooks.org/wiki/Haskell/Zippers#Differentiation_of_data_types
-- http://hackage.haskell.org/package/list-zipper-0.0.10/docs/src/Data.ListZipper.html#ListZipper
signature BTREE =
sig
  datatype tree  = Leaf | Tree of tree * int * tree;
  val empty : tree
  val insert : (int * tree) -> tree
end

structure Btree : BTREE =
struct
  datatype tree  = Leaf | Tree of tree * int * tree;
  val empty = Leaf

  fun insert (key, Leaf) =  Tree (Leaf, key, Leaf)
    | insert (key, Tree (l, x, r)) =
    if key < x
    then insert (key, l)
    else if key > x
    then insert (key, r)
    else Tree(l, x, r)
end
#include <iostream>
#include <stdio.h>
#include <cstring>
#include <deque>
#include <iostream>
#include <limits>
#include <string>
#include <vector>

enum class Tag { LB = 0, RB, ADD, MINUS, MUL, DIV, NUM, NEG };

struct Token {
  std::string val;
  Tag tag;
};

static bool is_op(const Token &t) {
  return t.tag == Tag::ADD || t.tag == Tag::DIV || t.tag == Tag::MUL ||
         t.tag == Tag::MINUS || t.tag == Tag::NEG;
}

std::vector<Token> lexer(const std::string &input) {
  std::vector<Token> v;
  int pos = 0;

  auto num = [&pos, &input]() -> Token {
    std::vector<char> buf;

    while (std::isdigit(input[pos])) {
      buf.push_back(input[pos]);
      pos++;
    }
    if (input[pos] == '.') {
      buf.push_back('.');
      pos++;

      while (std::isdigit(input[pos])) {
        buf.push_back(input[pos]);
        pos++;
      }
    }

    pos--;
    return Token{std::string(buf.begin(), buf.end()), Tag::NUM};
  };

  while (pos < input.size()) {
    char a = input[pos];

    if (a == ' ') {

    } else if (a == '(') {
      v.push_back(Token{"(", Tag::LB});

    } else if (a == ')') {
      v.push_back(Token{")", Tag::RB});

    } else if (a == '*') {
      v.push_back(Token{"*", Tag::MUL});

    } else if (a == '/') {
      v.push_back(Token{"/", Tag::DIV});

    } else if (a == '+') {
      v.push_back(Token{"+", Tag::ADD});

    } else if (a == '-') {
      // handle head
      auto p = v.back();
      if (is_op(p) || p.tag == Tag::LB || p.tag == Tag::NEG) {
        v.push_back(Token{"-", Tag::NEG});

      } else {
        // parse as minus
        v.push_back(Token{"-", Tag::MINUS});
      }
    } else {
      v.push_back(num());
    }

    pos++;
  }
  return v;
}

static int prec(const Token &t) {
  switch (t.tag) {
  case Tag::NEG:
    return 3;
  case Tag::MUL:
  case Tag::DIV:
    return 2;
  case Tag::ADD:
  case Tag::MINUS:
    return 1;
  default:
    return -1;
  }
}

std::vector<Token> infix_to_postfix(const std::vector<Token> &s) {
  std::vector<Token> stack;
  std::vector<Token> out;

  for (auto it = s.begin(); it != s.end(); ++it) {
    switch (it->tag) {
    case Tag::NUM:
      out.push_back(*it);
      break;

    case Tag::LB:
      stack.push_back(*it);
      break;

    case Tag::NEG:
      stack.push_back(*it);
      break;

    case Tag::RB: {
      while (stack.size() > 0 && stack.back().tag != Tag::LB) {
        out.push_back(stack.back());
        stack.pop_back();
      }

      stack.pop_back();
    }

    break;

    default: {
      if (prec(*it) > prec(stack.back())) {
        stack.push_back(*it);
      } else {
        while (stack.size() > 0 && prec(*it) <= prec(stack.back())) {
          out.push_back(stack.back());
          stack.pop_back();
        }
        stack.push_back(*it);
      }
    }
    }
  }

  while (stack.size() != 0) {
    out.push_back(stack.back());
    stack.pop_back();
  }

  return out;
}

double eval(std::vector<Token> &stack) {
  switch (stack.back().tag) {
  case Tag::ADD: {
    stack.pop_back();
    auto v1 = eval(stack);
    auto v2 = eval(stack);
    return v2 + v1;
  }
  case Tag::MINUS: {
    stack.pop_back();
    auto v1 = eval(stack);
    auto v2 = eval(stack);
    return v2 - v1;
  }
  case Tag::MUL: {
    stack.pop_back();
    auto v1 = eval(stack);
    auto v2 = eval(stack);
    return v2 * v1;
  }
  case Tag::DIV: {
    stack.pop_back();
    auto v1 = eval(stack);
    auto v2 = eval(stack);
    return v2 / v1;
  }
  case Tag::NEG: {
    stack.pop_back();
    auto v = eval(stack);
    return -v;
  }

  case Tag::NUM: {
    double val = std::atof(stack.back().val.c_str());
    stack.pop_back();
    return val;
  }
  default:
    return 0;
  }
}

double calc(std::string expression) {
  auto braced_expression = "(" + expression + ")";
  auto tokens = lexer(braced_expression);
  auto postfix_stack = infix_to_postfix(tokens);

  std::cout << expression << std::endl;

  for (auto &e : postfix_stack) {
    std::cout << e.val << ",   tag: " << static_cast<int>(e.tag) << std::endl;
  }

  auto val = eval(postfix_stack);
  std::cout << val << std::endl;
  return val;
}

int main(void) {
  std::cout << "so:\n" << calc("-7 * -(6 / 3)") << "\n" << std::endl;

  std::cout << "so:\n"
            << calc("2 + 3 * 4 / 3 - 6 / 3 * 3 + 8") << "\n"
            << std::endl;

  std::cout << "so:\n"
            << calc("-63 + 17 - 98 - -53 * 91 * 5 / -53 * -4") << "\n"
            << std::endl;

  std::cout << "so:\n" << calc("-53 * 91 * 5 / -53 * -4") << "\n" << std::endl;

  std::cout << "so:\n" << calc("-53 * 91 * 5 / -53 * -4") << "\n" << std::endl;

  std::cout << "so:\n" << calc("98 - -1 / -53 * -4") << "\n" << std::endl;

  return 0;
}
#include <iostream>

// k dimension tree.
// good performance when node number n >> 2^k.



module SegmentTree where


-- segment tree is used to store prefix sum
#include <concepts>
#include <functional>
#include <iostream>
#include <memory>
#include <optional>
#include <random>
#include <vector>

#define TEST

// Segment tree can be used to maintain information of intervals.
// O(logN) modify single element, modify range, and query in intervals.
// Segment tree is a static data structure, it can't be modified once it's
// built.
// the time complexity to build a segment tree: O(nlogn).
//
// Idea:
// what is interval? A interval is like an edge with two vertices.
// Let S be a set of intervals, and p1, p2, ... pn be endpoints of each
// intervals consecutively. We have intervals in S as:
// (-inf, p1), (p1, p1), (p1, p2), (p2, p2)...(pm, inf)
//
// This intervals can be constructred as a tree with follwoing properties:
//  1. full binary tree.
//  2. leaves represent points.
//  3. internal nodes are folded value of intervals.
//
// Analysis:
//  Index:
//    If represent the tree with an array, let the root node be d[1], then we
//    have left child d[2i], right child d[2i+1].
//
//  Space:
//    let n be number of leaves.
//    binary tree      =>    height = log(n)
//                     =>    # of leaves = 2^(log(n))
//    full binary tree =>    total # of nodes = 2^(log(n) + 1) - 1
//
//  imperical value for n: set length = 4n
//          0-4
//        /    \
//      0-2     3-4
//     /  \     / \
//   0-1   2-2 3-3 4-4
//   /  \   |   |   |
// 0-0  1-1 12 13   14
//  |    |
//  10  11

template <typename C, typename Operator> class SegTree {
private:
  std::vector<typename C::value_type> tree_;
  std::vector<bool> lazy_;
  C data_;
  Operator op;

  void build(typename C::iterator s, typename C::iterator t, size_t p) {
    if (s == t) {
      tree_[p] = *s;
      return;
    }

    auto m = s + ((t - s) >> 1);
    build(s, m, p * 2 + 1);
    build(m + 1, t, p * 2 + 2);

    tree_[p] = op(tree_[p * 2 + 1], tree_[p * 2 + 2]);
  }

public:
  const C &data() { return data_; }

  SegTree(const C &data, Operator op)
      : op(op), data_(data), tree_(4 * data.size()), lazy_(false, data.size()) {

    // note this is a quirk when using iterator as pointer. end is 1 over the
    // last element.
    build(data_.begin(), data_.end() - 1, 0);
  }

  SegTree(C &&data, Operator op)
      : op(op), data_(std::move(data)), tree_(4 * data.size()),
        lazy_(false, data.size()) {
    build(data_->begin(), data_->end() - 1, 0);
  }

  SegTree(SegTree &&seg) = default;
  SegTree(const SegTree &seg) = default;

  SegTree &operator=(const SegTree &seg) {
    SegTree tmp{seg};
    if (this != &seg) {
      tmp.swap(*this);
    }
    return *this;
  }

  SegTree &operator=(SegTree &&seg) {
    if (this != &seg) {
      *this = std::move(seg);
    }
    return *this;
  }

  void swap(SegTree &seg) { std::swap(*this, seg); }

  // range query.
  std::optional<typename C::value_type>
  get_interval_in(auto left, auto right, auto s, auto t, size_t p) {

    static auto update_sum = [this](auto &v, auto &sum) {
      if (v.has_value() && sum.has_value()) {
        sum.emplace(op(v.value(), sum.value()));
      } else if (v.has_value()) {
        sum.emplace(v.value());
      }
    };

    // [left, right] is the search range.
    // [s, t] is the current range.

    if (left <= s && t <= right) {
      return {tree_[p]};
    }

    std::optional<typename C::value_type> sum, v1, v2;
    auto m = s + ((t - s) >> 1);

    if (left <= m) {
      v1 = get_interval_in(left, right, s, m, p * 2 + 1);
      update_sum(v1, sum);
    }
    if (right > m) {
      v2 = get_interval_in(left, right, m + 1, t, p * 2 + 2);
      update_sum(v2, sum);
    }
    return sum;
  }

  typename C::value_type get_interval(typename C::iterator left,
                                      typename C::iterator right) {
    return get_interval_in(left, right, data_.begin(), std::prev(data_.end()),
                           0)
        .value();
  }

  typename C::value_type get_interval(size_t left, size_t right) {
    return get_interval_in(data_.begin() + left, data_.begin() + right,
                           data_.begin(), std::prev(data_.end()), 0)
        .value();
  }

  // range update with lazy propagation.
  void update_in(auto left, auto right, auto f, auto s, auto t) {
    // TODO
  }

  void update(typename C::iterator left, typename C::iterator right, auto f) {
    return update_in(left, right, f, data_.begin(), std::prev(data_.end()));
  }

  void update(size_t left, size_t right, auto f) {
    return update_in(data_.begin() + left, data_.begin() + right, f,
                     data_.begin(), std::prev(data_.end()));
  }

#ifdef TEST
  void dump() {
    std::cout << "Dumping..." << std::endl;
    std::cout << "data: " << std::endl;
    for (auto &v : data_) {
      std::cout << v << " ";
    }
    std::cout << "\n";
    std::cout << "tree: " << std::endl;
    for (auto &v : tree_) {
      std::cout << v << " ";
    }
    std::cout << "\n";
  }
#endif
};

int main(void) {

  {

    std::vector<int> data1{10, 11, 12, 13, 14};
    SegTree seg1{data1, [](auto a, auto b) { return a + b; }};
    seg1.dump();

    SegTree seg2 = seg1;
    seg2.dump();

    SegTree seg3{data1, [](auto a, auto b) { return a * b; }};
    seg3.dump();
  }

  {
    std::vector<int> data;

    std::random_device rng;
    std::mt19937 gen(rng());
    std::uniform_int_distribution<int> dist;

    for (int i = 0; i < 100; ++i) {
      auto value = abs(dist(gen)) % 100;
      data.push_back(value);
    }

    SegTree seg{data, [](auto a, auto b) { return a + b; }};
    seg.dump();
  }

  {
    std::cout << "== interval test ==" << std::endl;
    std::vector<int> data1{10, 11, 12, 13, 14};
    SegTree seg1{data1, [](auto a, auto b) { return a + b; }};
    seg1.dump();

    // check all ranges.
    for (int i = 0; i < data1.size(); ++i) {
      for (int j = i; j < data1.size(); ++j) {
        auto v = seg1.get_interval(i, j);
        std::cout << "(" << i << ", " << j << "): " << v << " " << std::endl;
      }
    }
  }

  return 0;
}
#include <iostream>

template <typename T> class SplayTree {};
module SplayTree where


(* -https://www.cs.cornell.edu/courses/cs3110/2011sp/Recitations/rec25-splay/splay.htm
 * *)

signature ORDERED_FUNCTIONAL_SET = sig
  type key
  type elem
  type set

  val compare: key * key -> order
  val keyOf : elem -> key
  val empty : unit -> set
  val add : set * elem -> set * bool
  val remove : set * key -> set * key option
  val lookup : set * key -> elem option
  val size : set -> int

  val first : set -> elem option
  val last : set -> elem option
  type 'b folder = ((elem * 'b) -> 'b) -> 'b -> key -> set -> 'b
  val fold_backward : 'b folder
  val fold_forward : 'b folder

  val print : set -> unit
end

signature ORDERED_SET_PARAMS = sig
  type key
  type elem
  val keyOf : elem -> key
  val compare : key * key -> order
  val toString : elem -> string
end


functor SplayTree(structure Params : ORDERED_SET_PARAMS)
  :>ORDERED_FUNCTIONAL_SET where type key = Params.key and
                                 type elem = Params.elem =
struct
  type key = Params.key
  type elem = Params.elem
  val compare = Params.compare
  val keyOf = Params.keyOf

  datatype tree = Empty
                | Node of tree * elem * tree

  type node = tree * elem * tree

end
module Treecentroid where

-- tree decomposition.
-- (separator decomposition)

-- the centroid of a tree.
-- the vertex that if it's removed from the tree, the
-- tree will split into a forest such that any tree in the forest
-- would have at most half the numberof vertices in the original
-- tree.
--
-- Centroid:
--    define S(v) be the sive of subtree rooted at node v.

--
--              0
--             / \
--            O   O
--           / \   \
--          0   0   0
--
#include "x86-simulator.h"

int main(void) {

_start:

  push('H');
  call(_push_char);

  push('e');
  call(_push_char);

  push('l');
  call(_push_char);

  push('l');
  call(_push_char);

  push('o');
  call(_push_char);

  push('\n');
  call(_push_char);

  jmp(_end);

_push_char:
  // prologue
  push(&r.rbp);
  move(&r.rbp, &r.rsp);
  sub_reg_const(&r.rsp, 8);
  push(&r.rdi);
  push(&r.rsi);

  // body
  move(&r.rax, Address{r.rbp + 8});
  printf("%c", r.rax);

  // epilogue
  pop(&r.rsi);
  pop(&r.rdi);
  move(&r.rsp, &r.rbp);
  pop(&r.rbp);
  ret;

_end:

  return 0;
}
#include "x86-simulator.h"


int main(void)
{

loop:
  cmp_reg_const(&r.rcx, 10);
  jge(endloop);
  std::cout << (r.rcx) << std::endl;
  inc(&r.rcx);

  jmp(loop);
endloop:

  return 0;
}
#include "x86-simulator.h"

int main(void) {

loop:
  cmp_reg_const(&r.rcx, 10);
  jge(endloop);
  std::cout << (r.rcx) << std::endl;
  inc(&r.rcx);

  jmp(loop);
endloop:

  return 0;
}
#ifndef X86_SIMULATOR_
#define X86_SIMULATOR_ value

// simulate c calling convention
// It's just a rough simulation.
// assume it's a 64 bit machine

#include <cstring>
#include <functional>
#include <inttypes.h>
#include <iostream>

// we have three segemetations
// ------------
// Stack 0          grow down
// ------------
// Heap 128 * 7 - 1 grow up
// ------------
// Data 128 * 7

#define STACK_BASE 256 * 8
#define HEAP_BASE 256 * 4
#define DATA_BASE 256
#define TEXT_BASE 0

// status register
struct CCR {
  int EM1 : 1;
  int EM2 : 1;
  int EM3 : 1;

  int X : 1; // extended
  // note:
  // There is no sign in two's complement system
  // what so ever. V and C have different meaning
  // depends on how you interpret your number.

  int N : 1; // sign flag
  int Z : 1; // zero
  int V : 1; // overflow
  int C;     // carry bit, we don't touch this
};

struct Register {
  // no ip reg.
  size_t rip;
  uint64_t rsp;
  uint64_t rbp;
  uint64_t rax;
  uint64_t rbx;
  uint64_t rcx;
  uint64_t rdx;
  uint64_t rsi;
  uint64_t rdi;
  CCR ccr;
};

static Register regfile{.rip = 0,
                        .rsp = STACK_BASE,
                        .rbp = STACK_BASE,
                        .rax = 0,
                        .rbx = 0,
                        .rcx = 0,
                        .rdx = 0,
                        .rsi = 0,
                        .rdi = 0,
                        .ccr = CCR{}};
struct Address {
  uint64_t address;
};

// for simplicity,
// we have in total 256 addresses
static char memory[256 * 8];

#define r regfile
#define m memory
// instructions
// we use intel convention, so all instructions has
// their destination on the left.

void move(uint64_t *reg1, uint64_t *reg2) { *reg1 = *reg2; }
void move(uint64_t *reg1, Address addr) { *reg1 = memory[addr.address]; }
void move(uint64_t addr, uint64_t *reg2) { memory[addr] = *reg2; }
void move(uint64_t *reg1, const uint64_t val) { *reg1 = val; }
void move(uint64_t addr, const uint64_t val) { memory[addr] = val; }

void swap_endianess(uint64_t val) {
  unsigned char *bytes = reinterpret_cast<unsigned char *>(&val);
  for (int i = 0; i < sizeof(val); i += 2) {
    unsigned char temp = std::move(bytes[i]);
    bytes[i] = std::move(bytes[sizeof(val) - i]);
    bytes[sizeof(val) - i] = temp;
  }
}

// push
// rsp-4 <- val
void push(uint64_t *reg) {
  regfile.rsp -= 8;
  swap_endianess(*reg);
  memcpy(memory + regfile.rsp, reg, sizeof(uint64_t));
}
void push(Address addr) {
  regfile.rsp -= 8;
  swap_endianess(*(memory + addr.address));
  memcpy(memory + regfile.rsp, (memory + addr.address), sizeof(uint64_t));
}
void push(const uint64_t val) {
  swap_endianess(val);
  regfile.rsp -= 8;
  memcpy(memory + regfile.rsp, &val, sizeof(uint64_t));
}

// pop
// rsp+4 -> val
void pop(uint64_t *reg) {
  auto old_rsp = regfile.rsp;
  regfile.rsp += 8;
  memcpy(reg, memory + old_rsp, sizeof(uint64_t));
}

void pop(Address addr) {
  auto old_rsp = regfile.rsp;
  regfile.rsp += 8;
  memcpy(memory + addr.address, memory + old_rsp, sizeof(uint64_t));
}

// lea
// only load the effective address
// reg <- mem
void lea(uint64_t *reg, Address addr) { *reg = addr.address; }

#define SET_CCR_Z(from)                                                        \
  if (from == 0) {                                                             \
    regfile.ccr.Z = 1;                                                         \
  } else {                                                                     \
    regfile.ccr.Z = 0;                                                         \
  }

// reg reg
static std::function<void(uint64_t *, uint64_t *)>
mk_binop_reg_reg(std::function<uint64_t(uint64_t, uint64_t)> op) {
  return [=](uint64_t *reg1, uint64_t *reg2) {
    std::memset(&regfile.ccr, 0, sizeof(regfile.ccr));
    *reg1 = op(*reg1, *reg2);
    SET_CCR_Z(*reg1);
  };
}

// reg addr
static std::function<void(uint64_t *, Address)>
mk_binop_reg_addr(std::function<uint64_t(uint64_t, uint64_t)> op) {
  return [=](uint64_t *reg, Address addr) {
    std::memset(&regfile.ccr, 0, sizeof(regfile.ccr));
    *reg = op(*reg, memory[addr.address]);
    SET_CCR_Z(*reg);
  };
}

// addr reg
static std::function<void(Address, uint64_t *)>
mk_binop_addr_reg(std::function<uint64_t(uint64_t, uint64_t)> op) {
  return [=](Address addr, uint64_t *reg) {
    std::memset(&regfile.ccr, 0, sizeof(regfile.ccr));
    memory[addr.address] = op(memory[addr.address], *reg);
    SET_CCR_Z(memory[addr.address]);
  };
}

// reg const
static std::function<void(uint64_t *, const uint64_t)>
mk_binop_reg_const(std::function<uint64_t(uint64_t, uint64_t)> op) {
  return [=](uint64_t *reg, const uint64_t val) {
    std::memset(&regfile.ccr, 0, sizeof(regfile.ccr));
    *reg = op(*reg, val);
    SET_CCR_Z(*reg);
  };
}

// mem const
static std::function<void(Address, const uint64_t)>
mk_binop_addr_const(std::function<uint64_t(uint64_t, uint64_t)> op) {
  return [=](Address addr, const uint64_t val) {
    memory[addr.address] = op(memory[addr.address], val);
    SET_CCR_Z(memory[addr.address]);
  };
}

// when we call this functions our ccr is always clear.
static auto add_ = [](uint64_t a, uint64_t b) {
  auto result = a + b;
  if (a > 0 && b > 0 && result < 0) {
    regfile.ccr.V = 1;
  }
  regfile.ccr.N = (result < 0);
  return result;
};

static auto sub_ = [](uint64_t a, uint64_t b) {
  auto result = a - b;
  if (a < 0 && b < 0 && result > 0) {
    regfile.ccr.V = 1;
  }
  if (a > b) {
    regfile.ccr.C = 1;
  }
  return result;
};

static auto and_ = [](uint64_t a, uint64_t b) { return a & b; };
static auto or_ = [](uint64_t a, uint64_t b) { return a | b; };
static auto xor_ = [](uint64_t a, uint64_t b) { return a ^ b; };
static auto nor_ = [](uint64_t a, uint64_t _) { return !a; };
static auto shl_ = [](uint64_t a, uint64_t b) { return a << b; };
static auto shr_ = [](uint64_t a, uint64_t b) { return a >> b; };

// cmp perform sub but only use the side effect.
auto cmp_ = [](uint64_t a, uint64_t b) {
  sub_(a, b);
  return a; // do nothing
};

// add
auto add_reg_reg = mk_binop_reg_reg(add_);
auto add_reg_addr = mk_binop_reg_addr(add_);
auto add_addr_reg = mk_binop_addr_reg(add_);
auto add_reg_const = mk_binop_reg_const(add_);
auto add_addr_const = mk_binop_addr_const(add_);

// sub
auto sub_reg_reg = mk_binop_reg_reg(sub_);
auto sub_reg_addr = mk_binop_reg_addr(sub_);
auto sub_addr_reg = mk_binop_addr_reg(sub_);
auto sub_reg_const = mk_binop_reg_const(sub_);
auto sub_addr_const = mk_binop_addr_const(sub_);

// and
auto and_reg_reg = mk_binop_reg_reg(and_);
auto and_reg_addr = mk_binop_reg_addr(and_);
auto and_addr_reg = mk_binop_addr_reg(and_);
auto and_reg_const = mk_binop_reg_const(and_);
auto and_addr_const = mk_binop_addr_const(and_);

// or
auto or_reg_reg = mk_binop_reg_reg(or_);
auto or_reg_addr = mk_binop_reg_addr(or_);
auto or_addr_reg = mk_binop_addr_reg(or_);
auto or_reg_const = mk_binop_reg_const(or_);
auto or_addr_const = mk_binop_addr_const(or_);

// xor
auto xor_reg_reg = mk_binop_reg_reg(xor_);
auto xor_reg_addr = mk_binop_reg_addr(xor_);
auto xor_addr_reg = mk_binop_addr_reg(xor_);
auto xor_reg_const = mk_binop_reg_const(xor_);
auto xor_addr_const = mk_binop_addr_const(xor_);

// cmp
auto cmp_reg_reg = mk_binop_reg_reg(cmp_);
auto cmp_reg_addr = mk_binop_reg_addr(cmp_);
auto cmp_reg_const = mk_binop_reg_const(cmp_);
auto cmp_addr_reg = mk_binop_addr_reg(cmp_);

auto shl_reg_const = mk_binop_addr_reg(shl_);
auto shl_addr_const = mk_binop_addr_const(shl_);

auto shr_reg_const = mk_binop_addr_reg(shr_);
auto shr_addr_const = mk_binop_addr_const(shr_);

void inc(uint64_t *reg) { (*reg)++; }
void inc(Address addr) { memory[addr.address]++; }
void dec(uint64_t *reg) { (*reg)--; }
void dec(Address addr) { memory[addr.address]--; }
void not_(uint64_t *reg) { *reg = ~(*reg); }
void not_(Address addr) { memory[addr.address] = ~memory[addr.address]; }

#define jmp(label) goto label
#define je(label)                                                              \
  if (regfile.ccr.Z != 0) {                                                    \
    goto label;                                                                \
  }

#define jne(label)                                                             \
  if (regfile.ccr.Z == 0) {                                                    \
    goto label;                                                                \
  }

#define jz(label)                                                              \
  if (regfile.ccr.Z == 0) {                                                    \
    goto label;                                                                \
  }

#define jg(label)                                                              \
  if (regfile.ccr.C == 1 && regfile.ccr.N != 0) {                              \
    goto label;                                                                \
  }

#define jge(label)                                                             \
  if (regfile.ccr.C == 1) {                                                    \
    goto label;                                                                \
  }

#define jl(label)                                                              \
  if (regfile.ccr.C != 1 && regfile.ccr.N != 0) {                              \
    goto label;                                                                \
  }

#define jle(label)                                                             \
  if (regfile.ccr.C != 1) {                                                    \
    goto label;                                                                \
  }

#define CONCAT_(x, y) x##y
#define CONCAT(x, y) CONCAT_(x, y)

// push current ip
//
// Note && to get the address of label is
// a gnu extension

#define call_(label, counter)                                                  \
  push((const uint64_t) && CONCAT(label, counter));                            \
  goto label;                                                                  \
  CONCAT(label, counter) :

#define call(label) call_(label, __COUNTER__)

#define ret                                                                    \
  pop(&regfile.rip);                                                           \
  goto *regfile.rip;

// you can use the c calling convention
// the convention comprises two parts for caller and callee rrspectively.
//
#endif /* ifndef X86_SIMULATOR_ */
(* Continuation: A function that express what to do next
 * *)

(* Though we have lots of anonymous values (lambdas, for example), what
 * the compiler really want is everything has a name and can be referred easily
 * by a table lookup. *)

(* CPS makes every part of control flow and data flow explicit. *)

module Prime = struct
  let rec iota l r : int list =
    l :: if l = r then [] else iota (l + 1) r
  exception E
  let isprime n =
    if n = 2 || n = 3 then true
    else if n < 2 || n mod 2 = 0 then false
    else
    let r = n |> float_of_int |> sqrt |> Float.floor |> int_of_float |> (fun x -> x + 1) in
    let result = ref true in
    (iota 2 r) |> (List.iter (fun x -> if n mod x = 0 then result := false else ()));
    !result
end


module DoPrimes = struct
(* Straight version
 * prodprimes has
 *   1. a return address k,
 *   2. a return value b of type bool,
 * in the second if clause we have two points:
 *   1. a point j: j p  = n * prodprimes (n - 1)
 *   2. a point h: h q = prodprimes (n - 1)
 * *)
let rec prodprimes n =
  if n = 1
  then 1
  else if Prime.isprime n
  then n * prodprimes (n - 1)
  else prodprimes (n - 1)

let isprime n k =  k (Prime.isprime n)

(* CPS transformed version
 * return just act like a function call.
 * Keep track of all control points it exposes.
 *
 * All control points are just functions, and all data labels are just
 * variables.
 * *)
let rec prodprimes' n c =
  if n = 1
  then c 1
  else
    let k = fun b ->
      if b = true
      then
        let j = fun p ->
          let a = n * p in c(a) in
        let m = n - 1 in
        prodprimes' m j
      else
        (* continuation being id indicates a tail call.
         * Because we can use c wherever h is used.
         * *)
        let h = fun q -> c(q) in
        let i = n - 1 in
        prodprimes' i h
    in isprime n k
end

(* CPS as IR has multiple advantages *)

(* NOTE: CPS for Inline expansion:
 * For CPS all paramters to functions are variables or constants,
 * never non trivial subexpression.
 * This avoid the problem the conflict of beta subsitution and strict evaluation
 * order.
 * *)

(* NOTE: CPS for closure reprensentation:
  * has nested scope in nature. It will be hard to represent the same notion with
  * say, SSA since there is no concept of nested scope in it's original form.
  * *)

(* NOTE: CPS for dataflow analysis:
 * We want the presentation shows the control flow faithfully.
 *)

(* NOTE: CPS for register allocation:
 * We want a good representation of the lifetime of a variable. (liveness analysis)
 * *)

let _ = DoPrimes.prodprimes' 10 (fun x -> Printf.printf "%d\n" x)
module CPS = struct
  type var
  type value =
    Var of var
  | Label of var
  | Int of int
  | Real of string
  | String of string

  type accesspath =
    Off of int
  | Sel of int * accesspath

  type primop = Add | Minus | Mul | Div | Gt | Lt | Ge | Le | Eq | Ne

  type cexp =
    Record of (value * accesspath) list * var * cexp
  | Select of int * value * var * cexp
  | Offset of int * value * var * cexp
  | App of value * value list
  | Fix of (var * var list * cexp) list * cexp
  | Switch of value * cexp list
  | Primop of primop * value list * var list * cexp list
end

let un = assert false

(* a example of representing addition with cps
 * Notes:
 *    1. all sub expressions must have a name. (arguments are atomic)
 * *)
let add_example () =
  let c: CPS.var = un in let d: CPS.cexp = un in let x: CPS.var = un in let y: CPS.var = un in
  CPS.Primop (CPS.Add, [CPS.Var x; CPS.Var y], [c], [d])

(* continuation implies an order of evaluation.
 * For the example below we have (x + y) * (10 * z)
 * You can evaluate (x + y) first, or (10 * z) first.
 * CPS forece you to choose one or the other when you're doing the
 * transfortation. *)
let nested_add () =
  let m: CPS.cexp = un in
  let a: CPS.var = un in let b: CPS.var = un in let c: CPS.var = un in
  let x: CPS.var = un in let y: CPS.var = un in let z: CPS.var = un in
  CPS.Primop (CPS.Add, [CPS.Var x; CPS.Var y], [a],
  [CPS.Primop (CPS.Add, [CPS.Int 10; CPS.Var z], [b],
  [CPS.Primop (CPS.Mul, [CPS.Var a; CPS.Var b], [c], [m])])])

(* this continuation doesn't return value, but choose a continuation to call based on
 * the result *)
let cps_with_no_output () =
  let a: CPS.var = un in let b: CPS.var = un in let f: CPS.cexp = un in let g: CPS.cexp = un in
  CPS.Primop (CPS.Gt, [CPS.Var a; CPS.Var b], [], [f; g])

(* Given a value v, choose one of the branch continution to preceed
 * e.g v = 1 choose e1 etc.  *)
let multiway_branches () =
  let v: CPS.value = un in let e0: CPS.cexp = un in let e1: CPS.cexp = un in let e2: CPS.cexp = un in
  CPS.Switch (v, [e0; e1; e2])

(* record operations
 * select + set. Row poly extends notions here.
 * *)

(* use continuation to represent record *)
let records () =
  let a: CPS.var = un in let c: CPS.var = un in let u: CPS.cexp = un in
  CPS.Record([(CPS.Var a, CPS.Off 0); (CPS.Int 2, CPS.Off 0)], c,  u)

(* select the 1th field from record u and bind the result to v, continue with
 * select the 2th field from record u and bind the result to w, continue with  e.
 * *)
let select_from_records () =
  let u: CPS.var = un in let v: CPS.var = un in let w: CPS.var = un in let e: CPS.cexp = un in
  CPS.Select (1, CPS.Var u, v,
  (CPS.Select (2, CPS.Var u, w, e)))

(* offet allows a varaible to point to the middle of a reacord
 * It has the same argument as select, but the purpose is to adjust the pointer.
 *)
let offset_of_records () =
  let v: CPS.var = un in let w: CPS.var = un in let e: CPS.cexp = un in
  CPS.Offset (1, CPS.Var v, w, e)

(* mutually recursive functions are defined with fix point
 * It's how you define new binding of a function.
 * *)
let mutually_recursive () =
  let f1: CPS.var = un in let v11: CPS.var = un in let v12: CPS.var = un in let b1: CPS.cexp = un in
  let f2: CPS.var = un in let v21: CPS.var = un in let v22: CPS.var = un in let b2: CPS.cexp = un in
  let e: CPS.cexp = un in
  CPS.Fix ([(f1, [v11; v12], b1);
            (f2, [v21; v22], b2)], e)

(* in CPS all functoini calls are tail calls
 * It's clear to write is as type, App has no cexp field!
 * *)
let apps_are_tailcalls () =
  let f: CPS.var = un in let v1: CPS.var = un in let v2: CPS.var = un in
  CPS.App (CPS.Var f, [CPS.Var v1; CPS.Var v2])


(* tansform *)
let _f () =
  let f x = 2 * x + 1
  in f (11 + 22) * f (33 + 44)

(* r is the rest of the entire computation *)
let _f_cps r =
  let f x k = k (2 * x + 1) in  (* we have this variable k determines return *)
  let k1 = fun i ->
    let k2 = fun j ->
      r (i * j)         (* all subexpressions are given a name *)
    in f (33 + 44) k2
  in f (11 + 22) k1     (* pass the result to continuaiont k1. *)
  (* k1 is also defined by us *)

(*
 * functions that escapes.
 * *)


(* Semantics of CPS *)
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>

// mmap is necessary.

int main(int argc, char *argv[]) {
  // Machine code for:
  //   mov eax, 0
  //   ret
  unsigned char code[] = {0xb8, 0x00, 0x00, 0x00, 0x00, 0xc3};

  if (argc < 2) {
    fprintf(stderr, "Usage: jit1 <integer>\n");
    return 1;
  }

  //   mov eax, <user's value>
  //   ret
  int num = atoi(argv[1]);
  memcpy(&code[1], &num, 4);

  // Allocate writable/executable memory.
  // Note: real programs should not map memory both writable
  // and executable because it is a security risk.
  void *mem = mmap(NULL, sizeof(code), PROT_WRITE | PROT_EXEC,
                   MAP_ANON | MAP_PRIVATE, -1, 0);
  memcpy(mem, code, sizeof(code));

  // convert mem to a function pointer.
  int (*func)() = mem;

  int val = func();
  printf("you entered: %d\n", val);

  munmap(mem, sizeof(code));
  return val;
}
run_() {
  lli "$1".ll
}
#include "ast.h"
#include "util.h"
#include <assert.h>
#include <stdlib.h>

// consstructor
Astm *compound_stm(Astm *s1, Astm *s2) {
  Astm *s = (Astm *)checked_malloc(sizeof(*s));
  s->kind = AcompoundStm;
  s->u.compound.stm1 = s1;
  s->u.compound.stm2 = s2;
  return s;
}

Astm *assign_stm(string id, Aexpr *expr) {
  Astm *s = (Astm *)checked_malloc(sizeof(*s));
  s->kind = AassignStm;
  s->u.assign.id = id;
  s->u.assign.expr = expr;
  return s;
}

Astm *print_stm(AexprList *exps) {
  Astm *s = (Astm *)checked_malloc(sizeof(*s));
  s->kind = AprintStm;
  s->u.print.exps = exps;
  return s;
}

Aexpr *eseq_expr(Astm *stm, Aexpr *expr) {
  Aexpr *s = (Aexpr *)checked_malloc(sizeof(*s));
  s->kind = Aeseqexpr;
  s->u.eseqexpr.stm = stm;
  s->u.eseqexpr.expr = expr;
  return s;
}

Aexpr *id_expr(string id) {
  Aexpr *s = (Aexpr *)checked_malloc(sizeof(*s));
  s->kind = Aidexpr;
  s->u.id = id;
  return s;
}

Aexpr *num_expr(int num) {
  Aexpr *s = (Aexpr *)checked_malloc(sizeof(*s));
  s->kind = Anumexpr;
  s->u.num = num;
  return s;
}

Aexpr *biop_expr(Aexpr *left, Abinop op, Aexpr *right) {
  Aexpr *s = (Aexpr *)checked_malloc(sizeof(*s));
  s->kind = Aopexpr;
  s->u.op.left = left;
  s->u.op.right = right;
  s->u.op.op = op;
  return s;
}

// it's just a cons list.
AexprList *exprlist_pair(Aexpr *first, AexprList *next_list) {
  AexprList *s = (AexprList *)malloc(sizeof(*s));
  s->kind = Apairlist;
  s->u.pair.head = first;
  s->u.pair.tail = next_list;
  return s;
}

AexprList *exprlist_last(Aexpr *last) {
  AexprList *s = (AexprList *)malloc(sizeof(*s));
  s->kind = AlastExprList;
  s->u.last = last;
  return s;
}

// this is not really typesafe..
Ast *node(void *o, AstTypes t) {
  Ast *ast = (Ast *)malloc(sizeof(*ast));
  ast->kind = t;
  assert(((Astm *)o)->kind);
  switch (t) {
  case AstAexpr:
    ast->u.expr = (Aexpr *)o;
    break;
  case AstAstm:
    ast->u.stm = (Astm *)o;
    break;
  case AstAexprList:
    ast->u.lst = (AexprList *)o;
    break;
  }
  return ast;
}

void free_astm(Astm *e) { visit_astm(e, free); }
void free_aexprlist(AexprList *e) { visit_aexprlist(e, free); }
void free_aexpr(Aexpr *e) { visit_aexpr(e, free); }

void visit_astm(Astm *e, void (*fn)(void *)) {
  switch (e->kind) {
  case AcompoundStm:
    visit_astm(e->u.compound.stm1, fn);
    visit_astm(e->u.compound.stm2, fn);
    break;
  case AassignStm:
    visit_aexpr(e->u.assign.expr, fn);
    break;
  case AprintStm:
    visit_aexprlist(e->u.print.exps, fn);
    break;
  }
  fn(e);
}

void visit_aexprlist(AexprList *e, void (*fn)(void *)) {
  switch (e->kind) {
  case Apairlist:
    visit_aexprlist(e->u.pair.tail, fn);
    visit_aexpr(e->u.pair.head, fn);
    break;
  case AlastExprList:
    visit_aexpr(e->u.last, fn);
    break;
  }
  fn(e);
}

void visit_aexpr(Aexpr *e, void (*fn)(void *)) {
  switch (e->kind) {
  case Aidexpr:
    break;
  case Anumexpr:
    // num is owned by expr, freed with free().
    break;
  case Aopexpr:
    visit_aexpr(e->u.op.left, fn);
    visit_aexpr(e->u.op.right, fn);
    break;
  case Aeseqexpr:
    visit_astm(e->u.eseqexpr.stm, fn);
    visit_aexpr(e->u.eseqexpr.expr, fn);
    break;
  }
  fn(e);
}

// pretty print the tree.
static void pretty_print(void *) { static int indent = 0; }
#pragma once
#include "util.h"
#include <stdbool.h>
#include <stdio.h>

// BFN
// Stm -> Stm ; Stm
// Stm -> id := Expr
// Stm -> print (ExprList)
// Expr -> id
// Expr -> num
// Expr -> (Stm, Expr)
// ExprList -> Expr, ExprList
// ExprList -> Expr
// Binop -> +
// Binop -> -
// Binop -> *
// Binop -> /

// even writing in c you simulate the ast with struct and union.
typedef enum { Aplus, Aminus, Atimes, Adiv } Abinop;

struct Astm_;
struct AexprList_;
struct Aexpr_;

typedef struct Astm_ Astm;
typedef struct AexprList_ AexprList;
typedef struct Aexpr_ Aexpr;

void free_astm(Astm *);
void free_aexprlist(AexprList *);
void free_aexpr(Aexpr *);

void visit_astm(Astm *, void (*fn)(void *));
void visit_aexprlist(AexprList *, void (*fn)(void *));
void visit_aexpr(Aexpr *, void (*fn)(void *));

typedef enum AstmTypes { AcompoundStm, AassignStm, AprintStm } AstmTypes;
struct Astm_ {
  AstmTypes kind;
  union {
    struct {
      Astm *stm1;
      Astm *stm2;
    } compound;

    struct {
      string id;
      Aexpr *expr;
    } assign;

    struct {
      AexprList *exps;
    } print;
  } u;
};
void free_1(Astm *);

Astm *compound_stm(Astm *s1, Astm *s2);
Astm *assign_stm(string id, Aexpr *expr);
Astm *print_stm(AexprList *exps);

typedef enum { Aidexpr, Anumexpr, Aopexpr, Aeseqexpr } AexprTypes;
struct Aexpr_ {
  AexprTypes kind;
  union {
    char *id;
    int num;

    struct {
      Aexpr *left;
      Abinop op;
      Aexpr *right;
    } op;

    struct {
      Astm *stm;
      Aexpr *expr;
    } eseqexpr;
  } u;
};

Aexpr *id_expr(string id);
Aexpr *num_expr(int num);
Aexpr *biop_expr(Aexpr *left, Abinop op, Aexpr *right);
Aexpr *eseq_expr(Astm *stm, Aexpr *expr);

typedef enum { Apairlist, AlastExprList } AexprListTypes;
struct AexprList_ {
  AexprListTypes kind;
  union {
    struct ast_t {
      Aexpr *head;
      AexprList *tail;
    } pair;
    Aexpr *last;
  } u;
};

AexprList *exprlist_pair(Aexpr *first, AexprList *next_list);
AexprList *exprlist_last(Aexpr *last);

typedef enum { AstAexpr, AstAstm, AstAexprList } AstTypes;
// A uniform interface for all notes;
// This serves as a fat pointer to handle the entire tree.
typedef struct {
  AstTypes kind;
  union { // unions holds the access of the underlying ast node.
    Aexpr *expr;
    Astm *stm;
    AexprList *lst;
  } u;
} Ast;
#include "ast.h"
#include "util.h"
#include <stdio.h>
#include <stdlib.h>

int main(void) {

  Astm *stm = compound_stm(
      assign_stm("a", biop_expr(num_expr(10), Adiv, num_expr(2))),
      print_stm(exprlist_pair(num_expr(2), exprlist_last(num_expr(2)))));

  free_astm(stm);
  return 0;
}
#include "util.h"
#include <stdio.h>
#include <stdlib.h>

void *checked_malloc(int sz) {
  void *p = malloc(sz);
  if (p == NULL) {
    fprintf(stderr, "Memory error\n");
    exit(-1);
  }
  return p;
}
#pragma once

typedef char* string;
void *checked_malloc(int);
structure Ast =
struct
  type id = string

  datatype binop = Plus | Minus | Times | Div

  datatype stm = CompoundStm of stm * stm
               | AssignStm of id * exp
               | PrintStm of exp list
  and exp = IdExp of id
               | NumExp of int
               | OpExp of exp * binop * exp
               | EseqExp of stm * exp
end
structure Main =
struct
  fun main () = ();
end
structure Util =
struct
  fun util () = ();
end
#include <stdio.h>
#include <stdlib.h>
#include <uv.h>

// we create a customized event loop, does nothing,
// and quit.

int main(void) {
  // create an event loop first
  uv_loop_t *loop = (uv_loop_t *)malloc(sizeof(uv_loop_t));
  uv_loop_init(loop); // initalize the loop.

  printf("Now quiting \n");
  uv_run(loop, UV_RUN_DEFAULT); // uv_run run on a given loop.

  uv_loop_close(loop); // deinitalize the loop.
  free(loop);

  return 0;
}
#include <stdio.h>
#include <uv.h>

// An event is essentailly a token notify you somehting happened.
// e.g. An event for socket read complete.
//
// Watcher is the component wathcing for what event happend, and
// make correspoinding actions.
//
// Each watcher will have a callback associated with it. When an event
// happend, the callback will be called.
//
// Define watcher as two tuple (e, f).

int64_t counter = 0;

void wait_for_a_while(uv_idle_t *handle) {
  counter++;
  if (counter >= 10e6)
    uv_idle_stop(handle);
}

int main(void) {

  uv_idle_t idler;
  uv_idle_init(uv_default_loop(), &idler);
  uv_idle_start(&idler, wait_for_a_while); // start watcher, register callback

  printf("Idling...\n");

  // idle event is fired immediately, so the callback will be called
  // directly.
  uv_run(uv_default_loop(), UV_RUN_DEFAULT);

  uv_loop_close(uv_default_loop());

  return 0;
}
#include <stdio.h>
#include <stdlib.h>
#include <uv.h>

int64_t counter = 0;

void wait_for_a_while(uv_idle_t *handle) {
  counter++;
  if (counter > 10e6) {
    uv_idle_stop(handle);
  }
}

int main(void) {
  uv_loop_t *loop = (uv_loop_t *)malloc(sizeof(uv_loop_t));
  uv_loop_init(loop);

  uv_idle_t idler;
  uv_idle_init(loop, &idler);
  uv_idle_start(&idler, wait_for_a_while);

  printf("Idling on our own event loop...\n");

  uv_run(loop, UV_RUN_DEFAULT);
  uv_loop_close(loop);

  free(loop);
  return 0;
}
#include <stdio.h>
#include <stdlib.h>
#include <uv.h>

// file change events.

uv_loop_t *loop;
const char *command;

void run_command(uv_fs_event_t *handle, const char *filename, int events,
                 int status) {
  char path[1024];
  size_t size = 1023;

  uv_fs_event_getpath(handle, path, &size);
  path[size] = '\0';

  fprintf(stderr, "Change detected in: %s \n", path);
  if (events & UV_RENAME)
    fprintf(stderr, "renamed, ");
  if (events & UV_CHANGE)
    fprintf(stderr, "changed, ");

  fprintf(stderr, "%s\n", filename ? filename : "");
  system(command);
}

int main(int argc, char *argv[]) {
  if (argc <= 2) {
    fprintf(stderr, "Usage: %s <command> <file1> [file2...]\n", argv[0]);
    return 1;
  }

  loop = uv_default_loop();
  command = argv[1];

  while (argc-- > 2) {
    fprintf(stderr, "Adding watch on %s\n", argv[argc]);
    uv_fs_event_t *fs_event_req =
        (uv_fs_event_t *)malloc(sizeof(uv_fs_event_t));

    uv_fs_event_init(loop, fs_event_req);
    uv_fs_event_start(fs_event_req, run_command, argv[argc],
                      UV_FS_EVENT_RECURSIVE);
  }

  return uv_run(loop, UV_RUN_DEFAULT);
}
#include <stdio.h>
#include <stdlib.h>
#include <uv.h>

#define DEFAULT_PORT 7000
#define DEFAULT_BACKLOG 128

uv_loop_t *loop;
struct sockaddr_in addr;

// it's a common trick to extend write_t with some extra attributes.
typedef struct {
  uv_write_t req;
  uv_buf_t buf;
} write_req_t;

void free_write_req(uv_write_t *req) {
  write_req_t *wr = (write_req_t *)req;
  free(wr->buf.base);
  free(wr);
}

// the allocation function again.
void alloc_buffer(uv_handle_t *handle, size_t suggested_size, uv_buf_t *buf) {
  buf->base = (char *)malloc(suggested_size);
  buf->len = suggested_size;
}

// bascially after echo back you just want to free the request.
void echo_write(uv_write_t *req, int status) {
  if (status) {
    fprintf(stderr, "Write error: %s\n", uv_strerror(status));
  }
  free_write_req(req);
}

void echo_read(uv_stream_t *client, ssize_t nread, const uv_buf_t *buf) {
  if (nread > 0) {
    write_req_t *req = (write_req_t *)malloc(sizeof(write_req_t));
    req->buf = uv_buf_init(buf->base, nread);
    uv_write((uv_write_t *)req, client, &req->buf, 1, echo_write);
    return;
  }

  if (nread < 0) {
    if (nread != UV_EOF) {
      fprintf(stderr, "Read error %s\n", uv_err_name(nread));
    }
    uv_close((uv_handle_t *)client, NULL);
  }
  free(buf->base);
}

void on_new_connection(uv_stream_t *server, int status) {
  if (status < 0) {
    fprintf(stderr, "New connection error %s\n", uv_strerror(status));
    return;
  }

  uv_tcp_t *client = (uv_tcp_t *)malloc(sizeof(uv_tcp_t));
  uv_tcp_init(loop, client);

  if (uv_accept(server, (uv_stream_t *)client) == 0) {
    uv_read_start((uv_stream_t *)client, alloc_buffer, echo_read);
  } else {
    uv_close((uv_handle_t *)client, NULL);
  }
}

int main(void) {

  loop = uv_default_loop();

  uv_tcp_t server;
  uv_tcp_init(loop, &server);

  uv_ip4_addr("0.0.0.0", DEFAULT_PORT, &addr);
  uv_tcp_bind(&server, (const struct sockaddr *)&addr, 0);

  int r = uv_listen((uv_stream_t *)&server, DEFAULT_BACKLOG, on_new_connection);
  if (r) {
    fprintf(stderr, "Listen error %s\n", uv_strerror(r));
    return 1;
  }

  return uv_run(loop, UV_RUN_DEFAULT);
}
// asynchronous cat.

#include <assert.h>
#include <stdio.h>
#include <uv.h>

void on_read(uv_fs_t *req);

// define three handlers.
uv_fs_t open_req;
uv_fs_t read_req;
uv_fs_t write_req;

static char buffer[1024];

// uv_buf_t can be cast to iovec.
static uv_buf_t iov;

void on_write(uv_fs_t *req) {
  if (req->result < 0) {
    // if an error occur, the result will be the error code.
    fprintf(stderr, "Write error: %s\n", uv_strerror((int)req->result));

  } else {
    // write to the opened file, which is open_req.result.
    uv_fs_read(uv_default_loop(), &read_req, open_req.result, &iov, 1, -1,
               on_read);

  }
}

void on_read(uv_fs_t *req) {
  if (req->result < 0) {
    fprintf(stderr, "Read error: %s\n", uv_strerror((int)req->result));

  } else if (req->result == 0) { // nothing to read
    // synchronous. because close is small task
    uv_fs_t close_req;

    // close the opened file, which is open_req.result.
    uv_fs_close(uv_default_loop(), &close_req, open_req.result, NULL);

  } else if (req->result > 0) {
    iov.len = req->result;
    uv_fs_write(uv_default_loop(), &write_req, 1, &iov, 1, -1, on_write);
  }
}

// open handler
void on_open(uv_fs_t *req) {
  assert(req == &open_req);   // this is the same req we passed to uv_fs_open.

  if (req->result >= 0) {
    iov = uv_buf_init(buffer, sizeof(buffer));
    uv_fs_read(uv_default_loop(), &read_req, req->result, &iov, 1, -1, on_read);
  } else {
    fprintf(stderr, "Error opening file %s\n", uv_strerror((int)req->result));
  }
}

int main(int argc, char *argv[]) {
  uv_fs_open(uv_default_loop(), &open_req, argv[1], O_RDONLY, 0, on_open);

  uv_run(uv_default_loop(), UV_RUN_DEFAULT);

  uv_fs_req_cleanup(&open_req);
  uv_fs_req_cleanup(&read_req);
  uv_fs_req_cleanup(&write_req);

  return 0;
}
// read a file and output it's content in the reversed order.

#include <stdio.h>
#include <uv.h>

uv_fs_t open_req;
uv_fs_t read_req;
uv_fs_t write_req;

static char buffer[1024];
static uv_buf_t iov;

void reverse(char *buffer, size_t size) {
  size_t start = 0;
  size_t end = size - 1;

  for (; start < end; start++, end--) {
    char tmp;
    tmp = buffer[start];
    buffer[start] = buffer[end];
    buffer[end] = tmp;
  }
}

void on_read(uv_fs_t *req);

void on_write(uv_fs_t *req) {
  printf("\non write...\n");
  if (req->result < 0) {
    fprintf(stderr, "Write error %s\n", uv_strerror((int)req->result));
    return;
  }

  uv_fs_read(uv_default_loop(), &read_req, open_req.result, &iov, 1, -1,
             on_read);
}

void on_read(uv_fs_t *req) {
  printf("\non read...\n");
  if (req->result < 0) {
    fprintf(stderr, "Read error %s\n", uv_strerror((int)req->result));
    return;
  }

  if (req->result == 0) {
    uv_fs_t close_req;
    uv_fs_close(uv_default_loop(), &close_req, req->result, NULL);
    return;
  }

  reverse(iov.base, iov.len);
  uv_fs_write(uv_default_loop(), &write_req, 1, &iov, 1, -1, on_write);
}

void on_open(uv_fs_t *req) {
  printf("\non open...\n");
  if (req->result < 0) {
    fprintf(stderr, "Open error, %s\n", uv_strerror((int)req->result));
    return;
  }

  iov = uv_buf_init(buffer, sizeof(buffer));
  uv_fs_read(uv_default_loop(), &read_req, req->result, &iov, 1, -1, on_read);
}

int main(int argc, char *argv[]) {
  uv_fs_open(uv_default_loop(), &open_req, argv[1], O_RDONLY, 0, on_open);

  uv_run(uv_default_loop(), UV_RUN_DEFAULT);

  uv_fs_req_cleanup(&open_req);
  uv_fs_req_cleanup(&read_req);
  uv_fs_req_cleanup(&write_req);

  return 0;
}
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <uv.h>

// uv_write_t + the buffer.
// we cast a normal uv_write_t to this type to associate buffer with it.
typedef struct {
  uv_write_t req;
  uv_buf_t buf;
} write_req_t;

uv_loop_t *loop;

// we have three pipes at hands.
uv_pipe_t stdin_pipe;
uv_pipe_t stdout_pipe;
uv_pipe_t file_pipe;

// initialize buffer.
void alloc_buffer(uv_handle_t *handle, size_t suggested_size, uv_buf_t *buf) {
  char *mem = (char *)malloc(suggested_size);
  *buf = uv_buf_init(mem, suggested_size);
}

// free uv_write_t and the buffer associated with it.
void free_write_req(uv_write_t *req) {
  write_req_t *wr = (write_req_t *)req;
  free(wr->buf.base);
  free(wr);
}

// when write finished just close resources.
void on_stdout_write(uv_write_t *req, int status) { free_write_req(req); }
void on_file_write(uv_write_t *req, int status) { free_write_req(req); }

void write_data(uv_stream_t *dest, ssize_t size, uv_buf_t buf, uv_write_cb cb) {
  // copy the data from buf to dest.
  // once the data is copied, buf is no only required.
  write_req_t *req = (write_req_t *)malloc(sizeof(write_req_t));
  char *mem = (char *)malloc(size);
  req->buf = uv_buf_init(mem, size);
  memcpy(req->buf.base, buf.base, size);

  // libuv's generic stream write function. write req->buf to req.
  uv_write((uv_write_t *)req, (uv_stream_t *)dest, &req->buf, 1, cb);
}

void read_stdin(uv_stream_t *stream, ssize_t nread, const uv_buf_t *buf) {
  if (nread < 0) {
    if (nread == UV_EOF) {
      // end of file
      // uv_close is a generic close function to close all types of handles.
      uv_close((uv_handle_t *)&stdin_pipe, NULL);
      uv_close((uv_handle_t *)&stdout_pipe, NULL);
      uv_close((uv_handle_t *)&file_pipe, NULL);
    }
  } else if (nread > 0) {
    /* write_data((uv_stream_t *)&stdout_pipe, nread, *buf, on_stdout_write); */
    write_data((uv_stream_t *)&stdout_pipe, nread, *buf, on_stdout_write);
    write_data((uv_stream_t *)&file_pipe, nread, *buf, on_file_write);
  }

  // free the buffer one read.
  if (buf->base) {
    free(buf->base);
  }
}

int main(int argc, char *argv[]) {
  loop = uv_default_loop(); // create event loop.

  // create a pipe. 0 indicates no ipc.
  uv_pipe_init(loop, &stdin_pipe, 0);
  uv_pipe_open(&stdin_pipe, 0); // open fd 0. the pipe is readable.

  uv_pipe_init(loop, &stdout_pipe, 0);
  uv_pipe_open(&stdout_pipe, 1); // open fd 1. The pipe is writeable.

  uv_fs_t file_req; // create a file handle

  // just open the file. set callback to NULL so no function will be called.
  int fd = uv_fs_open(loop, &file_req, argv[1], O_CREAT | O_RDWR, 0644, NULL);

  uv_pipe_init(loop, &file_pipe, 0);
  // open fd to fd.
  // the fd I tried is always 10. here is the fd table for proc/<pid>/fd:
  //
  // 0 -> /dev/pts/24
  // 1 -> /dev/pts/24
  // 2 -> /dev/pts/24
  // 3 -> 'anon_inode:[eventpoll]'
  // 4 -> 'pipe:[10332419]'
  // 5 -> 'pipe:[10332419]'
  // 6 -> 'pipe:[10332420]'
  // 7 -> 'pipe:[10332420]'
  // 8 -> 'anon_inode:[eventfd]'
  // 9 -> /dev/null
  // 10 -> /home/jimmy/newDisk/Repo/misc/concurrency/libuv/good1
  //
  // we can see fd 0, 1, 2 all open to /dev/pts/24, which is our terminal.
  // other than these three, there are also bunch of other file descriptors
  // being used before we get our fd for the file.
  uv_pipe_open(&file_pipe, fd);

  // uv_read_start is a stream handle to read an incoming stream.
  // it will keep reading data until no more to read.
  // each time read new data, it calls the alloc_buffer to store the data.
  uv_read_start((uv_stream_t *)&stdin_pipe, alloc_buffer, read_stdin);

  uv_run(loop, UV_RUN_DEFAULT);
  return 0;
}
{-# LANGUAGE DeriveFunctor #-}

module EvalMonad where

-- System.IO has file io apis, System.Environment has args apis.
-- Control.Parallel provides Eval monad. Things like rpar, rseq etc.

import Data.Maybe
import Control.DeepSeq
import Control.Parallel.Strategies
import Sudoku
import System.IO

-- Lazy IO stuffs.

-- IO action is carried out by the outer driver that tries to execute all the
-- effects of main; The correct order of execution is maintained by IO's
-- monadic sequencing

-- A catch on withFile, the file will be release after the function
-- is exited, but because haskell is lazily evaluated the content of the
-- file will not be read until it's needed. If your computation entails the
-- file is forced by actions outside the handle function, withFile will close
-- the file before it's content even be read.

-- Another catch with hGetContents.
-- hGetContents doesn't evaluate anything, it will represent a thunk
-- for some other operations to use it.
-- Some ppl suggest to call it listen, this might capture more characteristics
-- of it.

-- To solve this we need to make sure s is fully evaluated before it is
-- returned. DeepSeq can help you do that.
-- seq or bang pattern is not enough because they only force evaluation to
-- the WHNF, stuffs remained still unevaluated.
puzzles :: IO [String]
puzzles = do
  r <- withFile path ReadMode $ \handle -> do
    s <- hGetContents handle
    return $!! s
  return $ lines r
  where
    path = "sudoku17.1000.txt"

-- control synchrnoization with rpar and rseq.

-- in sequential
run0 :: IO ()
run0 = do
  p <- puzzles
  let r = solve <$> p
  print $ length $ filter isJust r

-- split the work into two sub tasks.
-- join both
-- force will fully evalutae it's argument and then return it.
run1 :: IO ()
run1 = do
  p <- puzzles
  let (as, bs) = splitAt (length p `div` 2) p
      solutions = runEval $ do
        as' <- rpar $ force $ map solve as
        bs' <- rpar $ force $ map solve bs
        rseq as'
        rseq bs'
        return $ as' ++ bs'
  print $ length $ filter isJust solutions
module EvaluaionStrategies where

import Control.Parallel.Strategies
import Control.DeepSeq

-- use strategies to modularize parallel code logic from
-- the parallelism code.
-- Strategy :: a -> Eval a

-- first create Strategy with the computation you want it to be
-- parallel
parPair'' :: Strategy (a, b)
parPair'' (a, b) = do
  a' <- rpar a
  b' <- rpar b
  return (a, b)

-- using this pattern we know
-- the result of (fib 2, fib 199) `using` parPair
-- is just the same as (fib 2, fib 199),
-- it's just the parallelized version
using' :: a -> Strategy a -> a
x `using'` s = runEval $ s x

-- parameterized strategy
evalPair' :: Strategy a -> Strategy b -> Strategy (a, b)
evalPair' sa sb (a, b) = do
  a' <- sa a
  b' <- sb b
  return (a', b')

-- define a new strategy
-- this strategy force the evaluation and wait for it to
-- finish.
rdeepseq' :: NFData a => Strategy a
rdeepseq' x = rseq (force x)

-- redefine pairPair' with evalPair. rpar is used as a strategy itself.
parPairWHNF :: Strategy (a, b)
parPairWHNF = evalPair' rpar rpar

-- now let's define a more generic parPair
parPair' :: Strategy a -> Strategy b -> Strategy (a, b)
parPair' sa sb = evalPair' (rparWith sa) (rparWith sb)

-- parPair with seq strategy.
parPairSeq :: (NFData a, NFData b) => Strategy (a, b)
parPairSeq = parPair' rdeepseq' rdeepseq'

-- Strategy for list --

evalList' :: Strategy a -> Strategy [a]
evalList' _ [] = return []
evalList' strat (x : xs) = do
  x' <- strat x
  xs' <- evalList' strat xs
  return $ x' : xs'
module Main where

main :: IO ()
main = putStrLn "Hello, Haskell!"
import Distribution.Simple
main = defaultMain
module Sudoku where

-- a simple soduku solver to simulate CPU bound
-- operations.

import Control.Monad
import Data.Array
import Data.List
import Data.Maybe

type Digit = Char

type Square = (Char, Char)

type Unit = [Square]

-- represent grid as array
type Grid = Array Square [Digit]

rows = "ABCDEFGHI"

cols = "123456789"

digits = "123456789"

box = (('A', '1'), ('I', '9'))

-- from my experience when you're using list comphension
-- the order can be completely omitted since it's an expression
-- anyway. The order of predicate might affect the efficiency, but
-- that's very easy to tell.
cross :: String -> String -> [Square]
cross rows cols = [(r, c) | r <- rows, c <- cols]

squares :: [Square]
squares = cross rows cols

-- array :: Ix i => (i, i) -> [(i, e)] -> Array i e
peers :: Array Square [Square]
peers = array box [(s, set (units ! s)) | s <- squares]
  where
    set = nub . concat

unitList :: [Unit]
unitList =
  [cross rows [c] | c <- cols] ++ [cross [r] cols | r <- rows]
    ++ [ cross rs cs
         | rs <- ["ABC", "DEF", "GHI"],
           cs <- ["123", "456", "789"]
       ]

units :: Array Square [Unit]
units =
  array box $
    [ ( s,
        [filter (/= s) u | u <- unitList, s `elem` u]
      )
      | s <- squares
    ]

allPossibilities :: Grid
allPossibilities = array box [(s, digits) | s <- squares]

parseGrid :: String -> Maybe Grid
parseGrid g = do
  regularGrid g
  foldM assign allPossibilities (zip squares g)
  where
    regularGrid :: String -> Maybe String
    regularGrid g =
      if all (`elem` "0.-123456789") g
        then Just g
        else Nothing

assign :: Grid -> (Square, Digit) -> Maybe Grid
assign g (s, d) =
  if d `elem` digits
    then do
      let ds = g ! s
          toDump = delete d ds
      foldM eliminate g (zip (repeat s) toDump)
    else return g

-- (//) Ix i => Array ie -> [(i, e)] -> Array i e
-- delete :: Eq a => [a] -> [a]
eliminate :: Grid -> (Square, Digit) -> Maybe Grid
eliminate g (s, d) =
  let cell = g ! s
   in if d `notElem` cell
        then return g
        else do
          let newCell = delete d cell
              newV = g // [(s, newCell)]
          newV2 <- case newCell of
            [] -> Nothing
            [d'] -> do
              let peersOfS = peers ! s
              foldM eliminate newV (zip peersOfS (repeat d'))
            _ -> return newV
          foldM (locate d) newV2 (units ! s)

locate :: Digit -> Grid -> Unit -> Maybe Grid
locate d g u = case filter ((d `elem`) . (g !)) u of
  [] -> Nothing
  [s] -> assign g (s, d)
  _ -> return g

search :: Grid -> Maybe Grid
search g =
  case [(l, (s, xs)) | (s, xs) <- assocs g, let l = length xs, l /= 1] of
    [] -> return g
    ls -> do
      let (_, (s, ds)) = minimum ls
      msum [assign g (s, d) >>= search | d <- ds]

solve :: String -> Maybe Grid
solve str = do
  grd <- parseGrid str
  search grd

printGrid :: Grid -> IO ()
printGrid = putStrLn . gridToString

-- elems :: Array i e -> [e]
-- use intermideiate results here to separate a complicated
-- expression into smaller expressions.
-- This will be fused so no performance penalty.
gridToString :: Grid -> String
gridToString g =
  let l0 = elems g
      l1 = (\s -> " " ++ s ++ " ") <$> l0
      l2 = (concat . sublist 3) <$> l1
      l3 = sublist 3 l2
      l4 = (concat . intersperse "|") <$> l3
      l5 = (concat . intersperse [line] . sublist 3) l4
   in unlines l5
  where
    sublist n [] = []
    sublist n xs = ys : sublist n zs
      where
        (ys, zs) = splitAt n xs
    line = hyphens ++ "+" ++ hyphens ++ "+" ++ hyphens
    hyphens = replicate 9 '-'
from threading import Semaphore, Thread
from random import randint
from time import sleep

thread_num = 5

"""
Generalize rendezous. Barrier force execution
join at a particular point.

format:
    rendezvous
    critical section
No thread get into critical sectin until all threads
passed rendezvous

Note avoid deadlock by muliple layers of mutexes.
"""


class Barrier:
    """ Join Barrier """

    def __init__(self, n: int):
        self._n = n
        self._n_arrived = 0

        self._mutex = Semaphore(1)    # one thread can pass.
        self._barrier = Semaphore(0)  # no thread can pass.

    def wait(self):
        # use mutex to protect the counter.
        self._mutex.acquire()
        self._n_arrived += 1
        if self._n_arrived == self._n:
            self._barrier.release()
        self._mutex.release()

        # when all thread passed, the last one make the first release
        # after that other threads will starts release their own acquire.

        self._turnstile()
        self._rewind()

    def _rewind(self):
        """ lock again after all threads passed. """
        self._mutex.acquire()
        self._n_arrived -= 1
        if self._n_arrived == 0:
            self._barrier.acquire()
        self._mutex.release()

    def _turnstile(self):
        """ each thread will lock in turnstil until a first release """
        # acquire and release in rapid succession.
        # lock at the very beginning.
        self._barrier.acquire()

        # release at the very end.
        self._barrier.release()


def worker(barrier: Barrier):
    print("rendezvous")
    sleep(randint(0, 1))
    barrier.wait()

    print("critical")


if __name__ == "__main__":

    barrier = Barrier(thread_num)

    for idx in range(100):
        print(idx, "============")
        threads = []
        for i in range(thread_num):
            t = Thread(target=worker, args=(barrier,))
            threads.append(t)
            t.start()

        for t in threads:
            t.join()
"""
Producer / Consumer

The buffer must have exlusive access when item is being added.
If a consumer arrives while buffer is empty, it blocks until a new item appear.

Be extremely careful when you have nested locks.
In particular,
When for a thread the release of a lock depends on another thread can
pass another lock, and the release of another lock is depends on the first
thread got unlock.
"""
from threading import Semaphore, Thread
from collections import deque
from random import randint


class BufferEnd(Exception):
    pass


class Buffer:
    def __init__(self):
        self._deque = deque()
        self._mutex = Semaphore(1)
        self._mutex_empty = Semaphore(0)

    def get(self):
        # NOTE: risk of DEAD LOCK
        # the senario that _mutex_empty is inside self._mutex
        # if consumer come first, lock _mutex and block at _mutex_empty,
        # then a producer come, it will block at _mutex and no one can proceed.
        self._mutex_empty.acquire()
        with self._mutex:
            print(self._deque)
            res = self._deque.popleft()
        return res

    def add(self, evt):
        with self._mutex:
            self._deque.append(evt)
        self._mutex_empty.release()


"""
Using BufferEnd Sentinel to send a end message.
The problem here is when there is aribitrary amont of
producers and consumers, how to shut consumers exactly when
all producers shutdown.
"""


def producer(buf: Buffer):
    tid = randint(0, 1000)
    with open('/dev/random', 'rb') as f:
        for i in range(5):
            raw = f.read(10)
            print(f"[producer] {tid} iter", i, ' raw ', raw)
            buf.add(hash(raw) % 10000)
    buf.add(BufferEnd)


def consumer(buf: Buffer):
    tid = randint(0, 1000)
    while True:
        print(f"[consumer] {tid} consuming ...")
        data = buf.get()
        if data is BufferEnd:
            buf.add(BufferEnd)
            break
        print(data)


if __name__ == "__main__":
    buf = Buffer()
    p1 = Thread(target=producer, args=(buf,))
    c1 = Thread(target=consumer, args=(buf,))
    c2 = Thread(target=consumer, args=(buf,))
    c3 = Thread(target=consumer, args=(buf,))

    p1.start()
    c1.start()
    c2.start()
    c3.start()

    p1.join()
    c1.join()
    c2.join()
    c3.join()
from threading import Semaphore, Thread
"""
a limited amount of threads can enter the critical section
at the same time.
In this case is 4.
"""


def worker(sem: Semaphore):
    global count
    sem.acquire()
    count += 1
    sem.release()


if __name__ == "__main__":
    count = 1
    sem = Semaphore(4)
    threads = []
    for i in range(10):
        t = Thread(target=worker, args=(sem,))
        threads.append(t)
        t.start()

    for t in threads:
        t.join()

    print("should be 11, actual ", count)
from threading import Thread, Semaphore

"""
the problem is Symmetric because all threads run the same code.
easier to generalize compare with Asymmetric code.

In this case the mutex can sync arbitrary amount of concurrency.

Code be protected is called critical section.
"""


def worker1(sem: Semaphore):
    global count
    sem.acquire()
    count += 1
    sem.release()


def worker2(sem: Semaphore):
    global count
    sem.acquire()
    count += 1
    sem.release()


if __name__ == "__main__":
    count = 1
    sem = Semaphore()

    t1 = Thread(target=worker1, args=(sem,))
    t2 = Thread(target=worker2, args=(sem,))
    t1.start()
    t2.start()

    t1.join()
    t2.join()
    print('should be 3, actually ', count)
from threading import Semaphore, Thread
from typing import Callable
from random import randint


class Queue:
    """
    Initial value for Semaphore is 0, and it cannot
    be released unless there is a thread waiting.
    """

    def __init__(self, fn: Callable):
        self._token = Semaphore(0)
        self._fn = fn

    @property
    def token(self):
        return self._token

    def assign_lead(self, other: 'Queue'):
        self._other = other
        self._other._other = self

    def wait_another(self):
        self._other.token.release()
        self._token.acquire()

    def start(self):
        self.t = Thread(target=self.run)
        self.t.start()

    def run(self):
        """ override """
        self.wait_another()
        self._fn()


def lead():
    print("leading")


def follow():
    print("following")


if __name__ == "__main__":
    leader = Queue(lead)
    follower = Queue(follow)
    follower.assign_lead(leader)

    leader.start()
    follower.start()
from threading import Semaphore, Thread
from time import sleep

"""
Rendezvous. Two threads rendezvous at a point of
execution, neither is allowed to proceed until both has
arrived.
a1 | b1 < a2 | b2

termys:
    V, inc, signal, release
    P, dec, wait, acquire
"""


def worker1(sema: Semaphore, semb: Semaphore):
    for i in range(30000000):
        ...
    print('[a] a1', sema._value, semb._value)

    sema.release()  # +
    semb.acquire()  # -

    for i in range(30000000):
        ...
    print('[a] a2', sema._value, semb._value)


def worker2(sema: Semaphore, semb: Semaphore):
    for i in range(30000):
        ...
    print('[b] b1', sema._value, semb._value)

    semb.release()  # +
    sema.acquire()  # -

    print('[b] b2', sema._value, semb._value)


if __name__ == "__main__":
    sema = Semaphore(0)
    semb = Semaphore(0)

    t1 = Thread(target=worker1, args=(sema, semb))
    t2 = Thread(target=worker2, args=(sema, semb))
    t1.start()
    t2.start()

    t1.join()

#include <iostream>
#include <memory>
#include <vector>


// you can implement your own  allocator
// as long as it compliant with the allocator traits,
// and the container will expect to use your allocator
// via the interface provided by the allocator trait.

// if there are things not implement from your own allocator,
// the allocator trait will pick a default.
#include <cstdio>
#include <iostream>
#include <string>

struct Vector3 {
  int x;
  int y;
  int z;

  std::string to_string() const {
    char buf[124];
    sprintf(buf, "<Vector3 %p>", this);
    return std::string(buf);
  }
};

int main(void) {
  Vector3 v{1, 2, 3};

  std::cout << v.to_string() << std::endl;

  // by reference get the same address.
  auto foo = [&]() { std::cout << v.to_string() << std::endl; };

  // by value the addres + f for some reason.
  auto bar = [=]() { std::cout << v.to_string() << std::endl; };

  foo();
  bar();
  return 0;
}
#include <iostream>

// default allocator from C++ 03
template <typename T> struct Allocator {

  using size_type = size_t;
  using difference_type = ptrdiff_t;
  using pointer = T *;
  using const_pointer = T const *;
  using reference = T &;
  using const_reference = T const &;
  using value_type = T;

  template <typename U> struct rebind { using other = Allocator<U>; };

  // 4 primitive operations of an allocator.

  //
  inline pointer allocate(size_type n, Allocator<T>::const_pointer hint = 0) {
    return static_cast<T *>(::operator new(n * sizeof(T)));
  }

  //
  inline void deallocate(pointer p, size_type n) { ::operator delete(p); }

  // note in modern c++ you don't need to implement
  // construct and destory, because there are corresponding
  // default in allocator_traits.
  inline void construct(pointer p, T const &val) { ::new ((void *)p) T(val); }

  //
  inline void destroy(pointer p) { return ((T *)p)->~T(); }
};

template <typename T, typename U>
inline bool operator==(Allocator<T> const &, Allocator<U> const &) {
  return true;
}

template <typename T, typename U>
inline bool operator!=(Allocator<T> const &, Allocator<U> const &) {
  return false;
}
#include <iostream>

// Why do you want a custome allocator?
// - separate allocastion from construction
// - separate destruction from deallocastion

// The purpose of allocator
// - Encapsulate information of allocation strategy
// - Encapsulate informatoin about addressing model
// - Hide memory management and addressing model details
// - Support reuse

// Types of Alocators?
//
// +--------------------+-------
// |         |  global  |  local
// +---------+----------+-------
// | general | jemalloc |  multipool_allocator
// +---------+----------+-------
// | special |  malloc  |  alloca
// +---------+----------+-------
//
// 1. Local allocator can be beneficial from it's
//    compact memeory. You have better locality to
//    exploit cache lines.
//    (Locality might be the most important property for
//     modern hardware in terms of performance)
//
// 2. Global general allocators also consider thread safety
//    But for single threaded application you might not
//    care about that.
//
// 3. alloca alocate space on the stack. It's very good
//    when you can save heap allocation, but it also
//    make stack overflow very easy.
//
// 4. Local alloator has the notion of release. You can just
//    forget about the memory without deallocate.
//    0 deallocation time.

// Possible allocator interface
// 1. as a function (malloc/free)
// 2. as reference wrapper template parameter.
// 3. pass the address of pure abstract base class.

// Allocator decision tree
//            Start
//    no -- Should I use an allocator?
//             |
//             | yes
//             |
//          Via Base class?
//             | (both yes and no)
//             |
//             |
//          Which allocator?
//          |     |     | ...
//          A     B     C
//          |     |     |
//          Wink out memory ?
//             |
//          Use optimal local allocation strategy

// monotonic, multipool, or multipool<monotonic>

// Five dimensions of memory allocation
// 1. Density of allocation
// 2. Varaition of allocated size
// 3. Locality of access memory
// 4. Utilization of allocated memory
// 5. Contention of oncurrent allocations.

// For performance, the goal of allocation is not to
// allocate things fast, but rather allocate things
// to achieve better locality.

// Some example of allocators
// - Stack based allocation
// - Per-container private allocation
// - per-thread allocation
// - pool/slab allocation
// - Areana allocation.
// - Debug
// - Relocatable data.

// Allocator propagations.
// - Lateral propagation
//  - copy/move construct
//  - copy/move assignment
//  - swap
// - Deep propagation.
//  - for case like, map<string, vector<list<string>>>,
//    you want to pass the same allocator down to all
//    other containers so they can share the same arena.
//  - scoped_allocater_adaptor

int main(void)
{

  return 0;
}
#include <algorithm>
#include <array>
#include <cstdlib>
#include <iostream>
#include <limits>
#include <memory>
#include <vector>

namespace allocator_demo::minialloc {

// after you implemented this parts you get a workable
// customized allocator.
template <typename T> struct MinimalAllocator {

  using value_type = T;

  template <typename U>
  MinimalAllocator(MinimalAllocator<U> const &) noexcept {}
  MinimalAllocator() = default;
  ~MinimalAllocator() = default;

  [[nodiscard]] T *allocate(size_t n);

  void deallocate(T *p, size_t);
};

template <typename T> T *MinimalAllocator<T>::allocate(size_t n) {
  std::cout << "allocating" << std::endl;
  return static_cast<T *>(::operator new(n * sizeof(T *)));
}

template <typename T> void MinimalAllocator<T>::deallocate(T *p, size_t n) {
  std::cout << "deallocating" << std::endl;
  ::operator delete(p);
}

template <typename T>
bool operator==(MinimalAllocator<T> const &, MinimalAllocator<T> const &) {
  return true;
};

template <typename T>
bool operator!=(MinimalAllocator<T> const &, MinimalAllocator<T> const &) {

  return false;
};
} // namespace allocator_demo::minialloc

namespace allocator_demo::myalloc {

template <typename T> struct MyAlloc {
  using value_type = T;

  MyAlloc() = default;
  template <typename U> constexpr MyAlloc(const MyAlloc<U> &) noexcept {}
  ~MyAlloc() = default;

  [[nodiscard]] T *allocate(size_t n) {
    if (n > std::numeric_limits<size_t>::max() / sizeof(T)) {
      throw std::bad_alloc();
    }

    if (auto p = static_cast<T *>(malloc(sizeof(T) * n))) {
      report(p, n);
      return p;
    }

    throw std::bad_alloc();
  }

  void deallocate(T *p, size_t n) noexcept {
    report(p, n, false);
    free(p);
  }

private:
  void report(T *p, size_t n, bool alloc = true) {
    std::cout << (alloc ? "Alloc" : "Dealloc") << ": " << sizeof(T) * n
              << " bytes at " << std::hex << std::showbase
              << reinterpret_cast<void *>(p) << std::dec << std::endl;
  }
};

} // namespace allocator_demo::myalloc

// simple arean
namespace allocator_demo::arena {

template <typename T> struct Arena {
  using value_type = T;
  static constexpr size_t N = 1024;

  Arena() : arena_{}, base_(arena_.begin()), current_(arena_.begin()) {}

  ~Arena() {
    std::cout << "see ya" << std::endl;
  }
  template <typename U> constexpr Arena(const Arena<U> &) {}

  [[nodiscard]] T *allocate(size_t n) {
    if (n > N / sizeof(T)) {
      throw std::bad_alloc();
    }

    current_ += n * sizeof(T);
    auto p = static_cast<T *>(reinterpret_cast<void *>(current_));
    report(p, n);

    return p;
  }

  void deallocate(T *, size_t n) {
    current_ -= n * sizeof(T);
    auto p = static_cast<T *>(reinterpret_cast<void *>(current_));
    report(p, n, false);
  }

private:
  std::array<char, N> arena_;
  char *base_;
  char *current_;

  void report(T *p, size_t n, bool alloc = true) const {
    auto distance = n * sizeof(T);
    std::cout << (alloc ? "Alloc" : "Dealloc") << ": " << n * sizeof(T)
              << " bytes at " << std::hex << std::showbase
              << reinterpret_cast<void *>(p) << std::dec << ", \n the arena is "
              << 100.0 * distance / N << " percent full" << std::endl;
  }
};

} // namespace allocator_demo::arena

#define CHECK(s, init)                                                         \
  {                                                                            \
    init v{};                                                                  \
    std::cout << s << std::endl;                                               \
    for (int i = 0; i < 50; ++i) {                                             \
      v.push_back(i);                                                          \
    }                                                                          \
    std::cout << "value[10]: " << v[10] << std::endl;                          \
    v.erase(std::remove_if(v.begin(), v.end(), [](int n) { return n > 18; }),  \
            v.end());                                                          \
  }

int main(void) {
  CHECK("v", std::vector<int>);

  using V1 = std::vector<int, allocator_demo::myalloc::MyAlloc<int>>;
  CHECK("myalloc", V1);

  using V2 = std::vector<int, allocator_demo::arena::Arena<int>>;
  CHECK("arena", V2);

  { std::vector<int, allocator_demo::arena::Arena<int>> v{1, 2, 3}; }

  return 0;
}
#include <iostream>

struct Vector3 {
  int x;
  int y;
  int z;
};

template <typename T> T *newnew(unsigned char *buf) {
  std::cout << "allocating size " << sizeof(T) << ".." << std::endl;

  T *ptr = new (buf) T;

  return ptr;
}

int main(void) {
  alignas(char) unsigned char buf1[sizeof(char)];
  alignas(Vector3) unsigned char buf2[sizeof(Vector3)];

  auto x = newnew<char>(buf1);
  auto y = newnew<Vector3>(buf2);
  *x = 'c';
  *y = Vector3{1, 2, 3};

  std::cout << *x << std::endl;
  std::cout << y->x << std::endl;
  std::cout << y->y << std::endl;
  std::cout << y->z << std::endl;

  // call the destructor mannually.
  y->~Vector3();
  return 0;
}
// Polymorphic memory resource.
// - Provide runtime polmorphism with single type argument to containers.
// - Client allocators store a pointer to a base class memory resource
// - No lateral propagation. An allcator sticks for life.

#include <array>
#include <chrono>
#include <list>
#include <memory_resource>

// simply allocate list on the stack.
// instead of allocating each nodes separately, we allocate the
// entire space first, then put item in it diresclty.
void lis() {
  std::array<char, 64> buffer{};
  std::fill_n(buffer.begin(), std::size(buffer) - 1, '_');
  std::pmr::monotonic_buffer_resource rsc{buffer.data(), buffer.size()};

  std::pmr::list<char> ls{{'a', 'b', 'c', 'd', 'e'}, &rsc};

  for (char ch = 'a'; ch <= 'z'; ++ch) {
    ls.push_back(ch);
  }
}
// https://howardhinnant.github.io/stack_alloc.html

#ifndef SHORT_ALLOC_
#define SHORT_ALLOC_

#include <cassert>
#include <cstddef>
#include <cstdint>

template <size_t N, size_t Alignment = alignof(std::max_align_t)> class Arena {
  // alignas allows you to specify alignment.
  alignas(Alignment) char buf[N];

  char *ptr;

public:
  ~Arena() { ptr = nullptr; }

  // Intialize the ptr to the buf position.
  Arena() noexcept : ptr(buf) {}

  // of course, we don't want our Arena be copied.
  Arena(const Arena &) = delete;
  Arena &operator=(const Arena &) = delete;

  template <size_t ReqAlign> char *allocate(size_t n);
  void deallocate(char *p, size_t n) noexcept;

  static constexpr size_t size() noexcept { return N; }

  size_t used() const noexcept { return static_cast<size_t>(ptr - buf); }
  void reset() noexcept { ptr = buf; }

private:
  static size_t align_up(size_t n) noexcept {
    return (n + (Alignment - 1)) & ~(Alignment - 1);
  }

  bool pointer_in_buffer(char *p) noexcept {
    return std::uintptr_t(buf) <= std::uintptr_t(p) &&
           std::uintptr_t(p) <= std::uintptr_t(buf) + N;
  }
};

template <size_t N, size_t Alignment>
template <size_t ReqAlign>
char *Arena<N, Alignment>::allocate(size_t n) {
  static_assert(ReqAlign <= Alignment, "alignment is too small");
  assert(pointer_in_buffer(ptr) && "short_alloc has outlived arena");
  auto const aligned_n = align_up(n);
  if (static_cast<decltype(aligned_n)>(buf + N - ptr) >= aligned_n) {
    char *r = ptr;
    ptr += aligned_n;
    return r;
  }

  static_assert(Alignment <= alignof(std::max_align_t),
                "you've chosen an "
                "alignment that is larger than alignof(std::max_align_t), and "
                "cannot be guaranteed by normal operator new");

  return static_cast<char *>(::operator new(n));
}

template <size_t N, size_t Alignment>
void Arena<N, Alignment>::deallocate(char *p, size_t n) noexcept {

  assert(pointer_in_buffer(ptr) && "shrot_alloc has outlived arena");
  if (pointer_in_buffer(p)) {
    n = align_up(n);
    if (p + n == ptr) {
      ptr = p;
    }
  } else {
    ::operator delete(p);
  }
}

#endif /* ifndef SHORT_ALLOC_ */
#include <memory>

// Note this is a C++ 20 feature.

template <typename A> auto allocator_new(A &a) {
  // allocate() allocate memory
  auto p = a.allocate(1);
  try {
    // construct create an object in the memory that just allocated.
    // if construct failed just call ::new()
    // it takes a raw pointer.
    std::allocator_traits<A>::construct(a, std::to_address(p));
  } catch (...) {
    a.deallocate(p, 1);
    throw;
  }
  return p;
}

template <typename A>
void allocator_delete(A &a, typename std::allocator_traits<A>::pointer p) {
  std::allocator_traits<A>::destroy(a, std::to_address(p));
  a.deallocate(p, 1);
}

int main(void) {

  std::allocator<int> a;
  auto p = allocator_new(a);
  allocator_delete(a, p);

  return 0;
}
#include <boost/regex.hpp>
#include <iostream>
#include <string>

// boost usually installed in /usr/include

void print_captures(const std::string &regx, const std::string &text) {
  boost::regex e(regx);
  boost::smatch what;
  std::cout << "Expression:  \"" << regx << "\"\n";
  std::cout << "Text:        \"" << text << "\"\n";
  if (boost::regex_match(text, what, e, boost::match_extra)) {
    unsigned i, j;
    std::cout << "** Match found **\n   Sub-Expressions:\n";
    for (i = 0; i < what.size(); ++i)
      std::cout << "      $" << i << " = \"" << what[i] << "\"\n";
    std::cout << "   Captures:\n";
    /* for (i = 0; i < what.size(); ++i) { */
    /*   std::cout << "      $" << i << " = {"; */
      /* for (j = 0; j < what.captures(i).size(); ++j) { */
      /*   if (j) */
      /*     std::cout << ", "; */
      /*   else */
      /*     std::cout << " "; */
      /*   std::cout << "\"" << what.captures(i)[j] << "\""; */
      /* } */
      /* std::cout << " }\n"; */
    /* } */
  } else {
    std::cout << "** No Match found **\n";
  }
}

int main(int, char *[]) {
  print_captures("(([[:lower:]]+)|([[:upper:]]+))+", "aBBcccDDDDDeeeeeeee");
  print_captures("(.*)bar|(.*)bah", "abcbar");
  print_captures("(.*)bar|(.*)bah", "abcbah");
  print_captures(
      "^(?:(\\w+)|(?>\\W+))*$",
      "now is the time for all good men to come to the aid of the party");
  return 0;
}
/* the book list some quirks of c */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void compatible_ptr() {
  char **ptr1 = NULL;
  const char **ptr2 = NULL;
  /* it's an error because of some rules of ptr assignment.
   * A ptr can assign to another ptr only when
   *  1. they both point to the compatible type (same type)
   *  2. left operand has all the qualifiers of the right operand
   * But is this case, ptr1 is a pointer to "pointer to char (char *)",
   * yet ptr2 is a pointer to "point to const char (const char *)".
   * So they point to different types technically. Thus they are not
   * ptrs to the compatible type. Rule 1 violated.
   *
   * It is so sketchy to be honest.
   * */
  ptr1 = ptr2;
}

void unsigned_conversion() {
  /* Usual arithmetic conversion.
   * In expression you try to convert a type to the "biggest"
   * form. (be as float as possible, as long as possible, as
   * unsigned as possible etc..)
   *
   * Some quriks will happen with expression involve float and
   * unsigned. Cause the sign flipped the evaluation can change
   * to something completely different.
   * */
  if (-1 < (unsigned char)1) { /* this print "1".*/
    printf("1");
  } else {
    printf("0");
  }

  /* this print "oops"...
   * Cause sizeof return unsigned value, and the arithmetic
   * conversion convert signed int -1 to unsigned int.
   * Need to be extra careful when unsigned int is involved */
#define TOTAL_ELEMENTS (sizeof(array) / sizeof(array[0]))
  const int array[] = {10, 20, 30, 40, 50, 60};
  int d = -1;
  if (d <= TOTAL_ELEMENTS - 2) {
    printf("yes");
  } else {
    printf("oops");
  }

#undef TOTAL_ELEMENTS
}

/* cdecl */
#define MAXTOKENS 100
#define MAXTOKENLEN 64

typedef enum type_tag { IDENTIFIER, QUALITFIER, TYPE } TypeTag;
typedef struct token {
  char type;
  char string[MAXTOKENLEN];
} Token;

static int top = -1;
static Token stack[MAXTOKENS];
static Token self;

#define pop stack[top--]
#define push(s) stack[++top] = s

TypeTag classify_string() {
  char *s = self.string;
  if (!strcmp(s, "const")) {
    strcpy(s, "read-only");
    return QUALITFIER;
  }

  if (!strcmp(s, "volatile"))
    return QUALITFIER;
  if (!strcmp(s, "void"))
    return TYPE;
  if (!strcmp(s, "char"))
    return TYPE;
  if (!strcmp(s, "signed"))
    return TYPE;
  if (!strcmp(s, "unsigned"))
    return TYPE;
  if (!strcmp(s, "short"))
    return TYPE;
  if (!strcmp(s, "int"))
    return TYPE;
  if (!strcmp(s, "float"))
    return TYPE;
  if (!strcmp(s, "double"))
    return TYPE;
  if (!strcmp(s, "struct"))
    return TYPE;
  if (!strcmp(s, "union"))
    return TYPE;
  if (!strcmp(s, "enum"))
    return TYPE;
  return IDENTIFIER;
}

void gettoken() {
  char *p = self.string;
  while ((*p = getchar()) == ' ')
    ;
  if (isalnum(*p)) {
    while (isalnum(*++p = getchar()))
      ;
    ungetc(*p, stdin);
    *p = '\0';
    self.type = classify_string();
    return;
  }

  if (*p == '*') {
    strcpy(self.string, "pointer to");
    self.type = '*';
    return;
  }

  self.string[1] = '\0';
  self.type = *p;
  return;
}

void read_to_first_identifier() {
  gettoken();
  while (self.type != IDENTIFIER) {
    push(self);
    gettoken();
  }
  printf("%s is", self.string);
  gettoken();
}

void decarrays() {
  while (self.type == '[') {
    printf("array ");
    gettoken();
    if (isdigit(self.string[0])) {
      printf("0..%d", atoi(self.string) - 1);
      gettoken();
    }
    gettoken();
    printf("of ");
  }
}

void decfunctionargs() {
  while (self.type != ')') {
    gettoken();
  }
  gettoken();
  printf("function returning");
}

void decpointers() {
  while (stack[top].type == '*') {
    printf("%s", pop.string);
  }
}

void declarator() {
  switch (self.type) {
  case '[':
    decarrays();
    break;
  case '(':
    decfunctionargs();
    break;
  }
  decpointers();

  while (top >= 0) {
    if (stack[top].type == '(') {
      pop;
      gettoken();
      declarator();
    } else {
      printf("%s ", pop.string);
    }
  }
}

void cdecl() {
  read_to_first_identifier();
  declarator();
  printf("\n");
}
#undef MAXTOKENS
#undef MAXTOKENLEN

/* differences between array and ptr addressing  */
void ptr_array() {
  char array[] = { 1, 2, 3 };
  char *p = NULL;

  /* 1. get address from array symbol
   * 2. plus offset to address
   * 3. get content of the address
   * array[3]:
   * array
   *   |
   *   v --- v
   *   1 2 3 4
   * */
  array[1];

  /* 1. get address1 from p symbol
   * 2. get address2 from where content of addess1 point to
   * 3. plus offset to address
   * 4. get content
   * p[3]:
   * p -> *ptr
   *       |
   *       v --- v
   *       1 2 3 4
   * */
  p[1];
}

int main(void) { return 0; }
#include <stdio.h>

static int num = 10;

int main(void) {
  int i, cur, next;
  int tmp;
  // here it shows the difference between lisp do.
  // in a lisp do, each interation will always use the
  // older value, but in C for loop, the side effect will
  // happen right in place.
  // if you write cur = next, all statement follow that will
  // use cur as next.
  for (i = cur = 0, next = 1; i < num;
       ++i, tmp = cur, cur = next, next = next + tmp) {
    printf("%d ", i);
    printf("%d ", cur);
    printf("%d \n", next);
  }
  return 0;
}
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  FILE *ft;
  char const *name = "abc.txt";
  int ch;
  ft = fopen(name, "r+");
  if (ft == NULL) {
    fprintf(stderr, "cannot open target file %s\n", name);
    exit(1);
  }
  while ((ch = fgetc(ft)) != EOF) {
    if (ch == 'i') {
      fseek(ft, -1, SEEK_CUR);
      fputc('a', ft);
      fseek(ft, 0, SEEK_CUR);
    }
  }
  fclose(ft);
  return 0;
}
int k(int a, int b) { return a; }

int abs(int a) {
  if (a >= 0) {
    return k(a, 0);
  }
  return -a;
}
int abs(int a);

int foo(int a, int b){
  int x = 10 + a;
  return a * b + a;
}

int main(void)
{
  int x = foo(1, 2);
  return 0;
}
gcc -O0 -masm=intel -fverbose-asm -c main.c -S
gcc -O0 -masm=intel -fverbose-asm -c abs.c -S
#include <gsl/gsl_math.h>
#include <gsl/gsl_sf_bessel.h>
#include <stdio.h>

// Topic: link with external libraries
// playing with shared libaries, static libaries,
// and some other linking techniques.

// gcc gsl.c -o a -lgsl -lgslcblas -lm
// or you can use -lcblas for the BLAS library.
// or add atlas support for fast matrix operation

// If you want to link to a shared libary, you need to be
// sure the .so file is in the path
//   $ LD_LIBRARY_PATH
// to set the load library path, do this in the shell:
//   $ LD_LIBRARY_PATH = /usr/local/lib
//   $ export LD_LIBRARY_PATH

// gsl allows you to swap out the native standard library and use the
// gsl's version
// It's normally better to use the native version because they usually
// have better platform specific optimization.
#ifndef HAVE_HYPOT
#define hypot gsl_hypot
double hypot_sum(double a, double b) {
  return hypot(a, b) + hypot(a + 1, b + 1);   // here we are using gsl function.
}
#endif

// alternative optimized functions
// again just macro substitute different versions

int main(void) {
  int e = 0;
  double f = gsl_frexp(12, &e);
  printf("the result: %f, %d", f, e);

  double x = 5.0;
  double y = gsl_sf_bessel_J0(x);
  printf("J1%g = %.18e\n", x, y);

  return 0;
}
#include "abs.h"

int main(void)
{

  int x = abs(1);
  return 0;
}
int main(void)
{

  return 0;
}
int f1() { return 1; }
int f1();
#include "file1.h"
#include <stdio.h>

int main(void) {
  printf("%d", f1());
  return 0;
}
#include <memory>
#include <type_traits>

struct trivial_vector3 {
  int x;
  int y;
  int z;
};

// a trival class is a pod.
static_assert(std::is_trivial_v<trivial_vector3>);
static_assert(
    std::is_trivially_assignable<trivial_vector3, trivial_vector3>::value);

struct copyable {
  copyable(const copyable &) = default;
};

static_assert(!std::is_trivial_v<copyable>);
static_assert(std::is_trivially_copy_assignable_v<copyable>);
static_assert(std::is_trivially_move_assignable_v<copyable>);
static_assert(std::is_move_assignable_v<copyable>);
static_assert(std::is_copy_assignable_v<copyable>);
static_assert(std::is_destructible_v<copyable>);
static_assert(std::is_scalar_v<int>);

struct nonmoveable {
  nonmoveable(const nonmoveable &) = default;
  nonmoveable(nonmoveable &&) = delete;
};

// classes has custom ctors are nolong trival
static_assert(!std::is_trivial_v<nonmoveable>);
static_assert(std::is_copy_constructible_v<nonmoveable>);
static_assert(!std::is_move_constructible_v<nonmoveable>);

struct has_nonmovable {
  has_nonmovable(const has_nonmovable &) = default;

  // this will be copy
  has_nonmovable(has_nonmovable &&) = default;
};
static_assert(std::is_copy_constructible_v<has_nonmovable>);
static_assert(std::is_move_constructible_v<has_nonmovable>);
#include <algorithm>
#include <iostream>
#include <memory>
#include <vector>

// c++ data models with constructors and destructors.
// The idea of having class is to make it easier to model real world problem.
// But when they need to run on the computer, how to efficiently manage their
// resources is also a problem we need to care about.
//
// c++ address this problem with RAII, you create an object by calling a
// constructor, and delete the object by calling it's destructor. Each object
// has their lifetime, within the lifetime the object will obtain resources, do
// it's work, free resources, and everything get managed properly.
//
// Constructor is nothing special but a function. By calling it you bring a new
// object into life with resources they require.
//
// What're resources? Say your class has two integer fields, so it will need to
// allocate 16 bytes to store those integers. The 16 memory space is an example
// of resource you acquire.
//
// The object can both be create on the heap or on the stack, but they will
// follow the same memory layout, and be created with the same procedure
// specified by the constructor.
//
// Among all the constructors you can define, there are two special
// constructors, which will be called by the compiler when their corresponding
// semantics get triggered.
//
// One is copy constructor, the other is move constructor.
// The common pattern is you pass another object (refernce, no matter lval ref
// or rval ref, they always ref to another obect with the same type) into the
// constructor, and the constructor decides to do something with the other
// object to create itself.
//
// Normally you get another object, you might want to copy it. You want to have
// another copy of the exact same memory layout, socket refs, etc as the object
// get passed in. Or maybe sometimes you don't want to copy the entire object
// but only part of it. These are all things you can specify in a copy
// construtor.
//
// What if you want to take over the object get passed in? Then you need the
// move semantics, steal resources from the other obejct directly.

// Notice for unique_ptr, it essentially still a object on the stack holds a
// poiner. Because it is a compile time construct, we can optimize it out and
// make it as efficient as a raw pointer. Of course copy an unique_ptr is not
// allowed. So what does it means to copy a unique_ptr? If you copy the
// unique_ptr, you probably want to copy the member field from one unique_ptr to
// another. And that make the object get pointed to by the member field an
// alias, no longer unique anymore.

// Let's make a class with both copy and move constructor, and see what happens.

class MemoryBlock {
  size_t size;
  int *data;

public:
  // first just make a simple constructor.
  // This constructor has no difference between define a fuction and
  // return MemoryBlock.
  explicit MemoryBlock(size_t size) : size(size), data(new int[size]) {
    std::cout << "Create memory block size: " << size << std::endl;
  }

  // because we now holds the array, we need corresponding destructor to delete
  // it. if yo don't define this, compiler will do it for you.
  ~MemoryBlock() {
    std::cout << "Deleting memory block, size: " << size << std::endl;
    if (data != nullptr) {
      delete[] data;
    }
  }

  // copy constructor
  MemoryBlock(const MemoryBlock &other)
      : size(other.size), data(new int[other.size]) {
    std::copy(other.data, other.data + size, data);

    std::cout << "copy construct a memory block size:" << size << std::endl;
  }

  // copy assignment
  MemoryBlock &operator=(const MemoryBlock &other) {

    // from here you can see & is merely a reference.
    if (this != &other) {
      size = other.size;
      data = new int[size];
      std::copy(other.data, other.data + size, data);

      std::cout << "copy assign a memory block" << size << std::endl;
    }
    return *this;
  }

  // move semantics
  // first initialze empty members.
  MemoryBlock(MemoryBlock &&other) : data(nullptr), size(0) {

    // steal the data directly
    data = other.data;

    // this is still copy, but it's primitive type so it's ok.
    size = other.size;

    // null out the other object.
    // This prevents the destructor from freeing resources multiple times.
    other.data = nullptr;
    other.size = 0;
    // What will be the problem if you don do this?
    // for example in case { A test(std::move(getA()));},
    // move getA() creates a rvalue, moved into test and get destroyed.
    // and after reach the end of the block test get destroyed again.
    std::cout << "Move memory block, size: " << size << std::endl;
  }

  // move assignment is very straight forward.
  MemoryBlock &operator=(MemoryBlock &&other) {

    data = other.data;
    size = other.size;
    other.data = nullptr;
    other.size = 0;

    std::cout << "Move assign memory block, size: " << size << std::endl;
    return *this; // return a reference
  }
};

void ad() {
  // define struct within function..
  struct R {
    double a, b, c;
  };
  static R rs[2] = {{1, 1, 1}, {1, 2, 3}};

  for (int i = 0, k = 0; i < 2; ++i) {
    rs[i] = {rs[i].a + 1, rs[i].b + 1, rs[i].c + 1};
  }
}

int main(void) {
  std::vector<MemoryBlock> v;

  // a lval reference.
  MemoryBlock m(18);
  MemoryBlock n(10);

  // move
  v.push_back(MemoryBlock(25));
  // copy
  v.push_back(m);

  // move
  // What does move do is a conditional cast.
  // it casts lvalue to rvalue, and keep rvalue
  v.push_back(std::move(n));

  return 0;
}
#include <iostream>
#include <memory>
#include <unordered_map>
#include <variant>
#include <vector>

enum jvalue_tag { O, A, N, B, JNULL };

struct jnull_t {};

struct jobject_t;
struct jarray_t;

using jvalue_t = std::variant<std::string, int, bool, jobject_t *, jarray_t *>;

struct jobject_t {
  std::unordered_map<std::string, jvalue_t> v;
};

struct jarray_t {
  std::vector<jvalue_t> v;
};

int main(void) {
  jarray_t arr{.v = {1, 2, 3}};
  jvalue_t v{&arr};

  if (std::holds_alternative<jarray_t *>(v)) {
    auto a = std::get<jarray_t *>(v);
    auto b = std::get<int>(a->v[0]);
    std::cout << b << std::endl;
  }
  return 0;
}
#include <iostream>

class Car {
public:
  int speed;

  void func() {}
};

// pointer to member functions
void apply(Car *c, void (Car ::*func)()) {
  // again, here the operator is ->*
  (c->*func)();
}

int main(void) {
  // declare a pointer to member.
  // notice, Car::* is a type!
  int Car::*pSpeed = &Car::speed;

  // you can fake a member pointer up.
  // there is no double in Car, but it can stop you from declaring
  // a member pointer to double.
  // This is the feature being used to test if a type is a class.
  double Car::*p;

  Car c1;

  // what it realy does is a binop takes an objecet and an object
  // pointer.
  int a = c1.*pSpeed;
  int b = (&c1)->*pSpeed;

  c1.speed = 10;
  std::cout << "speed is: " << c1.speed << std::endl;

  c1.*pSpeed = 2;
  std::cout << "speed is: " << c1.speed << std::endl;

  return 0;
}
#include <iostream>
#include <type_traits>

// let's define some type traits.

// define our version of move
// Now let's take a look at the move
// move take (T &&) universal reference.
// It remove all references first, and add two &&
// which guarantee us to get a rvalue reference.
// steps
// 0. accept universal ref (both lval and rval).
// 1. take type T
// 2. remvoe all reference
// 3. add && to make it universal reference.
// 4. return T with &&, make it a rval.
// Now it's a rval ref, compile can free to call the move
// constructor
template <typename T> typename std::remove_reference<T>::type &&move_(T &&a) {
  return a;
}

template <typename T>
constexpr T &&forward_(typename std::remove_reference<T>::type &&t) noexcept {
  static_assert(!std::is_lvalue_reference<T>::value,
                "template argument substituing T is an lvalue reference type");
  return static_cast<T &&>(t);
}
#include <iostream>
#include <memory>
#include <vector>

struct Parameters {
  int r1;
  int r2;
  std::unique_ptr<std::vector<int>> vs;
};

int foo(Parameters params) { return params.vs->size(); }

int main(void) {

  auto vs = std::make_unique<std::vector<int>>(std::vector<int>{1, 2, 3});
  auto res = foo({.r1 = 10, .r2 = 20, .vs = std::move(vs)});
  std::cout << res << std::endl;

  return 0;
}
#include <cmath>
#include <iostream>

// Complex is a POD,
// plain old data.
// Member variables declared alter in a
// structut must be at a higher address.
struct Complex {
  double real; // 0x80
  double img;  // 0x88
};

// Inheritance extend the object memory
// with new fields.
// Note if it's inherited is no longer POD.
struct Derived : Complex {
  double angle;
  /* data */
};

// Derived has similar layout as this.
struct LayotOfDerived {
  struct {
    double real;
    double img;
  };
  double angle;
};

// Now complex has a method
// But it's still a pod.
// the method resides somewhere else, and it
// only needs an address
struct Complex1 {
  double real; // 0x80
  double img;  // 0x88

  double abs() const { return std::hypot(real, img); }
};

// abs member function will be compiled into a separate function like this.
// compiler generated functions will have a mangled name,
// this happens for both methods and function overload.
// use c++filt to reverse the mangled name.
double _ZNK7Complex1absEv(Complex1 const *self) {
  return std::hypot(self->real, self->img);
}

// What about class with polymorphism
// Non virtual fuction find statically.
// virtual function binds dynamically with virtual table.
// --------
//  Erdos
// --------
//  vtable -> .....-> who_am_i_really() {}
struct Erdos {
  void who_am_i() { std::cout << "Erdos" << std::endl; }
  virtual void who_am_i_really() { std::cout << "Really Erods" << std::endl; }
};

struct Fermat : public Erdos {
  void who_am_i() { std::cout << "Fermat" << std::endl; }
  virtual void who_am_i_really() { std::cout << "Fermat" << std::endl; }
};

// More complicated polymorphism.
// Vtable is normally  stored in const region.
//
// On heap            On const region
// ========            =======
// Complex2         +>  Vtable
// ========         |  =======
// Vtable: 8 -> ... +   dtor* --------> ~Complex2() {...}
// --------            -------
//  real: 8            double(*) -----> double Complex2::abs() {...}
// --------            -------
//  img : 8
// --------
// Vtable are set by the constructor.
struct Complex2 {
  virtual ~Complex2() = default;
  virtual double abs() { return std::hypot(real, img); }
  double real;
  double img;
};

struct Derived2 : public Complex2 {
  virtual ~Derived2() = default;
  virtual double abs() { return std::hypot(std::hypot(real, img), angle); }
  double angle;
};

// Notice here, if you create A fermat1 it will prints
// "Really Erdos."
// Because after the Constructor set the vtable, the half
// constructed Fermat1 call who_am_i_really, which at this
// point points to Erdos1's vtable.
//
// When you are in a base class constructor, you are of tye
// type of that base class.
// Conclusion ! Never call virtual function in a constructor.
struct Erdos1 {
  Erdos1() { who_am_i_really(); }
  virtual void who_am_i_really() { std::cout << "Really Erods" << std::endl; }
};

struct Fermat1 : public Erdos {
  virtual void who_am_i_really() { std::cout << "Fermat" << std::endl; }
};

// YMMV, the layout not always the same.

int main(void) {
  std::cout << "Is Complex pod? " << std::is_pod<Complex>::value << std::endl;
  std::cout << "size " << sizeof(Complex) << std::endl;
  std::cout << "\n" << std::endl;

  std::cout << "Is Derived pod? " << std::is_pod<Derived>::value << std::endl;
  std::cout << "size " << sizeof(Derived) << std::endl;
  std::cout << "\n" << std::endl;

  std::cout << "Is LayotOfDerived pod? " << std::is_pod<LayotOfDerived>::value
            << std::endl;
  std::cout << "size " << sizeof(LayotOfDerived) << std::endl;
  std::cout << "\n" << std::endl;

  std::cout << "Is Complex1 pod? " << std::is_pod<Complex1>::value << std::endl;
  std::cout << "size " << sizeof(Complex1) << std::endl;
  std::cout << "\n" << std::endl;

  // polymorphism
  // both of them have a virtual table with a point to one method.
  // one pointer, 8 bytes.
  std::cout << "Is Erdos pod? " << std::is_pod<Erdos>::value << std::endl;
  std::cout << "size " << sizeof(Erdos) << std::endl;
  std::cout << "\n" << std::endl;

  std::cout << "Is Fermat pod? " << std::is_pod<Fermat>::value << std::endl;
  std::cout << "size " << sizeof(Fermat) << std::endl;
  std::cout << "\n" << std::endl;

  return 0;
}
#include <cmath>
#include <iostream>

struct complex {
  float real;
  float img;
  float abs() const { return std::hypot(real, img); }
};

// is

struct complex_compiled {
  float real;
  float img;
};
float abs(complex *self) { return std::hypot(self->real, self->img); }
#include <iostream>

// virtual table

struct Vector2VTable;
struct Vector3VTable;

struct vector2 {
  Vector2VTable *vtable;
  float x;
  float y;
};

struct vector3 {
  Vector3VTable *vtable;
  float x;
  float y;
  float z;
};

// virtual member functions
float vector2_dot_virtual(const vector2 *self, const vector2 &other) {
  return self->x + other.x + self->y + other.y;
}

float vector3_dot_virtual(const vector3 *self, const vector3 &other) {
  return self->x + other.x + self->y + other.y + self->z + other.z;
}

vector3 vector3_cross_virtual(const vector3 *self, const vector3 &other) {
  // fake cross product.
  return {0, 0, 0};
}

struct Vector2VTable {
  float (*dot)(const vector2 *self, const vector2 &other);
};

struct Vector3VTable {
  float (*dot)(const vector3 *self, const vector3 &other);
  vector3 (*cross)(const vector3 *self, const vector3 &other);
};

void vector2_constructor_base__(vector2 *vec) {
  vec->vtable = new Vector2VTable();
  vec->vtable->dot = &vector2_dot_virtual;
}

vector2 vector2_default_constructor() {
  vector2 tmp__{};
  vector2_constructor_base__(&tmp__);
  return tmp__;
}
vector2 vector2_copy_constructor(const vector2 &other) {
  vector2 tmp__ = vector2_default_constructor();
  tmp__.x = other.x;
  tmp__.y = other.y;
  return tmp__;
}
vector2 vector2_move_constructor(vector2 &&other) {
  vector2 tmp__ = vector2_default_constructor();
  tmp__.x = other.x;
  tmp__.y = other.y;
  return tmp__;
}
void vector2_destructor(vector2 *self) { delete self->vtable; }

void vector3_constructor_base__(vector3 *vec) {
  vec->vtable = new Vector3VTable();
  vec->vtable->dot = &vector3_dot_virtual;
  vec->vtable->cross = &vector3_cross_virtual;
}

vector3 vector3_default_constructor() {
  vector3 tmp__{};
  vector3_constructor_base__(&tmp__);
  return tmp__;
}

vector3 vector3_copy_constructor(const vector3 &other) {
  vector3 tmp__ = vector3_default_constructor();
  tmp__.x = other.x;
  tmp__.y = other.y;
  tmp__.z = other.z;
  return tmp__;
}
vector3 vector3_move_constructor(vector3 &&other) {
  vector3 tmp__ = vector3_default_constructor();
  tmp__.x = other.x;
  tmp__.y = other.y;
  tmp__.z = other.z;
  return tmp__;
}
void vector3_destructor(vector3 *self) { delete self->vtable; }

int main(void) {

  vector3 v3_1 = vector3_default_constructor();
  v3_1.x = 2;
  v3_1.y = 2;
  v3_1.z = 2;
  float result_1 = (*v3_1.vtable->dot)(&v3_1, v3_1);
  std::cout << "vector 3 dot product: " << result_1 << std::endl;

  vector3 v3_2 = vector3_copy_constructor(v3_1);

  vector2 v2_1 = vector2_copy_constructor(*reinterpret_cast<vector2 *>(&v3_2));

  vector3_destructor(&v3_1);
  vector3_destructor(&v3_2);
  vector2_destructor(&v2_1);
  return 0;
}
#include <cassert>
#include <iostream>

class Timer {};

int main(void) {

  Timer t{Timer()};
  assert(sizeof(t) == 1);
  std::cout << sizeof(t) << std::endl;
  return 0;
}
#include <iostream>

class Timer {};

int main(void) {

  Timer t{Timer()};
  std::cout << sizeof(t) << std::endl;
  return 0;
}
#include <iostream>
#include <vector>
// so called associative data type, just this
#include <iostream>
#include <map>
#include <unordered_map>

template <typename K> class GMapKey {
public:
  template <typename V> using GMap = void;
  template <typename V> static V lookup(K k, GMapKey<V>);
  template <typename V> static GMap<V> insert(K k, V v, GMapKey<V>);
};

template <> class GMapKey<int> {
public:
  template <typename V> using GMap = std::map<int, V>;
  template <typename V> static V lookup(auto k, GMap<V> m) { return m[k]; }
  template <typename V> static GMap<V> insert(auto k, V v, GMap<V> m) {
    m.insert(std::pair<int, V>(k, v));
    return m;
  }
};

template <> class GMapKey<char> {
public:
  template <typename V> using GMap = std::map<char, V>;
  template <typename V> static V lookup(auto k, GMap<V> m) { return m[k]; }
  template <typename V> static GMap<V> insert(auto k, V v, GMap<V> m) {
    m.insert(std::pair<char, V>(k, v));

    return m;
  }
};

int main(void) {
  std::map<int, char> m{};
  m = GMapKey<int>::insert(3, 'a', m);
  m = GMapKey<int>::insert(4, 'b', m);
  m = GMapKey<int>::insert(5, 'c', m);
  std::cout << GMapKey<int>::lookup(3, m) << std::endl;

  return 0;
}
#include <iostream>
#include <string>
#include <vector>

struct Base {
  virtual std::string get_name() const = 0;
};

struct Bar : Base {
  std::string get_name() const override { return "bar"; }
};

struct Foo : Base {
  std::string get_name() const override { return "Fool"; }
};

// liskov substitution principle
// basically just have a polymorphic pointer which can behave as
// any of the subclass.
void print_name(std::vector<const Base *> vec) {
  for (auto v : vec)
    std::cout << v->get_name() << std::endl;
}

int main(void) {

  Foo foo;
  Bar bar;

  std::vector<const Base *> vec{&foo, &bar};

  print_name(vec);

  return 0;
}
compile_ () {
  g++ ./specialization"$1".cc
}

dump_ () {
  compile_ $1 && objdump -C -d ./a.out > out."$1".asm
}
#include <cassert>
#include <iostream>

template <typename T> T byte_swap(T value) {
  unsigned char *bytes = reinterpret_cast<unsigned char *>(&value);
  for (size_t i = 0; i < sizeof(T); i += 2) {
    unsigned char v = std::move(bytes[i]);
    bytes[i] = std::move(bytes[i + 1]);
    bytes[i + 1] = std::move(v);
  }
}

template <> double byte_swap(double value) {
  assert(false && "Illegal to swap double");
  return value;
}

template <> char byte_swap(char value) {
  assert(false && "Illegal to swap char");
  std::cout << "good" << std::endl;
  return value;
}

int main(void) { return 0; }
#include <atomic>
#include <cassert>
#include <iostream>

template <typename T> T byte_swap(T value) {
  unsigned char *bytes = reinterpret_cast<unsigned char *>(&value);
  for (size_t i = 0; i < sizeof(T); i += 2) {
    unsigned char v = std::move(bytes[i]);
    bytes[i] = std::move(bytes[i + 1]);
    bytes[i + 1] = std::move(v);
  }
}

double byte_swap(double value) {
  assert(false && "Illegal to swap double");
  return value;
}

char byte_swap(char value) {
  assert(false && "Illegal to swap char");
  std::cout << "good" << std::endl;
  return value;
}

template <> char byte_swap(char value) {
  std::atomic<int> counter;
  assert(false && "Illegal to swap char");
  for (int i = 0; i < 10; ++i) {
    counter++;
  }
  return value + counter;
}

int main(void) {
  char c = 'a';
  char c1 = byte_swap(c);
  char c2 = byte_swap<>(c);
  return 0;
}
#pragma once
#if __GNUC__ >= 4
#define DLL_API __attribute__((visibility("default")))
#define DLL_LOCAL __attribute__((visibility("hidden")))
#else
#define DLL_API
#define DLL_LOCAL
#endif
#include "fvisibility.h"
#include <iostream>

int fvisibility() {
  std::cout << "fvisibility" << std::endl;
  return 1;
}
#include "common.h"

DLL_LOCAL
int fvisibility();

#include "fvisibility.h"

int main(void) {

  fvisibility();
  return 0;
}
#!/usr/bin/bash

# https://stackoverflow.com/questions/10749058/building-and-linking-a-shared-library

g++ -Wall -fpic fvisibility.cc -c -o libfvis.so
g++ -Wall main.cc -c -o main.o
g++ -Wall -fvisibility=hidden main.o -I. -L. -lfvis

rm main.o
#include <concepts>
#include <iostream>
#include <type_traits>
#include <vector>

// there are different types of constraints.
//
// 1. simple requirement
// 2. nested requirement
// 3. compound requirement
// 4. type requirement

// let's connstrain this function.
// left fold of addition.
template <typename... Args> auto add_(Args &&... args) { return (... + args); }

// what do we want to constrain here?
// 1. + is defined
// 2. typename ...Args are all of the same type
// 3. + should be noexcpet
// 4. return type should be the same

// let's define some handy type traits first. Latter
// we will use them to define the concept

// pattern matching on type list.
template <typename T, typename...> struct first_type { using type = T; };
template <typename... Args>
using first_type_t = typename first_type<Args...>::type;

// template boolean
template <typename T, typename... Ts>
inline constexpr bool are_same_v = std::conjunction_v<std::is_same<T, Ts>...>;

template <typename T, typename... Args>
concept same_as_first_type =
    std::is_same_v<std::remove_cvref_t<T>,
                   std::remove_cvref_t<first_type_t<Args...>>>;

template <typename... Args> requires requires(Args... args) {
  (... + args);                 // 1. simple requirement
  requires are_same_v<Args...>; // 2. nested requirement
  requires sizeof...(Args) > 1; // 3. nested requirement with boolean assertion.
  { (... + args) }
  noexcept->same_as_first_type<Args...>; // 4. compound requirements
}
auto add(Args &&... args) { return (... + args); }

// exercise
template <typename... Args> requires requires(Args... args) {
  (... * args);
  requires are_same_v<Args...>;
  requires sizeof...(args) > 1;
  { (... * args) }
  noexcept->same_as_first_type<Args>;
}
auto mul(Args &&... args) { return (... * args); }

// now you have these constrained functions, but how do you know if they
// are correct constrains or not?
// you need some methods to reliably test your constrains.

template <bool NOEXCEPT, bool hasOperatorPlus, bool validReturnType>
class ObjectMock {

public:
  ObjectMock() = default;

  ObjectMock &operator+(const ObjectMock &rhs) noexcept(NOEXCEPT) requires(
      hasOperatorPlus &&validReturnType) {
    return *this;
  }

  int operator+(const ObjectMock &rhs) noexcept(NOEXCEPT) requires(
      hasOperatorPlus && not validReturnType) {
    return 3;
  }
};

using NoAdd = ObjectMock<true, false, true>;
using ValidClass = ObjectMock<true, true, true>;
using NoNoexcept = ObjectMock<false, true, true>;
using DifferentReturnType = ObjectMock<false, true, false>;

template <typename... Args> concept TestAdd = requires(Args... args) {
  add(args...);
};

static_assert(TestAdd<int, int, int>);
//static_assert(TestAdd<NoAdd, NoAdd>);


int main(void)
{

  return 0;
}
#include <concepts>
#include <cstddef>
#include <iostream>
#include <string>

int main(void)
{

  return 0;
}
#include <iostream>
#include <thread>

template <typename T, T t> class Atomic_ {

  void operator++() {
    __asm__ __volatile__("lock;"
                         "incq %0;"
                         : "+m"(t)
                         :
                         :);
  }

  void operator--() {
    __asm__ __volatile__("lock;"
                         "decq %0;"
                         : "+m"(t)
                         :
                         :);
  }

  void cmp_n_xhg() {}
};
// https://stackoverflow.com/questions/31978324/what-exactly-is-stdatomic
#include <atomic>
#include <iostream>
#include <thread>

// A class works around an atomic variable.
struct Flag {
  // make an atomic
  std::atomic<int> foo;
  mutable std::atomic_int ff;

  Flag() : foo(0) {}

  void set(int x) { foo.store(x, std::memory_order_relaxed); }

  int set_to(int x) {
    // atomically do: old = foo; foo = x;
    int old = foo.exchange(x);
    return old;
  }

  void print() {
    int x;
    do {
      x = foo.load(std::memory_order_relaxed);
    } while (x == 0);
    std::cout << "reuslt: " << x << std::endl;
  }
};

// This is an terrible example because it
// really don't need atomic.
struct Flag1 {
  // make an atomic
  int foo;

  Flag1() : foo(0) {}

  void set(int x) { foo = x; }

  void print() {
    int x;
    do {
      x = foo;
    } while (x == 0);
    std::cout << "reuslt: " << x << std::endl;
  }
};

int main(void) {
  Flag1 flag;

  std::thread t1([&flag]() { flag.print(); });

  std::thread t2([&flag]() { flag.set(10); });

  t1.join();
  t2.join();

  return 0;
}
// https://stackoverflow.com/questions/48550134/software-transaction-memorystm-vs-compare-and-swapcas
// https://www.youtube.com/watch?v=ZQFzMfHIxng

// Atomic is slightly faster then mutex.
// but spinlock and mutex run roughly at the same speed.

// Atomic operations have to wait for cache line access.

#include <atomic>

// CAS
class CompareAndSwap {
  std::atomic<int> x;

  CompareAndSwap() : x(0) {}

  void inc() {
    // read the atomic value first.
    int x0 = x;

    // if x is not change, thus it's still equals to x1,
    // then swap it to x0+1.
    // If someone did change x, x != x0, so
    // compare exchange failed.
    // Put it in a while loop so we can try it again.
    while (!x.compare_exchange_strong(x0, x0 + 1))
      ;
  }
};

int main(void) { return 0; }
#include <iostream>

int main(void)
{
  return 0;
}
#include <atomic>
#include <chrono>
#include <iostream>
#include <thread>
#include <vector>
#include <benchmark/benchmark.h>

// what do system people do.?

// Four cases to demonstrate the effect of sharing cacheline
// has on performance.

void work(std::atomic<int> &a) {
  for (int i = 0; i < 100000; i++) {
    a++;
  }
}

void single_thread() {
  std::atomic<int> a;
  a = 0;

  for (int i = 0; i < 3; ++i) {
    work(a);
  }
}

// direct sharing.
//  a will bounce around in four different cachelines.
void direct_sharing() {
  std::atomic<int> a;
  a = 0;

  std::vector<std::thread> ts{};

  for (int i = 0; i < 3; ++i) {
    ts.emplace_back(std::thread([&]() { work(a); }));
  }

  for (auto &t : ts) {
    t.join();
  }
}

// false sharing.
// although different threads are using different atomic values,
// they happen to align in the sme cache line.
// the same cacheline will also bouncing around four threads, but this
// time 3/4 are useless.
void false_sharing() {
  std::atomic<int> a;
  std::atomic<int> b;
  std::atomic<int> c;
  std::atomic<int> d;

  std::thread t1([&]() { work(a); });
  std::thread t2([&]() { work(b); });
  std::thread t3([&]() { work(c); });
  std::thread t4([&]() { work(d); });

  t1.join();
  t2.join();
  t3.join();
  t4.join();
}

// No sharing at all among 4 threads.
// cacheline has maximum size 64 bytes. if we align the struct
// to 64 we can guarantee two structs don't fit in one cachline.
struct alignas(64) AlignedType {
  AlignedType() { val = 0; }
  std::atomic<int> val;
};

void no_sharing() {
  AlignedType a{};
  AlignedType b{};
  AlignedType c{};
  AlignedType d{};

  std::thread t1([&]() { work(a.val); });
  std::thread t2([&]() { work(b.val); });
  std::thread t3([&]() { work(c.val); });
  std::thread t4([&]() { work(d.val); });

  t1.join();
  t2.join();
  t3.join();
  t4.join();
}

#define BENCHMARK(fn)                                                          \
  {                                                                            \
    auto start = std::chrono::high_resolution_clock::now();                    \
    fn();                                                                      \
    auto end = std::chrono::high_resolution_clock::now();                      \
    std::chrono::duration<double, std::milli> elapsed = end - start;           \
    std::cout << #fn ": " << elapsed.count() << "ms" << std::endl;             \
  }

// % g++ false_sharing.cc -std=gnu++2a -lpthread && ./a.out
// single_thread: 3.42128ms
// direct_sharing: 8.17625ms
// false_sharing: 8.4682ms
// no_sharing: 1.01538ms

int main(void) {

  BENCHMARK(single_thread);
  BENCHMARK(direct_sharing);
  BENCHMARK(false_sharing);
  BENCHMARK(no_sharing);

  return 0;
}
#include <future>
#include <iostream>
#include <mutex>
#include <numeric>
#include <thread>
#include <vector>

// https://en.wikipedia.org/wiki/Futures_and_promises
//
// C++ async mechanism:
// An async operation has two side: [the producer/wr] and [the consumer]
//
// - Why promise and future are separate?
//   1. std::promise is a writable pending value (the function set the value),
//      std::future is a readony pending value (the value).
//
//      future can be defiend without specifying which pormise to set its value.
//      the value of a future can be set by any promise, but it can only be set once.
//
//      Settting the value of a future is called resolving/fulfilling.
//
// - What's the motivation of promise and future if we have thread already?
//   promise based model makes concurrent code easier to write.
//
//   futures and promise decouple the computation and the return value of the computation,
//   You can refer to the result of the computation as future and use freely without
//   concern how the value is computeted.
//
//   If the value is computed, where the value is used can preceed. Otherwise the thread
//   will wait for the value to arrive.
//
//   Doing so we can avoid writing too many low level locks. Essentially get put a lock
//   on the value acces it iself.
//
// - What does it mean by having more flexibility on computation (decouple computation and result)?
//   If you have a future, you can use it as other normal values.
//
//   Usually in an imperative setting, if you are using a value, it assumes some computation related
//   to this value is done before you are using it. In another word, the existence of the value
//   is part of the precondition of where you use it.
//
//   If you wrap the computation in a promise and use it's result as future, it's not necessarily
//   true that the value is computed when you are using it. The related computation is in promise
//   and is invoked when needed, a bit like lazy eval.
//
//   But because the whole computation is captured by the promise, it doesn't matter how you execute
//   it. You can run the code in promise synchronously, asynchornously, in another thread, in anther
//   core, or even somewhere far far away.
//
//   With promies and future, all you need to ensure is when future.get() is called, the computation
//   is done somewhere and the valueeventually arives. The flexibility comes by the fact that the
//   computation is decoupled from the current control flow.
//
// - Is it necessary for future and promise be two separate things?
//   No, you can totally create a promise by specifying what computation should it run,
//   and what value it should return, and use the exact same promise as the pending value.
//   It's just happen C++ stl design promose like this.
//   Now you not only have lower level primitives like promise + thread, you also can built
//   async which is a higher level interface.
//
// - What's the theory behind promise and future?
//   It's similar to actor model, as all operations happen asynchronously.
//   Promise and future forms two end of a communication.
//
//   - Promise "send message to mailbox" by set value in future.
//   - Future "get message from the mailbox" by accessing it's value.
//   if future accesses it's value but it's not there, it just wait.
//
//   Different from CSP which the producer cannot send the request if the consumer is
//   not waiting to receive.

// std::future provides mechanism to access the result of asynchronous
// operations. What is an asynchronous operation?
//   operations created by
//    1. std::async
//    2. std::packaged_task
//    3. std::promise



namespace promise_demo {
//// std::promise
//   Promise-future communication channel:
//
//   Each promise associates with a shared state and a result.
//   Operations on shared state:
//   1. *make ready* (unlock critical section allows waiting threads come in)
//   2. *release* (gives up its reference to the shared state.)
//      references to shared state act in a reference counting scheme.
//      If there is no reference to the shared state, the state is destroyed.
//   3. *abandon* store exception >> make ready >> realease.
//

// fold + on the vector,
// set value of promise to be the result,
// then signal promise to be ready.
//
void accumulate(std::vector<int>::iterator first,
                std::vector<int>::iterator last,
                std::promise<int> acc_promise) {
  int sum = std::accumulate(first, last, 0);

  std::cout << "\nsetting in accumulate: " << std::endl;
  // setting value and notifing the future.
  acc_promise.set_value(sum);
}

// sleep to simulate work,
// set barrier promise with no value. This will only signal it to be ready.
void do_work(std::promise<void> barrier) {
  std::this_thread::sleep_for(std::chrono::seconds(1));
  barrier.set_value();
}

void promise_demo() {
  std::cout << "Promise demo: ====" << std::endl;
  std::vector<int> numbers{1, 2, 3, 4, 5, 6};

  // create the promise
  std::promise<int> acc_promise;

  // get the future of the promise:
  // The result of promise is obtained from the future.
  // Once promise is finished future will have the value.
  std::future<int> acc_future = acc_promise.get_future();

  // NOTE this won't work. Different from std::thread, std::promise will not
  // automatically spawn a thread. Instead it merely represent a pending
  // computation that can have a pending return value future.
  //
  // std::cout << "result=" << acc_future.get() << std::endl;

  // launch the promie in a thread.
  // thread constructor has loads of overloads.
  std::thread worker(accumulate, numbers.begin(), numbers.end(),
                     std::move(acc_promise));

  // future::get() to get the result from promise. In this case is the sum of
  // vectors we calcualted.
  // It will wait until the future has a valid result.
  // Doesn't need to call wait before get.
  std::cout << "result=" << acc_future.get() << std::endl;
  worker.join();

  {
    // use promise<void> to signal state between threads.
    std::promise<void> barrier;
    std::future<void> barrier_future = barrier.get_future();
    std::thread new_worker(do_work, std::move(barrier));
    barrier_future.wait();
    new_worker.join();
  }

  std::cout << "End promise demo: ====" << std::endl;
}

} // namespace promise_demo

namespace async_demo {
// std::async funs the function asynchronously, and return a future to represent
// the pending result.

// There are two modes (execution policy):
// 1. std::launch::async (run function in a separate thread)
// 2. std::launch::deferred (lazy eval the function, call f synchronously)

struct X {
  std::shared_ptr<std::mutex> m;
  X(std::shared_ptr<std::mutex> m) : m(m) {}

  void foo(int i, const std::string &str) {
    std::lock_guard<std::mutex> lk(*m);
    std::cout << str << " " << i << std::endl;
  }

  void bar(const std::string &str) {
    std::lock_guard<std::mutex> lk(*m);
    std::cout << str << std::endl;
  }

  std::string operator()(int i, const std::string &str) {
    std::lock_guard<std::mutex> lk(*m);
    std::cout << str << " " << i << std::endl;
    return "DONE: " + str;
  }
};

// sum an vector in parallel.
// Takes any iterator.
// split it in half.
//
// recursively sum the first half and second half, but
// put the second half in anothe thread.

template <typename RandomIt> int parallel_sum(RandomIt first, RandomIt last) {
  auto len = last - first;
  if (len < 1000) {
    return std::accumulate(first, last, 0);
  }

  RandomIt mid = first + len / 2;
  auto handle =
      std::async(std::launch::async, parallel_sum<RandomIt>, mid, last);
  int sum = parallel_sum(first, mid);
  return sum + handle.get();
}

void async_demo() {
  std::cout << "Future demo: ===" << std::endl;
  auto future = std::async(std::launch::async,
                           []() { std::cout << "I am a thread" << std::endl; });
  future.get(); // retrieve the value from future.

  std::cout << "\n";
  {
    // use async to run parallel...
    std::vector<int> v(10000, 2);
    std::cout << "Sum is: " << parallel_sum(v.begin(), v.end()) << std::endl;
  }

  std::cout << "\n";
  {
    std::shared_ptr<std::mutex> m = std::make_shared<std::mutex>();
    X x{m};
    // (&a)->foo(42, "hello");
    auto a1 = std::async(&X::foo, &x, 42, "a1: hello, I maybe async or deferred");

    // x.bar("world") in lazy
    auto a2 =
        std::async(std::launch::deferred, &X::bar, x, "a2: world!, I'm deferred");

    // X()(43) in async
    auto a3 =
        std::async(std::launch::async, X{m}, 43, "a3: I'm in another thread!");
    std::cout << a3.get() << std::endl;

    //  cannot get twice
    // std::cout << a3.get() << std::endl;

    a2.wait(); // lazy eval
  }

  std::cout << "End future demo: ===" << std::endl;
}

} // namespace async_demo

//// std::packaged_task

int main(void) {
  async_demo::async_demo();
  std::cout << "\n";
  promise_demo::promise_demo();

  return 0;
}
// https://en.cppreference.com/w/cpp/atomic/atomic_compare_exchange
// https://stackoverflow.com/questions/40223599/what-is-the-difference-between-stdshared-ptr-and-stdexperimentalatomic-sha
// https://stackoverflow.com/questions/25199838/understanding-stdatomiccompare-exchange-weak-in-c11


// atomic_compare_exchange is the atomic swap.
// it's probably one of the most important operation for lock
// free data algorithms.

#include <atomic>
#include <iostream>
#include <memory>
#include <random>
#include <thread>

template <typename T> class LockFreeStack {
  struct node {
    std::shared_ptr<T> data;
    std::shared_ptr<node> next;
    node(const T &data) : data(std::make_shared<T>(data)) {}
  };

  std::shared_ptr<node> head;

public:
  void push(const T &data) {
    const std::shared_ptr<node> new_node = std::make_shared<node>(data);

    // put the current value of head into new_node->next
    new_node->next = std::atomic_load(&head);

    // make new_node the new head.
    // if the head is no longer what's stored in
    // new_node->next, that means some other thread must
    // have inserted a node just now.
    // So we should put that new head into new_node->next
    // and try again.
    while (!std::atomic_compare_exchange_weak(&head, &new_node->next, new_node))
      ;
  }

  std::shared_ptr<T> pop() {
    std::shared_ptr<node> old_head = std::atomic_load(&head);
    while (old_head &&
           !std::atomic_compare_exchange_weak(&head, &old_head, old_head->next))
      ;

    return old_head ? old_head->data : std::shared_ptr<T>();
  }
};

int main(void) {
  LockFreeStack<int> ls;

  ls.push(1);
  ls.push(2);

  auto out = ls.pop();
  auto out1 = out;

  std::cout << "value: " << (*out) << ", count: " << out.use_count() << std::endl;

  return 0;
}
#include <condition_variable>
#include <iostream>
#include <memory>
#include <mutex>
#include <thread>
#include <vector>

// Use recursive mutex, or reentrance lock, you can
// lock a same lock multiple times
struct Complex {
  std::recursive_mutex mut;
  int i;

  void mul(int x) {
    std::lock_guard<std::recursive_mutex> guard(mut);
    i *= x;
  }

  void div(int x) {
    std::lock_guard<std::recursive_mutex> guard(mut);
    i /= x;
  }

  // This function only works for reentrance lock.
  // If mut is just a ordinary mutex,
  // Once you enter both, mut will be lock.
  // Then you cannot preceed into mul because it's
  // lock_guard requires mut to be unlocked.
  void both(int x, int y) {
    std::lock_guard<std::recursive_mutex> guard(mut);
    mul(x);
    div(y);
  }
};

// Sometimes you don't want to lock a lock forever.
// Instead you want to say, I want to lock this mutex for
// a timeout, like 2000 ms, and then free it.
// Because I know locking it for 2000ms is long enough
// for it's purpose.
// This approach works only when you know the timeout
// is long enough to keep all threads properly synchronized.
// If you cann't guarantee that, the lock will be completely
// useless.
struct TimedLocking {
  std::vector<std::thread> threads;
  std::timed_mutex tmut;

  void work() {
    std::chrono::milliseconds timeout(500);
    for (int i = 0; i < 2; ++i) {
      if (tmut.try_lock_for(timeout)) {
        std::cout << std::this_thread::get_id() << ": do work with the mutex"
                  << std::endl;
        std::chrono::milliseconds sleep_duration(250);
        std::this_thread::sleep_for(sleep_duration);
        tmut.unlock();
      } else {
        std::cout << std::this_thread::get_id() << ": do work without mutex"
                  << std::endl;
        std::chrono::milliseconds sleep_duration(100);
        std::this_thread::sleep_for(sleep_duration);
      }
    }
  }

  // This is a good example of  constructor with side effect.
  // Whenever you create this thing it will execute
  // forever. Very stincky.
  TimedLocking() {
    for (int i = 0; i < 2; ++i) {
      // needs to capture this by value.
      // this is a raw pointer so be careful.
      threads.push_back(std::thread([this]() { this->work(); }));
    }

    for (auto &t : threads) {
      t.join();
    }
    std::cout << "end" << std::endl;
  }
};

// call_once can be used to make sure a function
// is called once no matter how many threads there are.
// once_flag is really just an atomic bool
struct CallOnce {
  std::once_flag flag;
  std::vector<std::thread> threads;

  void do_something() {
    std::call_once(flag, []() { std::cout << "call once!" << std::endl; });
    std::cout << "call each time" << std::endl;
  }

  CallOnce() {
    for (int i = 0; i < 4; ++i) {
      threads.push_back(std::thread([this]() { this->do_something(); }));
    }

    for (auto &t : threads) {
      t.join();
    }
    std::cout << "end" << std::endl;
  }
};

template <typename T> struct BoundedBuffer {
  // here we uses a unique_ptr to manage the ownership
  std::unique_ptr<std::vector<T>> buffer;
  int capacity;
  int front;
  int rear;
  int count;
  std::mutex lock;

  std::condition_variable not_full;
  std::condition_variable not_empty;

  BoundedBuffer(int capacity)
      : capacity(capacity), front(0), rear(0), count(0),
        buffer(std::make_unique<std::vector<T>>()) {
    buffer->reserve(capacity);
    buffer->resize(capacity);
  }

  ~BoundedBuffer() {}

  void add(T data) {
    // unique lock is also a wrapper to manage a lock.
    // It's necessary to use unique_lock with condition
    // variables.
    std::unique_lock<std::mutex> l(lock);

    // wait takes a lock and a preducate function.
    // it blocks until the predicate is true.
    // otherwise the thread will sleep.
    not_full.wait(l, [this]() { return count < capacity; });

    buffer->at(front) = data;
    rear = (rear + 1) % capacity;
    ++count;
    l.unlock();

    // To wake up a thread that is waiting for a condition
    // variable, you call nofity.
    //
    not_empty.notify_one();
  }

  int get() {
    std::unique_lock<std::mutex> l(lock);

    not_empty.wait(l, [this]() { return count > 0; });

    int result = buffer->at(front);
    front = (front + 1) % capacity;
    --count;

    l.unlock();
    not_full.notify_one();
    return result;
  }
};


// this is a simplified version of producer consumer model.
// There is no exit signal, so if items produced is lessthan
// item received, consumer will take meaningless items.
class ProducerComsumerProblem {

public:
  ProducerComsumerProblem() {
    BoundedBuffer<int> buffer{200};

    std::thread p1([&buffer]() { producer(1, buffer); });
    std::thread p2([&buffer]() { producer(2, buffer); });
    std::thread c1([&buffer]() { consume(1, buffer); });
    std::thread c2([&buffer]() { consume(2, buffer); });
    std::thread c3([&buffer]() { consume(3, buffer); });

    p1.join();
    p2.join();

    c1.join();
    c2.join();
    c3.join();
    std::cout << "end" << std::endl;
  }

  static void consume(int id, BoundedBuffer<int> &buffer) {
    for (int i = 0; i < 50; ++i) {
      int value = buffer.get();
      std::cout << "Consumer " << id << " got " << value << std::endl;
      std::this_thread::sleep_for(std::chrono::milliseconds(80));
    }
  }

  static void producer(int id, BoundedBuffer<int> &buffer) {
    for (int i = 0; i < 75; ++i) {
      buffer.add(i);
      std::cout << "Producer: " << id << " produced " << i << std::endl;
      std::this_thread::sleep_for(std::chrono::milliseconds(50));
    }
  }
};

int main(void) {
  Complex comp;
  comp.both(2, 3);
  std::cout << comp.i << std::endl;

  std::cout << "=====" << std::endl;

  TimedLocking timed;

  std::cout << "=====" << std::endl;

  CallOnce once;

  std::cout << "=====" << std::endl;

  ProducerComsumerProblem pcp;
  std::cout << "=====" << std::endl;

  return 0;
}
#include <mutex>
#include <thread>

// the prefereable way to lock a scope.
// It uses RAII so you don't need to care about
// to unlock.
// But the problem of this approach is you cannot
// lock in once place and unlock
// from the other, so you can't use mutex as signal.
struct Counter1 {
  int value;
  std::mutex mut;

  Counter1() : value(0) {}
  void inc() {
    std::lock_guard<std::mutex> guard(mut);
    ++value;
  }
  void dec() {
    std::lock_guard<std::mutex> guard(mut);
    --value;
  }
};

// just use mutex to lock the function call.
// to be exception safe, the increment statement
// is also wrapped in a try catch block.
// So even if an exception happend, the lock can
// still be freed.
struct Counter2 {
  int value;
  std::mutex mut;

  Counter2() : value(0) {}
  void inc() {
    mut.lock();
    try {
      ++value;

    } catch (std::exception e) {
      mut.unlock();
      throw e;
    }
    mut.unlock();
  }
  void dec() {
    mut.lock();
    try {
      ++value;

    } catch (std::exception e) {
      mut.unlock();
      throw e;
    }
    mut.unlock();
  }
};
#include <iostream>
#include <iostream>
#include <thread>
#include <vector>

// thread is introduced in c++11.
// it provides utilities not only starting and managing
// threads. But also synchronization primitives.

int main(void) {
  std::vector<std::thread> threads;

  std::thread detached([]() {
    std::cout << "I am detached from: " << std::this_thread::get_id()
              << std::endl;
  });
  // calling detached make this thread execute indepenently
  // from the main thread.
  // So if main thread finished eailer, it's not necessary
  // finished yet.
  detached.detach();

  for (int i = 0; i < 10; ++i

  ) {
    threads.push_back(std::thread([]() {
      std::cout << "hi from " << std::this_thread::get_id() << std::endl;
    }));
  }

  for (auto &t : threads) {
    // calling join force the current thread
    // waiting until t1 is finished.

    t.join();
  }

  return 0;
}
// a compile time brain fuck

#include <cstddef>
#include <cstdio>

template <size_t N> class Stream {
public:
  constexpr void push(char c) { data_[idx_++] = c; }
  constexpr operator const char *() const { return data_; }
  constexpr size_t size() { return idx_; }

private:
  size_t idx_{};
  char data_[N]{};
};

///////////////////////////////////////////////////////////////////////////////
constexpr size_t CELL_SIZE = 16;
template <typename STREAM>
constexpr auto parse(const char *input, bool skip, char *cells, size_t &pc,
                     STREAM &&output) -> size_t {
  const char *c = input;
  while (*c) {
    switch (*c) {
    case '+':
      if (!skip)
        ++cells[pc];
      break;
    case '-':
      if (!skip)
        --cells[pc];
      break;
    case '.':
      if (!skip)
        output.push(cells[pc]);
      break;
    case '>':
      if (!skip)
        ++pc;
      break;
    case '<':
      if (!skip)
        --pc;
      break;
    case '[': {
      while (!skip && cells[pc] != 0)
        parse(c + 1, false, cells, pc, output);
      c += parse(c + 1, true, cells, pc, output) + 1;
    } break;
    case ']':
      return c - input;
    default:
      break;
    }
    ++c;
  }
  return c - input;
}

template <typename STREAM>
constexpr auto parse(const char *input, STREAM &&output) -> STREAM && {
  char cells[CELL_SIZE]{};
  size_t pc{};
  parse(input, false, cells, pc, output);
  return output;
}

template <size_t OUTPUT_SIZE = 15>
constexpr auto brain_fuck(const char *input) {
  Stream<OUTPUT_SIZE> output;
  return parse(input, output);
}

///////////////////////////////////////////////////////////////////////////////
int main(int argc, char **argv) {
  // compile time
  constexpr auto res = brain_fuck(R"(
        ++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.
        >---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.
    )");
  puts(res);

  return 0;
}
int main(void)
{

  return 0;
}
int main(void)
{

  return 0;
}
#include <iostream>
#include <ranges>
#include <vector>

void vec_range_test() {
  std::vector<int> numbers{1, 2, 3, 4};
  auto results = numbers

                 | std::views::filter([](int n) { return n % 2 == 0; }) u

                 | std::views::transform([](int n) { return n * 2; })

                 | std::views::transform([](int n) { return 'c'; });

  for (auto v : results) {
    std::cout << v << ", " << std::endl;
  }
}

int main(void) {
  vec_range_test();
  return 0;
}
#include <type_traits>

// http://matt.might.net/articles/lambda-style-anonymous-functions-from-c++-templates/

#include <stdio.h>
#include <stdlib.h>

unsigned int MAXVAR = 0;

template <typename T> struct Expr {

  virtual void set(unsigned int id, void *p) {
    throw "Can't set in a generic expression";
  }

  virtual T eval() { throw "Can't evaluate a generic expression"; }

  virtual Expr<T> *clone() { throw "Can't clone a generic expression"; }
};

template <typename T> class Var : public Expr<T> {
public:
  T *value;

  unsigned int id;

  Var<T>() {
    this->value = nullptr;
    this->id = MAXVAR++;
  }

  Var<T>(const Var<T> &other) {
    this->value = other.value;
    this->id = other.id;
  }

  virtual void set(unsigned int id, void *p) override {
    if (this->id == id) {
      this->value = (T *)p;
    }
  }

  virtual Expr<T> *clone() override { return new Var(*this); }

  virtual T eval() override { return *value; }
};

template <typename T> class Const : public Expr<T> {
private:
  T value;

public:
  Const<T>(T value) { this->value = value; }

  virtual void set(unsigned int id, void *p) override {}

  virtual T eval() { return value; }

  virtual Expr<T> clone() { return new Const<T>(value); }
};

template <typename T> class BinOp : public Expr<T> {
private:
  T (*op)(T, T);
  Expr<T> *lhs;
  Expr<T> *rhs;

public:
  BinOp<T>(T (*op)(T, T), Expr<T> *lhs, Expr<T> *rhs)
      : lhs(lhs), rhs(rhs), op(op) {}

  virtual void set(unsigned int id, void *p) {
    lhs->set(id, p);
    rhs->set(id, p);
  }

  virtual T eval() { return op(lhs->eval(), rhs->eval()); }

  virtual Expr<T> *clone() { return new BinOp(op, lhs, rhs); }
};

int sum(int x, int y) { return x + y; }

int product(int x, int y) { return x * y; }

template <>

struct Expr<int> {
  virtual void set(unsigned int id, void *p) {
    throw "Can't set in a generic (int) expression";
  }

  virtual int eval() { throw "Can't evaluate a generic expression"; }

  virtual Expr<int> *clone() { throw "Can't clone a generic expression"; }

  Expr<int> &operator+(Expr<int> &that) {
    return *(new BinOp(sum, this->clone(), that.clone()));
  }

  Expr<int> &operator*(Expr<int> &that) {
    return *(new BinOp(product, this->clone(), that.clone()));
  }

  Expr<int> &operator+(int &that) {}
};
#include <iostream>

#include <vector>
#include <iostream>

auto compose(auto f, auto g) {
  return [=](auto &&... x) { return f(g(x...)); };
};



double foo(int a, char b) {
  return a + static_cast<int>(b);
}


int bar(std::vector<int> v) {
  return v.size();
}


int main(void)
{

  auto f = compose(foo, bar);
  return 0;
}
#include <algorithm>
#include <initializer_list>
#include <iostream>
#include <memory>
#include <vector>

class Base {
public:
  int a;
  int b;

  Base(int a, int b) : a(a), b(b) {}

  void scall() { std::cout << "I'm base" << std::endl; }
  virtual void vcall() { std::cout << "Virtual: I'm base" << std::endl; }
};

class Dervied : public Base {

public:
  int c;
  Dervied(int a, int b, int c) : c(c), Base(a, b) {}

  void scall() { std::cout << "I'm derived" << std::endl; }
  void vcall() override { std::cout << "Virtual: I'm derived" << std::endl; }
};

int main(void) {

  { // a templateed lambda
    auto tlam = []<typename T>(T a, auto &&b) { return a < b; };
    int val = 20;
    auto r = tlam(10, val); // lval 20 is converted to rval. move is redundant.
    std::cout << "> " << r << std::endl;
  }

  { // move lambda
    // note you need to construct a initializer list here.
    // C++ can't infer the type (braced list is not deducible ...).
    std::cout << "> ";
    auto pnums = std::make_unique<std::vector<int>>(
        std::initializer_list<int>({1, 2, 3}));
::
    for (const auto &v : *pnums) {
      std::cout << "before move: " << v << " ";
    }
    std::cout << std::endl;

    auto f = [ptr = std::move(pnums)]() noexcept {
      std::cout << "value moved from pnums: " << std::endl;
      for (const auto &v : *ptr) {
        std::cout << v << " " << std::endl;
      }
    };

    f();
    std::cout << "is pnum nullptr?: " << (pnums == nullptr) << std::endl;
  }

  { // make_unique allocate on heap.
    std::cout << "> ";
    std::string a("good");
    auto ptr =
        std::make_unique<std::string>(a); // this will create a new string.
    a.append("sd");

    std::cout << "make_unique makes another string. See:" << std::endl;
    std::cout << a << std::endl;
    std::cout << *ptr << std::endl;
  }

  { // transfer ownership between unique pointers.
    std::cout << "> ";

    auto ptr1 = std::make_unique<Base>(1, 2);
    auto ptr2 = std::move(ptr1);

    std::cout << "ptr1 is null? " << (ptr1 == nullptr) << std::endl;
    std::cout << "ptr2: " << (*ptr2).a << std::endl;
  }

  { // shared pointer.
    // an vector of shared pointers.
    std::cout << "> " << std::endl;
    std::vector<std::shared_ptr<Base>> v{
        std::make_shared<Base>(1, 2), std::make_shared<Base>(1, 3),
        std::make_shared<Base>(1, 4), std::make_shared<Base>(1, 8),
        std::make_shared<Base>(1, 9),
    };

    std::vector<std::shared_ptr<Base>> v2;

    // use shared pointer with stl algorithms.
    // your elements can have multiple references.
    // Here you basically copy the ptr to another array. It's not allowed
    // For unique pointers.
    std::remove_copy_if(v.begin(), v.end(), std::back_inserter(v2),
                        [](std::shared_ptr<Base> s) { return s->b >= 3; });

    std::cout << "v now: " << std::endl;
    for (const auto &v : v) {
      v->scall();
      std::cout << v << " ";
    }
    std::cout << std::endl;

    std::cout << "v2 now: " << std::endl;
    for (const auto &v : v2) {
      v->vcall();
      std::cout << v << " ";
    }
    std::cout << std::endl;
  }

  return 0;
}
#include <functional>
#include <iostream>
#include <string>

int main(void) {
  auto f = [](int n) -> std::function<int(std::string)> {
    return [=](std::string s) { return s.size() + n; };
  };

  auto x = f(1)(std::string("asd"));
  std::cout << x << std::endl;


  return 0;
}
#include <functional>
#include <iostream>

int function(int a) { return a + 1; }

class FunctionObject {
  int x_;

public:
  FunctionObject(const int x) : x_(x) {}

  int operator()(int a) { return a + x_; }
};

template <typename Fn> int template_caller(Fn f, int arg) { return f(arg); }

int function_caller(std::function<int(int)> f, int arg) { return f(arg); }

int main(void) {
  int x = 3;
  volatile int y;

  FunctionObject fo(x);

  auto lambda = [=](int a) { return a + x; };
  y = template_caller(function, 5);
  y = template_caller(fo, 5);
  y = template_caller(lambda, 5);

  y = function_caller(function, 5);
  y = function_caller(fo, 5);
  y = function_caller(lambda, 5);
  return 0;
}
#include <functional>
#include <iostream>

int main(void) {

  // this will segfault !
  // the return value is a reference to 42,
  // but after invocation 42 is gonne.
  std::function<const int &()> f([] { return 42; });
  int x = f();

  return 0;
}
#include <assert.h>
#include <cstddef>
#include <execution>
#include <forward_list>
#include <fstream>
#include <iostream>
#include <list>
#include <memory>
#include <mutex>
#include <regex>
#include <set>
#include <string>
#include <thread>
#include <unordered_map>
#include <variant>
#include <vector>

class Complex {
  double re, im;

public:
  Complex(double r, double i) : re{r}, im{i} {}
  Complex(double r) : re{r}, im{0} {}
  Complex() : re{0}, im{0} {}
  double real() const { return re; }
  void real(double d) { re = d; }
  double imag() const { return im; }
  void imag(double i) { im = i; }

  Complex &operator+=(Complex z) {
    re += z.re;
    im += z.im;
    return *this;
  }

  Complex &operator-=(Complex z) {
    re -= z.re;
    im -= z.im;
    return *this;
  }

  Complex &operator*=(Complex);
  Complex &operator/=(Complex);
};

Complex &Complex::operator*=(Complex z) {
  re = re * z.re - im * z.im;
  im = re * z.re + im * z.im;
  return *this;
}

class Vector {
public:
  Vector(int s) : sz{s}, elem(new double[s]), current{elem} {
    if (s < 0) {
      throw std::length_error("Vector constructor: negative size");
    }
    for (int i = 0; i != s; ++i)
      elem[i] = 0;
    current++;
  }

  Vector(std::initializer_list<double> list)
      : sz(static_cast<int>(list.size())), elem(new double[sz]), current(elem) {
    std::copy(list.begin(), list.end(), elem);
  };

  ~Vector() { delete[] elem; }

  int size() const;
  void push_back(double);
  Vector read(std::istream &is);

  double &operator[](int i);

private:
  int sz;
  double *elem;
  double *current;
};

int Vector::size() const { return sz; }

double &Vector::operator[](int i) {
  assert(i < sz && i > 0);
  return elem[i];
}

void Vector::push_back(double val) {
  try {
    current += 1;
    *current = val;
  } catch (std::out_of_range &err) {
    std::cout << err.what() << std::endl;
  }
}

class Container {
public:
  virtual double &operator[](int) = 0;
  virtual int size() const = 0;
  virtual ~Container() {}
};

class Vec : public Container {
public:
  Vec(int s) : v(s) {}
  ~Vec() {}
  double &operator[](int i) override { return v[i]; }
  int size() const override { return v.size(); }

private:
  Vector v;
};

struct Point {
  int x;
  int y;
};

// class hierachies.
class Shape {
public:
  virtual Point center() const = 0;
  virtual void move(Point to) = 0;
  virtual void draw() const = 0;
  virtual void rotate(int angle) = 0;
  virtual ~Shape() {}
};

class Circle : public Shape {
public:
  Circle(Point p, int rad);
  Point center() const override { return x; }

  void move(Point to) override { x = to; }

  void draw() const override;
  void rotate(int) override {}

private:
  Point x;
  int r;
};

class Smiley : public Circle {
public:
  Smiley(Point p, int rad) : Circle(p, rad), mouth(nullptr) {}
  ~Smiley() {
    delete mouth;
    for (auto p : eyes) {
      delete p;
    }
  }

  void move(Point p) override;
  void draw() const override;
  void rotate(int) override;
  void set_mouth(Shape *s);
  virtual void wink(int i);

private:
  std::vector<Shape *> eyes;
  Shape *mouth;
};

void Smiley::draw() const {
  Circle::draw();
  for (auto p : eyes) {
    p->draw();
  }
  mouth->draw();
}

enum class Kind { CIRCLE, TRIANGLE, SMILEY };

std::unique_ptr<Shape> read_shape(std::istream is, Kind k) {

  if (k == Kind::CIRCLE) {
    Point p = {.x = 10, .y = 20};
    int r = 20;
    return std::unique_ptr<Shape>(new Circle(p, r));
  }
  return nullptr;
}

class X {
public:
  X(int);                  // og
  X();                     // default
  X(const X &);            // copy
  X(X &&);                 // move
  X &operator=(const X &); // move assign
  X &operator=(X &&);      // copy assign
  ~X();                    // destructor.
};

// resource management

class Some {
public:
  Some() {
    std::thread t;
    my_threads.push_back(std::move(t));
  }

private:
  std::vector<std::thread> my_threads;
};

template <typename T> class V {
private:
  T *elem;
  int sz;

public:
  explicit V(int s);
  explicit V(std::initializer_list<T> list)
      : sz(static_cast<int>(list.size())) {
    elem = new T[sz];
    std::copy(list.begin(), list.end(), elem);
  };

  ~V() { delete[] elem; }
  T &operator[](int i);
  const T &operator[](int i) const;
  int size() const { return sz; }
};

template <typename T> V<T>::V(int s) {
  if (s < 0)
    throw std::range_error("negative size");

  elem = new T[s];
  sz = s;
}

template <typename T> const T &V<T>::operator[](int i) const {
  if (i < 0 || size() <= i)
    throw std::out_of_range("V::operator[]");
  return elem[i];
}

template <typename T> struct SpaceVec {
  T x;
  T y;
  T z;
};

// variable template;
template <typename T> constexpr T viscosity = 0.4;

template <typename T> constexpr SpaceVec<T> external_acc{T{}, T{-9.8}, T{}};

auto vis2 = 2 * viscosity<double>;
auto acc = external_acc<float>;

// currying in type
template <typename Value>
using StringMap = std::unordered_map<std::string, Value>;

// aliase. all std containers has ::value_type
template <typename C> using Value_type = typename C::value_type;

template <typename Container> void algo(Container &c) {
  V<Value_type<Container>> vec;
}

// compile time if
template <typename T> void update(T &target) {
  if constexpr (std::is_pod<T>::value) {
    // do something
  }
}

// fold expresions
template <typename... T> int sum(T... v) { return (v + ... + 0); }

// string
void dostring() {
  std::string name = "some literal";
  std::string address{"Fake address st."};
  std::string s = name.substr(3, 5);
  name.replace(0, 3, "no");
  name[0] = toupper(name[0]);
  printf("std::string to cstr: %s\n", name.c_str());
}

// string view (ptr length pair) like slice in rust.
std::string cat(std::string_view sv1, std::string_view sv2) {
  std::string res(sv1.length() + sv2.length(), 0);
  char *p = &res[0];
  std::copy(sv2.begin(), sv2.end(), p);
  return res;
}

// iter over while matching with regex
// sregex_iterator = string regex iterator.
void regex_iter() {
  std::string input = "aa as; asd ++e^asdf asdfg";
  std::regex pat(R"(\s+(\w+))");
  for (std::sregex_iterator p(input.begin(), input.end(), pat);
       p != std::sregex_iterator(); ++p) {
    std::cout << (*p)[1] << std::endl;
  }
}

// iostream
// vals  -> ostream -> stream buffer -> somewhere.
// vals  <- ostream <- stream buffer <- somewhere.

// containers
struct Entry {
  std::string name;
  unsigned int number;
  bool operator<(const Entry &other);
};

std::vector<Entry> phone_book = { // using initializer_list
    {"David Hume", 123456},
    {"Karl Popper", 234567},
    {"Bertrand Arthur", 345678}};

auto movev(std::vector<Entry> &&en) -> std::vector<Entry> {
  std::vector<Entry> phone_book = {// using initializer_list
                                   {"POO", 123456},
                                   {"PEE", 234567},
                                   {"PAA", 345678}};
  for (Entry e : phone_book) {
    en.push_back(e);
  }
  en.reserve(en.size() * 2); // double the size

  // make a mess.
  try {
    phone_book[phone_book.size()] = {"Joe", 9999};
  } catch (std::out_of_range &) {
    std::cerr << "range error\n";
  }
  return en;
}

// push_back will push a copy.
// when needs pointer just push back pointer.
auto dov(std::vector<Entry> &&phone_book) -> std::vector<Entry> {
  // vector can be thought as a kind of smart pointer.

  for (Entry e : phone_book) {
    std::cout << e.name << e.number << std::endl;
  }
  std::cout << phone_book.capacity() << std::endl;
  std::cout << phone_book.size() << std::endl;

  phone_book = movev(std::move(phone_book));
  return phone_book;
}

// list is by default double linked list
// single linked list is called forward list.
auto lf(std::vector<Entry> &&phone_book, const Entry &ee,
        std::vector<Entry>::iterator p, std::vector<Entry>::iterator q) {
  phone_book.insert(p, ee);
  phone_book.erase(q);
  return [&]() -> std::forward_list<Entry> {
    std::forward_list<Entry> fl;
    for (const auto e : phone_book) {
      std::copy(phone_book.begin(), phone_book.end(), fl.begin());
    }
    return fl;
  };
}

bool Entry::operator<(const Entry &y) { return name < y.name; }

// algorithms.
// based on iterator. use begin and end to specify a range.
auto vsort(std::vector<Entry> &vec, std::list<Entry> &lst) -> std::list<Entry> {
  std::list<Entry> res;
  std::sort(vec.begin(), vec.end());
  std::unique_copy(vec.begin(), vec.end(),
                   lst.begin()); // lst.size() >= unique_copy of vec.
  std::unique_copy(vec.begin(), vec.end(),
                   std::back_inserter(res)); // back_inserter will init res.
  return res;
}

static inline auto has_c(const std::string &s, char c) -> bool {
  return std::find(s.begin(), s.end(), c) != s.end();
}

template <typename T> using Iterator = typename T::iterator;

template <typename C, typename V>
auto find_all(C &c, V v) -> std::vector<typename C::iterator> {
  std::vector<Iterator<C>> res;
  for (auto p = c.begin(); p != c.end(); ++p) {
    if (*p == v)
      res.push_back(p);
  }
  return res;
}

// stream iterator.
// ios_base <-- ios <-- istream <-- ifstream
namespace StreamIterator {
static std::ostream_iterator<std::string>
    oo(std::cout); // write string to cout.
static std::istream_iterator<std::string> ii{std::cin};

// ifstream is a istream that can be attached to a file.
auto someio() -> void {
  std::string filename = "somename";
  double d = 3.14;
  // play with exception
  try {
    std::ofstream(filename, std::ios::binary)
            .write(reinterpret_cast<char *>(&d), sizeof(d))
        << 123 << "abc";
  } catch (std::exception &err) {
    std::cerr << err.what() << std::endl;
  }

  // just throw
  std::ifstream istrm(filename, std::ios::binary);
  if (!istrm.is_open()) {
    throw std::runtime_error("file not found");
  }
  istrm.read(reinterpret_cast<char *>(&d), sizeof(d));
  int n;
  std::string s;
  if (istrm >> n >> s)
    std::cout << "read back from file" << d << ' ' << n << ' ' << std::endl;
}

auto ffind() {
  const std::map<std::string, int> &m{
      {"good", 12},
      {"bad", 2},
      {"happy", 59},
      {"sad", 90},
  };
  auto greater_than = [](const std::pair<std::string, int> &r) {
    return r.second > 42;
  };
  return std::find_if(m.begin(), m.end(), greater_than);
}

auto paraf() {
  std::vector<std::string> v{"a", "b", "dd", "aa", "aaa"};
  std::sort(std::execution::par, v.begin(), v.end());
}

} // namespace StreamIterator

namespace Utilities {
std::mutex m;
std::vector<int> shared{1, 2, 3, 4, 5};

auto threadf() -> void {
  {
    // acquire here.
    std::scoped_lock<std::mutex> lck{m};
    std::for_each(shared.begin(), shared.end(), [](int a) { return a + 1; });
    // release here.
  }
}

auto uniqp(std::unique_ptr<std::string> str) -> std::unique_ptr<std::string> {
  str->append("good");
  {
    std::unique_ptr<std::string> str1 =
        std::make_unique<std::string>(str); // moved!
    if (str == nullptr) {
      std::cout << "null" << std::endl; // now str is null.
    }
    // str1 get released.
  }
  return str; // this is an error since str is moved.
}

// use move to safe space when swapping.
template <typename T> auto mswap(T &a, T &b) {
  T tmp{std::move(a)};
  a = std::move(b);
  b = std::move(tmp);
}

template <typename T, typename... Args>
auto mkunique(Args &&...args) -> std::unique_ptr<T> {
  return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
}

auto arrayf() {
  std::array<int, 4> arr = {1, 2, 3, 4};
  // c interface
  auto to_vec = [&arr](int *p, int sz) -> std::vector<int> {
    std::vector<int> v;
    std::copy(arr.begin(), arr.end(), std::back_inserter(v));
    return v;
  };
  return to_vec(&arr[0], arr.size());
}

auto bsetf() -> std::array<std::bitset<10>, 5> {
  std::bitset<10> bs{"11100011"};
  std::bitset<10> bs1 = ~bs;
  std::bitset<10> bs2 = bs & bs1;
  std::bitset<10> bs3 = bs << 2;
  std::bitset<10> bs4 = bs | bs2;

  return std::array{bs, bs1, bs2, bs3, bs4};
}

auto ptuple() -> std::string {
  std::tuple<std::string, int, double> t1{"Shark", 12, 2.14};
  auto t2 = std::make_tuple(std::string{"good"}, 3, 1.2);
  std::tuple t3{"Cod", 20, 9.9};
  std::string s = std::get<0>(t1);
  return s;
}

} // namespace Utilities

namespace Concurrency {}
template <typename T> concept Decremental = requires(T t) { --t; };
template <typename T> concept RevIterator = Decremental<T> &&requires(T t) {
  *t;
};

template <Decremental T> void f(T);
template <RevIterator T> void f(T);
#include <iostream>

namespace tpgcd {
/* gcd :: Int -> Int -> Int
 * gcd a 0 = a
 * gcd a b = gcd b $ a % b
 */
template <int a, int b> struct gcd {
  static constexpr int value = gcd<b, a % b>::value;
};
template <int a> struct gcd<a, 0> { static constexpr int value = a; };

void run() { std::cout << "GCD: " << gcd<25, 50>::value << std::endl; }
} // namespace tpgcd

namespace tpfib {
/* fib :: Int -> Int
 * fib 0 = 1
 * fib 1 = 1
 * fib i = (fib $ i - 1) $ (fib $ i - 2)
 */
template <int i> struct fib {
  static constexpr int value = fib<i - 1>::value + fib<i - 2>::value;
};
template <> struct fib<1> { static constexpr int value = 1; };
template <> struct fib<0> { static constexpr int value = 1; };

void run() { std::cout << "FIB: " << fib<5>::value << std::endl; }
} // namespace tpfib

namespace tpif {
/* data Union a b = a | b
 * if :: Bool -> a -> b -> Union a b
 * if false a b = b
 * if true a b = a
 */
template <bool C, typename Then, typename Else> struct If {};
template <typename Then, typename Else> struct If<false, Then, Else> {
  using test = Else;
};
template <typename Then, typename Else> struct If<true, Then, Else> {
  using test = Then;
};

struct A {
  static constexpr int value = 1;
};

struct B {
  static constexpr int value = 0;
};

struct C {
  static inline void exec() { std::cout << "yikes" << std::endl; }
};

struct D {
  static inline void exec() { std::cout << "yummies" << std::endl; }
};

auto run() -> void {
  std::cout << If<true, A, B>::test::value << std::endl;
  std::cout << If<false, A, B>::test::value << std::endl;
  If<false, C, D>::test::exec();
}
} // namespace tpif

namespace tplist {
/* data List = Nil | Cons a (List a)
 */
struct Nil {};
template <int a, typename L> struct List {
  static constexpr int head = a;
  using tail = L;
};

using mylist = List<10, List<100, List<2, Nil>>>;

/* sum :: (Semiring a) => List a -> a
 * sum [] = 0
 * sum (x:xs) = x + (sum xs)
 */
template <typename...> struct sum { static constexpr int value = 0; };
template <int a, typename Tail> struct sum<List<a, Tail>> {
  static constexpr int value = a + sum<Tail>::value;
};

/* foldr
 */
template <typename L, template <int> typename F, template <int, int> typename R,
          int Base>
struct foldr {
  static constexpr int value = Base;
};
template <int a, typename Tail, template <int> typename F,
          template <int, int> typename R, int Base>
struct foldr<List<a, Tail>, F, R, Base> {
  static constexpr int value =
      R<F<a>::value, foldr<Tail, F, R, Base>::value>::value;
};

} // namespace tplist

int main(void) {
  std::cout << tpgcd::gcd<28, 100>::value << std::endl;
  std::cout << tpfib::fib<10>::value << std::endl;
  tpif::run();
  std::cout << "sum: " << tplist::sum<tplist::mylist>::value << std::endl;

  return 0;
}
// cpp template metaprogramming.
// template <typename a> is like forall a. but not quite.
// Remind merge sort
// 1. divide list into n sublists each with len 1.
// 2. Recursively merge 2 sublists until there is only 1 list remain.

// define list.
struct Nil {}; // a empty type.
// define structure of List.
// value needs to be defined as constexpr,
// type can just be bind with a name with using.
template <int a, typename L> struct List {
  static constexpr int head = a;
  using tail = L;
};

// define Pair.
// it accomodates two types.
template <typename A, typename B> struct Pair {
  using first = A;
  using second = B;
};

// define conditional.
// it can be thought as an if expression which the value is returned via
// `test` binding.
// if_<true, A, B>::test will call the expression and get the return value.
template <bool C, typename Then, typename Else> struct if_ {};
template <typename Then, typename Else> struct if_<false, Then, Else> {
  using test = Then;
};
template <typename Then, typename Else> struct if_<true, Then, Else> {
  using test = Else;
};

// define split func
// split will split List<int a, typename L> into several
// List<int a, Nil>
//
// base case.
template <typename L> struct Split {};

// ues template <> when matching with concrete value
template <> struct Split<Nil> { using type = Pair<Nil, Nil>; };

// a is polymorhpic parameter thus need a forall to specify.
template <int a> struct Split<List<a, Nil>> {
  using type = Pair<List<a, Nil>, Nil>;
};
template <int a, int b, typename Tail> struct Split<List<a, List<b, Tail>>> {
private:
  using _Split_rec = typename Split<Tail>::type;

public:
  using type = Pair<List<a, typename _Split_rec::first>,
                    List<b, typename _Split_rec::second>>;
};

// merge
template <template <int, int> typename P, typename L1, typename L2>
struct Merge {};

template <template <int, int> typename P, typename L2>
struct Merge<P, Nil, L2> {
  using type = L2;
};

template <template <int, int> typename P, typename L1>
struct Merge<P, L1, Nil> {
  using type = L1;
};

template <template <int, int> typename P, int A1, typename Tail1, int A2,
          typename Tail2>
struct Merge<P, List<A1, Tail1>, List<A2, Tail2>> {
  using type = typename if_<
      P<A1, A2>::value,
      List<A1, typename Merge<P, Tail1, List<A2, Tail2>>::type>,
      List<A2, typename Merge<P, List<A2, Tail1>, Tail2>::type>>::test;
};

// sort
template <template <int, int> typename P, typename L> struct Sort {
private:
  using _split_list = typename Split<L>::type;
  using _l1 = Sort<P, typename _split_list::first>;
  using _l2 = Sort<P, typename _split_list::second>;

public:
  using type = typename Merge<P, _l1, _l2>::type;
};

template <template <int, int> typename P> struct Sort<P, Nil> {
  using type = Nil;
};

template <template <int, int> typename P, int a> struct Sort<P, List<a, Nil>> {
  using type = List<a, Nil>;
};
// https://onedrive.live.com/view.aspx?resid=F1B8FF18A2AEC5C5!1062
// Scott Meyeres Universal References in c++11.
#include <iostream>
#include <vector>
// T&: lvalue referece
// T&&: rvalue reference or universal reference
// universial reference happen when there is type deduction.
// universial reference can be deduced into both l and r value ref.

// four conditions for universal reference to emerge
// - function template parameter template <typename _InputIter>
// - auto declaration
// - typedef declaration
// - decltype expression.

struct Widget {};

// some examples.
namespace N1 {
void f(Widget &&w);       // rvalue reference.
Widget &&var1 = Widget(); // rvalue reference.
auto &&var2 = var1;       // lvalue reference.

template <typename T> void f(std::vector<int> &&p); // rvalue reference.

template <typename T> void f(T &&p); // uvalue reference.

}; // namespace N1

// ex 1
namespace E1 {
template <typename T> void f(T &&p); // ureference.

void foo() {
  Widget w;
  f(w);            // lvalue reference.
  f(std::move(w)); // rvalue reference.
  f(Widget());     // rvalue reference.
}
} // namespace E1

// ex 2
namespace E2 {
std::vector<int> v;
auto &&val = 10;       // rvalue reference.
auto &&element = v[5]; // lvalue reference;
} // namespace E2

// fyi range based for loop
namespace FYI {
template <typename T> void range(T &&__param) {
  auto &&__range = __param; // use uref to accept all types.
  // ...
}
} // namespace FYI

// Ex 3
namespace E3 {
template <typename T> struct Gardget {
  Gardget(Gardget &&rhs); // rref (undeduced).
};

template <typename T> struct Gardget1 {
  template <typename U> Gardget1(U &&rhs); // uref (deduded by U.)
};

} // namespace E3

// overloading + uref doesn't make sense
// counter example
namespace CEX {
class CounterEx {
public:
  template <typename T> void do_work(const T &param); // only for const lval
  template <typename T> void do_work(T &&param);      // match everthing
};
} // namespace CEX

// rref -> uref (std::move -> std::forward)
namespace MoveForward {
void doWork(const Widget &param) { // copy
  Widget param2 = param;
}

void doWork(Widget &&param) {
  Widget param2 = std::move(param); // move
}

template <typename T> void dowork(T &&param) {
  Widget param2 = std::forward<T>(param);   // forword -> copy and move.
}

} // namespace MoveForward


// c++ reference collapsing.
// T& &   => T&
// T&& &  => T&
// T& &&  => T&
// T&& && => T&&
// in other word,
// rref to rref => rref
// lref to anything => lref
//
// writing T&& is really leting the compiler doing the deduction
// based on the type.
// if T&& is deduced as a left reference, it will collapse into
// a lref
// onthe other hand, a rref T&& will be decuded to T itself.
#include <algorithm>
#include <array>
#include <iostream>
#include <numeric>
#include <sstream>
#include <string>
#include <vector>

// https://stackoverflow.com/questions/18290523/is-a-default-move-constructor-equivalent-to-a-member-wise-move-constructor

// a simple memory block that shows the idea of RAII with copy and move
// constructors.

class Block {
  size_t length_;
  int *data_;

public:
  // simple constructors to initialize the resourece.
  explicit Block(size_t length) : length_(length), data_(new int[length]) {
    std::cout << "In Block(sizet), length = " << length_ << "." << std::endl;
    for (int i = 0; i < length_; ++i) {
      data_[i] = i;
    }
  }

  std::string to_string() {
    std::stringstream ss;
    for (int i = 0; i < length_; ++i) {
      ss << data_[i];
    }

    return std::string("<Block, length") + std::to_string(length_) + ">";
  }

  // destructor
  // we manually write it, but the default one generated by the compiler should
  // do something similar
  ~Block() {
    std::cout << "In ~Block(), length = " << length_ << "." << std::endl;
    if (data_ != nullptr) {
      std::cout << "Deleting data_";
      delete[] data_;
    }

    std::cout << std::endl;
  }

  // copy constructor
  Block(const Block &other)
      : length_(other.length_), data_(new int[other.length_]) {

    std::cout << "In Block(const Block&), length = " << length_ << "."
              << std::endl;

    std::copy(other.data_, other.data_ + length_, data_);
  }

  Block &operator=(const Block &other) {
    std::cout << "In Block& operator= (const Block&), length = " << length_
              << "." << std::endl;

    // free existing resource
    if (this != &other) {
      delete[] data_;

      length_ = other.length_;
      data_ = new int[length_];
      std::copy(other.data_, other.data_ + length_, data_);
    }
    return *this;
  }

  size_t length() { return length_; }

  Block(Block &&other) noexcept : data_(nullptr), length_(0) {
    std::cout << "In Block(Block&&), length = " << length_ << "." << std::endl;

    // the diference is you don't allocate new data_, instead you just grab it's
    // data.
    data_ = other.data_;
    length_ = other.length_;

    // we don't care the state of the other code, just make it null.
    other.data_ = nullptr;
    other.length_ = 0;
  }

  Block &operator=(Block &&other) {
    delete[] data_;

    data_ = other.data_;
    length_ = other.length_;

    other.data_ = nullptr;
    other.length_ = 0;
    return *this;
  }
};

void use_move_improve_performance_1() {
  // rvalue refernce.
  // 1. construct Block in place (a rvalue).
  // 2. pass the rvalue as rvalue reference.
  // 3. v get rvalue and steal it's data.
  //
  // Note, because Block(25) rvalue, we don't care about how it is
  // after it's constructed.
  std::vector<Block> v;
  v.reserve(3);
  v.push_back(Block(2));
  v.push_back(Block(3));
  v.push_back(Block(5));
  v.push_back(Block(10)); // from these one vector needs to resize.
  v.push_back(Block(12)); // move will be called twice. (not copy thank god.)
  v.push_back(Block(13));
  std::cout << "hitting }" << std::endl;
}

void what_happens_to_source_of_a_move_1_lval() {
  static_assert(std::is_move_constructible_v<Block>);
  Block b(20);

  // cast block& to block&&;
  Block d(std::move(b));

  // notice, because of our move constructor's implemnetation, b its moved and
  // we should not use it afterward.
  std::cout << b.to_string() << std::endl;
}

struct Cube {
  int data_[10];
  Cube() {
    for (int i = 0; i < 10; ++i) {
      data_[i] = i;
    }
  }
  std::string to_string() {
    std::stringstream ss;
    for (int i = 0; i < 10; ++i) {
      ss << data_[i] << ",";
    }
    return ss.str();
  }
};

void what_happens_to_source_of_a_move_2_default_move() {

  Cube b;
  Cube d(std::move(b));

  // notice, int[10] is not move constructible
  static_assert(!std::is_move_constructible_v<int[10]>);

  static_assert(std::is_move_constructible_v<Cube>);
  static_assert(std::is_copy_constructible_v<Cube>);

  // using default move constructor nothing happen.
  std::cout << "d: " << d.to_string() << std::endl;
  std::cout << "b: " << b.to_string() << std::endl;

  for (int i = 0; i < 10; ++i) {
    d.data_[i] = 1;
  }

  // move actually copied...
  std::cout << "d: " << d.to_string() << std::endl;
  std::cout << "b: " << b.to_string() << std::endl;
}

int main(void) {
  std::cout << "use_move_improve_performance_1" << std::endl;
  use_move_improve_performance_1();
  std::cout << "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<" << std::endl;

  std::cout << "what_happens_to_source_of_a_move_1_lval" << std::endl;
  what_happens_to_source_of_a_move_1_lval();
  std::cout << "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<" << std::endl;

  std::cout << "what_happens_to_source_of_a_move_2_default_move" << std::endl;
  what_happens_to_source_of_a_move_2_default_move();
  std::cout << "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<" << std::endl;

  return 0;
}
#include <iostream>

std::string &f() {
  std::string s = "Example";
  return s;
}

int main(void) {

  std::string &r = f();        // dangling reference.
  std::cout << r << std::endl; // ub, read from dangling ref
  std::string s = f();         // ub, copy initialize from dangling ref.

  return 0;
}
#include <iostream>

// default constructors and their behaviors.

// is default move constructor equals member wise move?
// https://stackoverflow.com/questions/18290523/is-a-default-move-constructor-equivalent-to-a-member-wise-move-constructor

// not, compiler has specific knowledge of class(const class&) as copy
// consructor.
struct nonmovable {
  nonmovable() = default;
  nonmovable(const nonmovable &) = default;
  nonmovable(nonmovable &&) = delete;
};

struct movable {
  movable() = default;
  movable(const movable &) { std::cout << "copy" << std::endl; }
  movable(movable &&) { std::cout << "move" << std::endl; }
};

struct has_nonmovable {
  movable a;
  nonmovable b;

  has_nonmovable() = default;
  has_nonmovable(const has_nonmovable &) = default;
  has_nonmovable(has_nonmovable &&) = default;
};

int main(void) {

  // has_nonmovable has an not movable field.
  // so it's default move constructor will do a member wise 1copy instead...
  has_nonmovable c;
  has_nonmovable d(std::move(c));
  return 0;
}
#include <iostream>

int main(void)
{

  return 0;
}
#include <array>
#include <iostream>
#include <map>
#include <memory>

#define NOLEAK

// try use g++ dict.cc -std=c++17 -fsanitizer=address -g
// and valgrind to track down memeory corruptions.

// or use gdb to step down the constructor to see when stuffs are freed.

// basic raii with new and delete in c++ 03 style.
// notice the rule of five. If we only implement destructor but no copy
// constructor, we will have a double free easily when we try to construct a
// vector of SubValue with initializer list (initializer list construct
// SubValue, copy, and destruct. at this point data is freed. Next time the
// container calles the destructor it will be a double free.)
struct SubValue {
  char *data;
  int len;

  SubValue(const SubValue &s) : len(s.len), data(new char[s.len]) {
    for (int i = 0; i < len; ++i) {
      data[i] = s.data[i];
    }
  }

  SubValue(SubValue &&s) : len(s.len), data(s.data) { s.data = nullptr; }

  // when writing constructors we also care about exception guarantees.
  // exception guarantees can be summarized into 4 categories:
  //  0. no exception
  //  1. strong exception guarantees      -- no side effect on fail
  //  2. basic exception guaramtees       -- no memory leak.
  //  3. exception unsafe

  // this requires us to allocate extra memories, but guarantee strong exception
  // safty.
  // During creation of the copy if anything happen, we fail to copy, but the
  // orignal data is preserved.
  SubValue &operator=(const SubValue &sub) {
    SubValue tmp{sub};
    if (&sub != this) {
      tmp.swap(*this);
    }
    return *this;
  }

  // we can do something similar for move construtor.
  SubValue &operator=(SubValue &&sub) {
    SubValue tmp{std::move(sub)};
    tmp.swap(*this);
    return *this;
  }

  SubValue(char *data, int len) : data(data), len(len) {}

  ~SubValue() {
    std::cout << "Subvalue: yoho I'm starting to freed >>>" << std::endl;

    // check null to avoid double free.
    if (data != nullptr) {
      delete[] data;
    }
    std::cout << "Subvalue: yoho I'm freed <<<" << std::endl;
  }

  void swap(SubValue &sub) { std::swap(data, sub.data); }
};

struct Value {
  SubValue sub;

  // this should be save because we just print stuffs.
  ~Value() { std::cout << "Value: hoyo I'm freed!" << std::endl; }
};

///////////////////////////////////////////////////////////////////////

int main(void) {

  std::cout << "Value ================" << std::endl;

  {
    // freed . when hit } destructor will be called.
    Value v{SubValue{new char[10], 10}};
  }

  ///////////////////////////////////////////////////////////////////////

  std::cout << "Subvalue ================" << std::endl;

  {
    // needs to free.
    auto *vv = new SubValue{new char[10], 10};
#ifdef NOLEAK
    delete vv;
#endif
  }

  ///////////////////////////////////////////////////////////////////////

  std::cout << "Map with boxed value ================" << std::endl;

  {

    std::map<int, Value *> m{

        {1, new Value{SubValue{new char[10], 10}}},
        {2, new Value{SubValue{new char[10], 10}}}

    };

    std::cout << "char is " << m[1]->sub.data[0] << std::endl;

#ifdef LEAK
    // memory leak!
    // clear only clear boxed value. If map holds a pointer it will not free the
    // memory.
    m.clear();
#endif

#ifdef NOLEAK
    for (auto &[k, v] : m) { // don't store boxed value in map.
      delete v;
    }
    m.clear();
#endif
  }

  ///////////////////////////////////////////////////////////////////////

  std::cout << "Map with unboxed value ================" << std::endl;

  {

    std::map<int, Value> m;

    // double free
#ifdef LEAK
    m.emplace(std::make_pair(1, Value{SubValue{new char[10], 10}}));
#endif

#ifdef NOLEAK
    m.emplace(1, Value{SubValue{new char[10], 10}});
#endif
  }

  std::cout << "================" << std::endl;
  return 0;
}
#include <array>
#include <iostream>
#include <map>
#include <memory>

#define NOLEAK

// try use g++ dict.cc -std=c++17 -fsanitizer=address -g
// and valgrind to track down memeory corruptions.

// or use gdb to step down the constructor to see when stuffs are freed.

// basic raii with new and delete in c++ 03 style.
// notice the rule of five. If we only implement destructor but no copy
// constructor, we will have a double free easily when we try to construct a
// vector of SubValue with initializer list (initializer list construct
// SubValue, copy, and destruct. at this point data is freed. Next time the
// container calles the destructor it will be a double free.)
struct SubValue {
  char *data;
  int len;

  SubValue(const SubValue &s) : len(s.len), data(new char[s.len]) {
    for (int i = 0; i < len; ++i) {
      data[i] = s.data[i];
    }
  }

  SubValue(SubValue &&s) : len(s.len), data(s.data) { s.data = nullptr; }

  // when writing constructors we also care about exception guarantees.
  // exception guarantees can be summarized into 4 categories:
  //  0. no exception
  //  1. strong exception guarantees      -- no side effect on fail
  //  2. basic exception guaramtees       -- no memory leak.
  //  3. exception unsafe

  // this requires us to allocate extra memories, but guarantee strong exception
  // safty.
  // During creation of the copy if anything happen, we fail to copy, but the
  // orignal data is preserved.
  SubValue &operator=(const SubValue &sub) {
    SubValue tmp{sub};
    if (&sub != this) {
      tmp.swap(*this);
    }
    return *this;
  }

  // we can do something similar for move construtor.
  SubValue &operator=(SubValue &&sub) {
    SubValue tmp{std::move(sub)};
    tmp.swap(*this);
    return *this;
  }

  SubValue(char *data, int len) : data(data), len(len) {}

  ~SubValue() {
    std::cout << "Subvalue: yoho I'm starting to freed >>>" << std::endl;

    // check null to avoid double free.
    if (data != nullptr) {
      delete[] data;
    }
    std::cout << "Subvalue: yoho I'm freed <<<" << std::endl;
  }

  void swap(SubValue &sub) { std::swap(data, sub.data); }
};

struct Value {
  SubValue sub;

  // this should be save because we just print stuffs.
  ~Value() { std::cout << "Value: hoyo I'm freed!" << std::endl; }
};

///////////////////////////////////////////////////////////////////////

int main(void) {

  std::cout << "Value ================" << std::endl;

  {
    // freed . when hit } destructor will be called.
    Value v{SubValue{new char[10], 10}};
  }

  ///////////////////////////////////////////////////////////////////////

  std::cout << "Subvalue ================" << std::endl;

  {
    // needs to free.
    auto *vv = new SubValue{new char[10], 10};
#ifdef NOLEAK
    delete vv;
#endif
  }

  ///////////////////////////////////////////////////////////////////////

  std::cout << "Map with boxed value ================" << std::endl;

  {

    std::map<int, Value *> m{

        {1, new Value{SubValue{new char[10], 10}}},
        {2, new Value{SubValue{new char[10], 10}}}

    };

    std::cout << "char is " << m[1]->sub.data[0] << std::endl;

#ifdef LEAK
    // memory leak!
    // clear only clear boxed value. If map holds a pointer it will not free the
    // memory.
    m.clear();
#endif

#ifdef NOLEAK
    for (auto &[k, v] : m) { // don't store boxed value in map.
      delete v;
    }
    m.clear();
#endif
  }

  ///////////////////////////////////////////////////////////////////////

  std::cout << "Map with unboxed value ================" << std::endl;

  {

    std::map<int, Value> m;

    // double free
#ifdef LEAK
    m.emplace(std::make_pair(1, Value{SubValue{new char[10], 10}}));
#endif

#ifdef NOLEAK
    m.emplace(1, Value{SubValue{new char[10], 10}});
#endif
  }

  std::cout << "================" << std::endl;
  return 0;
}
#include <iostream>

// each object and reference has their lifetime.
// lifetime is a runtime property, there is a moment
// that a program begins, and a moment that it ends.

// The lifetime of an obejct begins when
// 1. storage with proper alignment is obtained and
// 2. initialization is complete.

// The lifetime of an object ends when
// 1. if it's a non class type, it's destoryed.
// 2. if it's a class type, it's destructor call starts
// 3. the storage which the object occupies is released,
//    or is reused by an object that is not nested within
//    it.

// In c++ you have different storage durations
// 1. auto (automatic storage duration)
// 2. register (automatic storage duration + hint to place object in
//              processor's register)
//
// 3. static (static storage duration, internal linkage)
// 4. extern (static storage duration, external linkage)
// 5. thread_local (thread storage duration)
//
// life time of an object is equal to or is nested within the
// lifetime of it's storage.
// So if a value is allocated on the stack, it has the automatic
// duration that is the same as the scope. Thus it will not live
// longer than the scope.

// Lifetime of reference begins when its initialzation is complete and ends
// as if it's a object.

// Note: the life time of referred object might end before end of lifetime
// of the reference, which make dangling references possible.
#include <iostream>

// Sub objects 1

struct S {
  S() { puts("S()"); }
  S(int) { puts("S(int)"); }
  S(const S &) noexcept { puts("S(const S&)"); }
  S(S &&) noexcept { puts("S(S &&)"); }
  S &operator=(const S &) {
    puts("operator=(const S&)");
    return *this;
  }

  S &operator=(S &&) {
    puts("S &operator=S &&()");
    return *this;
  }

  ~S() { puts("~S()"); }
};

// be optimzied off with return value optimization.
S get_s() { return {}; }
S get_another_s() { return {}; }

// it will be optmized off with Named return value optimization
S get_another_ss() {
  S s;
  return s;
}

int main(void) {
  // get_s is as if deleted.
  // S is constructed right here.
  S s = get_another_ss();
  return 0;
}
#include <iostream>

// Strucutured bindings create hidden values that are
// refrences (aren't object),
// RVO and automatic move cannot happen witha reference

struct S {
  S() { puts("S()"); }
  S(int) { puts("S(int)"); }
  S(const S &) noexcept { puts("S(const S&)"); }
  S(S &&) noexcept { puts("S(S &&)"); }
  S &operator=(const S &) {
    puts("operator=(const S&)");
    return *this;
  }

  S &operator=(S &&) {
    puts("S &operator=S &&()");
    return *this;
  }

  ~S() { puts("~S()"); }
};

struct Holder {
  S s;
  int i;
};

Holder get_holder() { return {}; }

// use structured binding.
S get_s() {
  // call a copy constructor instead.
  auto [s, i] = get_holder();
  return s;
}

// what's really going on here
S get_S_desugared() {
  auto e = get_holder();
  auto &s = e.s;
  auto &i = e.i;
  return s; // RVO doesn't apply for a reference.
}

int main(void) {
  S s = get_s();

  return 0;
}
#include <iostream>

struct S {
  S() { puts("S()"); }
  S(int) {
    // exception thrown here.
    // the constructor is not completed.
    // So the lifetime of the object is not started.
    // This obejct is not created what so ever.
    throw 1;
    puts("S(int)");
  }
  S(const S &) noexcept { puts("S(const S&)"); }
  S(S &&) noexcept { puts("S(S &&)"); }
  S &operator=(const S &) {
    puts("operator=(const S&)");
    return *this;
  }

  S &operator=(S &&) {
    puts("S &operator=S &&()");
    return *this;
  }

  ~S() { puts("~S()"); }
};

int main(void) {

  try {
    S s{1};

  } catch (...) {
  }
  return 0;
}
#include <iostream>
#include <type_traits>

// what is an object?

// this struct has exactly the same alignment as an interger.
struct Int {
  int i;
};

int use_Int() {
  static_assert(sizeof(Int) == sizeof(int));
  Int s{15};

  // reinterpret a struct to the first element of struct.
  // if you cast it to an integer you can use it directly.
  int &i = reinterpret_cast<int &>(s);
  i = 23;
  return s.i;
}

int use_int() {
  static_assert(sizeof(int) == sizeof(int));
  int s{15};
  int &i = reinterpret_cast<int &>(s);
  i = 23;
  return i;
}

void trait_check() {
  // trivially ... means there is no virtual function, abstract
  // base class, virtual destructor.
  static_assert(std::is_trivially_constructible<Int>::value);
  static_assert(std::is_trivially_constructible<int>::value);

  static_assert(std::is_trivially_destructible<Int>::value);
  static_assert(std::is_trivially_destructible<int>::value);

  static_assert(std::is_trivially_copyable<Int>::value);
  static_assert(std::is_trivially_copyable<int>::value);

  static_assert(std::is_trivially_move_constructible<Int>::value);
  static_assert(std::is_trivially_move_constructible<int>::value);

  static_assert(std::is_pod<Int>::value);
  static_assert(std::is_pod<int>::value);

  // they're both objects
  // an object is a type that is not a function, not a reference, not void.
  // so pretty much everything is an object.
  static_assert(std::is_object<Int>::value);
  static_assert(std::is_object<int>::value);
}

int main(void) {
  trait_check();

  return 0;
}
#include <iostream>

struct S {
  S() { puts("S()"); }
  S(const S &) noexcept { puts("S(const S&)"); }
  S(S &&) noexcept { puts("S(S &&)"); }
  S &operator=(const S &) {
    puts("operator=(const S&)");
    return *this;
  }

  S &operator=(S &&) {
    puts("S &operator=S &&()");
    return *this;
  }

  ~S() { puts("~S()"); }

  // some c++ attributes
  [[deprecated]] int foo() { return 1; }
  [[noreturn, deprecated]] void bar() { exit(1); }
  [[nodiscard]] int flag(int a) {
    if (a > 10) {
      return 1;
    } else {
      return -1;
    }
  }
};

// Nothing get constructed in the scope.
// Reference type is not an object type, so in this case
// it doesn't affect the lifetime of the obejct.
void f1() {
  S s; // S()
  { [[maybe_unused]] S &s2{s}; }
  // ~S()
}

// s2 copy constructed from s.
void f2() {
  S s; // S()
  {
    S s2{s}; // S(const &S)
  }          // ~S()
  // ~S()
}

int main(void) {
  f1();
  puts("");
  f2();

  return 0;
}
#include <functional>
#include <iostream>
#include <string_view>

// return a dangling reference.
const int &get_data_dangling() {
  const int i = 5;
  return i;
}

// return a reference wrapper.
std::reference_wrapper<const int> get_data_ref_wrapper() {
  const int i = 5;
  return std::ref(i);
}

// "hello" is in the static section.
// static duration.
const char *get_string_literal() { return "hello"; }

// same as above
std::string_view get_string_view1() { return "Hello World"; }

// now the pointer point to s with automatic duration.
// this one is ub.
std::string_view get_string_view2() {
  std::string s = "Hello World";
  return s;
}

// local array initialized by a global data.
// this is UB but no warning from the compiler.
std::string_view get_string_local() {
  const char s[] = "hello world";
  return s;
}

int main(void) {
  // how this work? what is a reference wrapper?
  std::cout << get_string_local() << std::endl;
  return 1;
}
#include <iostream>
#include <vector>

struct S {
  S() { puts("S()"); }
  S(int) { puts("S(int)"); }
  S(const S &) noexcept { puts("S(const S&)"); }
  S(S &&) noexcept { puts("S(S &&)"); }
  S &operator=(const S &) {
    puts("operator=(const S&)");
    return *this;
  }

  S &operator=(S &&) {
    puts("S &operator=S &&()");
    return *this;
  }

  ~S() { puts("~S()"); }
};

// return a default temporary.
S get_value() { return {}; }

int main(void) {
  {
    std::vector<S> vec;
    vec.push_back(S{1});
    // S(int)
    // S(&&S)
    // ~S()   // moved from object still need to be destructed.
    // ~S()   // this is when the object is destroyed.
  }
  puts("");

  {
    std::vector<S> vec;
    vec.emplace_back(S{1});
    // it's the same.
  }

  puts("");
  {
    std::vector<S> vec;
    vec.emplace_back(1);
    // This time we don't have move anymore.
  }

  puts("");
  {
    // assign rvalue to a const lvalue reference
    // You cannot take a non const reference of temporary
    const auto &val = get_value();
    puts("hello");
  }

  return 0;
}
#include <iostream>

struct S {
  const int &m;

  S &operator=(const S &) {
    puts("operator=(const S&)");
    return *this;
  }

  S &operator=(S &&) {
    puts("S &operator=S &&()");
    return *this;
  }

  ~S() { puts("~S()"); }
};

// initializa const int& with a
// temporary S{1}, then assign that to the const
// reference.
[[nodiscard]] int foo(void) {
  const S &s = S{1};
  return s.m;
}

int main(void) {
  auto v = foo();
  std::cout << v << std::endl;
  return 0;
}
#include <array>
#include <iostream>
#include <string>
#include <vector>

// initalizer_list<> invocations create hiden const arrays.

int main(void) {

  // one initialization. "a" and "b" are small string optimized.
  std::vector<std::string> v1{"a", "b"};

  // 5 initialization
  // two string initialized,
  // then vector get initialized,
  // then two string get copied to vector
  std::vector<std::string> v2{"aaaaaaaaaaaaaaaaaaaa", "bbbbbbbbbbbbbbbbbbbb"};

  // 0 initialization
  // standard array doesn't have any constructors.
  // And it will not use a initilizer list.
  std::array<std::string, 2> arr{"aaaaaaaaaaaaaaaaaaaa",
                                 "aaaaaaaaaaaaaaaaaaaa"};

  return 0;
}
#include <iostream>
#include <vector>

struct S {
  std::vector<int> data{1, 2, 3, 4, 5};
  const auto &get_data() const { return data; }
};

S get_s() { return S{}; }

// this is an UB!
int main(void) {
  for (const auto &v : get_s().get_data()) {
    std::cout << v;
  }

  return 0;
}

// desugared version of the ranged for loop.
void main__() {
  // not recursive object lifetime extension.
  auto &&range__ = get_s().get_data();
  auto begin__ = std::begin(range__);
  auto end__ = std::end(range__);
  for (; begin__ != end__; ++begin__) {
    const auto &v = *begin__;
    std::cout << v;
  }
}
#include <iostream>

struct S {
  S() { puts("S()"); }
  S(int) { puts("S(int)"); }
  S(const S &) noexcept { puts("S(const S&)"); }
  S(S &&) noexcept { puts("S(S &&)"); }
  S &operator=(const S &) {
    puts("operator=(const S&)");
    return *this;
  }

  S &operator=(S &&) {
    puts("S &operator=S &&()");
    return *this;
  }

  ~S() { puts("~S()"); }
};

struct Holder {
  S s;
  int i;
};

Holder get_holder() { return {}; }

S get_s() {
  // Note it's a move here.
  // get_holder return a rvalue.
  // and then you are accessing the member s
  // of the r value. Compiler know it, and see
  // it as a perfect candidate for calling a move constructor
  S s = get_holder().s;
  return s;
}

int main(void) {
  S s = get_s();
  return 0;
}
#include <iostream>


// Lifetime of temporary will be extended.

#include <functional>
#include <iostream>
#include <memory>

// original move semantics proposal.
// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm

class Caller {

public:
  std::shared_ptr<std::function<int(int)>> func;

  Caller(const std::function<int(int)> &fn)
      : func(std::make_shared<std::function<int(int)>>(fn)) {}

  Caller(std::function<int(int)> &&fn)
      : func(std::make_shared<std::function<int(int)>>(std::move(fn))) {}
};

void test_by_rval() {
  std::cout << "\n";
  std::cout << "test rva" << std::endl;
  Caller c1 = Caller([](int a) -> int { return 99; });

  Caller c2 = c1;

  std::cout << (*c2.func)(1) << std::endl;
  std::cout << "c1 c2 count of func: " << c2.func.use_count() << std::endl;

  {
    Caller c3 = c2;
    std::cout << "create c3, count of func: " << c2.func.use_count()
              << std::endl;
  }
  std::cout << "c3 destoryed, count of func: " << c2.func.use_count()
            << std::endl;
}

void test_by_lval() {
  std::cout << "\n";
  std::cout << "test lval" << std::endl;

  auto fn = [](int a) -> int { return -100; };

  {
    Caller c1 = Caller(std::move(fn));
    std::cout << fn(1) << std::endl;
    Caller c2 = c1;
    std::cout << (*c2.func)(1) << std::endl;
    std::cout << "c1 c2 count of func: " << c2.func.use_count() << std::endl;
  }

  // it's still here. the reason is move just cast type.
  // use move semantics means you don't case what's the state of the source.
  std::cout << fn(1) << std::endl;
}

void test_by_delete() {
  std::cout << "\n";
  std::cout << "test rva" << std::endl;
  Caller c1 = Caller([](int a) -> int { return 99; });

  Caller c2 = c1;
  Caller c3 = c1;

  std::cout << (*c2.func)(1) << std::endl;
  std::cout << "c1 c2 c3 count of func: " << c2.func.use_count() << std::endl;

  c2.~Caller();
  c1.~Caller();
  std::cout << "c1 delelted, count of func: " << c2.func.use_count()
            << std::endl;
}

int main(void) {
  test_by_rval();
  test_by_lval();
  test_by_delete();
  return 0;
}
#include <iostream>

// the motivation of move.
//
// First, in C++ you're not allowed to bind rvalue to
// non const referece.
//
// but sometimes you want to, like to steal from whatever
// the reference refers to.
//
// In that case you have rvalue reference now.
// We are allowed to pass a rvalue by rvalue reference, modify
// whatever it has.
// Because it's rvalue, after it's passed we can just forget about
// it.

// reference overload rules:
// 1. rvalue prefer rvalue reference.
// 2. lvalue prefer lvalue reference.
// 3. if there is no rvalue reference overload, rvalue can choose
//    to use const reference overload.
// 4. lvaue can bind to rvalue refernce, but it will prefer lvalue
//    reference first.
// 5. cv qualifier are cosidered after r/l reference.

void incr(int &r) { r++; }

int main() {
  double ss = 1;
  // this is illegal.
  // because when pass ss to incr,
  // there will be an implicit convertion from douhble to
  // int, which will introduce a temporary (rval),
  // which cannot be passed to a non const referece.
  // incr(ss);

  // this works as you convert double& int& to
  incr((int&)(ss));

  std::cout << "value << " << ss << std::endl;
}
#include "semaphore.h"
#include <functional>
#include <mutex>

template <typename T> class BoundBuffer {
  T *const buffer;
  Semaphore m;
  Semaphore empty; // count of free slots
  Semaphore full;  // count of used slots.

public:
  // empty has the bound initially.
  BoundBuffer(int bound) : m(1), empty(bound), full(0) {}
  void producer();
  void consumer();
};

template <typename T> void BoundBuffer<T>::producer() {
  // produce item
  empty.wait(); // one fewer slot or wait
  m.wait();
  // add to buf
  m.signal();
  full.signal();
}

template <typename T> void BoundBuffer<T>::consumer() {
  full.wait(); // wait til there's an item (initally full = 0, so it will lock)
  m.wait();
  // remove item from buf
  m.signal();
  empty.signal();
}
/*
 * Deadlock:
 *  1. deadlock: several threads compete for a finite num of resources
 *     at same time
 *  2. deadlock prevention: algorithms check availability to avoid deadlock.
 *  3. deadlock detection: find instances of deadlock when thread stop making
 *     progress.
 *  4. starvation: thread waiting indefinitely for some resources.
 *     (different from wait for each other)
 *
 * Necessary condition for deadlock:
 *  1. Mutual exclusion
 *  2. Hold and wait
 *  3. No preemption
 *  4. circular wait. threads {t1 ... tn} where t1 -> ti ... tn -> t1
 *
 * Detect deadlock
 *  1. Scane resource allocation graph and then break the cycles.

 */


#include <iostream>

int main(void) {
  std::cout << "yee ha" << std::endl;

  return 0;
}
#ifndef MONITOR_H
#define MONITOR_H

#include "semaphore.h"
#include <condition_variable>

/*
 * Two types of monitors:
 *  1. Mesa monitor
 *    - thread the signals keeps the lock
 *    - Waiting thread waits for the lock
 *  2. Hoare monitor
 *    - The thread signals gives up the lock and waiting thread
 *      get the lock
 *    - When the waiting thread is now executing exits or wait again,
 *      it release the lock back to the signaling thread.
 *
 * Monitors:
 *  1. Guarantee mutual exclusion.
 *  2. Only one thread can execute a monintor at a time.
 *
 * Monitors has:
 *  1. a lock
 *  2. 0 or more conditional variables.
 *  3. provides mutual exclusion for shared data.
 *  4. the lock is used to
 *    1. make sure only one thread is active.
 *    2. mutual exclusion for shared data.
 *  5. conditional variables enable threads to go sleep in critical sec.
 *     by releasing their lock at the same time it puts the threads to sleep.
 *
 * Use monitors to:
 *  1. Encapsulates shared data you want to protect.
 *  2. Acquires mutex at the start.
 *  3. Operates on the shared data.
 *  4. Temporarily releases the mutex if it can't complete.
 *  5. Requires the mutext when it can continue.
 *  6. Release the mutex at the end.
 *
 * Conditional variable:
 *  Queue of threads waiting for something inside a critical sectinon.
 *
 *  When we are waiting, we want to sleep in the critical section until
 *  get signaled.
 *  But you can't hold the lock while waiting otherwise you block otheres.
 *  With conditional variable, a thread can sleep in a critical section, and
 *  before it sleeps release locks it holds atomically.
 *
 *  wait(lock) atomic(release lock and sleep)
 *  signal() wake up, and re acquire locks.
 *  broadcast() wakeup all waiting threads.
 */

template <typename T> class QueueMon {

  const T *arr;
  std::condition_variable cv;
  Semaphore m;

public:
  QueueMon() : m(1) {}
  void add();
  void remove();
};

template <typename T> void QueueMon<T>::add() {
  m.wait();
  // put item into queue
  cv.notify_one();

  m.signal();
}

template <typename T> void QueueMon<T>::remove() {
  m.wait();
  while (1) {
    // cv.wait();
  }
  m.signal();
}

#endif /* ifndef MONITOR_H */
#ifndef QUEUE_H
#define QUEUE_H

#include "semaphore.h"
#include <cstring>
#include <thread>

template <typename T> class Queue {
  const size_t size;
  T *const arr;
  int start = 0, end = 0;
  Semaphore write, read;
  std::recursive_mutex writemtx, readmtx;

public:
  explicit Queue(const size_t size = 1)
      : size(size), arr(new T[size]), write(size), read(0) {}

  explicit Queue(const Queue &q)
      : size(q.size), arr(new T[size]), start(q.start), end(q.end),
        write(q.write), read(q.read) {
    std::lock_guard<std::recursive_mutex> lg(q.writemtx);
    std::memcpy(arr, q.arr, size * sizeof(T));
  }

  virtual ~Queue() { delete[] arr; }

  void add(const T &obj) {
    std::lock_guard<std::recursive_mutex> lg(writemtx);
    write.wait();
    arr[end++] = obj;
    end %= size;
    read.signal();
  }

  bool offer(const T &obj) {
    std::lock_guard<std::recursive_mutex> lg(writemtx);
    if (!full()) {
      add(obj);
      return true;
    }
    return false;
  }

  const T &front() {
    std::lock_guard<std::recursive_mutex> lg(readmtx);

    read.wait();
    read.signal();
    return arr[start % size];
  }

  bool empty() const { return !read.available(); }

  bool full() const { return !write.available(); }
};

#endif /* ifndef QUEUE_H */
/*
 * Reader Writer problem:
 *  - each read or write of the shared data must happend within a
 *    critical section.
 *  - Guarantee mutual exlucsion for writers.
 *  - Allow multiple readers to execute in the critical section at once.
 */

#include "semaphore.h"

class ReadWrite {
  int readers;
  Semaphore mutex; // control access to readers
  Semaphore wrt;   // control entry to first writer or reader.
public:
  explicit ReadWrite(int readers, int m, int w)
      : readers(readers), mutex(m), wrt(w) {}
  void read();
  void write();
};

void ReadWrite::write() {
  wrt.wait(); // any writers or readers?
  // do write
  wrt.signal();
}

void ReadWrite::read() {
  mutex.wait(); // ensure mutual exclusion
  readers += 1; // another reader
  if (readers == 1)
    wrt.wait(); // block writers.
  mutex.signal();

  // perform read

  mutex.wait(); // ensure mutual exclusion again.
  readers -= 1;
  if (readers == 0)
    wrt.signal();
  mutex.signal();
}
#ifndef SEMAPHORE_H
#define SEMAPHORE_H

#include <condition_variable>
#include <mutex>

/* Cons of semaphore:
 *  1. global variable in nature.
 *  2. no linguistic connection with data.
 *  3. access can come from anywhere
 *  4. overloaded purposes: mutual exclusion and scheduling constraints.
 *  5. hard to use
 */

class Semaphore {
  const size_t num_premissions;
  size_t avail;
  std::mutex m;
  std::condition_variable cv;

public:
  // default costructor.
  explicit Semaphore(const size_t &num_premissions = 1)
      : num_premissions(num_premissions), avail(num_premissions) {}

  // copy construtor. Should not copy state mutex or cv
  Semaphore(const Semaphore &s)
      : num_premissions(s.num_premissions), avail(s.avail) {}

  void wait() {
    std::unique_lock<std::mutex> lk{m};
    cv.wait(lk, [this] { return avail > 0; });
    avail--;
    lk.unlock();
  }

  void signal() {
    {
      std::lock_guard<std::mutex> lg{m};
      avail++;
    }
    cv.notify_one();
  }

  size_t available() const { return avail; }
};

#endif /* ifndef SEMAPHORE_H */

#include <iostream>
#include <thread>

#include "semaphore.h"

void too_much() {
  Semaphore m;
  bool no_milk = true;
  auto buy_milk = [&](std::string_view name) {
    m.wait();
    if (no_milk) {
      std::cout << "Buying milk from thread 1" << std::endl;
      no_milk = false;
    }
    m.signal();
  };

  auto t1 = std::thread(buy_milk, "thread 1");
  auto t2 = std::thread(buy_milk, "thread 2");

  t1.join();
  t2.join();
}
#include <iostream>

struct Foo {
  int i;
  float f;
  char c;
};

// pretty cool you can specify your own
// alignment.
struct alignas(64) Foo64 {
  int i;
  float x;
};

int main(void) {

  std::cout << "Alignment of "
            << "char       :" << alignof(char)
            << "\n"
               "poiter     :"
            << alignof(int *)
            << "\n"
               "class Foo  :"
            << alignof(Foo) << "\n"
            << "class Foo64 :" << alignof(Foo64) << "\n"
            << std::endl;

  return 0;
}
#include <functional>
#include <iostream>
#include <vector>
using std::function;
using std::vector;

template <typename... P> struct parameter_pack {
  template <template <typename...> typename T> using apply = T<P...>;
};

template <typename T> struct memfun_type { using type = void; };

template <typename Ret, typename Class, typename... Args>
struct memfun_type<Ret (Class::*)(Args...) const> {
  using type = std::function<Ret(Args...)>;
  using return_type = Ret;

  template <template <typename...> typename F> // all arguments
  using args_pack = typename parameter_pack<Args...>::template apply<F>;

  template <template <typename...> typename F> // arguments and return type.
  using all_pack = typename parameter_pack<Args..., Ret>::template apply<F>;
};

template <typename F> struct lambda_traits {
  using type = typename memfun_type<decltype(&F::operator())>::type;
  using return_type =
      typename memfun_type<decltype(&F::operator())>::return_type;

  // F2 is a hkt that takes ...Args as parameter
  template <template <typename...> typename F2>
  using args_pack =
      typename memfun_type<decltype(&F::operator())>::template args_pack<F2>;

  template <template <typename...> typename Fn>
  using all_pack =
      typename memfun_type<decltype(&F::operator())>::template all_pack<Fn>;
};

template <typename Fn, typename... Ts>
typename lambda_traits<Fn>::type foo(Fn fn) {
  return fn;
}

// composition
template <typename Fn1, typename Fn2> struct composition {
  template <typename... Args2>
  using p_ = std::function<typename lambda_traits<Fn1>::return_type(Args2...)>;
  using type = typename lambda_traits<Fn2>::template args_pack<p_>;
};

template <typename Fn1, typename Fn2>
typename composition<Fn1, Fn2>::type operator<(Fn1 f, Fn2 g) {
  return [=](auto &&... a) { return f(g(a...)); };
}


template <typename Fn1, typename Fn2> auto operator>(Fn1 f1, Fn2 f2) {
  return [=](auto ...a) { return f1(f2(a...)); };
}
// currying
template <typename...> struct currying_impl { using type = void; };
template <typename Arg, typename R> struct currying_impl<Arg, R> {
  using type = std::function<R(Arg)>;
};

template <typename Arg, typename... Args> struct currying_impl<Arg, Args...> {
  using type = std::function<typename currying_impl<Args...>::type(Arg)>;
};

template <typename Fn> struct curring {
  // funciotn<r(a, b, c...)> -> template <typename a, b, c, r>
  using type =
      typename lambda_traits<Fn>::template all_pack<currying_impl>::type;
};

template <typename Fn> using curring_t = typename curring<Fn>::type;

curring_t<std::function<int(double, char, vector<int>)>> f;
auto a = f(1.1);
auto b = a('1');
auto x = b({1, 2, 3});

// test for composition
function<char(int)> f1{[](int a) { return 'a'; }};
function<int(double)> f2{[](double b) { return b + 100 % 10; }};
function<vector<char>(char)> f3{[](char a) { return vector<char>{a, a, a}; }};
function<int(int, double)> f5{[](int b, double c) { return b + 100 % 10 + c; }};

composition<decltype(f1), decltype(f2)>::type f1f2(f1 < f2);
composition<decltype(f3), decltype(f1f2)>::type f3f1f2(f3 < f1f2);

auto f3f1f2_ = f3 < (f1 < f2);
auto f3f1f2__ = f3 > (f1 > f2);


auto c = [](auto x) { return f1(f2(x)); };

int main(void) {
  auto a = f1f2(1.1);

  // this should type checks.
  typename lambda_traits<
      composition<decltype(f3), decltype(f2)>::type>::return_type b =
      std::vector<char>{'a', 'a'};
  auto fx = [](int a) { return a + 1.1; } < [](char c) { return (int)c; };
  auto fx_r = fx('a');

  auto x1 = c(1.1);

  std::cout << f3f1f2(1.1).size() << std::endl;
  std::cout << f3f1f2_(1.1).size() << std::endl;
  std::cout << f3f1f2__(1.1).size() << std::endl;

  std::cout << a << std::endl;

  return 0;
}
#include <functional>
#include <iostream>
#include <vector>

template <typename... P> struct parameter_pack {
  template <template <typename...> typename T> using apply = T<P...>;
};

template <typename T> struct lambda_traits_impl { using type = void; };

template <typename Ret, typename Class, typename... Args>
struct lambda_traits_impl<Ret (Class::*)(Args...) const> {
  using type = std::function<Ret(Args...)>;
  using return_type = Ret;

  template <template <typename...> typename F> // all arguments
  using args_pack = typename parameter_pack<Args...>::template apply<F>;

  template <template <typename...> typename F> // arguments and return type.
  using all_pack = typename parameter_pack<Args..., Ret>::template apply<F>;
};

template <typename F> struct lambda_traits {
  using type = typename lambda_traits_impl<decltype(&F::operator())>::type;
  using return_type =
      typename lambda_traits_impl<decltype(&F::operator())>::return_type;

  // F2 is a hkt that takes ...Args as parameter
  template <template <typename...> typename F2>
  using args_pack = typename lambda_traits_impl<decltype(
      &F::operator())>::template args_pack<F2>;

  template <template <typename...> typename Fn>
  using all_pack = typename lambda_traits_impl<decltype(
      &F::operator())>::template all_pack<Fn>;
};

template <typename Fn1, typename Fn2> struct composition {
  template <typename... Args2>
  using p_ = std::function<typename lambda_traits<Fn1>::return_type(Args2...)>;
  using type = typename lambda_traits<Fn2>::template args_pack<p_>;
};

// template <typename Fn1, typename Fn2> decltype(auto) operator<(Fn1 f, Fn2 g)
// {
//   return [=](auto &&... a) { return f(g(a...)); };
// }

template <typename Fn1, typename Fn2> auto operator<(Fn1 f, Fn2 g) {
  return [=](auto &&...a) { return f(g(a...)); };
}

int main(void) {
  auto f = [](int a) { return a + 1; } <
           [](std::vector<int> v) { return v.size(); };
  std::cout << f(std::vector<int>{1, 2}) << std::endl;

  auto g = [](int a) { return a + 1.1; };
  auto h = [](std::vector<int> x, double y) { return x.size() + y; };

  auto gh = g < h;

  auto x = gh(std::vector<int>{1, 2}, 2);
  std::cout << x << std::endl;

  return 0;
}
// continuation with c++
// some experiments.

#include <functional>
#include <iostream>
#include <type_traits>

template <typename T> struct memfun_type { using type = void; };

template <typename Ret, typename Class, typename... Args>
struct memfun_type<Ret (Class::*)(Args...) const> {
  using type = std::function<Ret(Args...)>;
  using return_type = Ret;
};

template <typename F>
typename memfun_type<decltype(&F::operator())>::type
to_function(F const &func) { // Function from lambda !
  return func;
}

template <typename F> struct lambda_traits {
  using type = typename memfun_type<decltype(&F::operator())>::type;
  using return_type =
      typename memfun_type<decltype(&F::operator())>::return_type;
};

template <typename Fn, typename... Ts>
typename lambda_traits<Fn>::type foo(Fn fn) {
  return fn;
}

// find a way to simplify this.
template <typename T, typename Fn>
typename lambda_traits<Fn>::return_type tripleCPS(T a, Fn k) {
  return k(a * a * a);
}

template <typename T, typename Fn,
          typename R = typename lambda_traits<Fn>::return_type>
R factCPS(T a, Fn k) {
  if (a <= 0) {
    return k(1);
  } else {
    return factCPS(a - 1, [&](T b) { return k(a * b); });
  }
};

template <typename T, typename Fn,
          typename R = typename lambda_traits<Fn>::return_type>
R stringCPS(T a, Fn k) {
  return k("string");
}

template <typename T, typename Fn,
          typename R = typename lambda_traits<Fn>::return_type>
R doubleCPS(T a, Fn k) {
  static_assert(std::is_convertible_v<Fn, std::function<R(T)>>);
  return k(2 * a);
}

template <typename T, typename Fn,
          typename R = typename lambda_traits<Fn>::return_type>
R absCPS(T a, Fn k) {
  static_assert(std::is_convertible_v<Fn, std::function<R(T)>>);
  return k(-a);
}

template <typename T, typename Fn,
          typename R = typename lambda_traits<Fn>::return_type>
R lengthCPS(T a, Fn k) {
  static_assert(std::is_convertible_v<Fn, std::function<R(int)>>);
  return k(a.size());
}

template <typename T, typename Fn,
          typename R = typename lambda_traits<Fn>::return_type>
std::function<R(T)> makeCPS(Fn g) {
  return [](auto x, auto g) { return g(f(x)); };
}

auto id = [](auto a) { return a; };

int main(void) {
  // because in C++ there is no global inference, R cannot be inferred as it's
  // not a concrete type.

  auto a = doubleCPS(10, [](int a) {
    return doubleCPS(a, [](int b) {
      return stringCPS(b, [](std::string c) {
        return lengthCPS(c, [](int sz) { return sz; });
      });
    });
  });

  std::cout << a << std::endl;
  return 0;
}
#include <iostream>

// how the fuck this works so well.

auto doubleCPS = [](double a, auto k) -> decltype(auto) { return k(a * 2); };

auto absCPS = [](double a, auto k) -> decltype(auto) { return k(std::abs(a)); };

auto id = [](auto a) { return a; };

auto stringCPS = [](auto a, auto k) -> decltype(auto) {
  return k(std::string("string"));
};

auto sizeCPS = [](auto a, auto k) -> decltype(auto) { return k(a.size()); };

auto makeCPS = [](auto f) { return [=](auto x, auto g) { return g(f(x)); }; };

auto cps1 = makeCPS([](auto a) { return a + 99; });

int main(void) {

  auto a = doubleCPS(10, [](int a) {
    return stringCPS(a, [](auto b) {
      return sizeCPS(b, [](int sz) {
        return doubleCPS(
            sz, [](double v) { return cps1(v, [](double x) { return x; }); });
      });
    });
  });
  std::cout << a << std::endl;
  return 0;
}
#include <iostream>
#include <string_view>

int main(void)
{

  return 0;
}
#define LUA_MLIB
#include <lua.hpp>
#include <math.h>

extern "C" {
    static int cswap (lua_State *L) {
        double arg1 = luaL_checknumber(L, 1);
        double arg2 = luaL_checknumber(L, 2);

        lua_pushnumber(L, arg2);
        lua_pushnumber(L, arg1);
        return 2;
    }

    static int msin (lua_State *L) {
        double arg = luaL_checknumber(L, 1);
        lua_pushnumber(L, sin(arg));
        return 1;
    }

    static const struct luaL_Reg mylib[] = {
        {"cswap", cswap},
        {"msin", msin},
        {NULL, NULL}
    };

    LUA_MLIB int luaopen_mylib(lua_State *L) {
        luaL_newlib(L, mylib);
        return 1;
    }
}
#include <lua.hpp>
#include <cstring>
#define MAX_COLOR 255

typedef struct ColorRGB {
    unsigned char red, green, blue;
} ColorRGB;

struct ColorTable {
    char const *name;
    unsigned char red, green, blue;
} colortable[] = {
    {"WHITE", MAX_COLOR, MAX_COLOR, MAX_COLOR},
    {"RED", MAX_COLOR, 0, 0},
    {"GREEN", 0, MAX_COLOR, 0},
    {"BLUE", 0, 0, MAX_COLOR},
    {"BLACK", 0, 0, 0},
    {"NULL", 0, 0, 0}
};

// load some tables.
extern "C" {

    int getfield(lua_State *L, const char *key) {
        int result;
        lua_pushstring(L, key);
        lua_gettable(L, -2);
        if (!lua_isnumber(L, -1)) luaL_error(L, "invalid component");
        result = (int)lua_tonumber(L, -1);
        lua_pop(L, 1);
        return result;
    }

    // assume table is at the top.
    void setfield (lua_State *L, const char *key, int value) {
        lua_pushstring(L, key);
        lua_pushnumber(L, (double)value/MAX_COLOR); lua_settable(L, -3); }

    void setcolor(lua_State *L, struct ColorTable *ct) {
        lua_newtable(L);
        setfield(L, "r", ct->red);
        setfield(L, "g", ct->green);
        setfield(L, "b", ct->red);
        lua_setglobal(L, ct->name);
    }

    int main(void) {
        lua_State *L = luaL_newstate();
        luaL_dofile(L, "./config.lua");
        lua_getglobal(L, "background");

        ColorRGB color = {0, 0, 0};

        if (lua_isstring(L, -1)) {
            const char *name = lua_tostring(L, -1);
            int i = 0;
            while (colortable[i].name != NULL &&
                    strcmp(name, colortable[i].name) != 0)
                i++;

            if (colortable[i].name == NULL)
                luaL_error(L, "invalid color name %s", name);
            else {
                color.red = colortable[i].red;
                color.green = colortable[i].green;
                color.blue = colortable[i].blue;
            }
        } else if (lua_istable(L, -1)) {
            color.red = getfield(L, "r");
            color.green = getfield(L, "g");
            color.blue = getfield(L, "b");
        } else
            luaL_error(L, "invalid value for background");

        printf("RGB: %d, %d, %d", color.red, color.green, color.blue);
        return 0;
    }
}
background = {r=0.10, g=0.40, b=0}
#include <lua.hpp>

extern "C" {
    double f(lua_State *L, double x, double y) {
        double z;
        lua_getglobal(L, "f");
        lua_pushnumber(L, x);
        lua_pushnumber(L, y);

        if (lua_pcall(L, 2, 1, 0) != 0)
            luaL_error(L, "error running function f: %s", lua_tostring(L, -1));

        if (!lua_isnumber(L, -1))
            luaL_error(L, "function f must return a num");
        z = lua_tonumber(L, -1);
        lua_pop(L, 1);
        return z;
    }

    int main(void) {
        lua_State *L = luaL_newstate();
        luaL_dofile(L, "./function.lua");
        luaL_openlibs(L);
        lua_getglobal(L, "f");

        double z = f(L, 1, 0.2);
        printf("%f", z);

        return 0;
    }

}

function f (x, y)
    return x + y
end

#include <lua.hpp>
#include <stdarg.h>

extern "C" {

    void call_va(lua_State *L, const char *func, const char *sig, ...) {
        va_list vl;
        int narg, nres;

        va_start(vl, sig);
        lua_getglobal(L, func);

        narg = 0;
        while (*sig) {
            switch (*sig++) {
                case 'd':
                    lua_pushnumber(L, va_arg(vl, double));
                    break;
                case 'i':
                    lua_pushnumber(L, va_arg(vl, int));
                    break;
                case 's':
                    lua_pushstring(L, va_arg(vl, char *));
                    break;
                case '>':
                    goto endwhile;
                default:
                    luaL_error(L, "invalid option %s", *(sig - 1));
            }
            narg ++;
            luaL_checkstack(L, 1, "too many argumetns");
        }
        endwhile:
        nres = -nres;
        while (*sig) {

        }

        va_end(vl);
    }
}
#include <lua.hpp>
#include <lua.h>

extern "C" {
    static void stackDump (lua_State *L) {
        int top = lua_gettop(L);
        for (int i = 1; i <= top; ++i) {
            int t = lua_type(L, i);
            switch (t) {
                case LUA_TSTRING:
                    printf("%s", lua_tostring(L, i));
                    break;;
                case LUA_TBOOLEAN:
                    printf(lua_toboolean(L, i) ? "true" : "false");
                    break;;
                case LUA_TNUMBER:
                    printf("%g", lua_tonumber(L, i));
                    break;;
                default:
                    printf("%s", lua_typename(L, i));
                    break;;

            }
            printf(" ");

        }
        printf("\n");

    }


    int main(void) {
        lua_State *L = luaL_newstate();
        lua_pushboolean(L, 1);
        lua_pushnumber(L, 10);
        lua_pushnil(L);
        lua_pushstring(L, "hello");

        stackDump(L); // current statck.

        lua_pushvalue(L, -4); // change something.
        stackDump(L);

        lua_replace(L, 3);
        stackDump(L);

        lua_settop(L, 6);
        stackDump(L);

        lua_remove(L, -3);
        stackDump(L);

        lua_settop(L, -5);
        stackDump(L);

        lua_close(L);

        return 0;
    }

}
#include <functional>
#include <iostream>

template <int Init = 0> class M {
private:
  int count = Init;

public:
  M() = default;
  M(int n) : count(n) {}

  M good() {
    count++;
    return *this;
  }

  M bad() {
    count++;
    return M(count);
  }

  M automorph(const std::function<int(int)> &f) { return M(f(count)); }

  void show() { std::cout << "count: " << count << std::endl; }
};

int main(void) {
  M<0> m;
  m.show();
  m.good().good().good().show();
  m.bad().bad().bad().show();

  auto f = [](int v) { return v + 1000; };
  M<0> m1;
  m1.good()
      .good()
      .automorph([](int v) { return v + 10; })
      .automorph([](int v) { return v + 100; })
      .automorph(f)
      .automorph(f)
      .show();

  return 0;
}
#include <iostream>
#include <variant>

template <class... Ts> struct overloaded : Ts... { using Ts::operator()...; };
template <class... Ts> overloaded(Ts...) -> overloaded<Ts...>;

int main() {
  auto PrintVisitor = [](const auto &t) { std::cout << t << '\n'; };

  std::variant<int, float, std::string> intFloatString{"Hello"};
  std::visit(overloaded{[](int &i) { i *= 2; },      //
                        [](float &f) { f *= 2.0f; }, //
                        [](std::string &s) { s = s + s; }},
             intFloatString);

  std::visit(PrintVisitor, intFloatString);

  // "custom" print:
  std::visit(
      overloaded{
          [](const int &i) { std::cout << "int: " << i << '\n'; },
          [](const float &f) { std::cout << "float: " << f << '\n'; },
          [](const std::string &s) { std::cout << "string: " << s << '\n'; }},
      intFloatString);

  return 0;
}
#include <iostream>

// it's just for a function pointer with return type void;
template <typename F> using FnPtr = auto (*)(F) -> int;

// function pointer wrapper for all function types.
template <typename R, typename... Args> using FPtr = auto (*)(Args...) -> R;

int foo(int a) {
  std::cout << "good" << std::endl;
  return 1 + a;
}

using T1 = FnPtr<int>;

void bar(FnPtr<int> ptr) {}

int main(void) {
  bar(foo);
  return 0;
}

#include <concepts>
#include <iostream>
#include <vector>

using namespace std::literals;

// type of auto depend on the value of x.
// of course in C++ this only works at compile time.
template <auto x> auto f() {
  if constexpr (x >= 42)
    return 42;
  else
    return "oops"s;
}

int main(void) {
  auto x = f<10>();
  auto y = f<42>();

  static_assert(std::same_as<decltype(x), std::string>);
  static_assert(std::same_as<decltype(y), int>);
}
#include <concepts>
#include <iostream>

using namespace std::literals;

// selector: real -> *
// selector x = int ifx >= 42 else string
template <typename T, auto x>
concept selector =
    std::same_as<std::decay_t<T>,
                 std::conditional_t<(x >= 42), int, std::string>>;

// f: real[x] -> selector x -> ⊥
template <auto x> auto f(selector<x> auto) {}

int main(void) {
  f<42>(42);
  f<10>("opps"s);

  // f<64>("lol"s);
  return 0;
}
#include <functional>
#include <iostream>
#include <vector>

// - Bounded quantification: Basically type constraint.
//   (Interaction of parametric polymorphism with subtyping)
//
// https://en.wikipedia.org/wiki/Bounded_quantification

// type E = ∃ a. x: a, print: a -> string -> ⊥
struct E {
  using QuantificationBound = auto(std::string_view) -> void;
  std::function<QuantificationBound> f{};

  E() = default;

  // exists an x, doesn't mater what type it is.
  E(auto x) {
    // we can print with x, but nothing else.
    f = [=](auto msg) { x.print(msg); };
  }

  auto print(auto msg) const { f(msg); }
};

struct A {
  auto print(auto msg) const { std::cout << "A: " << msg << std::endl; }
};

struct B {
  auto print(auto msg) const { std::cout << "B: " << msg << std::endl; }
};

// achieve a similar effect as subtype polymorphism.
auto main() -> int {
  auto xs = std::vector<E>{A{}, B{}};
  for (auto &x : xs) {
    x.print("hi");
  }
}
#include <concepts>

template <template <typename> typename Con, typename Arg>
using apply = Con<Arg>;

template <typename> struct A {};
template <typename> struct B {};

int main(void) {
  using x = apply<A, int>;
  using y = apply<B, double>;

  static_assert(std::same_as<x, A<int>>);
  static_assert(std::same_as<y, B<double>>);
  return 0;
}
#include <functional>
#include <iostream>
#include <tuple>

using namespace std::literals;

// p: (∀ a. a -> a) -> ∀ ...b. b... -> π b...

auto p(auto f, auto... x) { return std::make_tuple(f(x)...); }

auto main(void) -> int {
  auto [x, y, z] = p([](auto x) { return x + x; }, 21, 1.5, "ja"s);

  return 0;
}
#include <concepts>
#include <iostream>
#include <vector>

using namespace std::literals;

// class C a = { type G a, g : a -> G a }
//
// F: * -> *
// ∀ C a. F a = [G a]
// F _ = int
//
// f: ∀ a. a -> F a

auto f(auto x) {
  if constexpr (requires { x.g(); })
    return std::vector{x.g()};
  else
    return 42;
}

struct A {
  auto g() { return 2.81; }
};

struct B {
  auto g() { return "oops"s; }
};

struct C {};

int main(void) {
  auto x = f(A{});
  static_assert(std::same_as<decltype(x), std::vector<double>>);

  auto y = f(B{});
  static_assert(std::same_as<decltype(y), std::vector<std::string>>);

  auto z = f(C{});
  static_assert(std::same_as<decltype(z), int>);
  return 0;
}


template <auto x> auto f() requires(x >= 42) {}

int main(void) {
  f<42>();
  // f<10>();
  return 0;
}
#include <iostream>
#include <memory>
#include <vector>

// just normal virtual functions

struct E {
  virtual auto print(std::string_view msg) -> void = 0;
};

// A <: E
struct A : E {
  auto print(std::string_view msg) -> void override {
    std::cout << "A: " << msg << std::endl;
  }
};

// B <: E
struct B : E {
  auto print(std::string_view msg) -> void override {
    std::cout << "B: " << msg << std::endl;
  }
};

int main(void) {
  auto xs = std::vector<std::unique_ptr<E>>{};
  xs.emplace_back(std::make_unique<A>());
  xs.emplace_back(std::make_unique<B>());

  for (auto &x : xs) {
    x->print("hi");
  }

  return 0;
}
// parametric polymorphism

#include <concepts>
#include <iostream>

using namespace std::literals;

auto id(auto x) { return x; }

int main(void) {
  auto x = id(13);
  auto y = id(13.1);
  auto z = id("asd"s);

  static_assert(std::same_as<decltype(x), int>);
  static_assert(std::same_as<decltype(y), double>);
  static_assert(std::same_as<decltype(z), std::string>);
  return 0;
}
#include <iostream>
#include <sstream>
#include <string>

class Str : public std::string {

public:
  Str(const Str &a) : std::string(a) { std::cout << "copyed" << std::endl; }

  Str(const char *str) : std::string(str) {}
};

Str operator+(Str &&a, Str &&b) {
  std::stringstream os;
  std::cout << "in move addition" << std::endl;
  os << a << b;
  return Str(os.str().c_str());
}

int main(void) {

  Str s1("abc");
  Str s2("cde");
  Str s3(s1);

  auto c = std::move(s1) + std::move(s2);
  std::cout << "result: " << c << std::endl;

  return 0;
}
#include <X11/Xlib.h>
#include <unistd.h>

int main(void) {
  Display *d = XOpenDisplay(0);
  if (d != nullptr) {
    Window w =
        XCreateWindow(d, DefaultRootWindow(d), 0, 0, 200, 100, 0,
                      CopyFromParent, CopyFromParent, CopyFromParent, 0, 0);

    XMapWindow(d, w);
    XFlush(d);
    sleep(10);
  }
  return 0;
}
#include <algorithm>
#include <benchmark/benchmark.h>
#include <cstdlib>
#include <iostream>
#include <numeric>
#include <vector>

static void accumulate_bench(benchmark::State &s) {
  auto N = 1 << s.range(0);

  std::vector<int> v(N);
  std::generate(std::begin(v), std::end(v), [] { return rand() % 100; });

  int result = 0;
  for (auto _ : s) {
    benchmark::DoNotOptimize(
        result = std::accumulate(std::begin(v), std::end(v), 0));
  }

  // note if you don't use result, it might be optimized away by the compiler.
}

BENCHMARK(accumulate_bench)->DenseRange(20, 25)->Unit(benchmark::kMicrosecond);
BENCHMARK_MAIN();
#!/usr/bin/bash
bench_() {
  g++ bench_accumulate.cc -lbenchmark -lpthread -O3
  if [[ $# -eq 0 ]]; then ./a.out; fi
}

bench_native_() {
  g++ bench_accumulate.cc -lbenchmark -lpthread -O3 \
    -march=native -mtune=native -flto -fuse-linker-plugin
  if [[ $# -eq 0 ]]; then ./a.out; fi
}

bench_sz_20_() {
  bench_ 1
  ./a.out --benchmark_filter=accumulate_bench/20
}

dump_() {
  bench_ 1 && objdump -C -d ./a.out > out.asm
}

perf_record_() {
  bench_ && perf record ./a.out && perf report
}

refresh_() {
  bench_ 1 && dump_
}
#include <benchmark/benchmark.h>
#include <iostream>
#include <random>

// branch predictions
// processors use branch predictors to help the pipeline
// to fille the instructions.

static void custom_args(benchmark::internal::Benchmark *b) {
  for (auto i : {14}) {
    // list of probabilities.
    //
    // when probability is 0 or 100, the brach predictor should always predict the
    // right branch, because there are no other possibilities.
    // as probability goes closer to 50, the branch predictor will start to make
    // more and more mistakes, so there should be more branch misses.
    for (auto j : {0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100}) {
      b = b->ArgPair(i, j);
    }
  }
}

static void BRANCH_RANDOM(benchmark::State &s) {
  auto N = 1 << s.range(0);

  double probability = s.range(1) / 100.0;

  std::random_device rd;
  std::mt19937 gen(rd());
  std::bernoulli_distribution d{probability};

  std::vector<bool> vin(N);
  std::generate(begin(vin), end(vin), [&]() { return d(gen); });

  int sink = 0;

  for (auto _ : s) {
    for (auto b : vin) {
      if (b) {
        benchmark::DoNotOptimize(sink += s.range(0));
      }
    }
  }
}

BENCHMARK(BRANCH_RANDOM)->Apply(custom_args)->Unit(benchmark::kMicrosecond);
BENCHMARK_MAIN();
#!/usr/bin/bash

bench_ () {
  g++ biased_branches.cc -O3 -lbenchmark
  if [[ $# -eq 0 ]]; then ./a.out; fi
}


perf_stat_ () {
  CASE="BRANCH_RANDOM/14/${1}" && echo $CASE
  bench_ 1 && perf stat ./a.out --benchmark_filter="$CASE"
}
#include <benchmark/benchmark.h>
#include <iostream>

// cache design
// - Direct Map Cache
//   concecutive bins. An address will map to a particular bin.
//   | | | | | - len = 4
//    0 1 2 3  - idicies
// which bin a memory go? idx <- addr `mod` len
//
// - Fully associated Cache
//   | ...  ... | - we can shove cache block in any one of the bin.
//
// - Set associative cache.
//   Combine both DM and FA.
//          way0  way1
//   set 0 |    |    |
//   set 1 |    |    |
//
//   1. mod to get set idx
//   2. find empty slot and save the cache block there.

// modern cpu use set associateive cache, though it mitidate the
// problem of direct map cache and fully associative cache, certain memory
// access pattern can still cache problem.

static void ASSOC(benchmark::State &s) {
  // 2^n
  int step = 1 << s.range(0);

  // 32 MB
  int N = 1 << 25;
  char *a = new char[N];

  for (int i = 0; i < N; i++) {
    a[i] = rand() % 100;
  }

  // try differetn step sizes
  while (s.KeepRunning()) {
    int i = 0;
    for (int iter = 0; iter < 10000; iter++) {
      a[i]++;
      // wrap around the size of the array.
      i = (i + step) % N;
    }
  }

  delete[] a;
}

BENCHMARK(ASSOC)->DenseRange(0, 64)->Unit(benchmark::kMicrosecond);

BENCHMARK_MAIN();
#!/usr/bin/bash

bench_ () {
  g++ cache_assoc.cc -O3 -lbenchmark
  if [[ $# -eq 0 ]]; then ./a.out; fi
}


perf_stat_ () {
  CASE="${1}" && echo $CASE
  bench_ 1 && perf stat -d -d -d ./a.out --benchmark_filter="$CASE"
}
#include <algorithm>
#include <benchmark/benchmark.h>
#include <iterator>
#include <vector>

struct Fields {
  int v0 = 0;
  int v1 = 0;
  int v2 = 0;
  int v3 = 0;
  int v4 = 0;
  int v5 = 0;
  int v6 = 0;
  int v7 = 0;
  int v8 = 0;
  int v9 = 0;
  int v10 = 0;
  int v11 = 0;
  int v12 = 0;
  int v13 = 0;
  int v14 = 0;
  int v15 = 0;

  void inc_v0() { v0++; }
};

// struct of Array
struct SoA {

  std::vector<int> v0s;
  std::vector<int> v1s;
  std::vector<int> v2s;
  std::vector<int> v3s;
  std::vector<int> v4s;
  std::vector<int> v5s;
  std::vector<int> v6s;
  std::vector<int> v7s;
  std::vector<int> v8s;
  std::vector<int> v9s;
  std::vector<int> v10s;
  std::vector<int> v11s;
  std::vector<int> v12s;
  std::vector<int> v13s;
  std::vector<int> v14s;
  std::vector<int> v15s;

  void update_v0s() {
    for (auto &i : v0s) {
      i++;
    }
  }

  SoA(int N) {
    v0s.resize(N);
    v1s.resize(N);
    v2s.resize(N);
    v3s.resize(N);
    v4s.resize(N);
    v5s.resize(N);
    v6s.resize(N);
    v7s.resize(N);
    v8s.resize(N);
    v9s.resize(N);
    v10s.resize(N);
    v11s.resize(N);
    v12s.resize(N);
    v13s.resize(N);
    v14s.resize(N);
    v15s.resize(N);
  }
};

// oop style
static void ARRAY_OF_STRUCT(benchmark::State &s) {
  int N = s.range(0);

  std::vector<Fields> vs;
  std::fill_n(std::back_inserter(vs), N, Fields{});

  while (s.KeepRunning()) {
    // there will be more cache missies because the field we want to
    // access scatter among different objects.
    // this might require the cpu to do some prefetching to optmize the access.
    for (auto &i : vs) {
      i.inc_v0();
    }
  }
}
BENCHMARK(ARRAY_OF_STRUCT)->DenseRange(8, 16);

// data oriented style.
static void STRUCT_OF_ARRAY(benchmark::State &s) {
  int N = s.range(0);

  SoA soa{N};

  while (s.KeepRunning()) {
    // all data are in the same vector, so when accessing one they will
    // be fetched into the cachline together:
    soa.update_v0s();
  }
}
BENCHMARK(STRUCT_OF_ARRAY)->DenseRange(8, 16);

BENCHMARK_MAIN();
#!/usr/bin/bash

bench_ () {
  g++ data.cc -O3 -lbenchmark
  if [[ $# -eq 0 ]]; then ./a.out; fi
}


perf_stat_ () {
  CASE="${1}" && echo $CASE
  bench_ 1 && perf stat -d -d -d ./a.out --benchmark_filter="$CASE"
}
#include <benchmark/benchmark.h>
#include <iostream>
#include <random>
#include <vector>

// underlying implementation of dynamic dispatching will use
// some sort of conditional somewhere, so branch misses applies
// here is merely a consequences of that.

struct JosephJostar {
  virtual float stand() const noexcept { return 2.0; }
};

struct KujoJotaro : public JosephJostar {
  virtual float stand() const noexcept { return 1.0; }
};

struct JosukeHigashikata : public JosephJostar {
  virtual float stand() noexcept { return 3.0; }
};

// this version has less branch misses.
static void vf_sorted(benchmark::State &s) {
  std::vector<JosephJostar *> jojos;

  std::fill_n(std::back_inserter(jojos), 10000, new JosephJostar);
  std::fill_n(std::back_inserter(jojos), 10000, new KujoJotaro);
  std::fill_n(std::back_inserter(jojos), 10000, new JosukeHigashikata);

  float sum = 0;

  while (s.KeepRunning()) {
    for (auto *jojo : jojos) {
      sum += jojo->stand();
    }
  }
}

BENCHMARK(vf_sorted)->UseRealTime()->Unit(benchmark::kMicrosecond);

// more branch misses.
static void vf_unsorted(benchmark::State &s) {
  std::vector<JosephJostar *> jojos;

  std::fill_n(std::back_inserter(jojos), 10000, new JosephJostar);
  std::fill_n(std::back_inserter(jojos), 10000, new KujoJotaro);
  std::fill_n(std::back_inserter(jojos), 10000, new JosukeHigashikata);

  std::random_device rng;
  std::mt19937 gen(rng());
  std::shuffle(std::begin(jojos), std::end(jojos), gen);

  float sum = 0;

  while (s.KeepRunning()) {
    for (auto *jojo : jojos) {
      sum += jojo->stand();
    }
  }
}

BENCHMARK(vf_unsorted)->UseRealTime()->Unit(benchmark::kMicrosecond);

BENCHMARK_MAIN();
#!/usr/bin/bash

bench_ () {
  g++ dynamic_dispatch.cc -O3 -lbenchmark
  if [[ $# -eq 0 ]]; then ./a.out; fi
}


perf_stat_ () {
  CASE="${1}" && echo $CASE
  bench_ 1 && perf stat -d -d -d ./a.out --benchmark_filter="$CASE"
}
#!/usr/bin/bash
bench_ () {
  g++ ./false_sharing.cc -lbenchmark -lpthread -g
  if [[ $# -eq 0 ]]; then ./a.out; fi
}

dump_ () {
  bench_ 1 && objdump -C -d ./a.out
}

perf_record_ () {
  bench_ 1 && perf record ./a.out --benchmark_filter="$1" && perf report
}

perf_c2c_ () {
  bench_ 1 && perf c2c record ./a.out && perf c2c report
}

perf_stat_ () {
  bench_ 1 && perf stat -d -d -d ./a.out --benchmark_filter="$1"
}

#include <atomic>
#include <benchmark/benchmark.h>
#include <chrono>
#include <iostream>
#include <thread>
#include <vector>

// what do system people do.?

// Four cases to demonstrate the effect of sharing cacheline
// has on performance.

void work(std::atomic<int> &a) {
  for (int i = 0; i < 100000; i++) {
    a++;
  }
}

void single_thread() {
  std::atomic<int> a;
  a = 0;

  for (int i = 0; i < 3; ++i) {
    work(a);
  }
}

static void SINGLE_THREADED(benchmark::State &s) {
  while (s.KeepRunning()) {
    single_thread();
  }
}

BENCHMARK(SINGLE_THREADED)->UseRealTime()->Unit(benchmark::kMillisecond);

// direct sharing.
//  a will bounce around in four different cachelines.
void direct_sharing() {
  std::atomic<int> a;
  a = 0;

  std::vector<std::thread> ts{};

  for (int i = 0; i < 3; ++i) {
    ts.emplace_back(std::thread([&]() { work(a); }));
  }

  for (auto &t : ts) {
    t.join();
  }
}

static void DIRECTED_SHARING(benchmark::State &s) {
  while (s.KeepRunning()) {
    direct_sharing();
  }
}

BENCHMARK(DIRECTED_SHARING)->UseRealTime()->Unit(benchmark::kMillisecond);

// false sharing.
// although different threads are using different atomic values,
// they happen to align in the sme cache line.
// the same cacheline will also bouncing around four threads, but this
// time 3/4 are useless.
void false_sharing() {
  std::atomic<int> a;
  std::atomic<int> b;
  std::atomic<int> c;
  std::atomic<int> d;

  std::thread t1([&]() { work(a); });
  std::thread t2([&]() { work(b); });
  std::thread t3([&]() { work(c); });
  std::thread t4([&]() { work(d); });

  t1.join();
  t2.join();
  t3.join();
  t4.join();
}

static void FALSE_SHARING(benchmark::State &s) {
  while (s.KeepRunning()) {
    false_sharing();
  }
}

BENCHMARK(FALSE_SHARING)->UseRealTime()->Unit(benchmark::kMillisecond);

// No sharing at all among 4 threads.
// cacheline has maximum size 64 bytes. if we align the struct
// to 64 we can guarantee two structs don't fit in one cachline.
struct alignas(64) AlignedType {
  AlignedType() { val = 0; }
  std::atomic<int> val;
};

void no_sharing() {
  AlignedType a{};
  AlignedType b{};
  AlignedType c{};
  AlignedType d{};

  std::thread t1([&]() { work(a.val); });
  std::thread t2([&]() { work(b.val); });
  std::thread t3([&]() { work(c.val); });
  std::thread t4([&]() { work(d.val); });

  t1.join();
  t2.join();
  t3.join();
  t4.join();
}

static void NO_SHARING(benchmark::State &s) {
  while (s.KeepRunning()) {
    no_sharing();
  }
}

BENCHMARK(NO_SHARING)->UseRealTime()->Unit(benchmark::kMillisecond);

BENCHMARK_MAIN();
#!/usr/bin/bash

bench_ () {
  g++ prefetching.cc -O3 -lbenchmark
  if [[ $# -eq 0 ]]; then ./a.out; fi
}


perf_stat_ () {
  CASE="${1}" && echo $CASE
  bench_ 1 && perf stat -d -d -d ./a.out --benchmark_filter="$CASE"
}
#include <benchmark/benchmark.h>
#include <cstdlib>
#include <iostream>

// given Matrix
// [ ... ... ... ...
//   ... ... ... ...
//   ... ... ... ...
// ]

// best case. elements we are accessing actually aligned.
// they will be naturally fetched into a cacheline.
static void ROWMAJOR(benchmark::State &s) {
  int N = 1 << 12;
  int *array = new int[N * N];

  while (s.KeepRunning()) {
    for (int i = 0; i < N; ++i) {
      for (int j = 0; j < N; ++j) {
        array[i * N + j] += j;
      }
    }
  }
}
BENCHMARK(ROWMAJOR)->Unit(benchmark::kMillisecond);

// theoriotically bad for cache usage. Everytime we acecss a new
// element we need to find it somewhere N elemnts apart from the last
// accessed element.
//
// Once cpe recognize this pattern, it will use prefetching helps to load
// elements that are N distance apart all together and fit them into one
// cache line.
static void COLMAJOR(benchmark::State &s) {
  int N = 1 << 12;
  int *array = new int[N * N];
  while (s.KeepRunning()) {
    for (int i = 0; i < N; ++i) {
      for (int j = 0; j < N; ++j) {
        array[j * N + i] += i;
      }
    }
  }
}
BENCHMARK(COLMAJOR)->Unit(benchmark::kMillisecond);

// if you check perf stat, cache misses for this version is 90%.
// almost no cache is used.
static void RANDOM_STRIKE(benchmark::State &s) {
  int N = 1 << 12;
  int *array = new int[N * N];
  while (s.KeepRunning()) {
    for (int i = 0; i < N; ++i) {
      for (int j = 0; j < N; ++j) {
        array[j * N + rand() % N] += i;
      }
    }
  }
}
BENCHMARK(RANDOM_STRIKE)->Unit(benchmark::kMillisecond);

BENCHMARK_MAIN();
#!/usr/bin/bash

bench_ () {
  g++ rvo.cc -O3 -lbenchmark
  if [[ $# -eq 0 ]]; then ./a.out; fi
}


perf_stat_ () {
  CASE="${1}" && echo $CASE
  bench_ 1 && perf stat -d -d -d ./a.out --benchmark_filter="$CASE" --benchmark_min_time=3
}
#include <array>
#include <benchmark/benchmark.h>
#include <cstdlib>
#include <cstring>
#include <iostream>

class MyString {

  char *data;
  size_t size;

public:
  MyString(const char *msg) {
    size = std::strlen(msg) - 1;
    data = new char[size];
    std::memcpy(data, msg, sizeof(char) * size);
  }

  MyString(const MyString &other) {
    // std::cout << "calling copy constructor" << std::endl;

    if (size < other.size) {
      if (data) {
        delete[] data;
      }
      data = new char[other.size];
    }

    std::memcpy(data, other.data, sizeof(char) * other.size);
    size = other.size;
  }

  MyString(MyString &&other) {
    // std::cout << "calling move constructor" << std::endl;

    if (!other.data) {
      return;
    }

    size = other.size;
    data = other.data;

    other.data = nullptr;
    other.size = 0;
  }

  ~MyString() { delete[] data; }
};

// return type optimization will add a pointer as argument of the
// function.
// the function will assign the address of value ms to the hidden ptr,
// and return the address instead of the value.
// At call site the returned address is dereferenced to get the same effect.
MyString rvo() {
  MyString ms{"hi"};
  return ms;
}

static void RVO(benchmark::State &s) {
  while (s.KeepRunning()) {
    for (int i = 0; i < 100000; ++i) {
      rvo();
    }
  }
}

BENCHMARK(RVO)->UseRealTime()->Unit(benchmark::kMillisecond);

// this cannot have return value optimization. because the problem
// doesn't know which branch will be choosen at runtime, so we don't know
// which MyString we should return to.
MyString norvo(bool cond) {
  MyString ms1{"Yo"};
  MyString ms2{"Sup"};
  if (cond) {
    return ms1;
  } else {
    return ms2;
  }
}

static void NORVO(benchmark::State &s) {
  while (s.KeepRunning()) {
    for (int i = 0; i < 100000; ++i) {
      norvo(rand() > 0.5);
    }
  }
}
BENCHMARK(NORVO)->UseRealTime()->Unit(benchmark::kMillisecond);

BENCHMARK_MAIN();
bench_ () {
  g++ ./spin_lock"$1".cc -I. -lpthread -lbenchmark -O3 -march=native -mtune=native -flto -fuse-linker-plugin
  if [[ $# -eq 1 ]]; then
    ./a.out
  fi
}

perf_record_ () {
  bench_ $1 1
  perf record ./a.out
  perf report
}

perf_stat_ () {
  bench_ $1 1
  perf stat -d -d -d ./a.out
}
// active backoff

#include <benchmark/benchmark.h>

#include <atomic>
#include <cstdint>
#include <iostream>
#include <thread>
#include <vector>

#define ITERATION 100000

class spin_lock {
protected:
  std::atomic<bool> locked{false};

public:
  virtual void lock();

  virtual void unlock() { locked.store(false); } // @write
};

class scoped_spin_lock {
private:
  spin_lock &lk;

public:
  scoped_spin_lock(spin_lock &lk) : lk(lk) { lk.lock(); }
  ~scoped_spin_lock() { lk.unlock(); }
};

inline std::int64_t inc(spin_lock &s, std::int64_t value) {

  for (int i = 0; i < ITERATION; ++i) {
    scoped_spin_lock lk{s};
    value++; // @write
  }

  return value;
}

template <typename Lock> inline void spin_lock_bench(benchmark::State &s) {
  auto num_threads = s.range(0);

  std::int64_t value = 0;

  std::vector<std::thread> threads;
  threads.reserve(num_threads);

  Lock slk{};

  for (auto _ : s) {
    for (auto i = 0u; i < num_threads; ++i) {
      threads.emplace_back([&] {
          int v = inc(slk, value);
          assert(v == ITERATION);
          });
    }

    for (auto &t : threads) {
      t.join();
    }

    threads.clear();
  }
}
// low context switching spin lock.
// native version 1

// this implementation has a coherence missing problem:
//          As we adding new thread, we have more direct sharing among threads.
//          Thus lots of cache misses.
//          Spawning more threads also have large overhead by itself.

#include <benchmark/benchmark.h>

#include "spin_lock.h"
#include <atomic>

//  all threads acccessing the atomic bool, because it's atomic the cpu
//  need to ensure each time a thread trying to write on it,
//  it has it's exclusive copy.

void spin_lock::lock() {
  while (locked.exchange(true)) // @write
    ;
}

static void naive(benchmark::State &s) { spin_lock_bench<spin_lock>(s); }

BENCHMARK(naive)
    ->RangeMultiplier(2)
    ->Range(1, std::thread::hardware_concurrency())
    ->UseRealTime()
    ->Unit(benchmark::kMillisecond);

BENCHMARK_MAIN();
// lockly spinning to reduce cash missing.

// four types of cache misses.
// 1. compulsory  (first time)
// 2. capacity    (access more data then cache supports.)
// 3. conflict    (mapped to the same associative set cache)
// 4. coherence   (direct sharing, false sharing, etc.)

#include <benchmark/benchmark.h>

#include "spin_lock.h"
#include <atomic>

// (way less).
void spin_lock::lock() {
  while (1) {
    if (!locked.exchange(true)) // @ only write once, get rid of uncessary xchg
      return;

    // all threads closely monitoring the state of the lock.
    // once the lock is available, all threads will try to grab
    // the lock with locked.exchange. The sudden burst impose a large overheat.
    while (locked.load()) // @read
      ;
  }
}

static void locally_spin(benchmark::State &s) { spin_lock_bench<spin_lock>(s); }

BENCHMARK(locally_spin)
    ->RangeMultiplier(2)
    ->Range(1, std::thread::hardware_concurrency())
    ->UseRealTime()
    ->Unit(benchmark::kMillisecond);

BENCHMARK_MAIN();
// active backoff

#include <benchmark/benchmark.h>

#include "spin_lock.h"
#include <atomic>

// Adding some idle operation between each read access.
// this way we separate out the access of the atomic lock.
// When it's availble, less thread will see the change, thus
// less threads will break the loop and do exchange.
// Thus reduce the burst contention.

void spin_lock::lock() {
  while (1) {
    if (!locked.exchange(true)) // @ only write once
      return;

    while (locked.load()) // @read
                          // dummy for loop wasting energy.
      for (volatile int i = 0; i < 100; i += 1)
        ;
  }
}

static void active_backoff(benchmark::State &s) {
  spin_lock_bench<spin_lock>(s);
}

BENCHMARK(active_backoff)
    ->RangeMultiplier(2)
    ->Range(1, std::thread::hardware_concurrency())
    ->UseRealTime()
    ->Unit(benchmark::kMillisecond);

BENCHMARK_MAIN();
// passive backoff

#include <benchmark/benchmark.h>

#include "spin_lock.h"
#include <atomic>
#include <emmintrin.h>
void spin_lock::lock() {
  while (1) {
    if (!locked.exchange(true)) // @ only write once
      return;

    do {
      for (int i = 0; i < 4; ++i) {
        _mm_pause(); // intrinsic for spin wait loop.
      }
    } while (locked.load());
  }
}

static void passive_backoff(benchmark::State &s) { spin_lock_bench<spin_lock>(s); }

BENCHMARK(passive_backoff)
    ->RangeMultiplier(2)
    ->Range(1, std::thread::hardware_concurrency())
    ->UseRealTime()
    ->Unit(benchmark::kMillisecond);

BENCHMARK_MAIN();
// exponential backoff

#include <benchmark/benchmark.h>

#include "spin_lock.h"
#include <atomic>
#include <emmintrin.h>

#define MIN_BACKOFF 4
#define MAX_BACKOFF 1024
void spin_lock::lock() {
  int back_off_iters = MIN_BACKOFF;
  while (1) {
    if (!locked.exchange(true)) // @ only write once
      return;

    do {
      for (int i = 0; i < back_off_iters; ++i) {
        _mm_pause(); // intrinsic for spin wait loop.
      }
      back_off_iters = std::min(back_off_iters << 1, MAX_BACKOFF);
    } while (locked.load());
  }
}

static void exponential_backoff(benchmark::State &s) {
  spin_lock_bench<spin_lock>(s);
}

BENCHMARK(exponential_backoff)
    ->RangeMultiplier(2)
    ->Range(1, std::thread::hardware_concurrency())
    ->UseRealTime()
    ->Unit(benchmark::kMillisecond);

BENCHMARK_MAIN();
// random backoff

#include <benchmark/benchmark.h>

#include "spin_lock.h"
#include <atomic>
#include <emmintrin.h>
#include <random>

#define MIN_BACKOFF 4
#define MAX_BACKOFF 1024

class random_spin_lock : public spin_lock {
private:
  std::uniform_int_distribution<int> dist;
  std::mt19937 rng;

public:
  void lock();

  random_spin_lock() {
    rng.seed(std::random_device()());
    dist = std::uniform_int_distribution<int>(MIN_BACKOFF, MAX_BACKOFF);
  }
};

void spin_lock::lock() {}

void random_spin_lock::lock() {
  while (1) {
    if (!locked.exchange(true)) // @ only write once
      return;

    do {
      int back_off_iters = dist(rng);
      for (int i = 0; i < back_off_iters; ++i) {
        _mm_pause(); // intrinsic for spin wait loop.
      }
    } while (locked.load());
  }
}

static void random_backoff(benchmark::State &s) {
  spin_lock_bench<random_spin_lock>(s);
}

BENCHMARK(random_backoff)
    ->RangeMultiplier(2)
    ->Range(1, std::thread::hardware_concurrency())
    ->UseRealTime()
    ->Unit(benchmark::kMillisecond);

BENCHMARK_MAIN();
// ticket spinlock to improve the fairness.

#include <benchmark/benchmark.h>

#include "spin_lock.h"
#include <atomic>
#include <emmintrin.h>
#include <random>

#define MIN_BACKOFF 4
#define MAX_BACKOFF 1024

void spin_lock::lock() {}

class ticket_lock : public spin_lock {
private:
  std::atomic<std::uint16_t> line{0};
  volatile std::uint16_t serving{0};

public:
  virtual void lock() override;
  virtual void unlock() override;
};

// we aim to optmize for the fairness of the lock. We hope all threads
// have equal opportunity to grab the lock.
void ticket_lock::lock() {
  auto place = line.fetch_add(1);
  while (serving != place)
    ;
}

void ticket_lock::unlock() { serving = serving + 1; }

static void ticket_based(benchmark::State &s) {
  spin_lock_bench<ticket_lock>(s);
}

BENCHMARK(ticket_based)
    ->RangeMultiplier(2)
    ->Range(1, std::thread::hardware_concurrency())
    ->UseRealTime()
    ->Unit(benchmark::kMillisecond);

BENCHMARK_MAIN();
#!/usr/bin/bash

bench_ () {
  g++ ./thread_affinity.cc -g -O3 -flto -fuse-linker-plugin -march=native -mtune=native -lbenchmark -lpthread

  if [[ $# -eq 0 ]]; then ./a.out; fi
}

perf_record_ () {
  bench_ 1 && perf record ./a.out --benchmark-filter="$1" && perf report
}

perf_stat_ () {
  bench_ 1 && perf stat -d -d -d ./a.out --benchmark_filter="$1"
}

perf_c2c_ () {
  bench_ 1 && perf c2c record ./a.out --benchmark_filter="$1" && perf c2c report
}
#include <atomic>
#include <benchmark/benchmark.h>
#include <cassert>
#include <iostream>
#include <pthread.h>
#include <thread>

#define ITERATION = 100000
// pinning threads to specific cores for performance.

void work(std::atomic<int> &a) {
  for (int i = 0; i < 100000; ++i) {
    a++;
  }
}

struct alignas(64) AlignedAtomic {
  AlignedAtomic(int v) { value = v; }
  std::atomic<int> value;
};

// thread 0, 1 wants to access the same atomic value.
// thread 2, 3 wants to access the same atomic value.
// if we leave the scheduling to the operating system, 0, 1, 2, 3
// are equally likely to be bounded to any core.
// So if core 1 was running thread 1 with cache filled with a,
// and next second it's scheduled with thread 3, the cache line
// is invalid and need to refetch.
void os_scheduler() {
  AlignedAtomic a{0};
  AlignedAtomic b{0};

  std::thread t0([&]() { work(a.value); });
  std::thread t1([&]() { work(a.value); });
  std::thread t2([&]() { work(b.value); });
  std::thread t3([&]() { work(b.value); });

  t0.join();
  t1.join();
  t2.join();
  t3.join();
}

static void OS_SCHEDULER(benchmark::State &s) {
  while (s.KeepRunning()) {
    os_scheduler();
  }
}

// We can bound certain threads to one particular core. It's called set
// thread affinity.
// By doing so, thread 0, 1 always get bound to the same cpu, thus the cache
// never get invalidated.
BENCHMARK(OS_SCHEDULER)->UseRealTime()->Unit(benchmark::kMillisecond);

void thread_affinity() {
  AlignedAtomic a{0};
  AlignedAtomic b{0};

  cpu_set_t cpu_set_1;
  cpu_set_t cpu_set_2;

  // zero out
  CPU_ZERO(&cpu_set_1);
  CPU_ZERO(&cpu_set_2);

  // set CPU cores to pin our threads to.
  CPU_SET(0, &cpu_set_1);
  CPU_SET(1, &cpu_set_2);

  // pin 0, 1 to core 0
  std::thread t0([&]() { work(a.value); });
  assert(pthread_setaffinity_np(t0.native_handle(), sizeof(cpu_set_t),
                                &cpu_set_1) == 0);
  std::thread t1([&]() { work(a.value); });
  assert(pthread_setaffinity_np(t1.native_handle(), sizeof(cpu_set_t),
                                &cpu_set_1) == 0);

  // pin 2, 3 to core 1
  std::thread t2([&]() { work(b.value); });
  assert(pthread_setaffinity_np(t2.native_handle(), sizeof(cpu_set_t),
                                &cpu_set_2) == 0);
  std::thread t3([&]() { work(b.value); });
  assert(pthread_setaffinity_np(t3.native_handle(), sizeof(cpu_set_t),
                                &cpu_set_2) == 0);

  t0.join();
  t1.join();
  t2.join();
  t3.join();
}

static void THREAD_AFFINITY(benchmark::State &s) {
  while (s.KeepRunning()) {
    thread_affinity();
  }
}

BENCHMARK(THREAD_AFFINITY)->UseRealTime()->Unit(benchmark::kMillisecond);

BENCHMARK_MAIN();
#include <iostream>

// use case of reinterpret case to check endianess.
bool is_little_endian() {
  // big endianess:    0000 0000 0000 0001
  // little endianess: 0000 0001 0000 0000
  std::uint16_t x = 0x0001;
  auto p = reinterpret_cast<std::uint8_t *>(&x);

  // if it's little endianess, *p will be the first 8 0 bits.
  return *p != 0;
}

int main() {

  int a = 1000;

  std::cout << "static cast 1000 to: doube, value is:" << static_cast<double>(a)
            << std::endl;

  // in memory it's still the representation of 1000, but the memory is treated
  // as double now.
  // you can't directly reinterpret cast int to double, but you can cast an
  // int pointer to double pointer then dereference it.
  std::cout << "reinterpret cast 1000 to: doube, value is:"
            << *reinterpret_cast<double *>(&a) << std::endl;
}
#include <iostream>

int main(void)
{

  return 0;
}
#include <iostream>
#include <memory>

struct pod_t {
  int a;
  int b;

  pod_t(int a, int b) : a(a), b(b) {}
};

int main(void) {
  std::unique_ptr<pod_t> ptr = std::make_unique<pod_t>(1, 2);

  auto pod1 = *ptr;

  int *cptr = new int(1);

  std::cout << "cptr, check where is the heap: " << cptr << std::endl;
  std::cout << "unique ptr is on the stack: " << &ptr << std::endl;
  std::cout << "unique ptr holds a heap pointer: " << ptr.get() << std::endl;
  std::cout << "ptr: " << &(*ptr) << " It's clearly on heap" << std::endl;
  std::cout << "ptr1: " << &pod1 << " It's on stack" << std::endl;

  return 0;
}
#include <assert.h>
#include <iostream>
#include <memory>
#include <sstream>
#include <vector>

struct Foo {
  int *data;

  Foo() {
    data = new int[10];
    for (int i = 0; i < 10; ++i) {
      data[i] = i;
    }
  }

  void shift1() {
    int tmp = data[9];
    for (int i = 9; i > 0; --i) {
      data[i] = data[i - 1];
    }
    data[0] = tmp;
  }

  std::string to_string() {
    std::stringstream ss;
    ss << "addr of data:  " << &data << " ";
    for (int i = 0; i < 10; ++i) {
      ss << data[i] << ", ";
    }
    return ss.str();
  }
};

static_assert(std::is_destructible_v<Foo>);

// this is good. use shared_ptr to manage resource with multiple owners.
using SF = std::shared_ptr<Foo>;

// this is bad, because you don't know if the underlying shared_ptr is
// valid.
using RSF = std::reference_wrapper<std::shared_ptr<Foo>>;

int main(void) {

  Foo f1;

  // Topic 1. is shared_ptr on stack or on heap?
  // this construct a new element that's different from f1.
  SF p0 = std::make_shared<Foo>(f1);

  // verify sure p1 is on the heap.
  std::cout << "stack address f1: " << &f1 << std::endl;

  // notice the value shared_ptr hold now is on the heap.
  // *p0 is
  std::cout << "stack address p0: " << &(*p0) << std::endl;
  std::cout << "stack address p0.get: " << p0.get() << std::endl;
  assert(&f1 != &(*p0));

  // change value through p0 should not affect f1.

  f1.shift1();
  std::cout << "*p0 after modify p0: " << p0->to_string() << std::endl;
  std::cout << "f1 after modify p0: " << f1.to_string() << std::endl;
  // cleary these two are allocated separately

  // Note: don't use shared ptr over stack allocated obj. doesn't make sense.

  // allocate on the heap.
  SF p1 = std::make_shared<Foo>();
  SF p2 = std::make_shared<Foo>();
  SF p3 = std::make_shared<Foo>();

  // this is quite problematic. if shared ptr is invalid you get a
  // null reference.
  RSF r1 = std::ref(p1);

  p1.reset();

  std::cout << "null referece ?" << r1.get() << std::endl;

  return 0;
}
#include <iostream>
#include <memory>

struct pod_t {
  int a;
  int b;
  int c;
};

int main(void) {

  pod_t *on_heap = new pod_t{1, 2, 3};
  std::cout << "on_heap: " << on_heap << std::endl;
  std::cout << "on_heap: " << on_heap->a << std::endl;

  auto a = std::unique_ptr<pod_t>(new pod_t());
  std::cout << a->a << std::endl;
  std::cout << a->b << std::endl;
  std::cout << a->c << std::endl;

  auto b = std::make_unique<pod_t>(1, 2, 3);
  std::cout << b->a << std::endl;
  std::cout << b->b << std::endl;
  std::cout << b->c << std::endl;
  return 0;
}
#include <iostream>
#include <memory>

struct Int {
  int i;
  Int(int i) : i(i) {}
};

int main(void) {
  auto a = std::make_unique<Int>(1);
  auto b = std::move(a);
  // now a {get(): 0x0}
  auto c = std::make_unique<Int>(*b);
  // now c is a unique ptr with copy of b.

  return 0;
}
#include <iostream>

int foo() {}

int main() {
  int a = foo();
  std::cout << a << std::endl;
}
#include <iostream>
#include <memory>
#include <random>
#include <thread>

int seed_offset = 0;
// get a rference of the pointer
template <typename T> void side_effect_with_ref(T &ptr) { (*ptr)++; }

template <typename T> void side_effect_with_copy(T ptr) { (*ptr)++; }

template <typename T> void side_effect_with_move(T &&ptr) { (*ptr)++; }
// pass the pointer by value directly.
template <typename T> void side_effect_with_ptr(T *ptr) { (*ptr)++; }

template <typename T> void side_effect_with_ref_to_val(T &val) {
  std::mt19937 gen(123 + seed_offset);
  seed_offset++;
  std::uniform_int_distribution<int> dist(0, 100);
  if (dist(gen) % 2 != 0) {
    std::cout << std::this_thread::get_id() << " incrementing.." << std::endl;
    val++;
  } else {
    std::cout << std::this_thread::get_id() << " decrementing.." << std::endl;
    val--;
  }
}

void naive() {
  auto ptr = std::make_unique<int>(10);
  std::cout << "first: " << *ptr << std::endl;
  side_effect_with_ref(ptr);
  side_effect_with_ref_to_val(*ptr);
  side_effect_with_ref_to_val(*ptr);
  side_effect_with_ref_to_val(*ptr);

  std::cout << "second: " << *ptr << std::endl;
}

void pass_unique_ptr() {
  auto ptr = std::make_unique<int>(10);
  std::cout << "first: " << *ptr << std::endl;

  // filthy
  // std::shared_ptr<int> sptr{std::shared_ptr<int>(ptr.get())};
  // side_effect_with_copy(sptr);

  side_effect_with_ptr(ptr.get());

  side_effect_with_move(std::move(ptr));

  std::cout << "ptr after moved: " << *ptr << std::endl;
}

void multiple_writer() {
  auto ptr = std::make_unique<int>(10);
  std::cout << "first: " << *ptr << std::endl;

  auto thread1 = std::thread([&ptr]() {
    std::cout << "from" << std::this_thread::get_id() << std::endl;
    side_effect_with_ref_to_val(*ptr);
  });
  auto thread2 = std::thread([&ptr]() {
    std::cout << "from" << std::this_thread::get_id() << std::endl;
    side_effect_with_ref_to_val(*ptr);
  });
  auto thread3 = std::thread([&ptr]() {
    std::cout << "from" << std::this_thread::get_id() << std::endl;
    side_effect_with_ref_to_val(*ptr);
  });

  thread1.join();
  thread2.join();
  thread3.join();
  std::cout << "ptr second: " << *ptr << std::endl;
}

int main(void) {
  naive();
  std::cout << "===============================" << std::endl;
  pass_unique_ptr();
  std::cout << "===============================" << std::endl;
  multiple_writer();
  std::cout << "===============================" << std::endl;
  return 0;
}
#include <iostream>

// underlying implementation
template <typename T1, typename T2> void func(T1 e1, T2 e2) {
  std::cout << "called" << std::endl;
}

// now we want this function to accept all different references.
// These are all overloads you need to provide
template <typename T1, typename T2> void wrapper(T1 &e1, T2 &e2) {
  func(e1, e2);
}

template <typename T1, typename T2> void wrapper(const T1 &e1, T2 &e2) {
  func(e1, e2);
}

template <typename T1, typename T2> void wrapper(T1 &e1, const T2 &e2) {
  func(e1, e2);
}

template <typename T1, typename T2> void wrapper(const T1 &e1, const T2 &e2) {
  func(e1, e2);
}

template <typename T1, typename T2> void wrapper(T1 &e1, T2 &&e2) {
  func(e1, e2);
}

template <typename T1, typename T2> void wrapper(T1 &&e1, T2 &e2) {
  func(e1, e2);
}

template <typename T1, typename T2> void wrapper(T1 &&e1, T2 &&e2) {
  func(e1, e2);
}

template <typename T1, typename T2> void wrapper(const T1 &e1, T2 &&e2) {
  func(e1, e2);
}

template <typename T1, typename T2> void wrapper(T1 &&e1, const T2 &e2) {
  func(e1, e2);
}

// to solve this problem we use perfect forwarding
// it takes the advantage of reference collapsing
template <typename T1, typename T2> void good_wrapper(T1 &&e1, T2 &&e2) {
  func(std::forward<T1>(e1), std::forward<T2>(e2));
}
#include <iostream>
#include <memory>

template <typename Ptr> struct BlockList {

  struct block;
  using block_ptr_t = typename std::pointer_traits<Ptr>::template rebind<block>;

  struct block {
    size_t size;
    block_ptr_t next_block;
  };

  block_ptr_t free_blocks;
};

int main(void) {
  BlockList<int *> bl1;
  BlockList<std::shared_ptr<char>> bl2;
  return 0;
}
#include <iostream>

struct S {
  int i;
  S(int i) : i(i) {}
};

void f1_rvalref(S &&s) { std::cout << s.i << std::endl; }
void f2_constref(const S &s) { std::cout << s.i << std::endl; }
void f3_ref(S &s) { std::cout << s.i << std::endl; }
void f4_val(S s) { std::cout << s.i << std::endl; }

void pass_lval_to_rval_ref() {
  S s(1);
  // must move other wise you can't pass it.
  f1_rvalref(std::move(s));
}

void pass_temporary_to_const_ref() {
  // the lifetime of the temporary get extended to span the scope

  f2_constref(S(1));
}

void pass_value_to_const_ref() {
  // it wii just take a reference of the value.
  S s(1);
  f2_constref(s);
}

void pass_temporary_to_ref() {
  // reference can't extend the lifetime.
  // must pass lvalue ref
  S s(1);
  f3_ref(s);
}

void pass_ref_to_value() {
  // it will just take the reference.
  S s(1);
  S &sr = s;
  f4_val(sr);
}

// overload to make it works for both nonconst reference and rvalue reference
// take a value, modify it destructively, and then use the value internally.
void f1(int &v) {
  v += 1;
  std::cout << v << std::endl;
}
void f1(int &&v) { return f1(v); }

template <typename T, typename U> void f22(T &t, const U &u) {}
template <typename T, typename U> void f2(T &&t, const U &u) {
  f22(std::forward(t), u);
}

int main(void) {
  int a = 1;
  f1(a);
  f1(1);
  return 0;
}
#include <iostream>

// pass by reference is more efficient then pass by value.
// The reason is very clear, instead of copying the
// argument, you essentially passing in an address.

struct Date {
  short month;
  short day;
  short year;
};

// a const ptr const int
const int *const p1 = nullptr;

// a const ref to int
// ref itself cannot chance, constness act on the value.
const int &p2 = 1;

// an example with rather long body.
// passing by const reference.
// we only need to see the data, and don't need to mutate it.
long get_date_of_year(const Date &date) {
  static int c_days_in_month[] = {31, 28, 31, 30, 31, 30,
                                  31, 31, 30, 31, 30, 31};
  long date_of_year = 0;

  for (int i = 0; i < date.month - 1; ++i) {
    date_of_year += c_days_in_month[i];
  }

  if (date.month > 2 &&
      ((date.year % 100 != 0 || date.year % 400 == 0) && date.year % 4 == 0)) {
    date_of_year++;
  }

  date_of_year *= 10000;
  date_of_year += date.year;
  return date_of_year;
}

// function can also be declared to return a reference type.
// Reasons to do so:
//  1. return value is large enough, ref is faster then copy
//  2. the type of the function must be a rval
//      e.g method overload, method must evaluate to a lvalue.
//  3. the referred to object will not go out of scope after return.

class Point {
public:
  // accessor functions as reference type.
  // You can return refrence because referred-to values are
  // not out of scope when the fucntion return,
  // they are still in the object.
  unsigned &x();
  unsigned &y();

  // declared at class scope
  unsigned obj_x;
  unsigned obj_y;
};

unsigned &Point::x() { return obj_x; }

unsigned &Point::y() { return obj_y; }

int main(void) {
  Date date{11, 25, 2020};
  std::cout << get_date_of_year(date) << std::endl;

  Point point;

  // returned a lval ref, you can assign to it.
  // Notice at this point value obj_x and obj_y are still
  // hold in the object point, and point is not out of scope
  // yet. That's why you can return a reference and be ok with it.
  point.x() = 10;
  point.y() = 20;

  std::cout << point.x() << " " << point.y() << std::endl;

  return 0;
}

// this is bad, a get destroyed after return,
// and you get the same problem as return a point to
// local variable.
volatile long &bad_return() {
  long a = 100;
  return a;
}
#include <iostream>

int main(void) {

  int i, j, *p;

  // 7 is a prvalue, assigned to lvalue.
  i = 7;

  // 7 = i invalid. Left operant must be a lvalue.

  // dereferenced pointer is a lvalue.
  *p = i;

  // the expression return an lvalue.
  ((i < j) ? i : j) = 7;

  // you cannot bind temporary object to a
  // non const lvalue refernce

  return 0;
}

// lvalue reference &
// holds the address of an object but behaves syntatically like an object.
// char & name;
//
// lvalue reference is the actually reference we talk about normally.
// lvalue reference can be thought as an alias of an object.
//
// a reference must be initialized! and the reference cannot be changed.


// rvalue reference &&
// concepts related to rvalue references: move semantics, perfect forwarding.
//
// We say rvalue reference support move semantics. What does that mean is
// if you have a rvalue reference, it refers to a temporary value. By knowing
// that we can move it to any lvalue reference directly without copy it.
//
// To implement move semantics you implement the move constructor.
// The compiler will invoke the constructor when it's appropriate.
//
//



/////////////////////////////////////////////
// explanation of why c++ added reference. //
/////////////////////////////////////////////
// Why reference are good?
// https://www.quora.com/Why-were-references-introduced-to-C++-when-we-already-had-pointers
//
// Imagine you are in c. Here you made a struct A, and a function return the
// struct.
struct A {
  int a;
};

struct A f() {
  A a = {1};
  return a;
};
// Your compiler knows it needs to return the value by copy.
// and because it's just a simple struct, copy is easy, just
// memcpy the memory to the new location.

// But here, imagine you have a c++ class.

class Foo {
  int a;
};

Foo g() {
  Foo a;
  return a;
}

// Looks similar, but c++ has constructors.
//
// Even if you don't declare anything, g++ will still create
// default copy constructor and move constructor for you.
// So the empty class has at least two hidden methods.
//
// a get returned, compiler know we want to copy this value.
// And to copy it we need to call a copy constructor implicitly.
// The compiler now need to find a way to pass this object
// into the copy constructor.
//
// To do that, we can't pass by value, because that will invoke another
// copy...
//
// So how about a pointer though?
// If we pass a pointer instead, the meaning of current syntax will be different.
// We say we want to return by value, but we really returned a pointer to
// the copy constructor.
//
// If we introduce reference, which merely another name for a variable it's
// possible that while we return a by value, we return the reference of
// it without invoke the copy constructor.
//
//



// compiler created constructors.
//
// There are three types of constructors the compiler can create for us:
//  1. copy constructor       A(const A&)
//  2. move constructor       A(A &&)
//  3. default constructor    A()
//
// * The body of default constructor created is empty;
//    Rationale:
//      If you don't specify anything, it just works like a c struct.
//      The memory get allocated and non initialized.
//
// * The body of default copy constructor copy all data members of one object to another.
//    Rationale
//      That's what a copy means.
//      In c++ all copy constructors should mean actual deep copy.
//      Shallow copy in other languages is just copy pointers.
//
// * As long as you declare any other constructor, there will be no default constructor
//    Rationale:
//      If you already defined some costructors, for most of the time you want to take
//      over the control of object creation. In that sense a copy constructor will be
//      an extra trouble.
//
// * Compiler create default and copy constructor if they are not explicitly defined.
//    Rationale:
//       When nothing is defined, just consider how do you make it behaves as close
//       as possible to a C struct.
//       You can declare a struct without initialize it, default constructor takes care of that.
//       You can copy a struct, and you have default copy constructors.
//
// * Move constructors will be generated iff there is no user declared copy, move, and destructor.
//    Rationale:
//       Notice if you declared a copy constructor, there will be no move constructor declared for you.
#include <iostream>

// for some api, we can't access the underlying opqaue data, to
// manipulate certain data we need to reinterpret our struct to fit with the
// api.

typedef struct Opaque_ *VendorGlobalUserData;
void VendorSetUserData(VendorGlobalUserData);
VendorGlobalUserData VendorGetUserData();

struct MyUserData {
  int m;
  MyUserData() : m(42) {}
};

int main(void) {

  // set global data
  MyUserData d;
  VendorSetUserData(reinterpret_cast<VendorGlobalUserData>(&d));

  // get global data.
  VendorGlobalUserData d1 = VendorGetUserData();
  MyUserData *p = nullptr;
  p = reinterpret_cast<MyUserData *>(d1);

  if (p) {
    std::cout << p->m << std::endl;
  }
  return 0;
}
#include <iostream>
#include <memory>

// get a rference of the pointer
template <typename T> void side_effect_with_ref(T &ptr) { (*ptr)++; }

// pass the pointer by value directly.
template <typename T> void side_effect_with_ptr(T *ptr) { (*ptr)++; }

int main(void) {
  auto ptr = std::make_unique<int>(10);
  std::cout << "first: " << *ptr << std::endl;
  side_effect_with_ref(ptr);
  side_effect_with_ptr(ptr.get());

  std::cout << "second: " << *ptr << std::endl;

  return 0;
}
#include <iostream>
#include <memory>
#include <vector>

// First makes some class with a hierchy.
// This will be allocated on the heap.
class Investment {

public:
  // virutal destructor for derived classes.
  virtual ~Investment() {}

  // avoid slicing
  Investment() = default;
  Investment(const Investment &) = delete;
  Investment &operator=(const Investment &) = delete;

  // define some interfaces.
  virtual size_t amount() const = 0;
};

class Stock : public Investment {

public:
  size_t value = 1000;
  size_t span = 1000;

  Stock(size_t val, size_t duration) : value(val) {}
  size_t amount() const override { return value; }
};

class Bond : public Investment {
public:
  size_t value = 1000;
  Bond(size_t &val) : value(val) {}
  size_t amount() const override { return value; }
};

class RealEstate : public Investment {

public:
  size_t value = 1000000;

  RealEstate(size_t &val) : value(val) {}
  size_t amount() const override { return value; }
};

enum class MakeWhatInvestment { MakeBond, MakeStock, MakeRealEstate };

// you return the unique pointer of Investment, indicates you transfer the
// ownership of the underlying resouce to the caller.
template <typename... Ts>
std::unique_ptr<Investment> make_investment(MakeWhatInvestment m,
                                            Ts &&... params) {
  // custom destructor for unique pointers.
  auto del = [](Investment *p) {
    std::cout << "die" << std::endl;
    delete p;
  };

  std::unique_ptr<Investment, decltype(del)> p(nullptr, del);
  p.reset(new Stock(1, 10));
  return std::make_unique<Stock>(1, 10);
}

void investment_balckhold(std::unique_ptr<Investment> p){
    // take away your investment.
};

void investment_balckhold_uref(std::unique_ptr<Investment> &&p) {}

int run_unique(void) {

  // now p_investment owns the unverlying Investment.
  auto p_investment =
      make_investment(MakeWhatInvestment::MakeBond, 10, 20, "asd",
                      std::string("ssd"), std::vector<int>{1, 2, 3});

  // this is not allowed because passing by value will copy the unique_ptr,
  // but the coopy constructor of a unique ptr is deleted.
  // investment_balckhold(p_investment);

  // this is ok. p_investment now it nullptr
  // and the ownership is transferred into investment_balckhold.
  // because it's am empty function, one the execution hit out of the scope,
  // the investment will be destroyed.
  investment_balckhold(std::move(p_investment));

  // here we create a new uique pointer and transfer the ownership to
  // p_investment again.
  p_investment = make_investment(MakeWhatInvestment::MakeStock, 10, 20, "asd",
                                 std::string("ssd"), std::vector<int>{1, 2, 3});

  // you still need to convert to to rvale.
  // universal reference doesnt take by value.
  investment_balckhold_uref(std::move(p_investment));

  return 0;
}
#include <iostream>
#include <memory>

// weak_ptr is used with the shared ptr. It doesn't increase the
// reference count, but it will still allow you to access the underlying
// resource.

std::weak_ptr<int> gw;

void observe() {
  std::cout << "use_count == " << gw.use_count() << std::endl;
  // has to be copied into a shared ptr to use.
  // this ensure while using the weak ref the underlying resource still
  // has at least one ref count and wont get free during usage.
  if (auto spt = gw.lock()) {
    std::cout << *spt << std::endl;
  }

  else {
    std::cout << "gw is expired" << std::endl;
  }
}

static_assert(sizeof(std::shared_ptr<int>) == 16);
static_assert(sizeof(std::weak_ptr<int>) == 16);

int main(void) {
  {
    auto sp = std::make_shared<int>(52);

    // copy to a weak ref.
    gw = sp;
    observe();
  }
  observe();

  return 0;
}
#include <algorithm>
#include <iostream>
#include <type_traits>
#include <vector>

template <unsigned int Digits> struct Entry {
  std::string name;
  unsigned int number[Digits];
};

std::vector<Entry<6>> phone_book1{
    {"Jimmy", {5, 6, 7, 1, 2, 3}}, {"Giles", {1, 2, 3, 4, 5, 6}},
    {"Lucas", {5, 6, 7, 1, 2, 3}}, {"Giles", {1, 2, 3, 4, 5, 6}},
    {"Giles", {1, 2, 3, 4, 5, 6}}, {"Bob", {5, 6, 7, 1, 2, 3}},
};


std::vector<Entry<6>> phone_book2{
    {"Bob", {5, 6, 7, 1, 2, 3}},
    {"Rick", {5, 6, 7, 1, 2, 3}},
    {"MM", {1, 2, 3, 4, 5, 6}},
    {"MM", {1, 2, 3, 4, 5, 6}},
};

template <typename T, typename Comp>
std::vector<T> make_set(std::vector<T> &xs, std::vector<T> &ys, Comp cmp) {
  std::vector<T> vs;
  std::unique_copy(xs.begin(), xs.end(), std::back_inserter(vs), cmp);
  std::unique_copy(ys.begin(), ys.end(), std::back_inserter(vs), cmp);
  std::sort(vs.begin(), vs.end(), cmp);
  return vs;
}

int main(void) {

  std::pointer_traits<std::vector<int>::iterator>::pointer a;

  phone_book1.erase(std::remove_if(phone_book1.begin(), phone_book1.end(),
                                   [](auto n) { return n.name == "Giles"; }),
                    phone_book1.end());
  for (auto n : phone_book1) {
    std::cout << n.name << "\n";
  }
  std::cout << "size: " << phone_book1.size() << std::endl;
  return 0;
}
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>

int main(void) {

  {
    std::cout << "[upper bound test 1]" << std::endl;
    std::cout << "data: 1, 3, 7, 7, 9, 10" << std::endl;
    std::vector<int> v{1, 3, 7, 7, 9, 10};
    // found
    auto it = std::upper_bound(v.begin(), v.end(), 8);
    std::cout << "looking for 8" << std::endl;
    if (it == v.end()) {
      std::cout << " |- END" << std::endl;
    } else {
      std::cout << " |- Not END, value is: " << *it << std::endl;
      std::cout << "  |- value of it - 1 is:  " << *(it - 1) << std::endl;
    }

    it = std::upper_bound(v.begin(), v.end(), 12);
    std::cout << "looking for 12" << std::endl;
    if (it == v.end()) {
      std::cout << " |- END" << std::endl;
    } else {
      std::cout << " |- Not END, value is: " << *it << std::endl;
    }
  }
  std::cout << std::endl;

  {
    std::cout << "[lower bound test 2]" << std::endl;
    std::cout << "data: 1, 3, 7, 7, 9, 10" << std::endl;
    std::vector<int> v{1, 3, 7, 7, 9, 10};
    // found
    auto it = std::lower_bound(v.begin(), v.end(), 8);
    std::cout << "looking for 8" << std::endl;
    if (it == v.end()) {
      std::cout << " |- END" << std::endl;
    } else {
      std::cout << " |- Not END, value is: " << *it << std::endl;
      std::cout << "  |- value of it - 1 is:  " << *(it - 1) << std::endl;
    }

    it = std::lower_bound(v.begin(), v.end(), 12);
    std::cout << "looking for 12" << std::endl;
    if (it == v.end()) {
      std::cout << " |- END" << std::endl;
    } else {
      std::cout << " |- Not END, value is: " << *it << std::endl;
    }
  }

  return 0;
}
#include <iostream>
#include <vector>
void print_vec(const std::vector<int> &);

void mk_string() {
  // normal
  std::string s1;
  std::string s2{"str"};
  std::string s3{s2};
  std::string s4 = s3;

  // ptr
  const uint8_t *arrs = new uint8_t(4);
  const_cast<uint8_t *>(arrs)[0] = 'a';
  const_cast<uint8_t *>(arrs)[1] = 'b';
  const_cast<uint8_t *>(arrs)[2] = 'c';
  const_cast<uint8_t *>(arrs)[3] = 'z';

  const char *se = reinterpret_cast<const char *>(arrs);
  std::string s5{se, 5};

  // fill
  std::string s6{10, 'a'};

  // iter
  std::vector<char> v{'a', 'z'};
  std::string s7{v.begin(), v.end()};

  std::cout << s1 << "\n"
            << s2 << "\n"
            << s3 << "\n"
            << s4 << "\n"
            << s5 << "\n"
            << s6 << "\n"
            << s7 << "\n"
            << std::endl;
}

void mk_vec() {
  std::vector<int> v1;

  // init list
  std::vector<int> v2{1, 2, 3, 4};

  // fill
  // note it needs to use bracket.
  std::vector<int> v3(10, 99);

  // range
  std::vector<int> v4{v3.begin(), v3.begin() + 3};

  print_vec(v1);
  print_vec(v2);
  print_vec(v3);
  print_vec(v4);
}

void print_vec(const std::vector<int> &v) {
  for (auto i : v) {
    std::cout << i << ", ";
  }
  std::cout << "\n" << std::endl;
}

int main() {
  mk_string();
  mk_vec();
}
#include <algorithm>
#include <array>
#include <iostream>
#include <list>
#include <map>
#include <memory>
#include <string>
#include <unordered_map>
#include <vector>

class Shape {
public:
  virtual ~Shape() = default;
  virtual size_t size() const = 0;
};

class Circle : public Shape {
public:
  size_t size() const override { return 10; }
};

template <unsigned int Digits> struct Entry {
  std::string name;
  unsigned int number[Digits];
};

std::vector<Entry<6>> phone_book{
    {"Jimmy", {5, 6, 7, 1, 2, 3}},
    {"Lucas", {5, 6, 7, 1, 2, 3}},
    {"Giles", {1, 2, 3, 4, 5, 6}},
};

// if you have polymorphis types, store poitners
// rather than type themselves, otherwise you will have
// slicing problems.
// !!!!
// This doesn't work because we are calling the vector's
// constructor with an initializer list,
// and an inisitalizer list only allows const access to it's elements,
// so the vector must copy it's elements.
// std::vector<std::unique_ptr<Shape>> shapes{
//   std::move(std::make_unique<Circle>()),
//   std::move(std::make_unique<Circle>()),
//   std::move(std::make_unique<Circle>()),
// };

std::vector<std::unique_ptr<Shape>> shapes = []() {
  std::vector<std::unique_ptr<Shape>> v;
  v.push_back(std::make_unique<Circle>());
  v.push_back(std::unique_ptr<Circle>(new Circle()));
  v.push_back(std::make_unique<Circle>());
  v.push_back(std::make_unique<Circle>());
  return v;
}();

// why one might want to use a red black tree instead of a
// hash map though?
// Hash table gives you O(1) looks up anyway.
// Hashtable doesn't preserve order. This only can evict a lot of
// use cases for hashtables.
// Apparently hashtable's performance is not very stable.
// Whenever there is a resize, the perfoamce plumment suddenly.
// Hash table also has poor locality, since data scattered around.
// If you consider putting things into a cacheline, hashtable might
// behave very bad.
std::map<std::string, std::array<int, 6>> phonebook_rbt{
    {"Jimmy", {1, 1, 1, 1, 1, 1}},
    {"Sam", {1, 1, 1, 1, 1, 1}},
    {"Lil", {1, 1, 1, 1, 1, 1}},
};

int main(void) {
  // set phonebook with a constant size.
  phone_book.reserve(30);
  phone_book.push_back({"Jimmy", {1, 2, 3, 4, 1, 2}});

  // handle the out of range exception.
  {
    int index = 1;
    try {
      std::cout << "shapes has size: " << shapes.size() << std::endl;

      auto v = std::move(shapes.at(3));
      std::cout << (v->size()) << std::endl;

    } catch (std::out_of_range e) {
      std::cout << e.what() << std::endl;
    }
  }

  {
    // the first element of shapes get moved out.
    auto c = std::move(shapes.at(0));
    std::cout << "shapes[0] moved out" << (shapes[0] == nullptr) << std::endl;
  }

  {
    // shapes1 is the new onwer of vectors hold by shape.
    decltype(shapes) shapes1{std::move(shapes)};

    // from this point onwards shapes is nullptr.
    std::cout << "shapes1[0] moved out" << (shapes1[0] == nullptr) << std::endl;
  }

  // here shapes is nolonger validd, but somehow you can still access it. jee.

  return 0;
}
#include <iostream>

void check_static() {
  static int a = 23;
  a++;
  std::cout << a << std::endl;
}

int main(void)
{
  check_static();
  check_static();
  check_static();
  check_static();

  return 0;
}
#include <iostream>

template <typename T> struct Maybe {
  T value;
  bool nothing;

public:
  Maybe(const T &v) : value(v) {}
  Maybe() : nothing(true) {}
};

template <template <typename> typename F> struct Functor {};

template <> struct Functor<Maybe> {
  template <typename A, typename TF>
  static Maybe<typename std::result_of<TF(A)>::type> fmap(const Maybe<A> &x,
                                                          TF func) {
    using Result = typename std::result_of<TF(A)>::type;
    if (x.nothing)
      return Maybe<Result>();
    else
      return Maybe<Result>(func(x.value));
  }
};

template <template <typename> typename H, typename S>
void f(const H<S> &value) {}

template <template <typename, typename> typename V, typename A, typename B>
void g(const V<A, B>);
#include <iostream>
#include <vector>

int main(void) {
  std::initializer_list<int> l{

#include "x.inc"

  };
  auto iter = l.begin();
  std::cout << sizeof(l) << std::endl;

  for (auto v : l) {
    std::cout << v << std::endl;
  }

  return 0;
}
#include <fstream>



int main(void)
{
  std::ifstream ifs("file.txt");

  return 0;
}
#include <string>
#include <unordered_map>
#include <iostream>
#include <vector>

struct Good {
  std::vector<int> vood;
};

int main(void) {
  std::vector<std::tuple<std::string, Good>> vs{{"1", Good{}}, {"2", Good{}}};
  std::unordered_map<std::string, Good> m;

  for (auto &[k, v] : vs) {
    m.emplace(k, v);
  }

  std::cout << m.bucket_count() << std::endl;
  std::cout << m.max_load_factor() << std::endl;

  return 0;
}
#include <iostream>
#include <memory>

int main(void) {

  // default allocator used for all stl containers.
  // default allocator is stateless, instance given to
  // the allocator are interchangable.
  std::allocator<int> a1;

  int *a = a1.allocate(1); // allocate 1 on heap
  a1.deallocate(a, 1);     // free

  // default allocator for string
  std::allocator<std::string> a2;
  // still default allocator for string
  // rebind int to string.
  decltype(a1)::rebind<std::string>::other a2_1;

  // still the same
  std::allocator_traits<decltype(a1)>::rebind_alloc<std::string> a2_2;

  return 0;
}
#include <algorithm>
#include <functional>
#include <iostream>
#include <list>
#include <numeric>
#include <random>
#include <string>
#include <type_traits>
#include <vector>

// accumulate
template <typename InputIt, typename T>
constexpr T my_accumulate(InputIt first, InputIt last, T init) {
  for (; first != last; ++first) {
    init = std::move(init) + *first;
  }
  return init;
}

template <typename InputIt, typename T, typename BinaryOperator>
constexpr T my_accumulate(InputIt first, InputIt last, T init,
                          BinaryOperator op) {
  for (; first != last; ++first) {
    init = op(std::move(init), *first);
  }
  return init;
}

// c++ folds use accumulate
// there is no difference between foldl' and foldr since
// everything is eager.
// default is foldl, and to foldr, just fold on the reverse
// iterator.
// There will be no performance panelty since it's just two
// pointers.
void folds() {
  std::cout << "folds" << std::endl;
  std::vector<int> vec{1, 2, 3};

  auto result =
      std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>());
  std::cout << result << std::endl;

  // default use +
  auto sum = std::accumulate(vec.begin(), vec.end(), 0);

  auto dash_fold = [](std::string a, int b) {
    return std::move(a) + '-' + std::to_string(b);
  };

  // lfold
  std::string s = std::accumulate(std::next(vec.begin()), vec.end(),
                                  std::to_string(vec[0]), dash_fold);

  // rfold
  std::string rs = std::accumulate(std::next(vec.rbegin()), vec.rend(),
                                   std::to_string(vec.back()), dash_fold);

  std::cout << s << std::endl;
  std::cout << rs << std::endl;
}

// partial sum
template <typename InputIt, typename OutputIt>
constexpr OutputIt my_partial_sum(InputIt first, InputIt last,
                                  OutputIt d_first) {
  if (first == last)
    return d_first;

  typename std::iterator_traits<InputIt>::value_type sum = *first;
  *d_first = sum;

  while (++first != last) {
    sum = std::move(sum) + *first;
    *++d_first = sum;
  }
  return ++d_first;
}

template <typename InputIt, typename OutputIt, typename BinaryOperator>
constexpr OutputIt my_partial_sum(InputIt first, InputIt last, OutputIt d_first,
                                  BinaryOperator op) {
  if (first == last)
    return d_first;

  typename std::iterator_traits<InputIt>::value_type sum = *first;
  *d_first = sum;

  while (++first != last) {
    sum = op(std::move(sum), *first);
    *++d_first = sum;
  }

  return ++d_first;
}

void partial_sum() {
  std::cout << "partial_sum" << std::endl;
  std::vector<int> vec{2, 2, 2, 2};
  std::partial_sum(vec.begin(), vec.end(), vec.begin());
  std::cout << "partial sum:" << std::endl;
  for (auto v : vec) {
    std::cout << v << std::endl;
  }
}

void iota() {
  // use iota to shuffle a list
  std::list<int> l(10);
  std::iota(l.begin(), l.end(), -4);

  // a vector of list elements iterators.
  std::vector<decltype(l)::iterator> v(l.size());
  std::iota(v.begin(), v.end(), l.begin());

  std::random_shuffle(v.begin(), v.end());

  std::cout << "Content of the og list: " << std::endl;
  for (auto n : l) {
    std::cout << n << " ";
  }
  std::cout << "\n";

  std::cout << "Content of the shuffled list: " << std::endl;
  for (auto n : v) {
    std::cout << *n << " ";
  }
  std::cout << "\n";
}

int main(void) {
  folds();
  partial_sum();
  iota();
  return 0;
}
#include <iostream>
#include <optional>

template <typename T> int foo(std::optional<T> v) { return v.value_or(-1); }

std::optional<int> bar(bool a) {
  if (a) {
    return 1;
  }
  return std::nullopt;
}

template <typename T> constexpr T optchain_(std::optional<T> t) {
  return t.value();
}

template <typename T, typename... Args>
constexpr T optchain_(std::optional<T> t, Args... args) {
  return t.value_or(optchain_(args...));
}

template <typename... Args>
auto optchain(Args... args) -> std::optional<decltype(optchain_(args...))> {
  try {
    auto v = optchain_(args...);
    return v;
  } catch (std::bad_optional_access) {
    return {};
  }
}

void test_optchain() {
  std::cout << "optional chaining" << std::endl;

  auto a = optchain(bar(false), bar(false), std::optional<int>(2),
                    std::optional<int>(3));

  std::cout << a.value() << std::endl;
}

/* template <typename R, typename... Args> */
/* auto optional_chaining(R r, Args... args) { */
/*   return r.value_or(optional_chaining(args...)); */
/* } */

int main(void) {
  auto x = std::optional<int>{1};

  if (auto p = bar(false)) {
    std::cout << p.value() << std::endl;
  } else {
    std::cout << "no nullopt" << std::endl;
  }

  if (auto a = bar(true)) {
    std::cout << a.value() << std::endl;
  } else {
    std::cout << "no val" << std::endl;
  }

  test_optchain();

  return 0;
}
#include <iostream>
#include <queue>
#include <vector>

#define PRINT(pq, v)                                                               \
  for (auto &n : v) {                                                          \
    auto e = pq.top();                                                         \
    std::cout << e << " ";                                                     \
    pq.pop();                                                                  \
  }                                                                            \
  std::cout << std::endl;

template <typename T> struct comp {
  bool operator()(T a, T b) { return a < b; }
};

void con1() {
  std::priority_queue<int, std::vector<int>, comp<int>> pq;

  std::vector<int> v{5, 3, 1, 6, 4, 8, 2};
  for (auto &n : v) {
    pq.push(n);
  }
  PRINT(pq, v);
}

void con2() {
  std::vector<int> v{5, 3, 1, 6, 4, 8, 2};
  auto cp = [](auto a, auto b) { return a < b; };
  std::priority_queue<int, std::vector<int>, decltype(cp)> pq(cp);
  std::cout << "1" << std::endl;
  for (auto &n : v) {
    pq.push(n);
  }
  PRINT(pq, v);
}

int main(void) {
  con1();
  con2();
  return 0;
}
#include <algorithm>
#include <iostream>
#include <iterator>
#include <vector>

template <typename T>
std::vector<int>::iterator current(std::reverse_iterator<T> ri) {
  return (ri).base();
}

// notice base iterator points one after the reverse iterator.
// when converting back,
// (p.rbegin()+1).base == p.end(),
// (p.rend()).base == p.begin
int main(void) {
  int i[] = {1, 2, 3, 4};
  std::vector<int> nums(i, i + 4);

  auto reverse_iter_1 = std::make_reverse_iterator(nums.begin());
  auto reverse_iter = std::make_reverse_iterator(nums.end());

  auto forward_iter = current(reverse_iter_1);

  std::cout << *nums.begin() << std::endl;
  std::cout << *nums.rbegin() << std::endl;
  std::cout << *(nums.rbegin() + 1).base() << std::endl;

  std::cout << "--" << std::endl;
  std::cout << *nums.end() << std::endl;
  std::cout << *(nums.end() - 1) << std::endl;

  // call a.rbegin().base will get on after
  // what current reverse iter points to.
  // x     _     _      _      _  reverse
  //
  //       ^
  //     rend+1
  //
  // _     _     _      _       x  base
  // ^
  // begin
  // which is rend + 1
  std::cout << *(nums.rend() - 1) << std::endl;

  std::cout << *(nums.rend() + 1).base() << std::endl;

  std::cout << "index with reverse iterator" << std::endl;
  auto riter = nums.rbegin();
  riter++;
  riter++; // iter in i[1]
  std::cout << nums.size() - 1 - (riter - nums.rbegin()) << std::endl;

  std::cout << "--" << std::endl;
  std::for_each_n(nums.begin(), 4, [](int n) { std::cout << n << " "; });

  std::cout << "--" << std::endl;
  std::for_each_n(reverse_iter, 4, [](int n) { std::cout << n << " "; });

  std::cout << "--" << std::endl;
  std::for_each_n(forward_iter, 4, [](int n) { std::cout << n << " "; });

  return 0;
}
#include <iostream>
#include <set>
#include <cassert>
#include <vector>

int main(void) {
  std::set<int> ins{1, 2, 3};
  std::set<int> nono{};
  std::vector<std::set<int>> vsnono;

  std::cout << nono.empty() << std::endl;
  std::cout << (ins.find(1) == ins.end()) << std::endl;

  for (int i = 0; i < vsnono.size(); ++ i) {
    assert(vsnono[i].empty());
  }

  return 0;
}
// You have all this stream headers.
// io in general
#include <iomanip>
#include <iostream>

// involve file system
#include <fstream>

// lower level, iostream based on this
#include <ios>

#include <iosfwd>
#include <istream>
#include <ostream>

// iostream operations in an allocated array object.
#include <sstream>
#include <streambuf>
#include <strstream>

#include <memory>
// what stream is
// While you're programming, streams can just be viewed as
// the source and destination of your data.The underlying
// implementation makes sure all resource is handled properly.
// Stream can be abstract, it's not necessary for a stream
// takes input from keyboards, it can also be a printer, a
// camera, or anything else.

void construct_outputstreams() {
  // ostream is a destination for bytes.
  // three most used output stream classes:
  // ostream, ofstream, ostringstream.

  // stream on the stack.
  std::ofstream file;
  file.open("file.txt");
  file.close();   //.this must be closed explicilty

  // make ostream on the heap
  // heere we are creating our own deleter.
  auto del = [](std::ofstream *os) {
    std::cout << "I'm closed" << std::endl;
    os->close();
    delete os;
  };

  std::unique_ptr<std::ofstream, decltype(del)> pfile(nullptr, del);
  pfile.reset(new std::ofstream());
  pfile->open("file.txt");

}

void format() {
  std::ios state(nullptr);

  std::cout << "The anser in decimal is: " << 42 << std::endl;
  // save current format
  state.copyfmt(std::cout);

  // load up some new formatting modifier
  std::cout << "In hex: 0x" << std::hex // change to hex
            << std::uppercase           // to upper case
            << std::setw(8)             // set width
            << std::setfill('0')        // set fill
            << 42 << std::endl;

  // restore the format state.
  std::cout.copyfmt(state);
}

int main(void) {
  // format();
  construct_outputstreams();
  return 0;
}
#include <iostream>
#include <string>
#include <string_view>

void weird() {
  constexpr std::string_view unicode[]{"▀▄─", "▄▀─", "▀─▄", "▄─▀"};
  for (int y{}, p{}; y != 20; ++y, p = ((p + 1) % 4)) {
    for (int x{}; x != 16; ++x) {
      std::cout << unicode[p];
    }
    std::cout << "\n";
  }
}

int main(void) {
  std::string s = "this is a long string";

  std::string_view sv{s};
  std::cout << sv.size() << std::endl;

  weird();
  return 0;
}
#!/usr/bin/bash

# print header information
g++ hello.h
g++ -H main.cc -o a


#pragma once
#include <iostream>

template <size_t N> struct fib {
  const static size_t value = fib<N - 1>::value + fib<N - 2>::value;
};
template <> struct fib<1> { const static size_t value = 1; };
template <> struct fib<0> { const static size_t value = 1; };

template <typename T> void say(T t) {
  auto value =
      fib<900>::value + fib<900>::value + fib<900>::value + fib<900>::value;
  std::cout << value << std::endl;
  std::cout << "  " << t << std::endl;
}

#pragma once

#include "hello.h"

int main(void) {
  say("hello");
  return 0;
}
#include <iostream>

struct S {
  int i;
  constexpr S(int i) : i(i) {}
};


int main(void)
{
  constexpr S s(1);

  return 0;
}
#include <functional>
#include <iostream>
#include <type_traits>

template <typename Fn, typename = std::enable_if_t<std::is_convertible<
                           Fn, std::function<int(int)>>::value>>
void template_fn(Fn fn) {
  auto i = fn(1);
  std::cout << "succeed: " << i << std::endl;
}

struct nil {};
template <typename...> struct head;
template <typename T, typename... Ts> struct head<T, Ts...> { using type = T; };
template <> struct head<> { using type = nil; };

head<>::type;

int main(void) {

  auto fn1 = [](int a) { return a + 1; };

  std::cout
      << std::is_convertible<decltype(fn1), std::function<int(int)>>::value
      << std::endl;

  std::cout << std::is_convertible<decltype(fn1), int>::value << std::endl;

  template_fn(fn1);

  return 0;
}
#include <iostream>

// what does decay do? //
// Do array decay convertion even when it's passed as reference.
//
// YOU WANT ARRAY DECAY TO POINTER FOR TEMPLATES.

// first note array is not of pointer type, it has it's own type.
// char[4] vs char *.
// You still have c aray decay to pointer, but technically they are different.
//
// Similar situation for a reference to a funcition. you can use a function
// pointer to repace it but they are of different types.
//
// decay<T> is a idenityt mapping except for array types and function types.
// It gives type liek this.
//   decay<char[4]>::type = char *
//   decay<&fn>::type = void(*fn)()

// First see a motivational example //

template <typename T> struct Identity { using type = T; };

template <typename T> T f1(T buff);
template <typename T> Identity<T> f2(T &buff);
void test() {
  const char buf[3] = {0, 0};

  auto x = f1(buf); // pass by value, array get decayed to a pointer.
  auto y = f2(buf); // pass by reference, array is still array.
}

// Why this happens?
// It's from c's heiritage, array cannot be passed by value as a function
// parameter. all arrays passed by value decayed into pointers.
//
// case by case analysis:
//  for f1:
//    buf is of type const char buf[3];
//    buf get pass to T x, by value.
//    compile sees it can't be passed by value becaues it's array type.
//    compile decay it into const char* to fit in.
//
//  for f2:
//    buf is of type const char buf[3];
//    buf pass to T& x as a reference.
//    compile pass the array type as int (&buf)[3].
//
// This also demonstrates that a reference type is really different type from
// the original type.

// now see the standard example:

const char arr[3] = {0, 0};
// this function works for most types.
template <typename T1, typename T2>
inline std::pair<T1, T2> makepair1(T1 x, T2 y) {
  return std::pair<T2, T2>(x, y);
}

// but this one is problematic as if you pass an array type, it will decay //
// if array type const char[3] is T1, it will
// have type return std::pair<const char[3], int>
// you can't construct std::pair<std::string, int>, thus it's ill formed.
template <class T1, class T2>
inline std::pair<T1, T2> make_pair2(T1 &x, T2 &y) {
  return std::pair<T1, T2>(x, y);
}

// this doesn't work. //
// It's because "a" we passed is of type char array and it doesn't decay because
// it's passed by reference.
// auto a1 = make_pair2<std::string, int>(arr, 1);

// What about just settle with the by value version?
// really? copy all the time?

// solution //
// attempt 1. use prefect forwarding
// Why this helps?
template <typename T1, typename T2>
inline std::pair<T1, T2> make_pair3(T1 &&x1, T2 &&x2) {
  return std::pair<T1, T2>(std::forward<T1>(x1), std::forward<T2>(x2));
}

auto a2 = make_pair3<std::string, int>(arr, 1); // no problem.

// with decay //
// finally we get decay. decay force to decay an array type to pointer.
template <typename T1, typename T2>
inline std::pair<std::decay_t<T1>, std::decay_t<T2>> make_pair4(T1 &&x,
                                                                T2 &&y) {
  return std::pair<std::decay_t<T1>, std::decay_t<T2>>(std::forward<T1>(x),
                                                       std::forward<T2>(y));
}
auto a3 = make_pair4<std::string, int>(arr, 1); // no problem.
#include <iostream>
#include <iterator>
#include <vector>

// Deduction guide for CONSTRUCTOR.
// Conclusion
// 1. constrain deduction of type parameters.
// 2. if some deduction guides are provided and non are satisfied,
//    type deduciton guide will failed.
// 3. use type_trait + type deduction we can constraint what type a type parameter
//    get deduced to without writing sfinae.

// now we defeind this template, but it's hard to deduce the type of Iter
// in the second constructor.
template <typename T> struct Container {
  Container(T t) {}

  template <typename Iter> Container(Iter beg, Iter end);
};

// we can write our own deduction guide.
// the guide works on the constructor...
template <typename Iter>
Container(Iter beg, Iter end)
    -> Container<typename std::iterator_traits<Iter>::value_type>;

// deduction guide for the first constructor.
// with this guide, no matter what number type are used, the container will
// deduce to Container<float> ...
#define EVERTHING_FLOAT
#ifdef EVERTHING_FLOAT
template <typename T> Container(T t) -> Container<float>;
#endif

Container c(7); // use implicit generate guide for consructor 1.

#ifdef EVERTHING_FLOAT
// this works because not type deduction invovles.
Container<std::vector<int>> k(std::vector<int>{});

// This doesn't work, because based on our deduciton guide it should be deduced
// to Container<float>, but there is no way to convert vector<int> to float.
// uncomment this will throw an error.

// Container k1(std::vector<int>{});
#endif

// this uses the deduction guide we provided above.
std::vector<char> v{};
auto d = Container(v.begin(), v.end());

// another nice thing is with the deduction guide, the second constructor only
// accept iterator now. Other types will fail by sfinae.
// this will fail
// Container e{1, 2};
#include <iostream>

// Conlusion:
// 1. explicit will change the behavior of type deduction.
// 2. when there is explcit constructor, the constructor will not
//    invovle in the copy init resolution
//   side note:
//      1. constructor is also overloaded, and the compiler needs to
//         deduce which constructor is the best fit.
//      2. for explicit constructor, we remove cases of overloading
//         that the constructor can involve into.
//
//         For example. explict constructor won't be considered when
//         the compiler needs to choose the copy constructor for a
//         copy init.
//

// explicit means a constructor cannot be used forf

template <typename T> struct A {
  explicit A(const T &, ...) noexcept;
  A(T &&, ...);
};

int i;

// error, because A is explicit so it's no used for copy initialization.
// thus the compiler will use the second constructor.
// i is deduced as rvalue,
// and we cannot deduce from rvalue reference from #2 because it's a lvalue.
// A a1 = {i, i};

// works, uses #1
A a2{i, i};

// ok, uses #2
A a3{0, i};

// ok, uses #2
A a4{0, i};

// Now let's define some deduction guides.
// notice now to trigger #2 you need to have explicit initialization, so
// the copy init cases above won't work anymore if you use type deduction.
template <typename T> A(const T &, const T &) -> A<T &>;
template <typename T> explicit A(T &&, T &&) -> A<T>;

// this failes now as oppose to a3.
// it's because according to the deduction guide, we
// A a5 = {0, 1};

A a6{1, 1}; // #4 best fit, use #2 to initialize.
#include <functional>
#include <iostream>

template <typename T> struct Thing {
  T t;
  using Type = T;
  template <typename U> Thing(U u) {}
};

Thing(const char *)->Thing<std::string>;

template <typename Queue, typename F> class Tasks {
  Tasks(Queue &&q, const F &on_finished);
};

template <typename Queue, typename F>
Tasks(Queue, F) -> Tasks<Queue, std::function<void()>>;


int main(void) {
  Thing thing{"asd"};
  using p = decltype(thing)::Type;
  p str{"god"};
  return 0;
}
#include <iostream>

// a constructor is explicit means it cannot be used for
//   1. implict conversion.
//   2. copy initialization.
// NOTE: if a constructor is not explicit, it's converting constructor.
//
// NOTE:
//      1. constructor is also overloaded, and the compiler needs to
//         deduce which constructor is the best fit.
//      2. for explicit constructor, we remove cases of overloading
//         that the constructor can involve into.
//
//         For example. explict constructor won't be considered when
//         the compiler needs to choose the copy constructor for a
//         copy init.
//
//         Further, explicit won't use explicit for convertion.
//         By conversion I mean (B)1. if the constructor is
//         explicit B::B(int), this won't work.
//
//      3. Consider explicit as a predicate that limit the visibility of
//         the type constructor.
//         Normally a converting constructor is visible in all cases,
//         including copy init and conversion.
//         But explict type constructor are hidden for those cases.
//
// SIDENOTE:
//  I feel most of confusion from C++ comes for different types of overloading,
//  there are so many of them that can happen in so many different cases.
//
//  deduction guide allows you to overload type.
//  function overloading allows you to overload function invocation,
//  overloading on constructor determines what type you end up with.
//
//  And there are some sporadic predicates like explicit in the language that
//  somehow alter the overloading behavior.
//
//  The main abstraction in c++ is adhoc polymorphism.  Parametric polymorphism is
//  also overloadble, which makes things complicated.

// let's do a little experiment.
struct A {
  A(int) {}
  A(int, int) {}
  operator bool() const { return true; }
};

struct B {
  explicit B(int) {}
  explicit B(int, int) {}
  explicit operator bool() const { return true; }
};

int main(void) {
  A a1 = 1;
  A a2(2);
  A a3{4, 5};
  A a4 = {4, 5};
  A a5 = (A)1;
  if (a1)
    ;

  // B b1 = 1; all explicit constructors are not considered for copy init.
  B b2(2);

  // this works because
  B b3 = (B)1;

  return 0;
}
#include <functional>
#include <iostream>
#include <type_traits>

using namespace std;

template <typename T> struct memfun_type { using type = void; };

template <typename Ret, typename Class, typename... Args>
struct memfun_type<Ret (Class::*)(Args...) const> {
  using type = std::function<Ret(Args...)>;
  using return_type = Ret;
};

template <typename F>
typename memfun_type<decltype(&F::operator())>::type
to_function(F const &func) { // Function from lambda !
  return func;
}

template <typename F> struct lambda_traits {
  using type = typename memfun_type<decltype(&F::operator())>::type;
  using return_type =
      typename memfun_type<decltype(&F::operator())>::return_type;
};

template <typename Fn, typename... Ts>
typename lambda_traits<Fn>::type foo(Fn fn) {
  return fn;
}

struct S {
  int i;
  S(int i) : i(i) {}
};

int main(void) {
  auto val = foo([](int a, int b) -> double { return a + b; })(1, 2);
  auto fn = [](int a) -> S { return S{1}; };
  lambda_traits<decltype(fn)>::return_type v{1};

  std::cout << v.i << std::endl;

  return 0;
}
#include <functional>
#include <iostream>
#include <type_traits>

using namespace std;

template <size_t n, typename...> struct elt_ { using at = void; };
template <typename T, typename... Ts> struct elt_<0, T, Ts...> {
  using at = T;
};
template <size_t n, typename T, typename... Ts> struct elt_<n, T, Ts...> {
  using at = typename elt_<n - 1, Ts...>::at;
};

template <typename... Ts> struct elt {
  template <size_t n> using at = typename elt_<n, Ts...>::at;
};

template <typename T> struct memfun_type { using type = void; };

template <typename Ret, typename Class, typename... Args>
struct memfun_type<Ret (Class::*)(Args...) const> {
  using type = std::function<Ret(Args...)>;
  using return_type = Ret;

  template <size_t n> using parameter = typename elt<Args...>::template at<n>;
};

template <typename F> struct lambda_traits {
  using type = typename memfun_type<decltype(&F::operator())>::type;
  using return_type =
      typename memfun_type<decltype(&F::operator())>::return_type;

  template <size_t n>
  using parameter =
      typename memfun_type<decltype(&F::operator())>::template parameter<n>;
};

auto foo = [](int, double, char) -> int { return 1; };

#define TEST
#ifdef TEST
static_assert(std::is_same_v<lambda_traits<decltype(foo)>::return_type, int>);
static_assert(std::is_same_v<lambda_traits<decltype(foo)>::parameter<0>, int>);
static_assert(
    std::is_same_v<lambda_traits<decltype(foo)>::parameter<1>, double>);
static_assert(std::is_same_v<lambda_traits<decltype(foo)>::parameter<2>, char>);
static_assert(
    !std::is_same_v<lambda_traits<decltype(foo)>::parameter<2>, double>);
#endif
#include <type_traits>

/* This version */

// template meta function.
// template meta function should always take a type as paramter.

template <typename T> struct make_const_ { using type = const T; };
make_const_<int>::type a = 1;

// identity
template <typename T> struct identity { using type = T; };

// Box value into type so it works with our convention.
// use curisou recurring pattern to add ::type refer to itself.
template <int N> struct int_ : identity<int_<N>> {
  static const int value = N;
};
template <bool N> struct bool_ : std::integral_constant<bool, N> {};
template <char N> struct char_ : std::integral_constant<char, N> {};

template <typename A, typename B> struct times {
  using type = int_<A::type::value * B::type::value>;
};
template <typename A, typename B> struct add {
  using type = int_<A::type::value + B::type::value>;
};
template <typename A, typename B> struct minus {
  using type = int_<A::type::value - B::type::value>;
};

constexpr bool H_less_then_(int a, int b) { return a < b; }
constexpr bool H_greater_then_(int a, int b) { return a > b; }

template <typename A, typename B> struct less {
  using type = int_<H_less_then_(A::type::value, B::type::value)>;
};

template <typename A, typename B> struct greater {
  using type = int_ < A::value<H_greater_then_(A::type::value, B::type::value)>;
};

template <typename A, typename B> struct equal {
  using type =
      int_ < A::value<A::type::value == B::type::value ? A::type::value
                                                       : B::type::value>;
};

constexpr int c = times<int_<1>, int_<2>>::type::value;
static_assert(c == 2);

// just inherits. The technique is called meta function forwarding.
template <typename A> struct double_n : times<A, int_<2>> {};

constexpr int c1 = double_n<times<int_<1>, int_<2>>::type>::type::value;
static_assert(c1 == 4);

////////////////////////////////////////////////////////////////////////////////
// higher order meta function
// meta functions take type as argument, but meta functions themselves are
// templates, not type. to work around we box them in another type.

struct make_const_volatile { // a template meta function class.
  using type = make_const_volatile;
  template <typename T> struct apply { using type = const volatile T; };
};

struct make_const {
  using type = make_const;
  template <typename T> struct apply { using type = const T; };
};

// taking higher order function
template <typename F> struct transform_int_type : F::template apply<int> {};

using cv_int = transform_int_type<make_const_volatile>::type;
using c_int = transform_int_type<make_const>::type;
cv_int c2 = 1;

////////////////////////////////////////////////////////////////////////////////
// use lazyness to implement conditional

template <typename C, typename T, typename F> struct if_;

// use lazyness for conditiona
template <bool C, typename T, typename F> struct if_impl_ { using type = T; };
template <typename T, typename F> struct if_impl_<true, T, F> {
  using type = T;
};
template <typename T, typename F> struct if_impl_<false, T, F> {
  using type = F;
};

// we pass T and F without evaluate them.
template <typename C, typename T, typename F>
struct if_ : if_impl_<C::value, T, F> {};

constexpr int c3 = times<int_<2>, if_<

                                      bool_<true>,

                                      int_<2>, int_<3>>::type>::type::value;
static_assert(c3 == 4);

//  control lazyness and strictness.
namespace nono {
template <typename N>
struct fact_nono :

    if_<typename less<N, int_<1>>::type,

        int_<1>,

        typename times<

            // this doesnt' work!!!
            // the value will returned by if, which is unevalutated.
            typename fact_nono<typename minus<N, int_<1>>::type>::type,

            N>::type

        > {};

// constexpr int c5 = fact_nono<int_<0>>::type::value;
} // namespace nono

// box and unbox
// the point is even if it's a value, it still has a ::type member to be
// accessed.
template <typename T> struct box { using type = box; };
template <typename T> struct unbox;
template <typename T> struct unbox<box<T>> { using type = T; };
unbox<box<int>>::type c4 = 1;

////////////////////////////////////////////////////////////////////////////////
// fact with right evaluation strategy.

template <typename N> struct fact;

template <typename N>
struct fact_impl
    : times<typename fact<typename minus<N, int_<1>>::type>::type, N> {};

template <typename N>
struct fact
    : if_<typename less<N, int_<1>>::type, int_<1>, fact_impl<N>>::type {};
constexpr int c5 = fact<int_<10>>::type::value;

int main(void) { return 0; }

// templatea meta funcotions accepting only nullary metafunctions is easier to
// work with.
#include "lambda_trait.h"
#include <any>
#include <functional>
#include <iostream>
#include <type_traits>

template <typename T> struct F {
  T value;
  using value_type = T;

  // template <typename U> F<U> map(std::function<U(T)>);

  template <typename Fn, typename U = typename lambda_traits<Fn>::return_type,
            typename T1 = typename lambda_traits<Fn>::template parameter<0>>
  F<U> map(Fn fn);
};

// we want to infer both U and T. T is from the caller U is from the function.
// if we type erase and deduce U, we can't specify T. If we specify T with
// std::function we can't deduce U (instead we need to provided U.)

template <typename T>
template <typename Fn, typename U, typename T1>
F<U> F<T>::map(Fn fn) {
  static_assert(std::is_same_v<T1, T>);

  U u = static_cast<std::function<U(T)>>(fn)(value);
  return F<U>{u};
}

int main(void) {
  F<int> f{1};
  F<double> f1 = f.map([](int a) { return 1.1; });

  return 0;
}
#include <iostream>
#include <string>

// varadic template and fold expression
//
// arguments of varadic tempalte is called parameter pack.
// it means to accepts zero or more tempalte arguments.
// Template arguments can be either types or values

// A function parameter pack is a function parameter that takes
// zero or more function arguments.

template <typename... Ts> struct Tuple {};
template <typename T1, typename T2> struct Pair {};

Tuple<> t0;
Tuple<int, int> t1;
Tuple<double, float> t2;

// - implement zip with parameter pack and pack extension
template <typename... Ts> struct zip {
  template <typename... Us> struct with {
    using type = Tuple<Pair<Ts, Us>...>;
  };
};

zip<int, int, int>::with<double, double, char>::type x;
zip<std::uint32_t, uint32_t>::with<std::int16_t, std::int16_t>::type y;

template <typename... Args> void f(Args... args) {}
template <typename... Args> void h(Args... args) {}

// - nested pack extension
template <typename... Args> void g(Args... args) {
  int n = 0;
  f(const_cast<const Args *>(args)...);

  // this results to f(h(T1, T2, T3...) + T1, h(T1, T2, T3...) + T2, ...);
  // the inner pattern is expanded first, then it is combined with the
  // outer pattern for the next expansion.
  f(h(args...) + args...);

  f(&args...);
  f(n, ++args...);
  f(++args..., n);
  f(std::forward(args)...);
  f(std::move(n), std::move(args)...);
}

template <typename T, typename... Ts>
auto mk_namedtuple(std::string name, Ts... args) {
  std::cout << name << " " << T() << std::endl;
  return Tuple<Ts...>{};
}

// note sizeof... is an operator only for parameter pack.
// here the semantic is how many parameters are there.
template <typename... Ts> auto partial_add3(Ts... xs) {
  static_assert(sizeof...(xs) <= 3);
  if constexpr (sizeof...(xs) == 3) {
    return (0 + ... + xs);
  } else {
    return [xs...](auto... ys) { return partial_add3(xs..., ys...); };
  }
}

auto a1 = partial_add3(1, 3, 4);
auto a2 = partial_add3(1, 3)(4);
#include <iostream>
#include <vector>

// class templates an be paritally specialized, and resulting class
// is still a template.
//
// Partial specialization is userful when a template has multiple
// types and only some of them need to be specialized.
// Or template has only one type but need to be specialized for
// different varaitions ""
//

template <typename T> struct PTS {
  enum { IsPointer = 0, IsPoitnerToMember = 0 };
};

template <typename T> struct PTS<T *> {
  enum { IsPointer = 1, IsPoitnerToMember = 0 };
};

template <typename T, typename U> struct PTS<T U::*> {
  enum { IsPointer = 0, IsPoitnerToMember = 1 };
};

struct S {};

int main(void) {

  std::cout << "PTS<S>: " << PTS<S>::IsPointer << " "
            << PTS<S>::IsPoitnerToMember << std::endl;

  std::cout << "PTS<S*>: " << PTS<S *>::IsPointer << " "
            << PTS<S *>::IsPoitnerToMember << std::endl;

  std::cout << "PTS<int S::*>" << PTS<int S::*>::IsPointer << " "<<
    PTS<int S::*>::IsPoitnerToMember<< std::endl;

  return 0;
}
#include <type_traits>

template <typename T> using Dummy = T;
template <typename T> using List_t = Dummy<T>;
template <typename T> using Set_t = Dummy<T>;

template <typename T, typename A, typename B, typename Res> struct Replace;
template <typename T, typename A> struct Replace<T, A, A, T>;

/* template <typename T, typename A, typename B, typename Res> */
/* struct Replace<std::set<T>, A, B, std::set<Res>>; */
/* template <typename T, typename A, typename B, typename Res> */
/* struct Replace<std::set<T>, A, B, std::set<Res>>; */

#include <iostream>

// =======================================================
// sfinae. Things can either be well formed or ill formed.

// template that holds a value and make it a type
template <typename T, T v> struct integral_const_ {
  static constexpr T value = v;
};

// type family indexed by true and false.
template <bool B> using bool_const_ = integral_const_<bool, B>;
using true_type_ = bool_const_<true>;
using false_type_ = bool_const_<false>;

// type family index by nat
template <size_t S> using nat_const_ = integral_const_<size_t, S>;
using nat_1_type_ = nat_const_<1>;
using nat_2_type_ = nat_const_<2>;
using nat_3_type_ = nat_const_<3>;
using nat_4_type_ = nat_const_<4>;
using nat_5_type_ = nat_const_<5>;

// =======================================================
// partial specialization
// resemble pattern matching
template <typename T> struct is_reference_ : false_type_ {};
template <typename T> struct is_reference_<T &> : true_type_ {};
template <typename T> struct is_reference_<T &&> : true_type_ {};

static_assert(is_reference_<int &>::value);
static_assert(!is_reference_<int>::value);

// we can act on tope of types
template <typename T> struct remove_reference_ { using type = T; };
template <typename T> struct remove_reference_<T &> { using type = T; };
template <typename T> struct remove_reference_<T &&> { using type = T; };

static_assert(std::is_same_v<remove_reference_<int &&>::type,
                             remove_reference_<int>::type>);

// =======================================================
// add reference
// use partial specialization to avoid al void cases.
template <typename T> struct add_lvalue_reference_bad_ { using type = T &; };
template <> struct add_lvalue_reference_bad_<void> { using type = void; };
template <> struct add_lvalue_reference_bad_<const void> { using type = void; };
template <> struct add_lvalue_reference_bad_<volatile void> {
  using type = void;
};
template <> struct add_lvalue_reference_bad_<const volatile void> {
  using type = void;
};

static_assert(std::is_same_v<add_lvalue_reference_bad_<int>::type, int &>);
static_assert(std::is_same_v<add_lvalue_reference_bad_<void>::type, void>);

// =======================================================
// Use sfinae to ask the compiler if certain specialization
// will be well formed or not.
// We do this to avoid void.
// This works because for all types other than void,
// remove_reference_<T> should be the same things a
// remove_reference_<T&>

template <typename T, typename Enable> struct ALR_impl1 { using type = T; };

template <typename T> struct ALR_impl1<T, std::remove_reference_t<T &>> {
  using type = T &;
};

template <typename T>
struct add_lvalue_reference_1_ : ALR_impl1<T, std::remove_reference_t<T>> {};

static_assert(std::is_same_v<add_lvalue_reference_1_<int>::type, int &>);
static_assert(std::is_same_v<add_lvalue_reference_1_<void>::type, void>);

// =======================================================
// void t map any type to void
template <typename...> using void_t = void;

// base case.
template <typename T, typename Enable> struct ALR_impl2 { using type = T; };
// try this one first
template <typename T> struct ALR_impl2<T, void_t<T &>> { using type = T &; };

template <typename T> struct add_lvalue_reference_2_ : ALR_impl2<T, void> {};

static_assert(std::is_same_v<add_lvalue_reference_2_<int>::type, int &>);

// this one first attempt ALR_impl2<T, void_t<T &>>
// and get ALR_impl2<void, void_t<void &>>, which is ill formed.
// Thus fallback to base case ALR_impl2<T, Enable>, and becomes
// ALR_impl2<void, void>::type = void.
static_assert(std::is_same_v<add_lvalue_reference_2_<void>::type, void>);

// =======================================================
// more on void_t
// if it's void batch the base case.
template <typename T, typename = void> struct has_foo : std::false_type {};
// if T has .foo, specialize this one.
template <typename T>
struct has_foo<T, decltype(std::declval<T &>().foo())> : std::true_type {};

// =======================================================
// declval
// for unevaluated expression. We need to create a value to get the
// type, but we don't need the value itself.
template <typename T>
auto declval_() noexcept -> std::add_rvalue_reference_t<T>;

template <typename T, typename U>
using assignment_result_t = decltype(declval_<T>() = declval_<U>());

static_assert(std::is_same_v<assignment_result_t<int &, double>, int &>);
static_assert(std::is_same_v<assignment_result_t<char &, double>, char &>);

// this is ill formed
static_assert(!std::is_same_v<assignment_result_t<char &, double>, char *>);

// =======================================================
// expression sfinae
// evaluate the wellformness of the expression, and project it to
// the type space.
template <typename T, typename U, typename Enable>
struct is_assignable_impl : std::false_type {};
template <typename T, typename U>
struct is_assignable_impl<T, U, decltype(void(declval_<T>() = declval_<U>()))>
    : std::true_type {};

template <typename T, typename U>
struct is_assignable_ : is_assignable_impl<T, U, void> {};

// you can't assign int to int&, hmmm
static_assert(is_assignable_<int &, int>::value);

// =======================================================
// let's make some other type traits
// a class is polymorphic if we can dynamic cast it so...
template <typename T, typename> struct IP_impl : std::false_type {};
template <typename T>
struct IP_impl<T, decltype(dynamic_cast<void *>(
                      std::declval<std::remove_cv_t<T> *>()))>
    : std::true_type {};

template <typename T> struct is_polymorphic_ : IP_impl<T, void *> {};

// constructable
template <typename T, typename...> struct IC_impl : std::false_type {};
template <typename T, typename... Ts>
struct IC_impl<
    T, decltype(void(::new (std::declval<void *>()) T(std::declval<Ts>()...))),
    Ts...> : std::true_type {};

template <typename T, typename... Ts>
struct is_constructible_ : IC_impl<T, void, Ts...> {};
#include <iostream>
#include <type_traits>

struct K {
  enum { int_t, float_t } type;

  template <typename Integer,
            typename std::enable_if<std::is_integral<Integer>::value,
                                    bool>::type = true>
  K(Integer n) : type(int_t) {}

  template <typename Floating,
            typename std::enable_if<std::is_floating_point<Floating>::value,
                                    bool>::type = true>
  K(Floating n) : type(float_t) {}
};

// another way to partial specialize
template <typename T, typename = void> struct A {};

template <typename T>
struct A<T, typename std::enable_if<std::is_floating_point_v<T>>::type> {};

// note:
// A common problem:
// Two overloads that only differ on the default template parameter.
// This cause a problem because the compiler treat them as the same
// specialization, so you end up with redefinition.


int main(void) {
  K n1(1);
  K n2(1.1);

  if (n1.type == K::int_t) {
    std::cout << "K int true" << std::endl;
  }

  if (n2.type == K::float_t) {
    std::cout << "K float true" << std::endl;
  }

  return 0;
}
#include <cassert>
#include <iostream>

// we write a generic function to
// swap two bytes.

template <typename T> T byte_swap(T value) {
  unsigned char *bytes = reinterpret_cast<unsigned char *>(&value);
  for (size_t i = 0; i < sizeof(T); i += 2) {
    unsigned char v = std::move(bytes[i]);
    bytes[i] = std::move(bytes[i + 1]);
    bytes[i + 1] = std::move(v);
  }
}

template <> double byte_swap(double value) {
  assert(false && "Illegal to swap double");
  return value;
}

template <> char byte_swap(char value) {
  assert(false && "Illegal to swap char");
  std::cout << "good" << std::endl;
  return value;
}
#include <memory>

// use pointer traits
template <typename Ptr> struct BlockList {
  struct block;

  using block_ptr_t = typename std::pointer_traits<Ptr>::template rebind<block>;

  struct block {
    std::size_t size;
    block_ptr_t next_block;
  };

  block_ptr_t free_blocks;
};


int main(void)
{
  BlockList<int*> bl1;

  BlockList<std::shared_ptr<char>> bl2;

  BlockList<std::unique_ptr<char>> bl3;

  return 0;
}
#include <deque>
#include <iostream>
#include <list>
#include <memory>
#include <stdlib.h>
#include <string>

/////////////////////////////
// varadic template
template <typename... Args> class VClass {};

// specialization
VClass<> v1;
VClass<int> v2;
VClass<double> v3;

/////////////////////////////
// this is not supported until 17
// type deduction on non type template parmeters.
template <auto x> constexpr auto constant = x;

// with this at hand you can treat templates as
// compile time fuction.
// from type to term level.
auto x1 = constant<1>;
auto x2 = constant<2>;
auto x3 = constant<'a'>;

/////////////////////////////
// templates as template paramters.
// higher kinded type
template <typename T, template <typename U, int I> typename Arr> class Klcass1 {
  T t;
  Arr<T, 10> a;
};

/////////////////////////////
// default template arguments.
template <typename T, typename Allocator = std::allocator<T>> class Vector {};

// use default allocator.
Vector<int> vec1;

// we can also swap out our own allocator.
// This is an arena allocator
template <typename T> class ArenaAlloc {
private:
  // blocks are linked list on heap.
  template <size_t BlockSize> struct Arean {
    struct Arena *next;
    struct Arena *pre;
    char block[BlockSize];
  };

public:
  T *allocate(T &&) {
    T *ptr = static_cast<T *>(malloc(sizeof(T)));
    return ptr;
  }

  void deallocate() { return; }
};

// now yor vector will be arena allocated. (fake)
Vector<int, ArenaAlloc<int>> vec2;

/////////////////////////////
// template specialization
template <typename K, typename V> class MyMap {};

// partial specialization.
template <typename K, typename V> class MyMap<K*, V*> {};

// you might want to handle the case ofstring as key
// differently.
template <typename V> class MyMap<std::string, V> {};

// or you might want to pop as log as you get get queue?
// who knows.
template <typename K> class MyMap<K, std::deque<int>> {};

/////////////////////////////
// specialization of function templates.

// first declare the most generic version
template <typename... Args> void f(Args... args) {
  ((std::cout << args), ...) << std::endl;
}

// now take at least one
template <typename T, typename... Args> void f(T t, Args... args) {
  std::cout << "T and args" << std::endl;
  ((std::cout << args), ...) << std::endl;
}

// only one argument.
// This case might conflict above?
template <typename T> void f(T t) { std::cout << "T!" << std::endl; }

template <> void f(int x) { std::cout << "int: " << x << std::endl; }

int main(void) {
  f(1, 2, 3);
  std::cout << "==" << std::endl;
  f(1);
  std::cout << "==" << std::endl;
  f(12.2);
  std::cout << "==" << std::endl;

  return 0;
}
#include <iostream>
#include <type_traits>
#include <vector>
#include <map>

// Void t and SFINAE
// Void t map sequence of any types to void.
// https://en.cppreference.com/w/cpp/types/void_t
// https://en.cppreference.com/w/cpp/language/sfinae

template <typename T, typename = void> struct is_iterable : std::false_type {};

template <typename T>
struct is_iterable<T, std::void_t<decltype(std::begin(std::declval<T>())),
                                  decltype(std::end(std::declval<T>()))>>
    : std::true_type {};


int main(int argc, char *argv[]) {
  std::cout << is_iterable<std::vector<int>>::value << std::endl;
  std::cout << is_iterable<double>::value << std::endl;
  return 0;
}
#include <iostream>

// The most basic type trait just turn on for some
// types and turn off for the others.

// we want byte_swap only be avaible on certain types
template <typename T> struct is_swappable {
  static const bool value = false; // default false
};

template <> struct is_swappable<unsigned short> {
  static const bool value = true;
};

template <> struct is_swappable<short> { static const bool value = true; };

template <> struct is_swappable<unsigned long> {
  static const bool value = true;
};

template <> struct is_swappable<long> { static const bool value = true; };

template <> struct is_swappable<unsigned long long> {
  static const bool value = true;
};

template <> struct is_swappable<long long> { static const bool value = true; };

// we write a generic function to
// swap two bytes.
template <typename T, typename = std::enable_if_t<is_swappable<T>::value>>
T byte_swap(T value) {
  unsigned char *bytes = reinterpret_cast<unsigned char *>(&value);
  for (size_t i = 0; i < sizeof(T); i += 2) {
    unsigned char v = std::move(bytes[i]);
    bytes[i] = std::move(bytes[i + 1]);
    bytes[i + 1] = std::move(v);
  }
  return value;
}

int main(void) {
  short s = 12;
  double d = 1.2;

  std::cout << byte_swap(s) << std::endl;
  // std::cout << byte_swap(d) << std::endl;

  return 0;
}
#include <iostream>
#include <type_traits>

// decltype returns the type of expression passed in.
// declval allows you to pass a type and as if get an
// instance of the type.

struct has_get_date_iml {

  // test is the function give us answer.
  // if the type T passed in has get_date, the first version will
  // get specialized, returh value of test will be true type.
  // But if the type doesn't have the get_date method, the second
  // test will take all other cases and return false type.
  template <typename T,
            typename get_date = decltype(std::declval<const T &>().get_date())>
  static std::true_type test(int);

  // match on anything else and ignore it.
  template <typename...> static std::false_type test(...);
};

// this is a helper function, all it does is to
// have a stand alone type based on behavior of test.
template <typename T>
struct has_get_date : decltype(has_get_date_iml::test<T>(0)) {};

struct GetDate {
  int get_date() { return 1; }
};

int main(void) {
  GetDate a;

  std::cout << has_get_date<decltype(a)>::value << std::endl;
  return 0;
}
#include <iostream>


// type erasure allows you to use various concrete type
// through a single generic interface.

// split representation and behavior


#include <iostream>

class A {
  using T1 = int;

public:
  using TP = char;
};

class B : public A {};

int main() {
  A::TP a = 10;
  B::TP b = 88;
}
#include <iostream>

// standard way of doing recursion with varadic templates.
// it's like use overloading to do pattern matching.
// you can't type this in haskell.

// base case
void printff(const char *s) {
  while (*s) {
    if (*s == '%') {
      if (*(s + 1) != '%')
        ++s;
      else
        throw std::runtime_error("invalid format string: missing argument");
    }
    std::cout << *s++;
  }
}

// inductive step
template <typename T, typename... Args>
void printff(const char *s, T value, Args... args) {
  while (*s) {
    if (*s == '%') {
      if (*(s + 1) != '%') {
        std::cout << value;
        s += 2;
        printff(s, args...);
        return;
      }
      ++s;
    }
    std::cout << *s++;
  }
}

int main(void) {
  printff("%s is %s, %d\n", "this", "string", 10);
  return 0;
}
#include <algorithm>
#include <iostream>
#include <sstream>
#include <string_view>

template <typename... Args,
          typename Enable = std::enable_if_t<
              std::conjunction_v<std::is_same<std::string, Args>...>>>
std::string print(Args... args) {
  std::string v;
  (v.append(args), ...);

  return v;
}

int main(void) {
  std::cout << print(std::string("asdl"), std::string("good")) << std::endl;

  return 0;
}
#include <iostream>
#include <memory>
#include <vector>

// You cannot initialize vector with unique_ptr with initializer list.
// The reason is the vector's construct will build a initalizer list first
// which will copy unique_ptrs.
template <typename T, typename... Args>
std::vector<std::unique_ptr<T>> make_uniquevec(const Args... args) {
  std::vector<std::unique_ptr<T>> v;

  // replicate statement, ooh..
  (v.push_back(std::make_unique<T>(args)), ...);

  return v;
}

int main(int argc, char *argv[]) {

  auto vec = make_uniquevec<int>(1, 2, 3, 4, 5);

  for (auto &ptr : vec) {
    std::cout << *ptr << " ";
  }
  std::cout << std::endl;

  auto _ = std::move(vec[0]);
  std::cout << (vec[0] == nullptr) << std::endl;

  return 0;
}
#include <iostream>
#include <limits>
#include <vector>

#define PRINT(name) std::cout << #name << " " << name << std::endl;

int main(void) {

  PRINT(INT8_MAX);
  PRINT(INT16_MAX);
  PRINT(INT32_MAX);
  PRINT(INT64_MAX);

  PRINT(INT8_MIN);
  PRINT(INT16_MIN);
  PRINT(INT32_MIN);
  PRINT(INT64_MIN);

  PRINT(UINT8_MAX);
  PRINT(UINT16_MAX);
  PRINT(UINT32_MAX);
  PRINT(UINT64_MAX);

  std::vector<int> v{1, 2, 3, 0};
  v[v.size() - 1] = INT32_MAX;
  for (auto &e : v)
    std::cout << e << " ";
  std::cout << std::endl;
  return 0;
}
#include <deque>
#include <iostream>

template <typename Container, typename I>
auto auth_and_access1(Container &c, I i) {
  return c[i];
}

template <typename Container, typename I>
auto auth_and_access2(Container &c, I i) -> decltype(c[i]) {
  return c[i];
}

template <typename Container, typename I>
decltype(auto) auth_and_access3(Container &c, I i) {
  return c[i];
}

int main(void) {
  std::deque<int> d{1, 2, 3};

  // here type of c[i] is deduced by template type deduction.
  // and the referencenss is dropped.
  int a = auth_and_access1(d, 2);

  decltype(auto) a1 = std::move(a);
  auto a2 = std::move(a);

  // by using a decltype you specify the return type to be
  // exactly the same a the expreesion you passed in.
  auth_and_access2(d, 2) = 10;

  return 0;
}
int main(void)
{

  return 0;
}
#include <iostream>

template <typename T, std::size_t N>
constexpr std::size_t array_size(T (&)[N]) noexcept {
  return N;
}

template <typename T> void universal(T &&t);
template <typename T> void byval(T t);

template <typename T> void initlist(std::initializer_list<T> init);

int main(void) {
  // array with known size.
  char arr[3] = {'a', 'b', 'c'};
  auto s = array_size(arr);
  if (s == 3) {
    std::cout << "yeet" << std::endl;
  }

  { // passing lvalue to universal reference .
    const int a = 10;
    // here T is deduced to const int&, parameter type is also const int &
    universal(&a);

    // here T is deduced to int, parameter type is int&&
    universal(10);
  }

  { // pasing by value drop the constness and volatile.

    volatile const int a = 10;
    const int &b = 10;
    // T has type int, a has type int.
    // because a is copied it doesn't matter if it passed in as const or not.
    byval(a);

    // reference is dropped here.
    byval(b);
  }

  { // auto type deduction

    // auto is just int
    auto x = 28;

    // you can add modifier to auto.
    // auto is still int.
    const auto cs = x;

    // still int
    const auto &rx = x;

    // x is lvalue reference of int => auto is int&
    auto &&uref1 = x;

    // cs is const lval ref, so constness preserve. auto is cosnt int&.
    auto &&unref2 = cs;

    // assigning a rvalue to rval reference. get int&&
    auto &&uref3 = 27;
  }

  // Only catch for auto
  // You can't decude the type of initializer list.
  // and you need to manually annotate that.
  { // the different part of auto type deduction compare with template.

    auto x1 = 27;

    auto x2(x1);

    // this get initialized to 27
    int x33 = {27};

    // this is just an initializer list.
    auto x3 = {27};

    auto x4{27};

    // why you can't deduce this?
    // auto x5 = {1, 2, 3.0};

    // but you can deduce here.
    initlist({1, 2, 3});
  }

  return 0;
}
#include <iostream>

#include <list>

// type aliasing can be used with tempaltes directly.
template <typename T> class MyAlloc {};
template <typename T> using MyAllocList = std::list<T, MyAlloc<T>>;

// it's hard to do with typedef, you need to wrap it within a struct.
template <typename T> struct MyAllocList1 {
  typedef std::list<T, MyAlloc<T>> type;
};

constexpr int foo() { return 1; }

int main(void) {
  {
    std::remove_const<const int>::type b;

    std::remove_const_t<const int> a;
    a = 10;
    auto a1 = a;
  }

  {
    std::remove_reference_t<int &&> b;
    b = 10;
    auto b1 = b;
  }

  {
    int a = 10;
    std::add_lvalue_reference_t<int> c(a);
    auto c1 = c;

    auto &&c2 = c;
  }

  return 0;
}
#include <assert.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
// CPU can faster than GPU in sequential code
// GPU can faster than CPU in parallel code

/*  CUDA terminology
    Host: the CPU
    Device: a coprocessor to CPU (GPU)
        has its own DRAM (device memory)
        run many threads in parallel
    Kernal Code: data-parallel portions of an application run on device
 */

// Serial part in rost C code compiled by host compiler (gcc)
// Highly parallel part in device SPMD kernal C code compiled by NVIDIA compiler
#define __global__ // called from cpu, execute on device
#define __device__ // cannot be called from cpu
#define __host__   // called and exe on cpu
#define __const__  // declare on constant memeory
#define __shared__ // in shared memory
#define __syncthreads()
#define __threadfence()

typedef struct {
  int x;
  int y;
  int z;
} ThreadId;

typedef struct {
  int x;
  int y;
  int z;
} BlockId;

typedef struct {
  int x;
  int y;
  int z;
} GridDim;

typedef struct {
  int x;
  int y;
  int z;
} BlockDim;

typedef struct {
  int x;
  int y;
  int z;
} Dim3;

Dim3 dim3(int, int, int);

ThreadId threadIdx;
BlockId blockIdx;
GridDim gridDim;
BlockDim blockDim;

typedef enum {
  cudaMemcpyHostToDevice,
  cudaMemcpyDeviceToHost,
  cudaMemcpyDeviceToDevice,
} CudaDirection;

typedef enum {
  cudaSuccess = 0,
  cudaErrorInvalidValue,
  cudaErrorMemoryAllocation,
  cudaErrorInitializationError,
  cudaErrorCudartUnloading,
  cudaErrorSyncronizatrrionError = 25,
} CudaError_t;

CudaError_t cudaMalloc(void **d_ptr, size_t);
CudaError_t cudaMemcpy(void *dst, void *src, size_t, CudaDirection);
CudaError_t cudaFree(void *);
CudaError_t cudaMemSet(void *d_ptr, int value, size_t n);
CudaError_t cudaConfigCall(size_t gridDim, size_t blockDim);
CudaError_t cudaGetLastError();
CudaError_t cudaDeviceSynchorize();
void atomicAdd(void *, int);
int atomicCAS(int *, int, int);
int atomicExch(int *, int);
/*  Array of Threads
    A CUDA kernal is executed by an array of threads
    SPMD (single program multiple data)
    thread ID are used to
        decide what data to work on
        make control decision
 */

// Kernal function for worker on single thread.
__global__ void foo(int a, int b) {}

/* ------------- */
//  Sample HOST code
//  device copy the memory from host.
/* ------------- */
void sample_host_code() {
  int *a = 0, *da = 0, num_bytes = 200;
  a = (int *)malloc(num_bytes);

  cudaMalloc((void **)&da, num_bytes);
  cudaMemcpy(da, a, num_bytes, cudaMemcpyHostToDevice);

  // do something here.

  cudaMemcpy(a, da, num_bytes, cudaMemcpyDeviceToHost);

  cudaFree(da);
  free(a);
}
#define CUDA_CHECK(err)                                                        \
  if (err != cudaSuccess) {                                                    \
    printf("cuda memory allocation error");                                    \
    printf("Error%d; %s: %d", err, __FILE__, __LINE__);                        \
    printf(cudaGetErrorString(err));                                           \
    cudaDeviceReset();                                                         \
    exit(-1);                                                                  \
  }

/* ------------- */
//   __global__ add
/* ------------- */

__global__ void add(int a, int b, int *c) { // runs on device
  *c = a + b;
}
void parallel_add() {
  int c;
  int *dc;
  cudaMalloc((void **)&dc, sizeof(int));
  add<<<1, 1>>>(2, 7, d_c);
  cudaMemcpy(&c, dc, sizeof(int), cudaMemcpyDeviceToHost);
  cudaFree(dc);
  printf("2 + 7 = %d", c);
}

/* ------------- */
//   __global__ vector addition
/* ------------- */
#define N 1024
#define INIT(a, n)                                                             \
  for (int i_ = 0; i_ < n; ++i) {                                              \
    a[i] = rand() % N;                                                         \
  }

#define INT_VEC_ALLOC(a, n)                                                    \
  a = (int *)malloc(sizeof(int) * n) if (a == NULL) {                          \
    printf("memory allocation failed");                                        \
    exit(-1);                                                                  \
  }

__global__ void vec_add(int *a, int *b, int *c, int n) { // runs on device
  int i = blockIdx.x * blockDim.x + threadIdx.x;
  if (i < n)
    c[i] = a[i] + b[i];
}

void parallel_vec_square() {
  int *a, *b; // also use b as output.
  int *da, *db;

  // calculate kernal config
  int nThreadPerBlock = 256;
  int nBlocks = N / nThreadPerBlock;
  if (N % nThreadPerBlock)
    nBlocks++;

  INT_VEC_ALLOC(a, N)
  INT_VEC_ALLOC(b, N)

  cudaMalloc((void **)da, N * sizeof(int));
  cudaMalloc((void **)db, N * sizeof(int));
  INIT(a, N)
  CUDA_CHECK(cudaMemcpy(da, a, N * sizeof(int), cudaMemcpyHostToDevice));
  CUDA_CHECK(cudaMemcpy(db, da, N * sizeof(int), cudaMemcpyDeviceToDevice));

  vec_add<<<nBlocks, nThreadPerBlock>>>(da, db, db, N);

  CUDA_CHECK(cudaMemcpy(b, db, N * sizeof(int), cudaMemcpyDeviceToHost));

  CUDA_CHECK(cudaGetLastError());
  CUDA_CHECK(cudaDeviceSynchorize());

  for (int i = 0; i < N; ++i)
    assert(a[i] == b[i] * b[i]);

  free(a);
  free(b);
  cudaFree(da);
  cudaFree(db);
}

/* ------------- */
// GPU design:
//  massively threaded. sustains 1000s of threads per app
// Software: grid and blocks
// Hardware:
//  SM: streaming multiprocessor
//  SP: streaming processor

// kernalFunc<<<gridSize, blockSize>>>()
// we can have as many blocks as we want
// each block can have maximum 1024 threads.

// CHOSING LUANCH CONFIGURATION
// KerFunc<<<gridSize, blockSize>>>(),
// blocks = (N-1) / (nthreads_per_block + 1)
// Goal: Threads per block should be large
// Blcok should be >= # of SM

/* ------------- */
// HIGHER DIMENSIONAL GRIDS / BLOCKS
// process 100 x 70 picture
/* ------------- */
#define WIDTH 100
#define HEIGHT 70
#define TILEWIDTH = 32
#define TILEHEIGHT = 32
__global__ void pickernal(float *dpin, float *dpout, int w, int h) {
  int y = blockIdx.y * blockDim.y + threadIdx.y;
  int x = blockIdx.x * blockDim.x + threadIdx.x;

  if ((y < h) && (x < w))
    dpout[y * w + x] = sin(dpin[y * w + x]) * 0.4;
}
// parallel kernal pic
void parallel_kernal_pic() {
  dim3 blocksize(WIDTH, HEIGHT);
  int nblk_x = (WIDTH - 1) / (TILEWIDTH - 1);
  int nblk_y = (HEIGHT - 1) / (TILEHEIGHT - 1);
  dim3 gridsize(nblk_x, nblk_y);

  float *x, *dx; // image
  pickernal<<<gridsize, blocksize>>>(x, dx, WIDTH, HEIGHT);
  cudaDeviceSynchorize(); // force printf in device ot flush here.
  printf("that's all");
  // ... memcpy stuffs.
}

/* ------------- */
// cuda limits.
// within a block maximum # of thread per block = 1024
// maximum dimension of a block 1024 / 1024/ 64
/* ------------- */

/* ------------- */
// Thread Cooperation
// Thread in same block can cooperate.
// communicate via shared memory, atomic operation and barrier synchronization.
// thread # used to assing works.
// threads can execute in any order.
/* ------------- */

#undef INIT
#undef INT_VEC_ALLOC
#undef N

/* ------------- */
//  PERFORMANCE and MEMORY
/* ------------- */

/* ------------- */
// Compute to Global Memory Access
// goal increase CGMA. More computation less IO.
/* ------------- */

/* ------------- */
//  Types of memory
// Programmable
//      register, shared memory, local memory, constant memory, global memory
// Non-programmable
//      L1, L2 Cache
/* ------------- */
// -----------------------
//         GRID
// -----------------------
//  BLOCK0,0 |  BLOCK0,1
// --------- | -----------
// SharedMem |  SharedMem
//  t, t, t..|  t, t, t..
//  r  r  r  |  r  r  r
// -----------------------
//       Global Memory
// -----------------------
//       Constant Memory
// -----------------------

// CUDA variables
// int x;               register | onchip mem | thread scope thread lifetime |
// very fast int array[10];       localmem | offchipmem | thread scope thread
// lifetime | slow
// __shared__ int x;    sharedmem|  onchip    | block scope block lifetime   |
// fast
// __device__ int x;    global   |  offchip   | grid+host scope,app lifetime |
// slow
// __const__ int x;     const    |  offchip   | grid+host scope,app lifetime |
// fast

// automatic variable:
// __local__ int a[10];
// automatic scalar var in register, automatic arrays resides in local memory by
// default

// -----------------------
//      Example of memory access
// -----------------------
#define N 1024
#define GRID_SZ = 4
#define BLOCK_SZ = N / GRID_SZ
__device__ float glb;    // in global mem
__const__ float C = 1.2; // in constant mem

__global__ void foo1(float *array, int len) {}
__device__ void helper() {}

__global__ void foo2(float *array, int len) {
  int i = threadIdx.x;    // in register
  float a1[100];          // often in local mem
  __shared__ float sh;    // block scope shared mem
  __shared__ float a2[N]; // same as sh.
  float *p_glb = &glb;    // pointer is in register. point to mem in global mem.
  const float *p_C = &C;
}
#undef N

// -----------------------
//      Memory tiling
//      utilize shared memory
//      reduce global memory access
// -----------------------
#define TILE_WIDTH = 32
__global__ void matrix_mul(float *m, float *n, float *p, int width) {
  __shared__ float ms[TILEWIDTH][TILEWIDTH];
  __shared__ float ns[TILEWIDTH][TILEWIDTH];

  int bx = blockIdx.x;
  int by = blockIdx.y;
  int tx = threadIdx.x;
  int ty = threadIdx.y;
  int y = by * TILEWIDTH + ty;
  int x = bx * TILEWIDTH + tx;

  // identify row and column of p element to work on.
  float value = 0;

  // loop over m and n tiles requried to compute p element
  int num_phases = width / TILEWIDTH;
  for (int ph = 0; ph < TILEWIDTH; ph++) {
    ms[ty][tx] = m[y * width + (ph * TILEWIDTH + tx)];
    ns[ty][tx] = n[(ty + ph * TILEWIDTH) * width + x];

    __syncthreads(); // thread sync within the same block.
    for (int k = 0; k < TILEWIDTH; k++) {
      value += ms[ty][k] * ns[k][tx];
    }
    __syncthreads();
  }
  p[y * width + x] = value;
}

#undef TILEWIDTH

// -----------------------
//      Avoid data race
// -----------------------
__global__ void foo() {
  __shared__ int array[100];
  int i = threadIdx.x;
  int temp;
  array[i] = i;
  __syncthreads(); // data is written first before any reads it.
  if (i > 1 && i < 100)
    temp = array[i - 1]; // ensure reading original data.
  __syncthreads();
  if (i > 1 && i < 100)
    array[i] = temp; // if other reads / writes are done after that.
  __syncthreads();
  // ...
}

// -----------------------
//      Atomic operation
//      Slower. because of serilize dexecution of threads.
//      No specific order.
//      Only certain operations are support.
//      Only int support for most operations.
// -----------------------

#define NUMTHREADS 10000
#define BLOCK_WIDTH 63
__global__ void increment_atomic(int *x) { atomicAdd(x, 1); }

void parallel_inc() {
  int *hx, *dx;
  cudaMalloc((void **)&dx, sizeof(int));
  cudaMemSet(dx, 0, sizeof(int));
  increment_atomic<<<NUMTHREADS / BLOCK_WIDTH, BLOCK_WIDTH>>>(dx);
  cudaMemcpy((void **)&hx, dx, sizeof(dx), cudaMemcpyDeviceToHost);
  cudaDeviceSynchorize();
  printf("x = %d\n", hx);
  free(hx);
  cudaFree(dx);
}
#undef NUMTHREADS
#undef BLOCK_WIDTH

// -----------------------
//      Critical section / lock
// -----------------------
struct Lock {
  int *mutex;
  Lock() {
    cudaMalloc((void **)&mutex, sizeof(int));
    cudaMemSet(mutex, 0, sizeof(int));
  }
  ~Lock() { cudaFree(mutex); }
  __device__ void lock() {
    while (atomicCAS(mutex, 0, 1) != 0)
      ;
    __threadfence();
  }
  __device__ void unlock() {
    atomicExch(mutex, 0);
    __threadfence();
  }
};

// -----------------------
//      Thread scheduling.
// -----------------------
// Transparent scalability:
//      GPU responsible for assigning thread blocks to SMs.
//      threads in the same block might cooperate.
//

#define Q9
__device__ void brighten(int *pixel) {
  *pixel *= 2;
  if (*pixel > 255)
    *pixel = 255;
}
__global__ void process(int *image, int width, int height) {
  int y = blockIdx.y * blockDim.y + threadIdx.y;
  int x = blockIdx.x * blockDim.x + threadIdx.x;
  if ((y < height) && (x < width))
    brighten(&image[y * width + x]);
}
int main(void) {
  // read an image along with its width and height - don't parallelize this part
  int *image;
  int *image_d;
  int width, height;
  const int TILE_WIDTH = 32;
  readImage("name.bmp", image, &width, &height);
  cudaMalloc(&image_d, sizeof(int) * width * height);
  cudaMemcpy(image_d, image, sizeof(int) * width * height,
             cudaMemcpyHostToDevice);
  dim3 blocksize(TILE_WIDTH, TILE_WIDTH);
  int nblk_x = (width - 1) / (TILE_WIDTH - 1);
  int nblk_y = (height - 1) / (TILE_WIDTH - 1);
  dim3 gridsize(nblk_x, nblk_y);
  // process the image - you should run this part on the GPU
  process<<<gridsize, blocksize>>>(image, width, height);
  cudaMemcpy(image, image_d, sizeof(int) * width * height,
             cudaMemcpyDeviceToHost);

  // save results - don't parallelize this part
  saveImage(image);
  free(image), cudaFree(image_d);
  return 0;
}
#undef Q9

#define Q10
__shared__ float min = 100000.0f; // assume max value in f is < 100,000
__device__ float partial_min[32];

__device__ float f(float x,
                   float y) { // Function is visualized in the plot above
  return x * x * (4 - 2 * x * x + 0.3f * (x * x * x * x)) + x * y +
         y * y * (-4 + 0.4f * y * y);
}
__global__ float getmin(float xa, float xb, float ya, float yb, int n) {
  float hx = (xb - xa) / n; // assume xb > xa
  float hy = (yb - ya) / n; // assume yb > ya

  // calculate the index.
  int yi = blockIdx.y * blockDim.y + threadIdx.y;
  int xi = blockIdx.x * blockDim.x + threadIdx.x;
  // calculate the coordinate
  yi = yi * hy;
  xi = xi * hx;

  if (min > f(xi, yi) && (yi >= ya && yi <= yb) && (xi >= xa && xi <= xb))
    min = f(xi, yi);
  __syncthreads();
  partial_min[xi] = min;
  __syncthreads();
  return min;
}

int main() {
  getmin<<<32, 32>>>(-10, 10, -10, 10, 1024);
  float *partial_min_main;
  cudaMemcpy(partial_min_main, partial_min, sizeof(float) * 32,
             cudaMemcpyDeviceToHost);

  // final step host collect data from blocks
  float min = 100000.0f;
  for (int i = 0; i < 32; i++) {
    if (min > partial_min[i])
      min = partial_min[i];
  }
  free(partial_min);
  cudaFree(partial_min_main);
  printf("The min value is %.2f\n", min); // OUTPUT: The min value is -11.96
  return 0;
}
#undef Q10

#define Q11
#include <stdio.h>
#define WIDTH 5 // Size of matrices

int main() {
  // allocate space for M and N on the heap and initialize them
  int *M = malloc(WIDTH * WIDTH * sizeof(int));
  int *N = malloc(WIDTH * WIDTH * sizeof(int));
  read(M);
  read(N);
  // compute MxN and find min – note that we don’t need to save the full matrix
  // resulting from MxN

  MPI_Init(NULL, NULL);
  MPI_Comm_rank(MPI_COMM_WORLD, &my_rank);
  MPI_Comm_size(MPI_COMM_WORLD, &comm_sz);

  int my_rank, comm_sz, my_n, source;
  if ()
    if (my_rank != 0) { // send my partial result to process 0
      MPI_Send(&my_sum, 1, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);
    } else { // process 0 combines the partial results

      printf("Hi from process %dof%d!\n", my_rank, comm_sz); // Print my message
      for (int q = 1; q < comm_sz; q++) { // Print others’ messages
        MPI_Recv(msg, LEN, MPI_CHAR, q, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
        printf("%s\n", msg);
      }
      total_sum = my_sum;
      for (source = 1; source < comm_sz; source++) {
        MPI_Recv(&my_sum, 1, MPI_DOUBLE, source, 0, MPI_COMM_WORLD,
                 MPI_STATUS_IGNORE);
        total_sum += my_sum;
      }
    }
  if (my_rank == 0)
    printf("%.15e\n", total_sum);

  int min = -1;
  for (int r = 0; r < WIDTH; r++)
    for (int c = 0; c < WIDTH; c++) {
      // compute value of MxN at (r,c)
      int value = 0;
      for (int k = 0; k < WIDTH; k++)
        value += M[r + WIDTH * k] * N[k + WIDTH * c];
      // find min
      if (min < value)
        min = value;
    }
  // print results
  printf("%d", min);
  return 0;
}
#undef Q11

#include <stdio.h>
#define WIDTH 5 // Size of matrices

int main() {
  // allocate space for M and N on the heap and initialize them
  int *M = malloc(WIDTH * WIDTH * sizeof(int));
  int *N = malloc(WIDTH * WIDTH * sizeof(int));
  read(M);
  read(N);
  MPI_Init(NULL, NULL);
  MPI_Comm_rank(MPI_COMM_WORLD, &my_rank);
  MPI_Comm_size(MPI_COMM_WORLD, &comm_sz);
  int my_rank, comm_sz, my_n, source;

  if (my_rank == 0) {
    // scatter rows of first matrix to different processes
    MPI_Scatter(a, WIDTH * WIDTH / sizeof(int), MPI_INT, aa, N * N / size,
                MPI_INT, 0, MPI_COMM_WORLD);

  } else {
    MPI_Recv(&my_sum, 1, MPI_INT, source, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
  }

  if (my_rank == 0) {
  }
  MPI_Finalize();
  return 0

         // compute MxN and find min – note that we don’t need to save the full
         // matrix resulting from MxN
         int min = -1;
  for (int r = 0; r < WIDTH; r++)
    for (int c = 0; c < WIDTH; c++) {
      // compute value of MxN at (r,c)
      int value = 0;
      for (int k = 0; k < WIDTH; k++)
        value += M[r + WIDTH * k] * N[k + WIDTH * c];
      // find min
      if (min < value)
        min = value;
    }
  // print results
  printf("%d", min);
  return 0;
}
#include <iostream>
#include <opencv2/core.hpp>
#include <opencv2/highgui.hpp>
#include <opencv2/imgcodecs.hpp>

// core.hpp basic building blocks of the lib
// highgui functions for input and output operations.

int main(int argc, char *argv[]) {
  if (argc != 2) {
    std::cout << "Usage: display_image ImageToLoadAndDisplay" << std::endl;
  }

  cv::Mat image;
  image = cv::imread(argv[1]);

  if (!image.data) {
    std::cout << "Could not open or find the image" << std::endl;
  }

  cv::namedWindow("Display window", cv::WINDOW_AUTOSIZE);
  cv::imshow("Display window", image);
  while (int key = (cv::waitKey()) != 27)
    ; // 27 for esc
  return 0;
}
#include <iostream>
#include <opencv4/opencv2/core.hpp>
#include <opencv4/opencv2/highgui.hpp>
#include <opencv4/opencv2/imgcodecs.hpp>
#include <opencv4/opencv2/imgproc.hpp>

int main(int argc, char *argv[]) {
  char *imageName = argv[1];
  cv::Mat image;
  image = cv::imread(imageName, 1);
  if (argc != 2 || !image.data) {
    printf("No image data\n");
    return -1;
  }

  cv::Mat gray_image;
  cv::cvtColor(image, gray_image, cv::COLOR_BGR2GRAY);
  cv::imwrite("~/newDisk/img/coins.png", gray_image);
  cv::namedWindow(imageName, cv::WINDOW_AUTOSIZE);
  cv::namedWindow("Gray image", cv::WINDOW_AUTOSIZE);

  cv::imshow(imageName, image);
  cv::imshow("Gray image", gray_image);

  while (int key = (cv::waitKey()) != 27)
    ; // 27 for esc
  return 0;
}
#include "../common.h"
#include <opencv2/highgui.hpp>
#include <opencv2/imgcodecs.hpp>

// linear blend operator
// g(x) = (1 - alpha) * f0(x) + alpha * f1(x)
// where 1 > alpha > 0

int main(int argc, char *argv[]) {
  double alpha = 0.5;
  double beta, input;

  cv::Mat src1, src2, dst;
  std::string imgname1;
  std::string imgname2;

  std::cout << "Simple linear blender" << std::endl;
  std::cout << "---------------------" << std::endl;
  std::cout << "Enter alpha [0 - 1]  " << std::endl;
  std::cin >> input;
  std::cout << "Enter file1:  " << std::endl;
  std::cin >> imgname1;
  std::cout << "Enter file2:  " << std::endl;
  std::cin >> imgname2;

  if (input >= 0.0 && input <= 1.0)
    alpha = input;

  // needs to be the same size
  src1 = cv::imread(imgname1.c_str());
  src2 = cv::imread(imgname2.c_str());

  cv::namedWindow("Linear Blend", 1);

  // generate g(x) image.
  beta = { 1.0 - alpha };
  // calculate weighted sum of two arrays.
  cv::addWeighted(src1, alpha, src2, beta, 0.0, dst);

  cv::imshow("Linear Blend", dst);

  return 0;
}


#include <iostream>
#include <opencv2/core.hpp>
#include <opencv2/highgui.hpp>
#include <opencv2/imgcodecs.hpp>

// general image processing operator:
//  a function take one or more input images and produces an output image.
//  image transformation can be seen as
//  Point operator. (pixel transform) like brightness and contrast adjustment
//  neightborhood operator. (area based)

// brightness and contrast adjustment
//  g(x) = alpha * f(x) + beta
//    where alpha > 0, beta is called gain and bias.

int main(int argc, char *argv[]) {
  double alpha; // contrast control
  int beta;     // bias, brightness control
  cv::Mat image = cv::imread(argv[1]);
  cv::Mat newimg = cv::Mat::zeros(image.size(), image.type());

  std::cout << "Basic Linear tranforms" << std::endl;
  std::cout << "----------------------" << std::endl;
  std::cout << "Enter alpha value:";
  std::cin >> alpha;
  std::cout << "Enter beta value:";
  std::cin >> beta;

  // traversal through every pixels. and assign new value.
  for (int y = 0; y < image.rows; ++y) {
    for (int x = 0; x < image.cols; ++x) {
      for (int c = 0; c < 3; ++c) {
        auto current = newimg.at<cv::Vec3b>(y, x)[c];
        current = cv::saturate_cast<uchar>(alpha * current + beta);
      }
    }
  }
  cv::namedWindow("Og", 1);
  cv::namedWindow("New", 1);

  cv::imshow("Og", image);
  cv::imshow("New", newimg);
  while (cv::waitKey() != 27)
    ;

  return 0;
}
#include <iostream>
#include <opencv2/core.hpp>
#include <opencv2/imgcodecs.hpp>
#include <opencv2/imgproc.hpp>
#include <opencv4/opencv2/highgui.hpp>
#include <string>

// some basic drawing toolds in opencv.
// use Point to define 2d point in an image.
// use Scalar
// draw line, ellipse, rectangle, circle, filled polygon.

auto myline(cv::Mat &img, const cv::Point start, const cv::Point end) -> void {
  const int thickness = 2;
  const int lineType = 8;
  cv::line(img, start, end, cv::Scalar(0, 0, 0), thickness, lineType);
}
auto myline(cv::Mat &img, const cv::Point start, const cv::Point end,
            const int thickness, const int lineType) -> void {
  cv::line(img, start, end, cv::Scalar(0, 0, 0), thickness, lineType);
}

auto myellipse(cv::Mat &img, const double angle, const int w) -> void {
  const int thickness = 2;
  const int lineType = 8;
  cv::ellipse(img, cv::Point(w / 2.0, w / 2.0), cv::Size(w / 4.0, w / 16.0),
              angle, 0, 360, cv::Scalar(255, 0, 0), thickness, lineType);
}

auto myfilledcirc(cv::Mat &img, const cv::Point center, const int w) -> void {
  const int thickness = 2;
  const int lineType = 8;
  cv::circle(img, center, w / 32.0, cv::Scalar(0, 0, 255), thickness, lineType);
}

auto mypolygon(cv::Mat &img, const int w) -> void {
  const int lineType = 8;
  cv::Point rook_points[20] = {
      cv::Point(w / 4.0, 7 * w / 8.0),
      cv::Point(3 * w / 4.0, 7 * w / 8.0),
      cv::Point(3 * w / 4.0, 13 * w / 16.0),
      cv::Point(11 * w / 16.0, 13 * w / 16.0),
      cv::Point(19 * w / 32.0, 3 * w / 8.0),
      cv::Point(3 * w / 4.0, 3 * w / 8.0),
      cv::Point(3 * w / 4.0, w / 8.0),
      cv::Point(26 * w / 40.0, w / 8.0),
      cv::Point(26 * w / 40.0, w / 4.0),
      cv::Point(22 * w / 40.0, w / 4.0),
      cv::Point(22 * w / 40.0, w / 8.0),
      cv::Point(18 * w / 40.0, w / 8.0),
      cv::Point(18 * w / 40.0, w / 4.0),
      cv::Point(14 * w / 40.0, w / 4.0),
      cv::Point(14 * w / 40.0, w / 8.0),
      cv::Point(w / 4.0, w / 8.0),
      cv::Point(w / 4.0, 3 * w / 8.0),
      cv::Point(13 * w / 32.0, 3 * w / 8.0),
      cv::Point(5 * w / 16.0, 13 * w / 16.0),
      cv::Point(w / 4.0, 13 * w / 16.0),
  };
  const cv::Point *ppt[1] = {rook_points};
  int npt[]{20};
  cv::fillPoly(img, ppt, npt, 1, cv::Scalar(255, 255, 255), lineType);
}

int main(int argc, char *argv[]) {
  const int w = 300;
  std::string atomwindow = "Drawing 1: Atom";
  std::string rookwindow = "Drawing 1: Atom";
  cv::Mat atomimg = cv::Mat::zeros(w, w, CV_8UC3);
  cv::Mat rookimg = cv::Mat::zeros(w, w, CV_8UC3);

  myellipse(atomimg, 90, w);
  myellipse(atomimg, 0, w);
  myellipse(atomimg, 45, w);
  myellipse(atomimg, -45, w);

  myfilledcirc(atomimg, cv::Point(w / 2.0, w / 2.0), w);

  mypolygon(rookimg, w);
  cv::rectangle(rookimg, cv::Point(0, 7 * w / 8.0), cv::Point(w, w),
                cv::Scalar(0, 255, 255), -1, 8);
  myline(rookimg, cv::Point(0, 15 * w / 16), cv::Point(w, 15 * w / 16));
  myline(rookimg, cv::Point(w / 4, 7 * w / 8), cv::Point(w / 4, w));
  myline(rookimg, cv::Point(w / 2, 7 * w / 8), cv::Point(w / 2, w));
  myline(rookimg, cv::Point(3 * w / 4, 7 * w / 8), cv::Point(3 * w / 4, w));

  cv::namedWindow(atomwindow.c_str(), cv::WINDOW_AUTOSIZE);
  cv::namedWindow(rookwindow.c_str(), cv::WINDOW_AUTOSIZE);

  cv::imshow(atomwindow.c_str(), atomimg);
  while (cv::waitKey() != 27)
    ;

  cv::imshow(rookwindow.c_str(), rookimg);
  while (cv::waitKey() != 27)
    ;
  return 0;
}
#include "../common.h"
#include <iostream>
#include <opencv2/core.hpp>
#include <opencv2/highgui.hpp>
#include <opencv2/imgcodecs.hpp>
#include <opencv2/imgproc.hpp>
#include <string>

auto sharpen(const cv::Mat &img) -> cv::Mat;

auto help(std::string_view progName) -> void {
  std::cout << "Usage: " << std::endl
            << progName << " [image_name] [G -- grayscale]" << std::endl;
}

int main(int argc, char *argv[]) {
  help(argv[0]);
  if (argc < 2) {
    std::cerr << "Not enought parameter" << std::endl;
  }
  std::string filname{argv[1]};

  cv::Mat I, J, K;
  if (argc >= 3 && !std::strcmp("G", argv[2]))
    I = cv::imread(filname.c_str(), cv::IMREAD_GRAYSCALE);
  else
    I = cv::imread(filname.c_str(), cv::IMREAD_COLOR);

  cv::namedWindow("Input", cv::WINDOW_AUTOSIZE);
  cv::namedWindow("Output", cv::WINDOW_AUTOSIZE);

  cv::imshow("Input", I);

  cv::Mat Isharpen1, Isharpen2;
  benchmark(
      1, [&I, &Isharpen1]() { Isharpen1 = sharpen(I); },
      "sharpening use formula methods");

  // use cv::Mat_ to make matrix with specific shape.
  // filter2D to apply a filter to an image.
  benchmark(
      1,
      [&I, &Isharpen2]() {
        cv::Mat kern = (cv::Mat_<char>(3, 3) << 0, -1, 0, -1, 5, -1, 0, -1, 0);
        cv::filter2D(I, Isharpen2, I.depth(), kern);
      },
      "sharpening with kernal");

  cv::imshow("Output", Isharpen1);
  while (int key = (cv::waitKey()) != 27)
    ;

  cv::imshow("Output", Isharpen2);
  while (int key = (cv::waitKey()) != 27)
    ;

  return 0;
}

// mask
//          | 0   -1   0 |
//  I = I * | -1   5  -1 |
//          | 0   -1   0 |
auto sharpen(const cv::Mat &img) -> cv::Mat {
  CV_Assert(img.depth() == CV_8U);
  cv::Mat result;
  result.create(img.size(), img.type()); // output image.
  const int nchannels = img.channels();

  for (int j = 1; j < img.rows; ++j) { // get row
    const uchar *prev = img.ptr<uchar>(j - 1);
    const uchar *current = img.ptr<uchar>(j);
    const uchar *next = img.ptr<uchar>(j + 1);
    uchar *ouput = result.ptr(j);

    // traversal columns.
    for (int i = nchannels; i < nchannels * (img.cols - 1); ++i) {
      *ouput++ =
          cv::saturate_cast<uchar>(5 * current[i] - current[i - nchannels] -
                                   current[i + nchannels] - prev[i] - next[i]);
    }
  }

  // skip the border by setting it to 0.
  result.row(0).setTo(cv::Scalar(0));
  result.row(result.rows - 1).setTo(cv::Scalar(0));
  result.col(0).setTo(cv::Scalar(0));
  result.col(result.cols - 1).setTo(cv::Scalar(0));
  return result;
}
#include <opencv4/opencv2/core.hpp>
#include <iostream>

int main(int argc, char *argv[]) {
  // cv::Mat is a customized reference count pointer.
  // maybe implemented with a shared pointer?
  // it has .clone() and .copyTo() to copy the matrix memory underneath.
  // Mat allows to use different color space and data type.
  // color space: [grayscale, rgb (bgr), hsv, hls]

  // cv::Scalar is a four element short vector. specify initialize data.
  cv::Mat m1(2, 2, CV_8UC3, cv::Scalar(0, 0, 255));

  // use arrays to initialize Mat.
  // m2(dimension, size of each dimension, ...)
  // Mat with dim > 2 cannot be printed (of course...)
  int sz[3] = {2, 2, 2};
  cv::Mat m2(3, sz, CV_8UC(1), cv::Scalar::all(0));

  // matlab style matrix initializer.
  cv::Mat m3 = cv::Mat::eye(4, 4, CV_64F);
  cv::Mat m4 = cv::Mat::ones(2, 2, CV_32F);
  cv::Mat m5 = cv::Mat::zeros(3, 3, CV_8UC1);

  // small matrix
  // use MatrixComma initializer
  // some template stuffs.
  cv::Mat m6 = (cv::Mat_<double>(3, 3) << 0, -1, 0, -1, 5, -1, 0, -1, 0);

  cv::Mat m7 = m6.clone();

  std::cout << "M1=" << m1 << std::endl;
  return 0;
}
// scan images, lookup tables and time measurement
#include <array>
#include <iostream>
#include <opencv2/core.hpp>
#include <opencv2/imgcodecs.hpp>
#include <string_view>
#include "../common.h"

// 1. color space reduction.
// (255, 255, 255) scheme for color pixel sometimes can be hard to compute,
// and the precision of colors for some algorithms is not critical.
// thus we can reduce the color space to (I/n) * n where n is number of levels.

// 2. lookup table for optimization.

static void help() {
  std::cout << "\n-----------------------------" << std::endl
            << "Usage: " << std::endl
            << "scan <image file> <int> [G] " << std::endl
            << "\n-----------------------------" << std::endl;
}

cv::Mat scanImageAndReduceC(cv::Mat &I, const std::array<uchar, 256> table);
cv::Mat scanImageAndReduceIterator(cv::Mat &I,
                                   const std::array<uchar, 256> table);
cv::Mat scanImageAndReduceRandomAccess(cv::Mat &I,
                                       const std::array<uchar, 256> table);

// calcualte lookup table.
// motivation
// Rather than apply (divideWidth * (i / divideWidth)) to every pixels,
// caclulate the mapping table ahead of time and just
// replace pixels with value in table.
static inline auto tableLoopUp(int divideWidth) -> std::array<uchar, 256> {
  std::array<uchar, 256> table;
  double t;
  for (int i = 0; i < 256; ++i) {
    table[i] = (uchar)(divideWidth * (i / divideWidth));
  }
  return table;
}

int main(int argc, char *argv[]) {
  help();
  if (argc < 3) {
    std::cout << "Not enougth paramters" << std::endl;
    return -1;
  }
  cv::Mat I, J;
  if (argc == 4 && !std::strcmp(argv[3], "G"))
    I = cv::imread(argv[1], cv::IMREAD_GRAYSCALE);
  else
    I = cv::imread(argv[1], cv::IMREAD_COLOR);

  if (!I.data) { // pointer to the data.
    std::cout << "Image" << argv[1] << " could not be loaded." << std::endl;
    return -1;
  }

  // read divideWidth.
  int divideWidth = 0;
  std::stringstream s;
  s << argv[2];
  s >> divideWidth;

  std::array<uchar, 256> table = tableLoopUp(divideWidth);

  // benchmarking.
  benchmark(
      100,
      [&I, &J, &table]() {
        cv::Mat cloneI = I.clone();
        J = scanImageAndReduceIterator(cloneI, table);
      },
      "reducing with iterator");

  benchmark(
      100,
      [&I, &J, &table]() {
        cv::Mat cloneI = I.clone();
        J = scanImageAndReduceC(cloneI, table);
      },
      "reducing with C operator");

  benchmark(
      100,
      [&I, &J, &table]() {
        cv::Mat cloneI = I.clone();
        J = scanImageAndReduceRandomAccess(cloneI, table);
      },
      "reducing with on the fly address generatoin");

  benchmark(
      100,
      [&I, &J, &table]() {
        cv::Mat lookupTable(1, 256, CV_8U);
        uchar *p = lookupTable.data;
        for (size_t i = 0; i < 256; ++i)
          p[i] = table[i];
        cv::LUT(I, lookupTable, J);
      },
      "use core function LUO");

  return 0;
}

// with C style access. fast
auto scanImageAndReduceC(cv::Mat &I, const std::array<uchar, 256> table)
    -> cv::Mat {
  CV_Assert(I.depth() == CV_8U);     // only accept char type matrices.
  const int channels = I.channels(); // get number of matrix channels.
  size_t nCols = I.cols * channels;  // get actual amount of col.
  size_t nRows = I.rows;

  if (I.isContinuous()) { // check if Mat is stored in a countinous mem.
    nCols *= nRows;       // if it is just loop through the memory.
    nRows = 1;
  }

  // will be 1 if image is stored countinously.
  for (size_t i = 0; i < nRows; ++i) {
    uchar *p = I.ptr(i);
    for (size_t j = 0; j < nCols; ++j) {
      p[j] = table[p[j]]; // assign the precaculated reduce space.
    }
  }

  return I;
}

// safer way of doing it with iterator.
// you don't need to care if image is stored continously or not.
// but since it uses iterator speed might get compensated.
cv::Mat scanImageAndReduceIterator(cv::Mat &I,
                                   const std::array<uchar, 256> table) {
  CV_Assert(I.depth() == CV_8U);
  const int channels = I.channels();

  switch (channels) {
  case 1: {
    for (auto it = I.begin<uchar>(), end = I.end<uchar>(); it != end; ++it) {
      *it = table[*it];
    }
    break;
  }
  case 3: {
    // cv::Vec3b is the short vector for uchar type.
    // openCV iterator go through columns and automatically skip the next row.
    for (auto it = I.begin<cv::Vec3b>(), end = I.end<cv::Vec3b>(); it != end;
         ++it) {
      (*it)[0] = table[(*it)[0]];
      (*it)[1] = table[(*it)[1]];
      (*it)[2] = table[(*it)[2]];
    }
    break;
  }
  }
  return I;
}

// on the fly address calcualtion with reference returning.
cv::Mat scanImageAndReduceRandomAccess(cv::Mat &I,
                                       const std::array<uchar, 256> table) {
  CV_Assert(I.depth() == CV_8U);
  const int channels = I.channels();
  switch (channels) {
  case 1: {
    for (size_t i = 0; i < I.rows; ++i)
      for (size_t j = 0; j < I.cols; ++j)
        I.at<uchar>(i, j) = table[I.at<uchar>(i, j)];
    break;
  }
  case 3: {
    // get copied. Mat_ take type parameter of type to look for.
    cv::Mat_<cv::Vec3b> _I = I;
    for (size_t i = 0; i < I.rows; ++i)
      for (size_t j = 0; j < I.cols; ++j) {
        // calculate address based on type and coord on fly.
        _I(i, j)[0] = table[_I(i, j)[0]];
        _I(i, j)[1] = table[_I(i, j)[1]];
        _I(i, j)[2] = table[_I(i, j)[2]];
      }
    I = _I;
    break;
  }
  }
  return I;
}
#include <functional>
#include <iostream>
#include <opencv4/opencv2/core.hpp>
#include <opencv4/opencv2/highgui.hpp>
#include <opencv4/opencv2/imgcodecs.hpp>
#include <opencv4/opencv2/imgproc.hpp>
#include <variant>

// different blur algorithms.
// gaussian filter, median filter, bilateral filter.
// smoothing can reduce noise and help further image progessing.

// linear filter (a common type of filter)
//    g(i, j) = Sum(f(i+k, j+k) * h(k, l)) where h(k, l) is the kernel.

// some common blurring filteres
// average filter, gaussian filter,  median filter
bool display_dst(int delay, cv::Mat &dst, const std::string &windowname);

template <typename T>
static inline auto apply(cv::Mat &src, cv::Mat &dst,
                         const int max_kernal_length, const T &filter,
                         const std::string &windowname) -> bool {
  for (int i = 1; i < max_kernal_length; i = i + 2) {
    if constexpr (std::is_same_v<T, decltype(cv::blur)>) {
      // size(w, h): define size of kernel
      // point(-1, -1): indicate position of anchor point. negative indicate
      // center of kernal.
      static_cast<decltype(cv::blur)>(filter)(src, dst, cv::Size(i, i),
                                              cv::Point(-1, -1));

    } else if constexpr (std::is_same_v<T, decltype(cv::GaussianBlur)>) {
      // size(w, h): size of kernal. w, h has to be odd.
      // seg_x std dev in x. = imply kernal size.
      // seg_y std dev in x. = imply kernal size.
      static_cast<decltype(cv::GaussianBlur) *>(filter)(src, dst,
                                                        cv::Size(i, i), 0, 0);

    } else if constexpr (std::is_same_v<T, decltype(cv::medianBlur)>) {
      static_cast<decltype(cv::medianBlur) *>(filter)(
          src, dst, i); // i size of the kernal. must be odd.

    } else if constexpr (std::is_same_v<T, decltype(cv::bilateralFilter)>) {
      // d: parameter of each pixel neighbour.
      // seg_color: standard dev in color space
      // seg_space: std dev in coordinate space (in pixel term)
      static_cast<decltype(cv::bilateralFilter)>(filter)(src, dst, i, i * 2,
                                                         i / 2);
    }

    if (!display_dst(1500, dst, windowname))
      return false;
  }

  return true;
}

bool display_caption(const std::string &caption, cv::Mat &src,
                     const std::string &windowname) {
  cv::Mat dst = cv::Mat::zeros(src.size(), src.type());
  cv::putText(dst, caption, cv::Point(src.cols / 4, src.rows / 2),
              cv::FONT_HERSHEY_COMPLEX, 1, cv::Scalar(255, 255, 255));
  cv::imshow(windowname, dst);
  int c = cv::waitKey(1500);
  if (c >= 0) {
    return false;
  }

  return true;
}

bool display_dst(int delay, cv::Mat &dst, const std::string &windowname) {
  cv::imshow(windowname, dst);
  int c = cv::waitKey(1500);
  if (c >= 0) {
    return false;
  }

  return true;
}

int main(int argc, char *argv[]) {
  constexpr int kernel_lenght = 31;
  cv::Mat src, dst;
  std::string windowname = "Filter demo";
  cv::namedWindow(windowname, cv::WINDOW_AUTOSIZE);
  if (argc != 2) {
    std::cout << "not enough parameter" << std::endl;
    std::cout << "usage: " << std::endl;
    std::cout << argv[0] << " <image file>" << std::endl;
    return -1;
  }

  std::string imgname = argv[1];
  src = cv::imread(imgname, 1);

  if (!display_caption("OG", src, windowname))
    return 0;

  apply(src, dst, kernel_lenght, cv::blur, windowname);
  apply(src, dst, kernel_lenght, cv::GaussianBlur, windowname);
  apply(src, dst, kernel_lenght, cv::medianBlur, windowname);
  apply(src, dst, kernel_lenght, cv::bilateralFilter, windowname);

  return 0;
}
#include <functional>
#include <iostream>
#include <opencv4/opencv2/core.hpp>
#include <string_view>

static inline void benchmark(const int times, std::function<void()> &&f,
                             const std::string_view report) {
  // benchmarak
  double t;
  t = (double)cv::getTickCount();
  for (int i = 0; i < times; ++i) {
    f();
  }
  t = 1000 * ((double)cv::getTickCount() - t) / cv::getTickFrequency();
  t /= times; // get sec.
  std::cout << report << ": " << t << " ms." << std::endl;
}
package main


import (
  "fmt"
  "io/ioutil"
  m "math"
  "net/http"
  "os"
  "strconv"
)

func main() {
  fmt.Println("Hello world!")
  beyondHello()
}

func beyondHello() {
  // declare and assignment
  var x int
  x = 3

  // short decleration. infer the type, declare and assign.
  y := 4

  sum, prod := learnMultiple(x, y)
  fmt.Println("sum:", sum, "prod:", prod)
  learnTypes()
}

// muti value return type
func learnMultiple(x, y int) (sum, prod int) {
  return x + y, x * y
}

func learnTypes() {
  str := "Learn Go!"
  s2 := `A "raw" string
  can include line breaks.`

  g := '∑'

  f := 3.1415926
  c := 3 + 4i

  var u uint = 7  // unsigned
  var pip float32 = 22. / 7
  n := byte('\n')

  // an array of 4 integers, initialized to all 0.
  var a4 [4]int

  //
  a5 := [...]int{3, 1, 5, 10, 1000} // array initialized with fixed size of five

  // arrays have value semantics
  a4_cpy := a4
  a4_cpy[0] = 25

  fmt.Println(a4_cpy[0] == a4[0])

  // slice have dynamic size.
  s3 := []int{4, 5, 9}  // a slice of 3 elements.
  s4 := make([]int, 4)  // allocate slice of 4 ints.
  var d2 [][]float64    // no RAII. only decleration.

  bs := []byte("a slice")   // type converision

  // slice have reference semantics
  s3_ref := s3 // s3_ref ref to the same value

  // slices are dynamic, adding elemnets at run time
  s := []int{1, 2, 3}
  s = append(s, 4, 5, 6)

  // you have pointer in go
  p, q := learnMemory()
  fmt.Println(*p, *q)

  // create hash table
  m := map[string]int{"three": 3, "four": 4}
  m["one"] = 1

  _, _, _ = str, s2, g


  file, _ := os.Create("output.txt")
  fmt.Fprint(file, "Write to a file")
  file.Close()

  fmt.Println(s, c, a4, s3, d2, m)
  learnFlowControl()
}


// by the way you don't need return type for x because it's
// abbreviated in y's type
func learnNamedReturns(x, y int) (z int) {
  z = x * y
  return // z is implicit
}


// go is gced yet has pointer.
// you can't have pointer arithmeic, so pointer really just act
// like a reference.
func learnMemory() (p, q *int) {
  p = new(int)    // allocate for int, return a ptr
  s := make([]int, 20) // allocate 20 ints as single block of memory
  s[3] = 7
  r := -2
  return &s[3], &r  // take the address of an object
}


func expensiveComputation() float64 {
  return m.Exp(10)
}


func learnFlowControl() {

  if true {
    fmt.Println("told ya")
  }

  if false {

  } else {

  }

  x := 42.0
  switch x {
  case 0:
  case 1, 2: // multiple matches
  case 42:   // cases don't fall throught
  case 43:   // unreached
  default:
  }

  // type switch allows switching on the type of something
  // instead of value.
  var data interface{}
  data = ""
  switch c := data.(type) {
  case string:
    fmt.Println(c, "is a string")
  case int64:
    fmt.Println("%d is an int64\n", c)
  default:
  }

  for x := 0; x < 3; x++ {
    fmt.Println("iteration", x)
  }

  for {
    break
    continue
  }

  for key, valuie := range map[string]int{"one": 1, "two": 2, "three": 3} {
    fmt.Println("Hello, %sν", name)
  }

  // intermediate assignment in if
  if y := expensiveComputation(); y > x {
    x = y
  }

  // closure
  xBig := func() bool {
    return x > 10000
  }

  x = 99999
  x = 1.3e3
  goto love
love:
  learnFunctionFactory()
  learnDefer()
  learnInterfaces()
}

func learnFuncionFactory() {
  fmt.Println(sentenceFactory("summer")("A beautiful", "day"))

  d := sentenceFactory("summer")
  fmt.Println(d("A beautiful", "day"))
  fmt.Println(d("A beautiful", "afternoon"))
}

// decorators. return another function
func sentenceFactory(mystring string) func(before, after stsring) string {
  return func(before, after string) string {
    return fmt.Sprintf("%s %s %s", before, mystring, after)
  }
}

func learnDefer() (ok bool) {
  // defer pushes a funtion call onto a list. The list of saved
  // calls is executed after the surrounding function returns.
  defer fmt.Println("deferred statements execute in reverse order.")
  defer fmt.Println("\n this line is being printed first because")
  // defer is commonly used to close a file, so the function closing the
  // file stays close to the function opening the file.
  return ture
}

// an interface
type Stringer interface {
  String() string
}

// normal struct
type pair struct {
  x, y int
}

// implement String function for pair.
// now pair implements Stringer.
// row poly.
func (p pair) String() string {
  return fmt.Sprintf("(%d, %d)", p.x, p.y)
}


func learnInterfaces() {
  p := pair{3, 4}
  fmt.Println(p.String())
  var i Stringer    // declare i implements Stringer
  i = p             // it's clearly dynamic dispatch
  fmt.Println(i.Stringer())

  fmt.Println(p)
  fmt.Println(i)

  learnVaradicParams("great", "learning", "here")
}

// varadic parameters.
// interface{} is just void* that accepts everything.
func learnVaradicParams(myStrings ...interface{}) {
  for _, param := range myStrings {
    fmt.Println("param:", param)
  }

  fmt.Println("params:", fmt.Sprintf(myStrings...))
  learnErrorHandling()
}

func learnErrorHandling() {
  m := map[int]string{3: "three", 4: "four"}
  // this is error handling?
  if x, ok := m[1]; !ok {
    fmt.Println("no one there")
  } else {
    fmt.Print(x)
  }

  if _, err := strconv.Atoi("non-int"); err != nil {
    fmt.Println(err)
  }

  learnConcurrency()
}

// c is a channel (concurrency safe communication object).
func inc(i int, c chan int) {
  c <- i + 1  // <- is the send operator
}

func learnConcurrency() {
  c := make(chan int)  // make a integer channel
  go inc(0, c)  // go starts new goroutine
  go inc(10, c)
  go inc(-805, c)

  fmt.Println(<-c, <-c, <-c) // <-x is receive

  cs := make(chan string)       // a string channel
  ccs := make(chan chan string) // a channel of string channel.
  go func() { c <- 84 }()
  go func() { cs <- "wordy" }()

  select {
  case i := <-c:
    fmt.Println("it's a %T", i)
  case <-cs:
    fmt.Println("it's a string")
  case <-ccs:
    fmt.Println("didn't happen.")
  }

  learnWebProgramming()
}


// p as self
func (p pair) ServeHTTP(w http.ResponseWriter, r *http.Request) {
  w.Write([]byte("You learned Go in Y minutes!"))
}

func requestServer() {
  resp, err := http.Get("http://localhost:8080")
  fmt.Println(err)
  defer resp.Body.Close()
  body, err := ioutil.ReadAll(resp.Body)
  fmt.Printf("νWebserver said: `%s`", string(body))
}
package main

import (
  "html/template"
  "io/ioutil"
  "log"
  "net/http"
  "regexp"
)

type Page struct {
  title string
  body []byte
}

func (p *Page) save() error {
  filename := p.title + ".txt"
  return ioutil.WriteFile(filename, p.body, 0600)
}

func loadPage(title string) (*Page, error) {
  filename := title + ".txt"
  body, err := ioutil.ReadFile(filename)
  if err != nil {
    return nil, err
  }
  return &Page{title: title, body: body}, nil
}

func viewHandler(w http.ResponseWriter, r *http.Request, title string) {
  p, err := loadPage(title)
  if err != nil {
    http.Redirect(w, r, "/edit/" + title, http.StatusFound)
    return
  }
  renderTemplate(w, "view", p)
}

func editHandler(w http.ResponseWriter, r *http.Request, title string) {
  p, err := loadPage(title)
  if err != nil {
    p = &Page {title: title}
  }
  renderTemplate(w, "edit", p)
}

func saveHandler(w http.ResponseWriter, r *http.Request, title string) {
	body := r.FormValue("body")
	p := &Page{Title: title, Body: []byte(body)}
	err := p.save()
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	http.Redirect(w, r, "/view/"+title, http.StatusFound)
}

var templates = template.Must(template.ParseFiles("edit.html", "view.html"))

func renderTemplate(w http.ResponseWriter, tmpl string, p *Page) {
	err := templates.ExecuteTemplate(w, tmpl+".html", p)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
	}
}

var validPath = regexp.MustCompile("^/(edit|save|view)/([a-zA-Z0-9]+)$")

func makeHandler(fn func(http.ResponseWriter, *http.Request, string)) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		m := validPath.FindStringSubmatch(r.URL.Path)
		if m == nil {
			http.NotFound(w, r)
			return
		}
		fn(w, r, m[2])
	}
}

func main() {
	http.HandleFunc("/view/", makeHandler(viewHandler))
	http.HandleFunc("/edit/", makeHandler(editHandler))
	http.HandleFunc("/save/", makeHandler(saveHandler))

	log.Fatal(http.ListenAndServe(":8080", nil))
}
mod mark_sweep;

// == GC ==
// The goal of an ideal garbage collector is to reclaim the space used by every object that will no longer be used by the program.

// === Big Idea ===
// - liveness is a global property, but free is a local action. This is why manual memory management i so hard.
// - Well designed programs are built from components that are highly cohesive and loosely coupled.
// - GC decouple the problem of memory manage instead of scatter it througout the code.
// - We care about the reachability of an object. If an object is not reachable, the gc will reclaim it's space.

// === GC algorithm criterions ===
// - safty: You don't want to reclaim live objects.
// - throughput: Overall time spent on gc should be as low as possible. That is gc happens as less frequent as possible.
// - completeness: Garbages need to evenutally be collected. Not necessarily instant because in some cases defer the collection of some garbages imporve the gc performances (young old generations).
// - pause time: of course shorter the better.

// === Some terms ===
// - mutator: application program. mutate the object graph
// - collector: collect unreachable nodes.
// - allocator: The C++ sorts.

// === Fundamental GC schemes ===
// 1. Mark and sweep
// 2. Copying collection
// 3. mark compact
// 4. reference counting

fn main() {
    println!("Hello, world!");
}

pub mod mark_sweep1;
import bpy

bl_info = {
    "name": "Cursor Array",
    "blender": (2, 80, 0),
    "category": "Object",
}


class ObjectCursorArray(bpy.types.Operator):
    bl_idname = "object.cursor_array"
    bl_label = "Cursor Array"
    bl_options = {"REGISTER", "UNDO"}

    total = bpy.props.IntProperty(name="Step", default=2, min=1, max=100)

    def execute(self, context: bpy.types.Context):
        scene = context.scene
        cursor_pos = scene.cursor.location
        obj = context.active_object

        for i in range(self.total):
            obj_new = obj.copy()
            scene.collection.objects.link(obj_new)
            factor = i / self.total
            obj_new.location = (obj.location * factor) + \
                (cursor_pos * (1.0 - factor))

        return {"FINISHED"}


def menu_draw(self, context):
    self.layout.operator(ObjectCursorArray.bl_idname)


addon_keymaps = []


def register():
    bpy.utils.register_class(ObjectCursorArray)
    bpy.types.VIEW3D_MT_object.append(menu_draw)

    wm = bpy.context.window_manager

    kc = wm.keyconfigs.addon

    if kc:
        km = wm.keyconfigs.addon.keymaps.new(
            name="Object Mode", space_type="EMPTY")
        kmi = km.keymap_items.new(
            ObjectCursorArray.bl_idname, "T", "PRESS", ctrl=True, shift=True)
        kmi.properties.total = 4
        addon_keymaps.append((km, kmi))


def unregister():
    for km, kmi in addon_keymaps:
        km.keymap_items.remove(kmi)
    addon_keymaps.clear()

    bpy.utils.unregister_class(ObjectCursorArray)
    bpy.types.VIEW3D_MT_object.remove(menu_draw)


if __name__ == "__main__":
    register()


FINISHED = {"FINISHED"}
import bpy
from bpy.props import (StringProperty,
                       BoolProperty,
                       IntProperty,
                       FloatProperty,
                       FloatVectorProperty,
                       EnumProperty,
                       PointerProperty,
                       )

from bpy.types import (Panel,
                       Menu,
                       Operator,
                       PropertyGroup)
bl_info = {
    "name": "Addon template",
    "blender": (2, 80, 0),
    "version": (0, 0, 1),
    "location": "3D View > Tools",
    "category": "Development"
}


class MyProperties(PropertyGroup):
    my_bool = BoolProperty(
        name="Enable or Disable",
        description="A bool property",
        default=False
    )

    my_int = IntProperty(
        name="Int Value",
        description="A integer property",
        default=32,
        min=10,
        max=100
    )

    my_float = FloatProperty(
        name="Float Value",
        description="A float property",
        default=32.1,
        min=0.0,
        max=0.1
    )

    my_float_vector = FloatVectorProperty(
        name="Float Vector",
        description="A float vec property",
        default=(0.0, 0.0, 0.0),
        min=0.0,
        max=0.1
    )

    my_string = StringProperty(
        name="String input",
        description="some strings",
        default="",
        maxlen=1024,
    )

    my_enum = EnumProperty(
        name="DropDown",
        description="Apply data to attributes",
        items=[("OP1", "Option 1", ""),
               ("OP2", "Option 2", ""),
               ("OP3", "Option 3", ""),
               ]
    )


class Hello(Operator):
    bl_label = "Print Values Operator"
    bl_idname = "wm.hello"

    def execute(self, context: bpy.types.Context):
        scence = context.scene
        mytool = scence.my_tool

        print("Hello")
        print("Bool: ", mytool.my_bool)
        print("Int: ", mytool.my_int)
        print("Float: ", mytool.my_float)
        print("String: ", mytool.my_string)
        print("Enum: ", mytool.my_enum)

        return {"FINISHED"}


class CustomMenu(bpy.types.Menu):
    bl_label = "Select"
    bl_idname = "OBJECT_CustomMenu"

    def draw(self, context: bpy.types.Context):
        layout = self.layout

        layout.operator("object.select_all",
                        text="Select/Unselect All").action = "TOGGLE"
        layout.operator("object.select_all", text="Inverse").action = "INVERT"
        layout.operator("object.select_random", text="Random")


class CustomPanel(bpy.types.Panel):
    bl_label = "My Panel"
    bl_idname = "OBJECT_CustomPanel"
    bl_space_type = "VIEW_3D"
    bl_region_type = "UI"
    bl_category = "Tools"
    bl_context = "objectmode"

    @classmethod
    def poll(cls, context: bpy.types.Context):
        return context.object is not None

    def draw(self, context: bpy.types.Context):
        layout = self.layout
        scence = context.scene
        mytool = scence.my_tool

        layout.prop(mytool, "my_bool")
        layout.prop(mytool, "my_enum", text="")
        layout.prop(mytool, "my_int")
        layout.prop(mytool, "my_float")
        layout.prop(mytool, "my_string")
        layout.prop(mytool, "my_float_vector", text="")
        layout.menu(CustomMenu.bl_idname, text="Presets", icon="SCENE")
        layout.separator()


classes = (
    MyProperties,
    Hello,
    CustomMenu,
    CustomPanel
)


def register():
    from bpy.utils import register_class
    for cls in classes:
        register_class(cls)


def unregister():
    from bpy.utils import unregister_class
    for cls in reversed(classes):
        unregister_class(cls)
    del bpy.types.Scene.my_tool


if __name__ == "__main__":
    register()
#!/usr/bin/bash
g++ triangleGL.cpp -o triangleGL.out -lglfw -lGL -lGLEW
#define GLFW_INCLUDE_NONE
#include <GL/gl.h>
#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <array>
#include <stdio.h>

struct Vertex {
  float x, y;
  float r, g, b;
};

static Vertex vertices[3] = {{-0.6f, -0.4f, 1.f, 0.f, 0.f},
                             {0.6f, -0.4f, 0.f, 1.f, 0.f},
                             {0.f, 0.6f, 0.f, 0.f, 1.f}};

// shader code as string directly.
static const char *vertex_shader_text =
    "#version 110\n"
    "uniform mat4 MVP;\n"
    "attribute vec3 vCol;\n"
    "attribute vec2 vPos;\n"
    "varying vec3 color;\n"
    "void main()\n"
    "{\n"
    "    gl_Position = MVP * vec4(vPos, 0.0, 1.0);\n"
    "    color = vCol;\n"
    "}\n";

static const char *fragment_shader_text =
    "#version 110\n"
    "varying vec3 color;\n"
    "void main()\n"
    "{\n"
    "    gl_FragColor = vec4(color, 1.0);\n"
    "}\n";

// setting up an error callback.
// it's passed to glfw, and in case anything failed, this
// cb will get called.
void error_callback(int error, const char *desc) {
  fprintf(stderr, "Error %d, %s\n", error, desc);
}

// get called when the window is closed.
void window_close_callback(GLFWwindow *w) {
  fprintf(stderr, "Window is closed");
}

// receiving the input
static void key_callback(GLFWwindow *window, int key, int scancode, int action,
                         int mod) {
  if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS) {
    glfwSetWindowShouldClose(window, GLFW_TRUE);
  }
}

int main(void) {
  GLFWwindow *window;

  // init
  if (!glfwInit())
    return -1;

  // setting an error callback.

  // create a windowed mode window with opengl context
  // normally widow creation won't fail, but it's possible that the context
  // creation failed due to driver support.
  if (!(window = glfwCreateWindow(640, 480, "Hello World", nullptr, nullptr))) {
    glfwTerminate();
    return -1;
  }

  // set minial version hint
  glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);
  glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);

  // make the window's context the current context.
  glfwMakeContextCurrent(window);

  // register the error callback.
  glfwSetErrorCallback(error_callback);
  glfwSetWindowCloseCallback(window, window_close_callback);
  glfwSetKeyCallback(window, key_callback);

  glewExperimental = GL_TRUE;
  glewInit();

  // get version info
  glEnable(GL_DEPTH_TEST); // enable depth testing.
  glDepthFunc(GL_LEFT);    // depth-testing interpretes small value as closer.

  // loop til it's closed
  // this function just check the windows closing flag.
  while (!glfwWindowShouldClose(window)) {
    // renders stuffs
    int width, height;
    glfwGetFramebufferSize(window, &width, &height);
    glViewport(0, 0, width, height);

    glClear(GL_COLOR_BUFFER_BIT);
    glfwSwapBuffers(window);
    glfwPollEvents();
  }

  glfwTerminate();

  return 0;
}
module HendersonHasselbalch where

-- ph and pka

-- - conjugate acid and conjugate base.
--   conjugate acid: being able to give away proton.
--   conjugate base: being able to take proton.
--   e.g HF/F- is a conjugate pair.

-- - for buffer solution we want the ph to be stable at certain ph.
--   solution with conjugate pair can rebalance the ph when acid or base is
--   added into the solution.

log10 = logBase 10.0

ka :: [Float] -> [Float] -> Float
ka reactants products = product reactants / product products

-- some definitional equations.
ph' :: Float -> Float
ph' h3o = - (log10 h3o)

pka' :: Float -> Float -> Float -> Float
pka' h3o conjugateBase conjugateAcid = ph' h3o - log10 (conjugateBase / conjugateAcid)

-- HendersonHasselbalch
-- calculate ph from pka and log of the ratio of molarity of conjugat pair

ph :: Float -> Float -> Float -> Float
ph pka conjugateBase conjugateAcid = pka + log10 (conjugateBase / conjugateAcid)

-- Thymol Blue
-- H2Ln + H20 <=> H3O+ + Ln-
-- H2Ln -> red
-- HLn- -> yellow
-- Ln2- -> blue

-- Beer's law
-- A = εcl
-- where ε: molar absorbance coefficient
--       c: concentration of sample
--       l: path length

module Iso where

-- function contained in netype better to be isomorphic.
-- to the type it wraps.

type Iso a b = (a -> b, b -> a)

newtype Sum a = Sum {getSum :: a}

isoCheck ::  Iso a (Sum a)
isoCheck = (Sum, getSum)

module Listy where

newtype Listy a = Listy [a] deriving (Eq, Show)
module ListyInstances where

import Data.Monoid
import Listy

instance Monoid (Listy a) where
    mempty = Listy []

instance Semigroup (Listy a) where
    Listy [] <> Listy [] = Listy []
    Listy a <> Listy [] = Listy a
    Listy [] <> Listy a = Listy a
    Listy a <> Listy a' = Listy (a <> a')


module Main where

main :: IO ()
main = putStrLn "Hello, Haskell!"
import Distribution.Simple
main = defaultMain
module Addition where

import Test.Hspec
import Test.QuickCheck

divBy :: Integral a => a -> a -> (a, a)
divBy num denom = go num denom 0
    where go n d count
            | n < d = (count, n)
            | otherwise = go (n - d) d (count + 1)

mul :: (Eq a, Num a) => a -> a -> a
mul a b
  | a == 0 = b
  | otherwise = mul (a - 1) (a * b)

-- return a Generator type Gen Int
-- return return a monad with value Int
trivialInt :: Gen Int
trivialInt = return 1

-- elements return one value from
oneToFive :: Gen Int
oneToFive = elements [1, 2, 3, 4, 5]

genBool :: Gen Bool
genBool = choose (False, True)

genBool' :: Gen Bool
genBool' = elements [False, True]

genOrdering :: Gen Ordering
genOrdering = elements [LT, EQ, GT]

genTuple :: (Arbitrary a, Arbitrary b) => Gen (a, b)
genTuple = do
    a <- arbitrary
    b <- arbitrary
    return (a, b)

genChar :: Gen Char
genChar = elements ['a'..'z']

genEither :: (Arbitrary a, Arbitrary b) => Gen (Either a b)
genEither = do
    a <- arbitrary
    b <- arbitrary
    elements [Left a, Right b]

genMaybe :: Arbitrary a => Gen (Maybe a)
genMaybe = do
    a <- arbitrary
    elements [Nothing, Just a]

-- using quickcheck without hspec
prop_additionGreater :: Int -> Bool
prop_additionGreater x = x + 1 > x

runQc :: IO ()
runQc = quickCheck prop_additionGreater


main :: IO ()
main = hspec $ do
    describe "+" $ do
        it "1 + 1 is greater than 1" $ do
            (1 + 1) > 1 `shouldBe` True
        it "2 + 2 is equal to 4" $ do
            2 + 2 `shouldBe` 4
    describe "divBy" $ do
        it "15 divided by 3 is 5" $ do
            divBy 15 3 `shouldBe` (5, 0)
        it "22 divided by 5 should be 4 reminder 2" $ do
            divBy 22 5 `shouldBe` (4 ,2)
    describe "mul" $ do
        it "2 multiply with 3 should be 6" $ do
            mul 2 3 `shouldBe` 6
    describe "property test" $ do
        it "x + 1 > x" $ do
            property $ \x -> x + 1 > (x :: Int)



module Array where

{-# OPTIONS_GHC -fglasgow-exts #-}

import Control.Monad.ST
import Data.Array
import Data.Array.IO
import Data.Array.ST
import Data.Array.Storable
import Foreign.C.Types
import Foreign.Ptr

-- immutable arrays
buildPair :: (Int, Int)
buildPair =
  let arr = listArray (1, 10) (repeat 37) :: Array Int Int
      arr' = arr // [(1, 64)]
   in (arr ! 1, arr' ! 1)

-- mutable IO arrays
-- sikilar to IORefs
ioarray = do
  arr <- newArray (1, 10) 37 :: IO (IOArray Int Int)
  a <- readArray arr 1
  writeArray arr 1 64
  b <- readArray arr 1
  print (a, b)

-- mutable array in ST monad
-- ST is more general version of IO
buildPairST = do
  arr <- newArray (1, 10) 37 :: ST s (STArray s Int Int)
  a <- readArray arr 1
  writeArray arr 1 64
  b <- readArray arr 1
  return (a, b)

-- freezing and thawing
-- conversion between immutable and mutable arrays with freeze and thaw
-- convert array into STArray, alters it, and converts it back.
modifyAsST :: Array Int Int -> Array Int Int
modifyAsST arr = runST $
  do starr <- thaw arr
     compute starr
     newarr <- freeze starr
     return newarr

compute :: STArray s Int Int -> ST s ()
compute arr = do writeArray arr 1 64

-- storable array is an IO mutable array which stores its contents in a contiguous memory block living
-- in the C heap. Elements are stored according to the class 'Storable'. You can obtain the pointer to
-- the array contents to manipulate elements from languages like C.
-- It's slower than IOUArray but it can be passed to C routine.
-- The pointer to the array contentes is obtained by 'withStorableArray'. The idea is similar to
-- `ForeignPtr`. The pointer should be used only during execution of the IO action returned by the
-- function passed as argument to `withStorableArray`
runStorage = do
  arr <- newArray (1, 10) 37 :: IO (StorableArray Int Int)
  a <- readArray arr 1
  withStorableArray arr
    (\ptr -> memset ptr 0 40)
  b <- readArray arr 1
  print (a, b)

foreign import ccall unsafe "string.h"
  memset :: Ptr a -> CInt -> CSize -> IO ()
module Ch10 where

-- write functions with fold

myAnd :: [Bool] -> Bool
myAnd = foldr (&&) True

myOr :: [Bool] -> Bool
myOr = foldr (||) False

myAny :: (a -> Bool) -> [a] -> Bool
myAny f xs = myOr (map f xs)

myElem :: Eq a => a -> [a] -> Bool
myElem e xs = myOr (map (== e) xs)

myReverse :: [a] -> [a]
myReverse = foldl (flip (:)) []

myMap :: (a -> b) -> [a] -> [b]
myMap f = foldr ((:) . f) []

myFilter :: (a -> Bool) -> [a] -> [a]
myFilter pred = foldr (\x y -> case pred x of
                                 True -> x:y
                                 False -> y) []

squish :: [[a]] -> [a]
squish = foldr (++) []

squishMap :: (a -> [b]) -> [a] -> [b]
squishMap f = foldr (++) [] . map f

squishAgain :: [[a]] -> [a]
squishAgain = squishMap id

myMaximumBy :: (a -> a -> Ordering) -> [a] -> a
myMaximumBy comp xs = foldr (\a b -> if comp a b == GT then a else b) (head xs) xs











module Ch11 where

import Data.Char

capitalizeWord :: String -> String
capitalizeWord (x:xs) = (toUpper x) : xs





module Ch12 where

-- string processing

notThe :: String -> Maybe String
notThe s =
    if s == "The" || s == "the"
       then Nothing
    else Just s

tokenize :: String -> [String]
tokenize str = go str ""
    where
        go "" acc = (reverse acc) : []
        go (a:as) acc
          | a == ' ' = (reverse acc) : (go as "")
          | otherwise = go as (a : acc)

hasVowel :: String -> Bool
hasVowel "" = False
hasVowel (x:xs) =
    let vowels = "aeiou"
     in (elem x vowels) || hasVowel xs


replaceThe :: String -> String
replaceThe s =
    let tokens = tokenize s
     in concat (foldr (\x y -> case notThe x of
                         Nothing -> "a " : y
                         _ -> x : " ": y)
              [] tokens)

countTheBeforeVowel :: String -> Integer
countTheBeforeVowel s =
    let tokens = tokenize s
     in foldr (\x y -> case () of
                         _ | notThe x == Nothing -> 1 + y
                           | hasVowel x -> 0
                           | otherwise -> y)
        0 tokens

countVowels :: String -> Integer
countVowels "" = 0
countVowels (x:xs) =
    if elem x "aeiou"
       then 1 + countVowels xs
    else countVowels xs

countConsonants :: String -> Integer
countConsonants s = (fromIntegral . length $ s) - (countVowels s)

newtype Word' =
    Word' String
    deriving (Eq, Show)

mkWord :: String -> Maybe Word'
mkWord w
  | countVowels w > countConsonants w = Nothing
  | otherwise = Just $ Word' w

-- Natural number
data Nat =
    Zero
  | Succ Nat
  deriving (Eq, Show)

natToInteger :: Nat -> Integer
natToInteger Zero = 0
natToInteger (Succ xs) = (+1) . natToInteger $ xs

integerToNat :: Integer -> Maybe Nat
integerToNat n
  | n < 0 = Nothing
  | otherwise = Just (go n)
        where
            go n
                | n == 0 = Zero
                | otherwise = Succ (go (n - 1))

-- lib for Maybe, some catamorphism here.
isJust :: Maybe a -> Bool
isJust (Just _) = True
isJust _ = False

isNothing :: Maybe a -> Bool
isNothing x = not (isJust x)

mayybee :: b -> (a -> b) -> Maybe a -> b
mayybee z f (Just m) = (f m)
mayybee z f Nothing = z

fromMaybe :: a -> Maybe a -> a
fromMaybe z (Just x) = x
fromMaybe z Nothing = z

catMaybes :: [Maybe a] -> [a]
catMaybes [] = []
catMaybes (x:xs) = case x of
                     Nothing -> catMaybes xs
                     (Just a) -> a : catMaybes xs

flipMaybe :: Eq a => [Maybe a] -> Maybe [a]
flipMaybe [] = Just []
flipMaybe t@(x:xs)
  | any (==Nothing) t = Nothing
  | otherwise = Just (go (x:xs))
        where
            go [] = []
            go (Just a:as) = a : go as

-- lib for Either
lefts :: [Either a b] -> [a]
lefts [] = []
lefts (x:xs) = case x of
                 (Left a) -> a : lefts xs
                 _ -> lefts xs

rights :: [Either a b] -> [b]
rights xs = foldr (\x y -> case x of
                             (Right a) -> a : y
                             _ -> y)
            [] xs

partitionEithers :: [Either a b] -> ([a], [b])
partitionEithers xs = go xs ([], [])
    where
        go [] acc = acc
        go (a:as) (l1, l2) =
            case a of
              (Left a) -> go as (a:l1, l2)
              (Right a) -> go as (l1, a:l2)

eitherMaybe :: (b -> c) -> Either a b -> Maybe c
eitherMaybe f (Right e) = Just $ f e
eitherMaybe f (Left _) = Nothing

either' :: (a -> c) -> (b -> c) -> Either a b -> c
either' aToc _ (Left a) = aToc a
either' _ bToc (Right b) = bToc b

-- write your own iterate and unfoldr, anamorphism.
myIterate :: (a -> a) -> a -> [a]
myIterate f z = z : myIterate f (f z)

myUnfoldr :: (b -> Maybe (a, b)) -> b -> [a]
myUnfoldr f z =
    case (f z) of
      Just (a, b) -> a : myUnfoldr f b
      Nothing -> []

-- binary tree practices.
data BinaryTree a =
    Leaf
  | Node (BinaryTree a) a (BinaryTree a)
  deriving (Eq, Ord, Show)

unfoldTree :: (a -> Maybe (a, b, a)) -> a -> BinaryTree b
unfoldTree f x =
    case (f x) of  -- unpack the return value!
      Nothing -> Leaf
      Just (a, b, c) -> Node (unfoldTree f a) b (unfoldTree f c)

treeBuild :: Integer -> BinaryTree Integer
treeBuild 0 = Leaf
treeBuild n =
    unfoldTree (\x -> if x >= n
                         then Nothing  -- very expressive here.
                      else Just (x+1, x, x+1)) 0




















module Ch3 where


addExclimationMark :: String -> String
addExclimationMark n = n ++ "!"

get4thChar :: String -> Char
get4thChar n = n !! 4

takeLastWord :: String -> String
takeLastWord n = drop 9 (addExclimationMark n)

thirdLetter :: String -> Char
thirdLetter x = x !! 2

letterIndex :: Int -> Char
letterIndex x = str !! x
                where str = "Curry is awesome!"






module Ch4  where

len :: [a] -> Integer
len [] = 0
len (x:xs) = 1 + len xs

-- pattern matching.
isPalindrome :: String -> Bool
isPalindrome "" = True
isPalindrome s =
    if reverse s == s  -- if-eles-then is expression.
       then True
    else
        False

absolute n =
    if n < 0
        then negate n
    else n

-- type alias.
type Name = String
-- data decalaration.
-- type constructor and data constructor.
data Pet = Cat | Dog Name

zipwap :: (a, b) -> (c, d) -> ((b, d), (a, c))
zipwap t1 t2 = (,) ((,) (snd t1) (snd t2)) ((,) (fst t1) (fst t2))

theHead :: [a] -> a
theHead = \ (x:xs) -> x


first :: (a, b) -> a
first = \ (a, b) -> a

-- polymorphism
-- parametric polymorphism
identity :: a -> a
identity = \x -> x

-- constrained polymorphism
-- bounded by the set of types with insance of Eq typeclass
isEqual :: Eq a => a -> a -> Bool
isEqual x y = x == y

{-# LANGUAGE NoMonomorphismRestriction #-}

module Ch5 where


example = 1

f1 :: Num a => a
f1 = (* 9) 6

f2 :: Num a => (a, String)
f2 = head [(0, "doge"), (1, "kitteh")]

f3 :: (Integer, String)
f3 = head [(0 :: Integer, "doge"), (1, "kitteh")]

f4 :: Bool
f4 = if False then True else False

f5 :: Int
f5 = length [1, 2, 3, 4, 5]

f6 :: Bool
f6 = (length [1, 2, 3, 4]) > (length "TACOCAT")

myFunc :: (x -> y)
       -> (y -> z)
       -> c
       -> (a, x)
       -> (a, z)
myFunc xToy yToz _ (a, x) = (a, (yToz (xToy x)))

-- e1
f :: Int -> String
f = undefined

g :: String -> Char
g = undefined

h :: Int -> Char
h i = g (f i)

-- e2
data A
data B
data C

q :: A -> B
q = undefined

w :: B -> C
w = undefined

e :: A -> C
e a = w (q a)

-- e3
data X
data Y
data Z

xz :: X -> Z
xz = undefined

yz :: Y -> Z
yz = undefined

xform :: (X, Y) -> (Z, Z)
xform (x, y) = (xz x, yz y)

-- e4
munge :: (x -> y) -> (y -> (w, z)) -> x -> w
munge xToy yTowz x = fst (yTowz (xToy x))

module Ch6 where

-- 1.
data Person = Person String deriving Show
printPerson :: Person -> IO ()
printPerson person = putStrLn (show person)

-- 2.
data Mood = Blah
          | Woot deriving (Show, Eq)

settleDown :: Mood ->  Mood
settleDown x =
    if x == Woot
       then Blah
    else x

-- 3.
type Subject = String
type Verb = String
type Object = String

data Sentence =
    Sentence Subject Verb Object
    deriving (Eq, Show)

-- given datatype delacaration
data Rocks =
    Rocks String deriving (Eq, Show)

data Yeah =
    Yeah Bool deriving (Eq, Show)

data Papu =
    Papu Rocks Yeah
    deriving (Eq, Show)

-- anonymous functions
addOneIfOdd n = case odd n of
    True -> f n
    False -> n
    where f = \n -> n + 1

addFive = \x -> \y -> (if x > y then y else x) + 5

mflip f x y = f y x


-- pattern matching
isItTwo :: Integer -> Bool
isItTwo 2 = True
isItTwo _ = False


module Ch7 where

-- Ex variety pack
k :: (a, b) -> a
k (x, y) = x

f :: (a, b, c) -> (d, e, f) -> ((a, d), (c, f))
f (a, b, c) (d, e, f) = ((a, d), (c, f))


-- Case expressions
functionC x y =
    case isBigger of
      True -> x
      False -> y
    where isBigger = x > y

ifEvenAdd2 n =
    case even n of
      True -> n + 2
      False -> n

nums x =
    case compare x 0 of
      LT -> -1
      GT -> 1
      _ -> 0

foldBoolCase :: a -> a -> Bool -> a
foldBoolCase x y t =
    case t of
        True -> x
        False -> y

foldBoolGuard :: a -> a -> Bool -> a
foldBoolGuard x y t
  | t = x
  | otherwise = y

foldBoolPatternMatch :: a -> a -> Bool -> a
foldBoolPatternMatch x y True = x
foldBoolPatternMatch x y False = x

g :: (a -> b) -> (a, c) -> (b, c)
g f (a, c) = (f . fst $ (a, c), c)

roundTrip :: (Show a, Read a) => a -> a
roundTrip a = read (show a)

roundTripPointFree :: (Show a, Read a) => a -> a
roundTripPointFree = read . show

-- ex pattern matching is about the data.
data SumOfThree a b c =
    FirstPossible a
  | SecondPossible b
  | ThirdPossible c
  deriving (Eq, Show)

sumToInt :: SumOfThree a b c -> Integer
sumToInt (FirstPossible _) = 0
sumToInt (SecondPossible _) = 0
sumToInt (ThirdPossible _) = 0

module Ch9 where

import Data.Char

-- list pattern matching
myTail :: [a] -> [a]
myTail [] = []
myTail (_:xs) = xs

-- with Maybe
safeTail :: [a] -> Maybe [a]
safeTail [] = Nothing
safeTail (x:[]) = Nothing
safeTail (_:xs) = Just xs

safeHead :: [a] -> Maybe a
safeHead [] = Nothing
safeHead (x:_) = Just x

-- enum
tokenize :: Char -> String -> [String]
tokenize delimiter = splitWords . dropWhile (== delimiter)
    where
        splitWords "" = []
        splitWords s =
            let word = takeWhile (/= delimiter) s
                (_, rest) = splitAt (length word) s
            in word : splitWords (dropWhile (== delimiter) rest)

-- list comperhension
hasVow :: String -> Maybe [Char]
hasVow xs = out res
    where
        res = [x | x <- xs, elem x "aeiou"]
        out s
          | s == [] = Nothing
          | otherwise = Just s

mySqr = [x^2 | x <- [1..5]]
myCube = [x^3 | x <- [1..5]]

len :: [a] -> Integer
len [] = 0
-- pattern match on the : constructor.
len (_:xs) = 1 + len xs

mySum :: Num a => [a] -> a
mySum [] = 0
mySum (x:xs) = x + mySum xs

myMap :: (a -> b) -> [a] -> [b]
myMap _ [] = []
myMap f (x:xs) = f x : myMap f xs

myFilter :: (a -> Bool) -> [a] -> [a]
myFilter _ [] = []
myFilter pred (x:xs)
  | pred x = x : myFilter pred xs
  | otherwise = myFilter pred xs

-- exercises
capitalize :: String -> String
capitalize "" = ""
capitalize (x:xs) = toUpper x : xs

capAll :: String -> String
capAll "" = ""
capAll (x:xs) = toUpper x : capAll xs

capHead :: String -> Maybe Char
capHead "" = Nothing
capHead x = Just (toUpper . head $ x)

-- practices
myAnd :: [Bool] -> Bool
myAnd [] = True
myAnd (x:xs) = if x == False then False else myAnd xs

myOr :: [Bool] -> Bool
myOr [] = False
myOr (x:xs) = if x == True then True else myOr xs

myAny :: (a -> Bool) -> [a] -> Bool
myAny f xs = myOr. map f $ xs

myElem :: Eq a => a -> [a] -> Bool
myElem _ [] = False
myElem e (x:xs) = if e == x then True else myElem e xs

myReverse :: [a] -> [a]
myReverse [] = []
myReverse (x:xs) = myReverse xs ++ [x]

squishMap :: (a -> [b]) -> [a] -> [b]
squishMap f (x:xs) = concat . go f $ (x:xs)
    where go f [] = []
          go f (x:xs) = f x : go f xs

squishAgain :: [[a]] -> [a]
squishAgain nestedList = squishMap id nestedList




{-# LANGUAGE DeriveFunctor #-}

module Cont where

import Control.Monad

newtype Cont r a = Cont {runCont :: (a -> r) -> r} deriving (Functor)

instance Applicative (Cont r) where
  pure = return
  (<*>) = ap

instance Monad (Cont r) where
  return a = Cont ($ a)
  Cont s >>= f = Cont $ \k ->
    s $ \x ->
      runCont (f x) $ k

callCC :: ((a -> Cont r b) -> Cont r a) -> Cont r a
callCC f = Cont $ \h -> runCont (f (\a -> Cont $ \_ -> h a)) h
{-# LANGUAGE GeneralizedNewtypeDeriving #-}

module Coroutine where

import Control.Applicative
import Control.Monad.Cont
import Control.Monad.State

-- coroutine is a ContT stacked with a StateT containing the suspend coroutines.
newtype CoroutineT r m a = CoroutineT
  {runCoroutineT' :: ContT r (StateT [CoroutineT r m ()] m) a}
  deriving (Functor, Applicative, Monad, MonadCont, MonadIO)

-- manipulate coroutine queue.
getCCs :: Monad m => CoroutineT r m [CoroutineT r m ()]
getCCs = CoroutineT $ lift get

putCCs :: Monad m => [CoroutineT r m ()] -> CoroutineT r m ()
putCCs = CoroutineT . lift . put

dequeue :: Monad m => CoroutineT r m ()
dequeue = do
  currentCCs <- getCCs
  case currentCCs of
    [] -> return ()
    (p : ps) -> do
      putCCs ps
      p

queue :: Monad m => CoroutineT r m () -> CoroutineT r m ()
queue p = do
  ccs <- getCCs
  putCCs (ccs ++ [p])

yield :: Monad m => CoroutineT r m ()
yield = callCC $ \k -> do
  queue (k ())
  dequeue

fork :: Monad m => CoroutineT r m () -> CoroutineT r m ()
fork p = callCC $ \k -> do
  queue (k ())
  p
  dequeue

exhaust :: Monad m => CoroutineT r m ()
exhaust = do
  exhausted <- null <$> getCCs
  if not exhausted
    then yield >> exhaust
    else return ()

runCoroutineT :: Monad m => CoroutineT r m r -> m r
runCoroutineT = flip evalStateT [] . flip runContT return . runCoroutineT' . (<* exhaust)

ex :: IO ()
ex = runCoroutineT $ do
  fork $ replicateM_ 3 (printOne 3)
  fork $ replicateM_ 4 (printOne 4)
  replicateM_ 2 (printOne 2)
  where
    printOne n = do
      liftIO (print n)
      yield
module Main where

import Control.Monad
import Control.Monad.Trans.Cont

main :: IO ()
main = putStrLn "Hello, Haskell!"

-- make a new continuation
square :: Int -> Cont r Int
square n = return (n ^ 2)

-- simply simply return
squareCC :: Int -> Cont r Int
squareCC n = callCC $ \k -> k (n ^ 2)

-- early return
foo :: Int -> Cont r String
foo x = callCC $ \k -> do
  let y = x ^ 2 + 3
  when (y > 20) $ k "here"
  return $ show $ y

-- act like goto
bar :: Char -> String -> Cont r Int
bar c s = do
  msg <- callCC $ \k -> do
    let s0 = c : s
    when (s0 == "saying Hello") $ k "hello"
    let s1 = show s0
    return ("saying" ++ s1)
  return (length msg)

quux :: Cont r Int
quux = callCC $ \k -> do
  let n = 5
  k n
  return 25 -- this line will never execute.

-- complicated control flow.
fun :: Int -> String
fun n = (`runCont` id) $ do
  str <- callCC $ \exit1 -> do
    when (n < 10) (exit1 (show n))
    let ns = map digitToInt (show (n `div` 2))
    n' <- callCC $ \exit2 -> do
      when ((length ns) < 3) (exit2 (length ns))
      when ((length ns) < 5) (exit2 n)
      when ((length ns) < 7) $ do
        let ns' = map intToDigit (reverse ns)
        exit1 (dropWhile (== '0') ns')
      return $ sum ns
    return $ "(ns = " ++ (show ns) ++ ") " ++ (show n)
  return $ "Answer: " ++ str
  where
    digitToInt :: Char -> Int
    digitToInt n = read $ n : []
    intToDigit :: Int -> Char
    intToDigit = head . show

-- exception
divExcept :: Int -> Int -> (String -> Cont r Int) -> Cont r Int
divExcept x y handler = callCC $ \ok -> do
  err <- callCC $ \notOk -> do
    when (y == 0) $ notOk "Denominator 0"
    ok $ x `div` y
  handler err
module PatternMatching where

type BoolCPS r = r -> r -> r


true :: BoolCPS r
true x _ = x

false :: BoolCPS r
false _ x = x

check :: BoolCPS String -> String
check b = b "It's true" "It's false"
import Distribution.Simple
main = defaultMain
import Distribution.Simple
main = defaultMain
module Main where

import Control.Monad (forever)
import Data.Char (toLower)
import Data.Maybe (isJust)
import Data.List (intersperse)
import System.Exit (exitSuccess)
import System.Random (randomRIO)


type WordList = [String]

minWordLen = 5 :: Int
maxWordLen = 9 :: Int

allWords :: IO WordList
allWords = do
    dict <- readFile "data/dict.txt"
    return (lines dict)


gameWords :: IO WordList
gameWords = do
    aw <- allWords
    return (filter gameLen aw)
    where gameLen w =
            let l = length (w :: String)
             in l > minWordLen && l < maxWordLen

randomWord :: WordList -> IO String
randomWord wl = do
    randomIndex <- randomRIO (0, (length wl) - 1)
    return $ wl !! randomIndex

randomWord' :: IO String
randomWord' = gameWords >>= randomWord

data Puzzle = Puzzle String [Maybe Char] [Char]

instance Show Puzzle where
    show (Puzzle _ discovered gussed) =
        (intersperse ' ' $ fmap renderPuzzleChar discovered)
        ++ " Gussed so far: " ++ gussed

freshPuzzle :: String -> Puzzle
freshPuzzle s = Puzzle s (map (const Nothing) s) []

charInWord :: Puzzle -> Char -> Bool
charInWord (Puzzle w _ _) c = elem c w

alreadyGussed :: Puzzle -> Char -> Bool
alreadyGussed (Puzzle _ _ gussed) c = elem c gussed

renderPuzzleChar :: Maybe Char -> Char
renderPuzzleChar Nothing = '_'
renderPuzzleChar (Just c) = c

fillInCharacter :: Puzzle -> Char -> Puzzle
fillInCharacter (Puzzle word filledInSoFar s) c =
    Puzzle word newFilledInSoFar (c:s)
    where
        zipper guessed wordChar guessChar =
            if wordChar == guessed
               then Just wordChar
            else guessChar

        newFilledInSoFar =
            zipWith (zipper c) word filledInSoFar

handleGUess :: Puzzle -> Char -> IO Puzzle
handleGUess puzzle guess = do
    putStrLn $ "Your guess was:" ++ [guess]
    case (charInWord puzzle guess , alreadyGussed puzzle guess) of
      (_, True) -> do
          putStrLn "You already guessed that\
                    \ character, pick something else!"
          return puzzle
      (True, _) -> do
          putStrLn "This character was in the word,\
                   \ filling in the word accordingly."
          return (fillInCharacter puzzle guess)
      (False, _) -> do
          putStrLn "This character wasn't in the word, try again."
          return (fillInCharacter puzzle guess)

gameOver :: Puzzle -> IO ()
gameOver (Puzzle wordToGuess _ guessed) =
    if (length guessed) > 20
       then do putStrLn "You lose!"
               putStrLn $ "The word was: " ++ wordToGuess
               exitSuccess
       else return ()

gameWin :: Puzzle -> IO ()
gameWin (Puzzle wordToGuess filledInSoFar _) =
    if all isJust filledInSoFar
       then do putStrLn $ "You win! " ++ wordToGuess
               exitSuccess
    else return ()

runGame :: Puzzle -> IO ()
runGame puzzle = forever $ do
    gameOver puzzle
    gameWin puzzle
    putStrLn $ "Current puzzle is: " ++ show puzzle
    putStr "Guess a letter: "
    guess <- getLine
    case guess of
      [c] -> handleGUess puzzle c >>= runGame
      _ -> putStrLn "Your guess must be a single character."

main :: IO ()
main = do
    word <- randomWord'
    let puzzle = freshPuzzle (fmap toLower word)
    runGame puzzle



import Distribution.Simple
main = defaultMain
module Main where

import Lib
import Network.Wreq
import qualified Data.ByteString.Lazy as BS

urls :: [String]
urls = [ "https://hvaccloud.org:5000/view/project/generic"
       , "https://hvaccloud.org:5000/view/2/spots"]

mappingGet :: [IO (Response BS.ByteString)]
mappingGet = map get urls

traversedUrls :: IO [Response BS.ByteString]
traversedUrls = traverse get urls


module Lib
    ( someFunc
    ) where



someFunc :: IO ()
someFunc = putStrLn "someFunc"
main :: IO ()
main = putStrLn "Test suite not yet implemented"
module Main where

main :: IO ()
main = putStrLn "Hello, Haskell!"

module QuickSort where

import Control.Monad
import Control.Monad.ST
import Control.Monad.State
import Control.Monad.Trans
import Data.Array.ST
import Data.Array
import Data.Array.Unsafe
import System.Random

-- slow quick sort
-- this will copy memory for each upate
quicksortSlow :: (Ord a) => [a] -> [a]
quicksortSlow [] = []
quicksortSlow (x : xs) = left ++ [x] ++ right
  where
    left = quicksortSlow $ filter (<= x) xs
    right = quicksortSlow $ filter (> x) xs

-- in place quick sort with ST monad
swap :: STArray s Int a -> Int -> Int -> ST s ()
swap arr i j = do
  a <- readArray arr i
  b <- readArray arr j
  writeArray arr i b
  writeArray arr j a

partition' :: (Ord a) => STArray s Int a -> a -> Int -> StateT Int (ST s) ()
partition' arr pivot i = do
  pivotIdx <- get
  this <- lift $ readArray arr i
  when (this < pivot) $ do
    lift $ swap arr i pivotIdx
    put (pivotIdx + 1)

-- partition loop
partition ::
  (Ord a) => STArray s Int a -> Int -> Int -> ST s Int
partition arr start end = do
  pivot <- readArray arr start
  let pivotIdx0 = start + 1
  finalPivotIdx <-
    execStateT
      (mapM (partition' arr pivot) [(start + 1) .. (end - 1)])
      pivotIdx0
  swap arr start (finalPivotIdx - 1)
  return $ finalPivotIdx - 1

-- end the ST effect here.
quicksortHelper :: (Ord a) => Int -> Int -> STArray s Int a -> ST s ()
quicksortHelper start end stArr = when (start + 1 < end) $ do
  pivotIdx <- partition stArr start end
  quicksortHelper start pivotIdx stArr
  quicksortHelper (pivotIdx + 1) end stArr

-- provides a pure interface
quicksort :: (Ord a) => Array Int a -> Array Int a
quicksort arr = runSTArray $ do
  stArr <- thaw arr
  let (min, max) = bounds arr
  quicksortHelper min (max + 1) stArr
  return stArr

quicksort1 arr = runSTArray


-- a randome array for testing.
randomArray :: IO (Array Int Int)
randomArray = do
  randoms <- replicateM 100 $ randomRIO (1, 1000)
  return $ array (1, 100) (zip [1 .. 100] randoms)
import Distribution.Simple
main = defaultMain
module Main where

main :: IO ()
main = putStrLn "Hello, Haskell!"
import Distribution.Simple
main = defaultMain
import Distribution.Simple
main = defaultMain
module Main where

import           HttpClientX
import           HsLuaX
import           LuaCallback
import qualified Foreign.Lua                   as Lua

main :: IO ()
main = do
  --httpclientRun
  print "-----------------------------------"
  print "runLuaScript"
  runLuaScript
  print "runCallLuaFromHs"
  runCallLuaFromHs
  print "runCallHsFromLua"
  runCallHsFromLua
  print "lua callbacks"
  luaCallbackRun

  print "-----------------------------------"

local function c1()
  print("callback 1")
  return "callback 1 return value"
end

local function c2()
  print("callback 2")
  return false
end

local function c3()
  print("callback 3")
  return 3
end

local function cfails()
  print("Failing from lua")
  error("failed")
end


print("begin>")
addLuaCallbacks(c1, c2)
callLuaCallbacks()
print("reset")
resetLuaCallbacks()
callLuaCallbacks()
print("add callbacks in reverse order")
addLuaCallbacks(c3)
addLuaCallbacks(c2)
addLuaCallbacks(c1)
addLuaCallbacks(cfails)
local callbackrets = callLuaCallbacks()
for _, v in ipairs(callbackrets) do
  print(v)
end
print("end...")
username = os.getenv("USER") or "God"
password = os.getenv("PWD") or "dontdisturb"

function getuserpwd (site)
  local cookies = { ["www.a.com"] = {"joe", "god"}
                  , ["www.b.com"] = {"hoe", "godness"}
                  }
  if cookies[site] then
    return cookies[site]
  elseif site:match("[.]c[.]com$") then
    return {"boss", "boss"}
  else
    return { username
           , password }
  end
end
print("game")
print("hi")
for i=1,3 do
  print(move(1, "forward"))
  print(move(2, "forward"))
end
{-# LANGUAGE OverloadedStrings #-}
module HsLuaX where

import qualified Foreign.Lua as Lua
import Data.ByteString.Char8
import qualified Data.ByteString as B

runLuaScript :: IO ()
runLuaScript = Lua.run $ do
  Lua.openlibs
  Lua.dofile "lua/configfile.lua"
  name <- Lua.getglobal "username" *> Lua.peek (-1)
  pwd <- Lua.getglobal "password" *> Lua.peek (-1)
  Lua.liftIO $ print (name :: String, pwd :: String)

runCallLuaFromHs :: IO ()
runCallLuaFromHs = Lua.run $ do
  Lua.openlibs
  Lua.dofile "lua/configfile.lua"
  (name, pwd) <- Lua.callFunc "getuserpwd" ("mail.google.com" :: String)
  Lua.liftIO $ print (name :: String, pwd :: String)

hsMove :: Lua.Integer -> String -> Lua.Lua String
hsMove (Lua.Integer n) direction = return
  ("going " ++ show n ++ " step(s) " ++ direction)

runCallHsFromLua = Lua.run $ do
  Lua.openlibs
  Lua.registerHaskellFunction "move" hsMove
  Lua.loadfile "lua/game.lua"
  Lua.call 0 0


{-# LANGUAGE OverloadedStrings #-}
module HttpClientX where

import Control.Monad.IO.Class (liftIO)
import Control.Exception (try)
import System.IO (stdout)
import Network.HTTP.Simple
import Network.HTTP.Client (defaultManagerSettings, newManager)
import Network.HTTP.Client.TLS (tlsManagerSettings)
import qualified Data.ByteString.Lazy.Char8 as L8
import qualified Data.ByteString.Char8 as S8
import Data.Yaml as Yaml
import Data.Aeson (Value)
import qualified Data.Conduit.List as CL

httpclientRun:: IO ()
httpclientRun = do
  basic
  json
  buildreq
  buildbody
  catchFailedConnection
  streaming
  overrideproxy
  connManager

basic :: IO ()
basic = do
  response <- httpLBS "http://httpbin.org/get"
  putStrLn $ "The status code was: " ++
    show (getResponseStatusCode response)
  print $ getResponseHeader "Content-Type" response
  L8.putStrLn $ getResponseBody response

json :: IO ()
json = do
  response <- httpJSON "http://httpbin.org/get"
  putStrLn $ "The status code was" ++
    show (getResponseStatusCode response)
  print $ getResponseHeader "Content-Type" response
  S8.putStrLn $ Yaml.encode (getResponseBody response :: Value)

buildreq :: IO ()
buildreq = do
  request' <- parseRequest "POST http://httpbin.org/post"
  let request =
       setRequestMethod "PUT"
       $ setRequestPath "/put"
       $ setRequestQueryString [("hello", Just "world")]
       $ setRequestBodyLBS "This is my request body"
       $ setRequestSecure True
       $ setRequestPort 443 request'
  response <- httpJSON request
  putStrLn $ "The status code was" ++
    show (getResponseStatusCode response)
  print $ getResponseHeader "Content-Type" response
  S8.putStrLn $ Yaml.encode (getResponseBody response :: Value)

data Person = Person String Int
instance ToJSON Person where
  toJSON (Person name age) = object
    [ "name" .= name
    , "age"  .= age
    ]

people :: [Person]
people = [Person "Alice" 30, Person "Bob" 35, Person "Charlie" 40]

buildbody :: IO ()
buildbody = do
  let request = setRequestBodyJSON people "POST http://httpbin.org/post"
  response <- httpJSON request :: IO (Response Value)
  putStrLn $ "current status is " ++ show (getResponseStatusCode response)
  print $ getResponseHeader "Content-Type" response
  S8.putStrLn $ Yaml.encode (getResponseBody response)

catchFailedConnection :: IO ()
catchFailedConnection = do
  eresponse <- try $ httpLBS "http://does-not-exist"
  case eresponse of
    Left e -> print (e :: HttpException)
    Right response -> L8.putStrLn $ getResponseBody response

streaming :: IO ()
streaming = httpSink "http://httpbin.org/get" $ \response -> do
  liftIO $ putStrLn
         $ "The status code was: "
        ++ show (getResponseStatusCode response)
  CL.mapM_ (S8.hPut stdout)

overrideproxy :: IO ()
overrideproxy = do
  let request = setRequestProxy (Just (Proxy "127.0.0.1" 3128)) "https://httpbin.org/get"
  eresponse <- try $ httpLBS request
  case eresponse of
    Left e -> print (e :: HttpException)
    Right response -> do
      putStrLn $ "The status code was" ++
        show (getResponseStatusCode response)
      L8.putStrLn $ getResponseBody response

connManager :: IO ()
connManager = do
  manager <- newManager tlsManagerSettings
  let request = setRequestManager manager "https://httpbin.org/get"
  response <- httpLBS request
  putStrLn $ "The status code was: " ++
    show (getResponseStatusCode response)
  print $ getResponseHeader "Content-Type" response
  L8.putStrLn $ getResponseBody response




{-# LANGUAGE OverloadedStrings #-}
module LuaCallback where

import Data.IORef
import qualified Data.ByteString.Char8 as BC
import Control.Monad (void)
import Foreign.Lua

luaCallbackRun :: IO ()
luaCallbackRun = do
  callback <- newIORef []  -- create IORef. mutable values in IO monad.
  run $ do
    openlibs
    registerHaskellFunction "addLuaCallbacks" (addLuaCallbacks callback)
    registerHaskellFunction "callLuaCallbacks" (callLuaCallbacks callback)
    registerHaskellFunction "resetLuaCallbacks" (resetLuaCallbacks callback)
    void $ dofile "lua/callback.lua"

type LuaFunRef = Reference

-- put addCallbacks into ref list.
addLuaCallbacks :: IORef [LuaFunRef] -> Lua NumResults
addLuaCallbacks cs = do
  -- get the topmost index of argument
  args <- gettop
  as <- checkArgs args
  case as of
    Nothing -> do  -- no problem
      addCallbacks 1 args
      return 0
    Just errArg -> do
      pushstring $ BC.pack $  -- push string to the top
        "argument " ++ show errArg ++ " is not a function"
      return 1

    where
      -- check if all args are functions
      checkArgs :: StackIndex -> Lua (Maybe StackIndex)
      checkArgs 0 = return Nothing
      checkArgs n = do
        ty <- ltype n
        if ty == TypeFunction
           then checkArgs (n - 1)
           else return $ Just n

      -- arg is the range of index of arguments.
      addCallbacks :: StackIndex -> StackIndex -> Lua ()
      addCallbacks n maxIdx
        | n > maxIdx = return ()
        | otherwise = do
            pushvalue n
            refId <- ref registryindex
            liftIO $ modifyIORef cs (++ [refId])
            addCallbacks (n+1) maxIdx

callLuaCallbacks :: IORef [LuaFunRef] -> Lua NumResults
callLuaCallbacks cs = do
  cs' <- liftIO $ readIORef cs
  createtable (length cs') 0
  iter cs'
  return 1
    where
      iter [] = return ()
      iter (c:rest) = do
        getglobal' "table.insert"
        pushvalue (-2)
        getref registryindex c
        call 0 1
        call 2 0
        iter rest

resetLuaCallbacks :: IORef [LuaFunRef] -> Lua NumResults
resetLuaCallbacks cs = do
  cs' <- liftIO $ readIORef cs
  mapM_ (unref registryindex) cs'
  liftIO $ writeIORef cs []
  return 0

main :: IO ()
main = putStrLn "Test suite not yet implemented"
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE TemplateHaskell #-}
module HLearn.Cluster.KMedois where


import           Data.List
import           Data.Function                  ( on )
import qualified Data.Vector.Unboxed           as U
import qualified Data.Vector                   as Vec
import qualified Data.Vector.Mutable           as MVec
import           HLearn.Cluster.Error
import           HLearn.Cluster.Data
import           HLearn.Internal.Data
import           HLearn.Internal.Metric
import           Control.Monad.State
import           Control.Monad.Except
import           Control.Monad.Reader
import           Control.Monad.Trans.Except
import           System.Random
import qualified Lens.Micro.Platform           as L
import           Lens.Micro.Platform     hiding ( assign )


-- | record the best medoid and o in each cluster.
data LocalSwap = LocalSwap { _localSwapCi :: !Int
                           , _localSwapPi :: !Int
                           -- points associated with thecluster cneter
                           , _localSwapPoints :: ![Point]
                           }
L.makeLenses ''LocalSwap

limit = 100

data KMedoisEnv = KMedoisEnv { kmedEnvDim :: Int
                             , kmedEnvNum :: Int
                             , kmedPoints :: [Point]
                             , kmedEnvBound :: [(Double, Double)]
                             }

data KMedoisState = KMedoisState { kmedClusters :: [Cluster]
                                 , kmedCost :: Double
                                 }

type KMedois' a
  = ExceptT ClusterError (ReaderT KMedoisEnv (State KMedoisState)) a

newtype KMedois a = KMean { unKmean :: KMedois' a }
  deriving (Functor, Applicative, Monad, MonadState KMedoisState, MonadError ClusterError, MonadReader KMedoisEnv)

runKmedois :: KMedoisEnv -> IO (Either ClusterError [Cluster])
runKmedois env@(KMedoisEnv dim ncluster points _) = do
  initState <- (\cs -> KMedoisState cs 0.0) <$> initClusters
  return $ flip evalState initState $ flip runReaderT env $ runExceptT
    (unKmean kmedois)
 where
  initClusters = do
    idxs <- replicateM ncluster $ randomRIO (0, length points)
    return [ Cluster idx (points !! idx) [] | idx <- idxs ]  -- randomly choose

kmedois :: KMedois [Cluster]
kmedois = loop 0 0.0
 where
  loop n oldCost = do
    s@(KMedoisState clusters costImproved) <- get
    ncluster                               <- kmedEnvNum <$> ask
    when (ncluster > limit) $ do
      liftEither $ Left (ClusterInitError "too many clusters")
    clusters' <- step
    newCost   <- kmedCost <$> get
    if isCostImproved oldCost newCost
      then return clusters'
      else put (s { kmedClusters = clusters' }) >> loop (n + 1) newCost

step :: KMedois [Cluster]
step = assign >>= newCluster

-- for each medoids m and for each non medoids o
-- try swap m and o, compute the cost, keep the swap of the best cost.
-- then perform best swap of mbest and obest.
assign :: KMedois (Vec.Vector LocalSwap)
assign = do
  s@(KMedoisState clusters _)    <- get
  KMedoisEnv _ ncluster points _ <- ask
  let nearestCluster p =
        fst $ minimumBy (compare `on` snd) [ mkpair c p | c <- clusters ]
  return
    $ (Vec.create $ do
        vec <- MVec.replicate ncluster (LocalSwap 0 0 [])
        let
          addPoint p = do
            let c   = nearestCluster p
                cid = _clusterId c
            lswap <- MVec.read vec cid
            MVec.write vec cid $! addToLocalSwap lswap p
          doBestSwap c@(Cluster cid _ _) = do
            let (ci, pi) = localBestSwap c points s
            ps <- MVec.read vec cid
            MVec.write vec cid $! ps { _localSwapCi = ci, _localSwapPi = pi }
        mapM_ addPoint   points   -- add associated points to each local swaps
        mapM_ doBestSwap clusters -- try swap and record
        return vec
      )
  where mkpair c p = (c, sqDistance (_clusterCent c) p)

addToLocalSwap :: LocalSwap -> Point -> LocalSwap
addToLocalSwap lswap p = lswap & localSwapPoints %~ (\points -> p : points)

-- | Swap each point with the center in the same cluster, return the best swap.
localBestSwap :: Cluster -> [Point] -> KMedoisState -> (Int, Int)
localBestSwap (Cluster ci _ _) points s = fst $ minimumBy
  (compare `on` snd)
  [ let cost = getLocalCost $ swap (ci, pi) s in ((ci, pi), cost)
  | pi <- [0 .. length points]
  ]
 where
  swap (ci, pi) s@(KMedoisState clusters _) =  -- swap one point
    let pointsP = points !! pi
    in  s { kmedClusters = clusters & (ix ci) . clusterCent .~ pointsP }
  getLocalCost :: KMedoisState -> Double
  getLocalCost = undefined

isCostImproved :: Double -> Double -> Bool
isCostImproved old new | new - old < 0 = True
                       | otherwise     = False

localSwapToCluster :: Int -> LocalSwap -> Cluster
localSwapToCluster cid lswap@(LocalSwap ci si _) = undefined

-- | filter away clustser has no point closes to it.
newCluster :: Vec.Vector LocalSwap -> KMedois [Cluster]
newCluster vec = do
  points <- kmedPoints <$> ask
  let clusters :: [Cluster]
      clusters =
        [ localSwapToCluster i lswap
        | (i, lswap) <- [0 ..] `Prelude.zip` (Vec.toList vec)
        ]
      cost = getCost points clusters
  modify (\s -> s { kmedCost = cost })
  return clusters
 where
  getCost points clusters =
    sum [ euclideanDistance p c | (Cluster _ c _) <- clusters, p <- points ]

{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE TemplateHaskell #-}
module HLearn.Cluster.KMedois where


import           Data.List
import           Data.Function                  ( on )
import qualified Data.Vector.Unboxed           as U
import qualified Data.Vector                   as Vec
import qualified Data.Vector.Mutable           as MVec
import           HLearn.Cluster.Error
import           HLearn.Cluster.Data
import           HLearn.Internal.Data
import           HLearn.Internal.Metric
import           Control.Monad.State
import           Control.Monad.Except
import           Control.Monad.Reader
import           Control.Monad.Trans.Except
import           System.Random
import qualified Lens.Micro.Platform           as L
import           Lens.Micro.Platform     hiding ( assign )


-- | record the best medoid and o in each cluster.
data LocalSwap = LocalSwap { _localSwapCi :: !Int
                           , _localSwapPi :: !Int
                           -- points associated with the cluster cneter
                           , _localSwapPoints :: ![Point]
                           }
L.makeLenses ''LocalSwap

limit = 100

data KMedoisEnv = KMedoisEnv { kmedEnvDim :: Int
                             , kmedEnvNum :: Int
                             , kmedPoints :: [Point]
                             , kmedEnvBound :: [(Double, Double)]
                             }

data KMedoisState = KMedoisState { kmedClusters :: [Cluster]
                                 , kmedCost :: Double
                                 }

type KMedois' a
  = ExceptT ClusterError (ReaderT KMedoisEnv (State KMedoisState)) a

newtype KMedois a = KMean { unKmean :: KMedois' a }
  deriving (Functor, Applicative, Monad, MonadState KMedoisState, MonadError ClusterError, MonadReader KMedoisEnv)

runKmedois :: KMedoisEnv -> IO (Either ClusterError [Cluster])
runKmedois env@(KMedoisEnv dim ncluster points _) = do
  initState <- (\cs -> KMedoisState cs 0.0) <$> initClusters
  return $ flip evalState initState $ flip runReaderT env $ runExceptT
    (unKmean kmedois)
 where
  initClusters = do
    idxs <- replicateM ncluster $ randomRIO (0, length points)
    return [ Cluster idx (points !! idx) [] | idx <- idxs ]  -- randomly choose

kmedois :: KMedois [Cluster]
kmedois = loop 0 0.0
 where
  loop n oldCost = do
    s@(KMedoisState clusters costImproved) <- get
    ncluster                               <- kmedEnvNum <$> ask
    when (ncluster > limit) $ do
      liftEither $ Left (ClusterInitError "too many clusters")
    clusters' <- step
    newCost   <- kmedCost <$> get
    if isCostImproved oldCost newCost
      then return clusters'
      else put (s { kmedClusters = clusters' }) >> loop (n + 1) newCost

step :: KMedois [Cluster]
step = assign >>= newCluster

-- for each medoids m and for each non medoids o
-- try swap m and o, compute the cost, keep the swap of the best cost.
-- then perform best swap of mbest and obest.
assign :: KMedois (Vec.Vector LocalSwap)
assign = do
  s@(KMedoisState clusters _)    <- get
  KMedoisEnv _ ncluster points _ <- ask
  let nearestCluster p =
        fst $ minimumBy (compare `on` snd) [ mkpair c p | c <- clusters ]
  return
    $ (Vec.create $ do
        vec <- MVec.replicate ncluster (LocalSwap 0 0 [])
        let
          addPoint p = do
            let c   = nearestCluster p
                cid = _clusterId c
            lswap <- MVec.read vec cid
            MVec.write vec cid $! addToLocalSwap lswap p
          doBestSwap c@(Cluster cid _ _) = do
            let (ci, pi) = localBestSwap c points s
            ps <- MVec.read vec cid
            MVec.write vec cid $! ps { _localSwapCi = ci, _localSwapPi = pi }
        mapM_ addPoint   points   -- add associated points to each local swaps
        mapM_ doBestSwap clusters -- try swap and record
        return vec
      )
  where mkpair c p = (c, sqDistance (_clusterCent c) p)

addToLocalSwap :: LocalSwap -> Point -> LocalSwap
addToLocalSwap lswap p = lswap & localSwapPoints %~ (\points -> p : points)

-- | Swap each point with the center in the same cluster, return the best swap.
localBestSwap :: Cluster -> [Point] -> KMedoisState -> (Int, Int)
localBestSwap (Cluster ci _ _) points s = fst $ minimumBy
  (compare `on` snd)
  [ let cost = getLocalCost $ swap (ci, pi) s in ((ci, pi), cost)
  | pi <- [0 .. length points]
  ]
 where
  swap (ci, pi) s@(KMedoisState clusters _) =  -- swap one point
    let pointsP = points !! pi
    in  s { kmedClusters = clusters & (ix ci) . clusterCent .~ pointsP }
  getLocalCost :: KMedoisState -> Double
  getLocalCost = undefined

isCostImproved :: Double -> Double -> Bool
isCostImproved old new | new - old < 0 = True
                       | otherwise     = False

localSwapToCluster :: Int -> LocalSwap -> Cluster
localSwapToCluster cid lswap@(LocalSwap ci si _) = undefined

-- | filter away clustser has no point closes to it.
newCluster :: Vec.Vector LocalSwap -> KMedois [Cluster]
newCluster vec = do
  points <- kmedPoints <$> ask
  let clusters :: [Cluster]
      clusters =
        [ localSwapToCluster i lswap
        | (i, lswap) <- [0 ..] `Prelude.zip` (Vec.toList vec)
        ]
      cost = getCost points clusters
  modify (\s -> s { kmedCost = cost })
  return clusters
 where
  getCost points clusters =
    sum [ euclideanDistance p c | (Cluster _ c _) <- clusters, p <- points ]
t
module BinaryTreeMonad where

import           Data.Maybe

data BinaryTree a =
    Leaf
  | Node (BinaryTree a) a (BinaryTree a)
  deriving (Eq, Show, Ord)

treeInsert :: Ord a => a -> BinaryTree a -> BinaryTree a
treeInsert a Leaf = Node Leaf a Leaf
treeInsert a (Node l b r)
  | a > b = Node l b (treeInsert a r)
  | a < b = Node (treeInsert a l) b r
  | otherwise = Node l b r

preorderHead :: BinaryTree a -> Maybe a
preorderHead Leaf         = Nothing
preorderHead (Node _ a _) = Just a

preorderLeft :: BinaryTree a -> BinaryTree a
preorderLeft Leaf         = Leaf
preorderLeft (Node l _ _) = l

preorderRight :: BinaryTree a -> BinaryTree a
preorderRight Leaf         = Leaf
preorderRight (Node _ _ r) = r

preorderTraverse :: BinaryTree a -> [a]
preorderTraverse t = go t []
  where go tree acc =
          case tree of
            Node Leaf a Leaf -> a : acc
            Node l a Leaf    -> a : go l acc
            Node Leaf a r    -> a : go r acc
            Node l a r       -> a : go l acc ++ go r acc
            Leaf             -> acc

instance Ord a => Monoid (BinaryTree a) where
  mempty = Leaf

instance Ord a => Semigroup (BinaryTree a) where
  t <> Leaf = t
  Leaf <> t = t
  t <> t' =   -- because treeInsert is not associative, can only use foldl here
    let go :: Ord a => [a] -> BinaryTree a -> BinaryTree a
        go tl tree = foldl (flip treeInsert) tree tl
    in go (preorderTraverse t) t'

instance Functor BinaryTree where
  fmap _ Leaf = Leaf
  fmap f (Node l a r) =
    Node (fmap f l) (f a) (fmap f r)

instance Foldable BinaryTree where
  foldMap _ Leaf = mempty
  foldMap f t =
    let h = preorderHead t
        tl = preorderLeft t
        tr = preorderRight t
     in fromJust (f <$> h) <> foldMap f tl <> foldMap f tr

--  TODO:  <12-11-19, Jimmy> --
--  I need either a monoid instance for Bin tree without Ord typelclass constraint
--  or Monad and Applicative without using Monoidal append.
--  Since Applicative and Monad have instances for higher kinded type,
--  The higher kinded type must be fully polymorphic, you cannot apply
--  typeclass constraint on them.

instance Applicative BinaryTree where
  -- TODO: mapping applicative, now it doesn't works as expected
  pure a = Node Leaf a Leaf
  Leaf <*> _                       = Leaf
  Node Leaf f Leaf <*> Node _ a' _ = Node Leaf (f a') Leaf
  Node lf af rf <*> Node l' a' r'  = Node (lf <*> l') (af a') (rf <*> r')


module EitherMonad where

data Either' e a =
    Left' e
  | Right' a
  deriving (Eq, Show)

instance Functor (Either' e) where
  fmap f (Left' e) = Left' e
  fmap f (Right' a) = Right' $ f a

instance Applicative (Either' e) where
  pure = Right'
  Right' f <*> Right' a = Right' $ f a
  Left' a <*> _ = Left' a
  _ <*> Left' a = Left' a

instance Monad (Either' e) where
  return = Right'
  Right' a >>= f = f a
  Left' a >>= _ = Left' a

type TestEither = Either' Int Int

tEitherFunctor :: IO ()
tEitherFunctor = do
  putStrLn "[*] tEitherFunctor: fmap (+1) (Right' 2 :: TestEither)"
  print $ fmap (+1) (Right' 2 :: TestEither)

  putStrLn "[*] tEitherFunctor: fmap (+1) (Left' 2 :: TestEither)"
  print $ fmap (+1) (Left' 2 :: TestEither)
  putStr "\n"

tEitherApplicative :: IO ()
tEitherApplicative = do
  putStrLn "[*] tEitherApplicative: Right' (+1) <*> (Right' 2 :: TestEither)"
  print $ Right' (+1) <*> (Right' 2 :: TestEither)

  putStrLn "[*] tEitherApplicative: Right' (+1) <*> (Left' 2 :: TestEither)"
  print $ Right' (+1) <*> (Left' 2 :: TestEither)

  putStrLn
    "[*] tEitherApplicative: Left' (+1) <*> Right' 2 :: (Either' (Int -> Int) Int)"
  print $ let res = Left' (+1) <*> Right' 2 :: (Either' (Int -> Int) Int)
              isLeft' (Left' _) = True
              isLeft' _ = False
           in if isLeft' res then "correct" else "wrong"
  putStr "\n"

tEitherMonad :: IO ()
tEitherMonad = do
  putStrLn "[*] tEitherMonad: (Right' 2 :: TestEither) >>= \\x -> Right' $ x + 1"
  print $ (Right' 2 :: TestEither) >>= \ x -> Right' $ x + 1

  putStrLn "[*] tEitherMonad: (Left' 2 :: TestEither) >>= \\x -> Right' $ x + 1"
  print $ (Left' 2 :: TestEither) >>= \ x -> Right' $ x + 1
  putStr "\n"

runEitherMonadTest :: IO ()
runEitherMonadTest = tEitherFunctor >> tEitherApplicative >> tEitherMonad

module FunctionMonad where


module IdentityMonad where

newtype Identity a = Identity a deriving (Eq, Show, Ord)

instance Functor Identity where
  fmap f (Identity a) = Identity $ f a

instance Applicative Identity where
  pure = Identity
  Identity f <*> Identity a = Identity $ f a

instance Monad Identity where
  return = Identity
  Identity a >>= f = f a

tIdentityMonad :: IO ()
tIdentityMonad =
  putStrLn "[*] Identity Monad: " >>
    print (Identity 2 >>= \ x -> Identity $ x + 1)











module ListMonad where

data List a =
    Nil
  | Cons a (List a)
  deriving (Eq, Show)

instance Monoid (List a) where
  mempty = Nil

instance Semigroup (List a) where
  Nil <> Nil = Nil
  as <> Nil = as
  Nil <> as = as
  Cons a as <> bs =
    Cons a (as <> bs)

instance Functor List where
  fmap _ Nil = Nil
  fmap f (Cons a as) = Cons (f a) (fmap f as)

instance Applicative List where
  pure a = Cons a Nil
  Nil <*> _ = Nil
  _ <*> Nil = Nil
  Cons f fs <*> Cons a as =
    Cons (f a) (fmap f as <> (fs <*> as))

instance Monad List where
  return a = Cons a Nil
  Nil >>= _ = Nil
  Cons a as >>= f = f a <> (as >>= f)


testList1 = Cons 1 (Cons 2 (Cons 3 Nil))
testList2 = Cons 9 (Cons 8 (Cons 7 Nil))
testFunctionList = Cons (+1) (Cons (+2) (Cons (+3) Nil))

tListMonadMonoid :: IO ()
tListMonadMonoid = do
  putStrLn "[*] tListMonadMonoid: "
  print $ testList1 <> testList2
  print $ testList2 <> testList1
  print $ testList2 <> Nil
  putStrLn "\n"

tListMonadFunctor :: IO ()
tListMonadFunctor = do
  putStrLn "[*] tListMonadFunctor: "
  print $ (+1) <$> testList1
  putStrLn "\n"

tListMonadApplicative :: IO ()
tListMonadApplicative = do
  putStrLn "[*] tListMonadApplicative: "
  print $ testFunctionList <*> pure 1
  print $ testFunctionList <*> testList1
  putStrLn "\n"

tListMonadMonad :: IO ()
tListMonadMonad = do
  putStrLn "[*] tListMonadMonad"
  print $ testList1 >>= \ x -> Cons (x + 99) Nil
  print $ return 1 >>= \ x -> Cons (x + 99) Nil
  putStrLn "\n"

runListMonad :: IO ()
runListMonad = tListMonadMonoid >> tListMonadFunctor >> tListMonadApplicative
             >> tListMonadMonad
module Main where

data List a = Cons a (List a) | Nil

instance Functor List where
  fmap f Nil = Nil
  fmap f (Cons a as) =
    Cons (f a) (fmap f as)

instance Applicative List where
  pure x = Cons x Nil
  (Cons f fs) <*> (Cons a as) =
    Cons (f a) (fs <*> as)
  Nil <*> _ = Nil
  _ <*> Nil = Nil

-- impelment functions with monad and functor.
j :: Monad m => m (m a) -> m a
j m = m >>= id

l1 :: Monad m => (a -> b) -> m a -> m b
l1 f m = f <$> m

l2 :: Monad m => (a -> b -> c) -> m a -> m b -> m c
l2 f m1 m2 = f <$> m1 <*> m2

a :: Monad m => m a -> m (a -> b) -> m b
a = flip (<*>)

meh :: Monad m => [a] -> (a -> m b) -> m [b]
meh (x : xs) f = do
  x' <- f x
  ((:) x') <$> (meh xs f)

flipType :: (Monad m) => [m a] -> m [a]
flipType = (flip meh) id

main :: IO ()
main = undefined
module NopeMonad where


-- a monad doing nothing.
data Nope a = NopeDog deriving (Eq, Show)

instance Functor Nope where
  fmap _ NopeDog = NopeDog

instance Applicative Nope where
  pure _ = NopeDog
  NopeDog <*> NopeDog = NopeDog

instance Monad Nope where
  return _ = NopeDog
  NopeDog >>= _ = NopeDog


tNopeMonadFunctor :: IO ()
tNopeMonadFunctor = do
  putStrLn "[*] tNopeMonadFunctor: "
  print $ fmap (+1) NopeDog
  putStr "\n"

tNopeMonadApplicative :: IO ()
tNopeMonadApplicative = do
  putStrLn "[*] tNopeMonadApplicative: "
  print $ NopeDog <*> NopeDog
  putStr "\n"

tNopeMonad :: IO ()
tNopeMonad = do
  putStrLn "[*] tNopeMonad: "
  print $ NopeDog >>= const NopeDog
  putStr "\n"

runNopeMonadTest :: IO ()
runNopeMonadTest = do
  tNopeMonadFunctor
  tNopeMonadApplicative
  tNopeMonad

import Distribution.Simple
main = defaultMain
module Main where

import Mts1

main :: IO ()
main = putStrLn "Hello, Haskell!"
module Mts1 where

import Control.Applicative
import Control.Monad
import Control.Monad.Trans.Class
import Data.Char

newtype MaybeT' m a = MaybeT' {runMaybeT' :: m (Maybe a)}

instance Monad m => Monad (MaybeT' m) where
  return = MaybeT' . return . return
  x >>= f = MaybeT' $ do
    maybeval <- runMaybeT' x
    case maybeval of
      Nothing -> return Nothing
      Just val -> runMaybeT' $ f val

instance Monad m => Applicative (MaybeT' m) where
  pure = return
  (<*>) = ap

instance Monad m => Functor (MaybeT' m) where
  fmap = liftM

instance Monad m => Alternative (MaybeT' m) where
  empty = MaybeT' $ return Nothing
  x <|> y = MaybeT' $ do
    maybeval <- runMaybeT' x
    case maybeval of
      Nothing -> runMaybeT' y
      Just _ -> return maybeval

instance Monad m => MonadPlus (MaybeT' m) where
  mzero = empty
  mplus = (<|>)

instance MonadTrans MaybeT' where
  lift = MaybeT' . (liftM Just)

-- use mtf
isValid :: String -> Bool
isValid s =
  length s >= 8
    && any isAlpha s
    && any isNumber s
    && any isPunctuation s

getPassphrase :: MaybeT' IO String
getPassphrase = do
  s <- lift getLine --  lift IO in IO String into IO (Maybe String).
  guard (isValid s)
  return s

askPassphrase :: MaybeT' IO ()
askPassphrase = do
  lift $ putStrLn "Insert your new passphrase"
  value <- getPassphrase
  lift $ putStrLn "Storing in database..."

askPassphrase' :: MaybeT' IO ()
askPassphrase' = do
  lift $ putStrLn "Insert your new passphrase"
  value <- msum $ repeat getPassphrase
  lift $ putStrLn "Storing in database"

newtype Identity a = Identity {runIdentity :: a}

instance Monad Identity where
  return a = Identity a
  m >>= f = f (runIdentity m)

instance Applicative Identity where
  pure = return
  (<*>) = ap

instance Functor Identity where
  fmap = liftM

newtype IdentityT m a = IdentityT {runIdentityT :: m (Identity a)}

instance Monad m => Monad (IdentityT m) where
  return = IdentityT . return . return
  x >>= f = IdentityT $ do
    identityval <- runIdentityT x
    runIdentityT $ f (runIdentity identityval)

instance Monad m => Applicative (IdentityT m) where
  pure = return
  (<*>) = ap

instance Monad m => Functor (IdentityT m) where
  fmap = liftM

newtype State s a = State {runState :: s -> (a, s)}

instance Monad (State s) where
  return a = State $ \s -> (a, s)
  (State x) >>= f = State $ \s ->
    let (a', s') = x s
     in runState (f a') s'

instance Applicative (State s) where
  pure = return
  (<*>) = ap

instance Functor (State s) where
  fmap = liftM

newtype StateT s m a = StateT {runStateT :: s -> m (a, s)}

instance Monad m => Monad (StateT s m) where
  return a = StateT $ \s -> return (a, s)
  (StateT x) >>= f = StateT $ \s -> do
    (a', s') <- x s
    runStateT (f a') s'

instance Monad m => Applicative (StateT s m) where
  pure = return
  (<*>) = ap

instance Monad m => Functor (StateT s m) where
  fmap = liftM

instance MonadTrans (StateT s) where
  lift c = StateT $ \s -> c >>= (\x -> return (x, s))
import Distribution.Simple
main = defaultMain
import Distribution.Simple
main = defaultMain
module Main where

import Control.Monad (forever, when)
import Data.List (intercalate)
import Data.Traversable (traverse)
import Morse (stringToMorse, morseToChar)
import System.Environment (getArgs)
import System.Exit (exitFailure,
                    exitSuccess)
import System.IO (hGetLine, hIsEOF, stdin)


convertToMorse :: IO ()
convertToMorse = forever $ do
  weAreDone <- hIsEOF stdin
  when weAreDone exitSuccess

  -- otherwise proceed
  line <- hGetLine stdin
  convertLine line
  where
    convertLine line = do
          let morse = stringToMorse line
          case morse of
            (Just str) -> putStrLn (intercalate " " str)
            Nothing -> do
                putStrLn $ "ERROR: " ++ line
                exitFailure

convertFromMorse :: IO ()
convertFromMorse = forever $ do
    weAreDone <- hIsEOF stdin
    when weAreDone exitSuccess

    -- otherwise proceed
    line <- hGetLine stdin
    convertLine line
    where
        convertLine line = do
            let decoded :: Maybe String
                decoded =
                    traverse morseToChar
                             (words line)
            case decoded of
              (Just s) -> putStrLn s
              Nothing -> do
                  putStrLn $ "ERROR: " ++ line
                  exitFailure

main :: IO ()
main = do
    mode <- getArgs
    case mode of
        [arg] ->
            case arg of
              "from" -> convertFromMorse
              "to" -> convertToMorse
              _ -> argError
        _ -> argError
    where argError = do
            putStrLn "Please specify the\
                      \ first argument\
                      \ as being 'from' or\
                      \ 'to' morse,\
                      \ such as: morse to"
            exitFailure

module Morse
  ( Morse
  , charToMorse
  , stringToMorse
  , letterToMorse
  , morseToLetter
  , morseToChar
  , morse
  ) where
import qualified Data.Map as M
import Data.Maybe


type Morse = String


letterToMorse :: (M.Map Char Morse)
letterToMorse = M.fromList
  [ ('a', ".-")
  , ('b', "-...")
  , ('c', "-.-.")
  , ('d', "-..")
  , ('e', ".")

  , ('f', "..-.")
  , ('g', "--.")
  , ('h', "....")
  , ('i', "..")
  , ('j', ".---")
  , ('k', "-.-")

  , ('l', ".-..")
  , ('m', "--")
  , ('n', "-.")
  , ('o', "---")
  , ('p', ".--.")
  , ('q', "--.-")

  , ('r', ".-.")
  , ('s', "...")
  , ('t', "-")
  , ('u', "..-")
  , ('v', "...-")
  , ('w', ".--")

  , ('x', "-..-")
  , ('y', "-.--")
  , ('z', "--..")

  , ('1', ".----")
  , ('2', "..---")
  , ('3', "...--")
  , ('4', "....-")
  , ('5', ".....")
  , ('6', "-....")
  , ('7', "--...")
  , ('8', "---..")
  , ('9', "----.")
  , ('0', "-----")
  ]

morseToLetter :: M.Map Morse Char
morseToLetter =
  M.foldrWithKey (flip M.insert) M.empty letterToMorse

charToMorse :: Char -> Maybe Morse
charToMorse c = M.lookup c letterToMorse

stringToMorse :: String -> Maybe [Morse]
stringToMorse = traverse charToMorse
    -- Equivalence to:
    -- sequence $ fmap charToMorse s

morseToChar :: Morse -> Maybe Char
morseToChar m = M.lookup m morseToLetter

morse :: String -> [Morse]
morse s = fromMaybe [] (stringToMorse s)


main :: IO ()
main = putStrLn "Test suite not yet implemented"
module Ast where

-- for simple calculator
data Expr
  = Add Expr Expr
  | Mul Expr Expr
  | Sub Expr Expr
  | Lit Int
  deriving (Show)

eval :: Expr -> Int
eval (Lit n) = n
eval (Add a b) = eval a + eval b
eval (Mul a b) = eval a * eval b
eval (Sub a b) = eval a - eval b
module Basic where

-- parser is like a state
newtype Parser a = Parser {runParser :: String -> Maybe (a, String)}

char :: Char -> Parser Char
char c =
  Parser $ \s ->
    case s of
      (x : xs) -> if c == x then Just (c, xs) else Nothing
      _ -> Nothing

-- Hutton Meijer parser
-- it express a range of possible valid parses starting from the input provided.
type Token = Char

newtype HMParser a = P {runHMParser :: [Token] -> [(a, [Token])]}
module Main where

import Control.Monad (forever)
import Control.Applicative (Alternative(..))
import Parse
import Ast

int :: Parser Expr
int = do
  n <- number
  return (Lit n)

-- the order determines the precedence
expr :: Parser Expr
expr = term `chainl1` addop

term :: Parser Expr
term = factor `chainl1` mulop

factor :: Parser Expr
factor = int <|> parens expr

infixOp :: String -> (a -> a -> a) -> Parser (a -> a -> a)
infixOp x f = reserved x >> return f

addop :: Parser (Expr -> Expr -> Expr)
addop = (infixOp "+" Add) <|> (infixOp "-" Sub)

mulop :: Parser (Expr -> Expr -> Expr)
mulop = infixOp "*" Mul

run :: String -> Expr
run = runParser expr

main :: IO ()
main = forever $ do
  putStr "> "
  a <- getLine
  print $ eval $ run a

module Parse where

import Control.Applicative hiding (some, many)
import Control.Monad
import Data.Char

newtype Parser a = Parser {parse :: String -> [(a, String)]}

runParser :: Parser a -> String -> a
runParser m s =
  case parse m s of
    [(res, [])] -> res
    [(_, rs)] -> error "Not consume the entire stream"
    _ -> error "Parse failed"

item :: Parser Char
item = Parser $ \s ->
  case s of
    [] -> []
    (c : cs) -> [(c, cs)]

bind :: Parser a -> (a -> Parser b) -> Parser b
bind p f =
  Parser $ \s ->
    concatMap (\(a, s') -> parse (f a) s') $
      parse p s

unit :: a -> Parser a
unit a = Parser $
  \s -> [(a, s)]

instance Functor Parser where
  fmap f (Parser cs) =
    Parser $
      \s -> [(f a, b) | (a, b) <- cs s]

instance Applicative Parser where
  pure = return
  (Parser cs1) <*> (Parser cs2) =
    Parser $ \s ->
      [ (f a, s'')
        | (f, s') <- cs1 s,
          (a, s'') <- cs2 s'
      ]

instance Monad Parser where
  return = unit
  (>>=) = bind

instance MonadPlus Parser where
  mzero = failure
  mplus = combine

instance Alternative Parser where
  empty = mzero
  (<|>) = option

combine :: Parser a -> Parser a -> Parser a
combine p q = Parser $ \s -> parse p s ++ parse q s

failure :: Parser a
failure = Parser (\cs -> [])

option :: Parser a -> Parser a -> Parser a
option p q = Parser $ \s ->
  case parse p s of
    [] -> parse q s
    res -> res

some :: (Alternative f) => f a -> f [a]
some v = some_v
  where
    many_v = some_v <|> pure []
    some_v = (:) <$> v <*> many_v

many :: (Alternative f) => f a -> f [a]
many v = many_v
  where
    many_v = some_v <|> pure []
    some_v = (:) <$> v <*> many_v

satisfy :: (Char -> Bool) -> Parser Char
satisfy p = item >>= \c -> if p c then pure c else failure

oneOf :: [Char] -> Parser Char
oneOf s = satisfy (flip elem s)

chainl :: Parser a -> Parser (a -> a -> a) -> a -> Parser a
chainl p op a = (p `chainl1` op) <|> return a

chainl1 :: Parser a -> Parser (a -> a -> a) -> Parser a
p `chainl1` op = p >>= \a -> rest a
  where
    rest a =
      ( do
          f <- op
          b <- p
          rest (f a b)
      )
        <|> return a

char :: Char -> Parser Char
char c = satisfy (c ==)

natural :: Parser Integer
natural = read <$> some (satisfy isDigit)

string :: String -> Parser String
string [] = pure []
string (c : cs) = char c >> string cs >> pure (c : cs)

token :: Parser a -> Parser a
token p = do
  a <- p
  spaces
  pure a

reserved :: String -> Parser String
reserved = token . string

spaces :: Parser String
spaces = many $ oneOf " \n\r"

digit :: Parser Char
digit = satisfy isDigit

number :: Parser Int
number = do
  s <- string "-" <|> pure []
  cs <- some digit
  pure $ read (s ++ cs)

parens :: Parser a -> Parser a
parens m = do
  reserved "("
  n <- m
  reserved ")"
  pure n
import Distribution.Simple
main = defaultMain
module State where

import Control.Monad.State

state1 :: Maybe ((), Int)
state1 = runStateT (put 8) 7
-- ((), 8)

state2 :: Maybe (Int, Int)
state2 = runStateT get 8
-- (8, 8)

state3 :: Maybe (Int, Int)
state3 = runStateT (put 1 >> get) 8
-- (1, 1)

state4 :: Maybe (Int, Int)
state4 = runStateT (put 1 >> put 2 >> get) 111
-- (2, 2)

state5 :: Maybe (Int, Int)
state5 = runStateT (put 1 >> get >> return 10) 112
-- (10, 112)

import Distribution.Simple
main = defaultMain
module Main where

import Data.Int
import Control.Applicative

type PyTrip = (Int, Int, Int)

testSet :: Int -> [PyTrip]
-- testSet n = (,,) <$> [1..n] <*> [1..n] <*> [1..n]
testSet n = liftA3 (,,) [1..n] [1..n] [1..n]

isPythagoreanTriple :: PyTrip -> Bool
isPythagoreanTriple (a, b, c) = a ^ 2 + b ^ 2 == c ^ 2

checkPyTrip :: [PyTrip] -> [PyTrip]
checkPyTrip [] = []
checkPyTrip (x:xs) = if isPythagoreanTriple x
                        then x : checkPyTrip xs
                     else checkPyTrip xs

perimeter :: (Floating a) => a -> a -> a -> a
perimeter a b c = sum [a, b, c]

tripleArea :: (Floating a, Ord a) => a -> a -> a -> Maybe a
tripleArea a b c =
  if abs(a + b) > c && abs(b + c) > a
     then let p = perimeter a b c / 2
           in Just $ sqrt(product [p, p - a, p - b, p - c])
  else Nothing

main :: IO ()
main = do
  print $ tripleArea 10 20 30
  print $ tripleArea 10 20 20
  print $ checkPyTrip (testSet 10)




{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE InstanceSigs #-}

module Main where

-- Let's show that fmap a function to another function
-- is the same as func comp when two functions has
-- the same type of parameter (same funcotorial context).

comp :: forall a b c. (b -> c) -> (a -> b) -> a -> c
comp f g x = f (g x)

compEqfmap x = fg' x == fg'' x
  where
    f = (+ 10)
    g = (* 2)
    fg' = f `comp` g
    fg'' = f <$> g

-- Reader: a way of stringing functions together when all
-- those functions are awaiting one input from a shared environment.
-- Like create a little scope with a "global variable."
-- It can avoid passing the same parameter over and over again.

newtype Reader r a = Reader {runReader :: r -> a}

-- the Functor of Reader is really just a wrapper of fmap. --
-- and since fmap is the same as (.) in terms of fuction composition.
instance Functor (Reader r) where
  fmap :: (a -> b) -> Reader r a -> Reader r b
  fmap f (Reader ra) = Reader $ f . ra

-- Exercise
ask :: Reader a a
ask = Reader $ id

-- The Applicative of function --
-- For functions Applicative will
-- do a function composition underline the
-- common parameter.
instance Applicative (Reader r) where
  pure :: a -> Reader r a
  pure a = Reader $ const a

  (<*>) :: Reader r (a -> b) -> Reader r a -> Reader r b
  (Reader rab) <*> (Reader ra) =
    Reader $ \r -> rab r (ra r)

-- Exercise
liftA2' :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
liftA2' f fa fb = f <$> fa <*> fb

asks :: (r -> a) -> Reader r a
asks f = Reader $ f

-- The Monad of function --
instance Monad (Reader r) where
  return = pure
  m >>= k =
    Reader $ \r ->
      runReader (k (runReader m r)) r

-- Change what comes below but not above. --
newtype ReaderT r m a = ReaderT {runReaderT :: r -> m a}

withReaderT ::
  forall r' r m a.
  (r' -> r) ->
  ReaderT r m a -> -- func that modify the environment
  ReaderT r' m a -- computation to run in the modified env
withReaderT f m = ReaderT $ runReaderT m . f


main :: IO ()
main = putStrLn "Hello, Haskell!"
import Distribution.Simple
main = defaultMain
import Distribution.Simple
main = defaultMain

{-# LANGUAGE OverloadedStrings#-}
module Main where

import Control.Monad (replicateM)
import Control.Monad.IO.Class (liftIO)
import qualified Data.ByteString.Char8 as BC
import Data.Text.Encoding (decodeUtf8, encodeUtf8)
import qualified Data.Text.Lazy as TL
import qualified Database.Redis as R
import Network.URI (URI, parseURI)
import qualified System.Random as SR
import Web.Scotty


-- the parameter be passed to randomElement
alphaNum :: String
alphaNum = ['A'..'Z'] ++ ['0'..'9']

-- take optional character list, and return a random char.
-- randomRIO use the global random number
randomElement :: String -> IO Char
randomElement xs = do
    let maxIndex :: Int
        maxIndex = length xs -1
    randomDigit <- SR.randomRIO (0, maxIndex) :: IO Int
    return (xs !! randomDigit)

-- replicateM replicate over the IO monad structure.
shortyGen :: IO String
shortyGen = replicateM 7 (randomElement alphaNum)

-- set the key and value for redis.
saveURI :: R.Connection
        -> BC.ByteString
        -> BC.ByteString
        -> IO (Either R.Reply R.Status)
saveURI conn shortURI uri =
    R.runRedis conn $ R.set shortURI uri

-- ask for uri based on the shorty version in redis.
getURI :: R.Connection
       -> BC.ByteString
       -> IO (Either R.Reply (Maybe BC.ByteString))
getURI conn shortURI = R.runRedis conn $ R.get shortURI

-- shorty uri get demonstrated on the browser.
linkShorty :: String -> String
linkShorty shorty =
    concat [ "<a href=\""
           , shorty
           , "\"> Copy and paste your short URL </a>"
           ]

shortyCreated :: Show a => a -> String -> TL.Text
shortyCreated resp shawty =
    TL.concat [ TL.pack (show resp)
              , " shorty is: ", TL.pack (linkShorty shawty)
              ]

shortyAintUri :: TL.Text -> TL.Text
shortyAintUri uri =
    TL.concat [ uri
              , " wasn't a url, did you forget http:///?"
              ]

shortyFound :: TL.Text -> TL.Text
shortyFound tbs =
    TL.concat [ "<a herf=\"", tbs, "\">", tbs, "</a>"]

-- ScottyM () indicates this monad return nothing into the system.
app :: R.Connection
    -> ScottyM ()
app rConn = do
    get "/" $ do
        uri <- param "uri"
        let parseUri :: Maybe URI
            parseUri = parseURI (TL.unpack uri)
        case parseUri of
            Just _ -> do
                shawty <- liftIO shortyGen
                let shorty = BC.pack shawty
                    uri' = encodeUtf8 (TL.toStrict uri)
                resp <- liftIO (saveURI rConn shorty uri')
                html (shortyCreated resp shawty)
            Nothing -> text (shortyAintUri uri)
    get "/:short" $ do
        short <- param "short"
        uri <- liftIO (getURI rConn short)
        case uri of
            Left reply -> text (TL.pack (show reply))
            Right mbBS -> case mbBS of
                Nothing -> text "uri not found"
                Just bs -> html (shortyFound tbs)
                    where tbs :: TL.Text
                          tbs = TL.fromStrict (decodeUtf8 bs)
main :: IO ()
main = do
    rConn <- R.connect R.defaultConnectInfo
    scotty 3000 (app rConn)

module Lib
    ( someFunc
    ) where

someFunc :: IO ()
someFunc = putStrLn "someFunc"
main :: IO ()
main = putStrLn "Test suite not yet implemented"
module Main where

import Control.Applicative (liftA3)
import Control.Monad (replicateM, join)
import System.Random
import Control.Monad.State

-- State and it's monadic interace --
-- notice State is not in-place mutation, you need ST
-- to do that.
-- State can be thought as data that exists in addition to
-- the input and output of the function that can potentially
-- change after each function is evaluated.

-- State in haskell:
--  1. let us have state doesn't require IO
--  2. is limited only to the data in our State container.
--  3. maintains referential transparency.
--  4. explicit in types

data Die
  = DieOne
  | DieTwo
  | DieThree
  | DieFour
  | DieFive
  | DieSix
  deriving (Eq, Show)

class ToDie a where
  toDie :: a -> Die

instance ToDie Int where
  toDie n =
    case n of
      1 -> DieOne
      2 -> DieTwo
      3 -> DieThree
      4 -> DieFour
      5 -> DieFive
      6 -> DieSix
      x -> error $ "This is a terrible error handling" ++ show x

-- state function turn a state function into a state monad transformer
rollDie :: State StdGen Die
rollDie = toDie <$> state (randomR (1, 6 :: Int))

tripleDices :: State StdGen (Die, Die, Die)
tripleDices = liftA3 (,,) rollDie rollDie rollDie

-- note to repeat the action instead of the value with `repeat`.
nDie :: Int -> State StdGen [Die]
nDie n = replicateM n rollDie

rollTil20 :: StdGen -> Int
rollTil20 g = go 0 0 g
  where
    go :: Int -> Int -> StdGen -> Int
    go sum count gen
      | sum >= 20 = count
      | otherwise =
        let (die, nextGen) = randomR (1, 6) gen
         in go (sum + die) (count + 1) nextGen

-- Exercise
rollsToGetN :: Int -> StdGen -> Int
rollsToGetN n g = go 0 0 g
  where
    go :: Int -> Int -> StdGen -> Int
    go sum count gen
      | sum >= n = count
      | otherwise =
        let (die, nextGen) = randomR (1, 6) gen
         in go (sum + die) (count + 1) nextGen

rollsCountLogged :: Int -> StdGen -> (Int, [Die])
rollsCountLogged n g = go 0 0 [] g
  where
    go :: Int -> Int -> [Die] -> StdGen -> (Int, [Die])
    go sum count dices gen
      | sum >= n = (count, dices)
      | otherwise =
        let (die, nextGen) = randomR (1, 6) gen
         in go (sum + die) (count + 1) ((toDie die) : dices) nextGen

-- write your own State --
newtype Moi s a = Moi {runMoi :: s -> (a, s)}

instance Functor (Moi s) where
  fmap f (Moi g) =
    Moi $ (\(a, s) -> (f a, s)) <$> g

instance Applicative (Moi s) where
  pure a = Moi $ \s -> (a, s)
  (Moi f) <*> (Moi g) =
    Moi $ \s ->
      let (ab, s') = f s
          (a, s'') = g s
       in (ab a, s'')

instance Monad (Moi s) where
  return = pure
  (Moi f) >>= g =
    Moi $ \s ->
      let (a, s') = f s
       in  (runMoi $ g a) s'

-- fizzbuzz with state --
fizzBuzz :: Integer -> String
fizzBuzz n
  | n `mod` 15 == 0 = "FizzBuzz"
  | n `mod` 5 == 0 = "Fizz"
  | n `mod` 3 == 0 = "Buzz"
  | otherwise = show n

fizzBuzzList :: [Integer] -> [String]
fizzBuzzList list = execState (mapM_ addResult list) []

addResult :: Integer -> State [String] ()
addResult n = do
  xs <- get
  let result = fizzBuzz n
  put (result : xs)
fizzBuzz100 = mapM_ putStrLn $ reverse $ fizzBuzzList [1..100]

-- Exercise (implement some state accessors) --
mget :: Moi s s
mget = Moi $ \s -> (s, s)

mput :: s -> Moi s ()
mput s = Moi $ \s' -> ((), s)

mexec :: Moi s a -> s -> s
mexec (Moi sa) s = snd $ sa s

meval :: Moi s a -> s -> a
meval (Moi sa) s = fst $ sa s

mmodify :: (s -> s) -> Moi s ()
mmodify f = Moi $ \s -> ((), f s)

main :: IO ()
main = putStrLn "Hello, Haskell!"
import Distribution.Simple
main = defaultMain
{-# LANGUAGE BangPatterns #-}
module Main where

import           Control.Parallel.Strategies
import           Data.Digest.Pure.MD5        (md5)

import           Control.Concurrent
import           Control.Concurrent.Chan
import           Control.Concurrent.STM
import           Control.Monad
import           Data.ByteString.Lazy        as L
import           System.Environment


main :: IO ()
main = Prelude.putStrLn "Hello, Haskell!"

{- sparks
    - Most basic atomic parallelism.
    - A hint to GHC runtime that a computation can be evaluated
      to WHNF in parallel

    For example, `rpar a`:
      - spin a separate spark
      - evaluate to WHNF
      - place the computation in the spark pool.

    Terms:
      * Fizzled: The result has already been evaluated by the main
                 thread so the spark need not to be converted
      * Dud: The expression has already been evaluated, the computed value
             the computed value is returned and the spark is not converted.
      * CG'd: The spark is added to spark pool but the rseult it not referenced,
              so the result is collected.
      * Ovverflowed: Insufficient space in the spark pool when spanwing.

    Note:
      Parallel runtime is necessary for using spark, with GHC, -threaded must be
      turned on.
-}


sparkEx :: (a -> b) -> a -> a -> (b, b)
sparkEx f x y = runEval $ do
  a <- rpar $ f x
  b <- rpar $ f y
  rseq a          -- make sure after result is present after the call.
  rseq b
  return (a, b)


{- Thread.
    In haskell we use green threads. There are bound threads (OS threads) and unbound threads.
    We can choose to run a computation on bound thread or unbound thread with
      runInBoundThread and runInUnboundThread
    Threads live in IO monad.
-}





{- Chan

-}


------------------------------------------------------------------------------
-- Some examples.
------------------------------------------------------------------------------

-- Use MVar to control threads.
{-
   Locking mutable variable (MVar)
      - common for communicating values
      - used for signaling

  the function `takeMVar :: Mvar a -> IO a` will block until the MVar is non-empty
  `putMVar :: MVar a -> a -> IO ()` will block until the current MVar is empty.


-}
runWithMVar :: IO ()
runWithMVar = do
  files <- getArgs
  str <- newEmptyMVar     -- create a new MVar to protect file content.
  mapM_ (forkIO . hashAndPrint str) files
  presults (Prelude.length files) str
 where
   presults i var = replicateM_ i (takeMVar var >>= Prelude.putStrLn)

-- here the content of the file is protected by MVar.
hashAndPrint :: MVar String -> FilePath -> IO ()
hashAndPrint str f = do
  bs <- L.readFile f
  let !h = show $ md5 bs  -- get strictly evaluated here.
  putMVar str (f ++ ": " ++ h)
import Distribution.Simple
main = defaultMain
module Ch18Monad where

-- Nope Monad
data Nope a = NopeDog deriving (Eq, Show)

instance Functor Nope where
  fmap _ NopeDog = NopeDog

instance Applicative Nope where
  pure _ = NopeDog
  NopeDog <*> NopeDog = NopeDog

instance Monad Nope where
  return _ = NopeDog
  NopeDog >>= _ = NopeDog

-- Either' Monad


-- PhEither Monad
-- data PhEither b a =
--     PLeft a
--   | PRight b
--   deriving (Eq, Show)

-- instance Functor (PhEither b) where
--     fmap _ (PRight a) = (PRight a)
--     fmap f (PLeft a) = PLeft (f a)

-- instance Applicative (PhEither b) where
--     pure x = PLeft x
--     (PLeft f) <*> (PLeft a) = PLeft $ f a
--     (PRight a) <*> _ = PRight a
--     _ <*> (PRight a) = PRight a

-- instance Monad (PhEither b) where
--     return = pure
--     (PLeft a) >>= f = f a
--     (PRight a) >>= _ = PRight a


-- Identity

newtype Identity a = Identity a deriving (Eq, Show, Ord)

instance Functor Identity where
    fmap f (Identity a) = Identity $ f a

instance Applicative Identity where
    pure x = Identity x
    (Identity f) <*> (Identity a) = Identity $ f a

instance Monad Identity where
    return = pure
    (Identity a) >>= f = f a

-- List Monad
data List a =
    Nil
  | Cons a (List a)
  deriving (Eq, Show)

instance Monoid (List a) where
    mempty = Nil

instance Semigroup (List a) where
    Nil <> Nil = Nil
    as <> Nil = as
    Nil <> as = as
    (Cons a as) <> bs =
        (Cons a (as <> bs))

instance Functor List where
    fmap f Nil = Nil
    fmap f (Cons a as) =
        Cons (f a) (fmap f as)

instance Applicative List where
    pure x = Cons x Nil
    (Cons f fs) <*> (Cons a as) =
        Cons (f a) (fs <*> as)
    Nil <*> _ = Nil
    _ <*> Nil = Nil

instance Monad List where
    return = pure
    Nil >>= f = Nil
    (Cons a as) >>= f =
        (f a) <> (as >>= f)

-- impelment functions with monad and functor.
j :: Monad m => m (m a) -> m a
j m = m >>= id

l1 :: Monad m => (a -> b) -> m a -> m b
l1 f m = f <$> m

l2 :: Monad m => (a -> b -> c) -> m a -> m b -> m c
l2 f m1 m2 = f <$> m1 <*> m2

a :: Monad m => m a -> m (a -> b) -> m b
a = flip (<*>)

meh :: Monad m => [a] -> (a -> m b) -> m [b]
meh (x:xs) f = do
    x' <- f x
    ((:) x') <$> (meh xs f)

flipType :: (Monad m) => [m a] -> m [a]
flipType = (flip meh) id

module IOFunctor where

getInt :: IO Int
getInt = read <$> getLine

-- functor IO
meFunctor :: IO String
meFunctor = (++ "Me too! I am Functor") <$> getLine

-- monad IO
meTooIsm :: IO String
meTooIsm = do
    input <- getLine
    return (input ++ "and me too! I am monad")

module IdentityAndConstantApplicative where

-- Idenitity a
newtype Identity a = Identity a deriving (Eq, Show, Ord)

instance Functor Identity where
    fmap f (Identity a) = Identity $ (f a)

instance Applicative Identity where
    pure = Identity
    Identity f <*> Identity a = Identity (f a)


-- Constant a b

newtype Constant a b =
    Constant { getConstant :: a }
    deriving (Eq, Ord, Show)

instance Functor (Constant a) where
    fmap _ (Constant a) = Constant a

instance Monoid a => Applicative (Constant a) where
    pure _ = Constant mempty
    Constant a <*> Constant a' = Constant (a <> a')
 module MonadCountMe where

data CountMe a =
    CountMe Integer a
    deriving (Eq, Show)

instance Functor CountMe where
    fmap f (CountMe i a) = CountMe i (f a)

instance Applicative CountMe where
    pure = CountMe 0
    CountMe n f <*> CountMe n' a = CountMe (n + n') (f a)

instance Monad CountMe where
    return = pure
    CountMe n a >>= f =
        let CountMe n' b = f a
         in CountMe (n + n') b  -- careful about the monoid part of Monad


-- Kleisli composition
mcomp :: Monad m =>
        (b -> m c)
     -> (a -> m b)
     -> a -> m c
mcomp f g a = g a >>= f

module ValidationApplicative where

data Validation e a =
    Failure e
  | Success a
  deriving (Eq, Show)

data Errors =
    DividedByZero
  | StackOverFlow
  | MooglesChewedWires
  deriving (Eq, Show)

instance Functor (Validation e) where
    fmap f (Success a) = Success (f a)
    fmap f (Failure e) = Failure e

-- compare with either, the validation type combine errors with
-- different monoidal behavior.
instance Monoid e => Applicative (Validation e) where
    pure = Success
    (Success f) <*> (Success a) = Success (f a)
    (Failure e) <*> (Failure e') = Failure (e <> e')
    (Failure e) <*> (Success a) = Failure e
    (Success a) <*> (Failure e) = Failure e
module AsPattern where
import Data.Char

isSubsequeneOf :: (Eq a) => [a] -> [a] -> Bool
isSubsequeneOf [] _ = True
isSubsequeneOf (x:xs) par =
    elem x par && isSubsequeneOf xs par

captializeWords :: String -> Maybe [(String, String)]
captializeWords "" = Nothing
captializeWords s =
    let capHead (x:xs) = toUpper x : xs
        capHead [] = ""
        tokenize str = go str ""
            where
                go "" acc = [reverse acc]
                go (a:as) acc
                  | a == ' ' = reverse acc : go as ""
                  | otherwise = go as (a : acc)
        tuplize = map (\a -> (a, capHead a))
     in Just (tuplize . tokenize $ s)
module BinaryTree where

data BinaryTree a =
    Leaf
  | Node (BinaryTree a) a (BinaryTree a)
  deriving (Eq, Ord, Show)

insert' :: Ord a => a -> BinaryTree a -> BinaryTree a
insert' b Leaf = Node Leaf b Leaf
insert' b (Node left a right)
  | b == a = Node left a right
  | b < a = Node (insert' b left) a right
  | b > a = Node left a (insert' b right)

mapTree :: (a -> b) -> BinaryTree a -> BinaryTree b
mapTree f Leaf = Leaf
mapTree f (Node left a right) = Node (mapTree f left) (f a) (mapTree f right)

-- traverse binary tree
testTree :: BinaryTree Integer
testTree = Node (Node Leaf 3 Leaf) 1 (Node (Node Leaf 2 Leaf) 5 Leaf)



preorder :: BinaryTree a -> [a]
preorder t = go t []
    where go tree acc =
            case tree of
              Node Leaf a Leaf -> a : acc
              Node left a Leaf -> a : go left acc
              Node Leaf a right -> a : go right acc
              Node left a right -> a : go left acc ++ go right acc
              Leaf -> acc

inorder :: BinaryTree a -> [a]
inorder t = go t []
    where go tree acc =
            case tree of
              Node Leaf a Leaf -> a : acc
              Node left a Leaf -> go left acc ++ [a]
              Node Leaf a right -> a : go right acc
              Node left a right -> go left acc ++ [a] ++ go right acc
              Leaf -> acc

postorder :: BinaryTree a -> [a]
postorder t = go t []
    where go tree acc =
            case tree of
              Node Leaf a Leaf -> a : acc
              Node left a Leaf -> go left acc ++ [a]
              Node Leaf a right -> go right acc ++ [a]
              Node left a right -> go left acc ++ go right acc ++ [a]
              Leaf -> acc

-- catamorphisms of tree structures.
-- lazy eval
foldTreer :: (a -> b -> b) -> b -> BinaryTree a -> b
foldTreer _ z Leaf = z
foldTreer f z (Node left a right) =
    f a (foldTreer f (foldTreer f z left) right)

-- strict tail call
foldTreel :: (a -> b -> b) -> b -> BinaryTree a -> b
foldTreel _ z Leaf = z
foldTreel f z (Node left a right) =
    foldTreel f (foldTreel f (f a z) left) right

-- strict tail call
foldTreei :: (a -> b -> b) -> b -> BinaryTree a -> b
foldTreei _ z Leaf = z
foldTreei f z (Node left a right) =
    foldTreei f (f a (foldTreei f z left)) right





module BindByFmapAndJoin where

import Control.Monad (join)

-- a >>= implemented with join and fmap along.
-- fmap apply a function with type (a -> m b) to m a
-- so it will become m (m a)
-- join :: m (m a) -> m a
fbind :: Monad m => (a -> m b) -> m a -> m b
fbind f ma = join $ fmap f ma


-- Monad can be regarded as fmap a function to a monadic
-- structure, then merge the outmost layer.

module Cases where

f1 x = if x + 1 == 1 then "AWESOME" else "wut"

f x =
    case x + 1 == 1 of  -- handle cases for all data constructors
      True -> "AWESOME"
      False -> "wut"

pal xs =
    let y = xs == reverse xs in
        case y of
          True -> "Yes"
          False -> "No"

greetingIfCool :: String -> IO ()
greetingIfCool coolness =
    case cool of
      True -> putStrLn "Cool"
      False -> putStrLn "not cool"
    where cool = coolness == "cool?"
module case where

f1 = if x + 1 == 1 then "AWESOME" else "wut"

f x =
    case x + 1 == 1 of
      True -> "AWESOME"
      False -> "wut"
module Ciphers where
import Data.Char

modAplhaBete :: Int -> Int -> Int
modAplhaBete identity n = (+97) . mod (identity - 97 + n) $ 26

shift :: Char -> Int -> Char
shift char = chr . modAplhaBete (ord char)

encodeCeaser :: String -> Int -> String
encodeCeaser "" _ = ""
encodeCeaser s shiftVal =
    let (x:xs) = s
     in shift x shiftVal : encodeCeaser xs shiftVal

ceaser :: String -> String
ceaser s = encodeCeaser s 13

unceaser :: String -> String
unceaser s = encodeCeaser s (-13)
module ConditionExpr where

greetingIfCool :: String -> IO ()
greetingIfCool coolness =
    if cool coolness
       then putStrLn "cool!"
    else
       putStrLn "not cool"
    where cool v = v == "Hehe"

module ConstFunctor where

newtype Constant a b =
    Constant { getConstant :: a }
    deriving (Eq, Show)

instance Functor (Constant m) where
    fmap _ (Constant v) = Constant v

-- this will return (Constant 9) because the (const 2 will no be applied)
-- Constant 9 (const 2 b), b is the phahtom type without a value in term level.
constMapOnConstant = fmap (const 2) (Constant 9)
-- this will be Just 9 because Just (const 2 9)
constMapOnJust = fmap (const 2) (Just 9)


module Constructvalues where

data GuessWhat =
    Chickenbutt deriving (Eq, Show)

data Id a =
    MkId a deriving (Eq, Show)

data Product a b =
    Product a b deriving (Eq, Show)

data Sum a b =
    First a
  | Second b
  deriving (Eq, Show)

data RecordProduct a b =
    RecordProduct { pfirst :: a
                  , psecond :: b }
                  deriving (Eq, Show)

------------------------------------------------
newtype NumCow =
    NumCow Int
    deriving (Eq, Show)

newtype NumPig =
    NumPig Int
    deriving (Eq, Show)

newtype NumSheep =
    NumSheep Int
    deriving (Eq, Show)

type Name = String
type Age = Int
type LovesMud = Bool
type PoundsOfWool = Int

-- vanilla Farmhouse
data Farmhouse =
    Farmhouse NumCow NumPig
    deriving (Eq, Show)

type Farmhouse' = Product NumCow NumPig

-- use Product with more than 2 values
data BigFarmhouse =
    BigFarmhouse NumCow NumPig NumSheep
    deriving (Eq, Show)

type BigFarmhouse' =
    Product NumCow (Product NumPig NumSheep)

data CowInfo =
    CowInfo Name Age
    deriving (Eq, Show)

data PigInfo =
    PigInfo Name Age LovesMud
    deriving (Eq, Show)

data SheepInfo =
    SheepInfo Name Age PoundsOfWool
    deriving (Eq, Show)

data Animal =
    Cow CowInfo
  | Pig PigInfo
  | Sheep SheepInfo
  deriving (Eq, Show)

-- better way
type Animal' =
    Sum CowInfo (Sum PigInfo SheepInfo)


------------------------------------------------
-- just a value here.
idIdentity :: Id (a -> a)
idIdentity = MkId $ \x -> x

-- Programmer
data OS =
    Linux
  | BSD
  | Mac
  | Win
  deriving (Eq, Show)

data PL =
    Haskell
  | Cpp
  | Python
  | CommonLisp
  deriving (Eq, Show)

data Programmer =
    Programmer { os :: OS
               , lang :: PL }
    deriving (Eq, Show)

allOs :: [OS]
allOs = [ Linux
        , BSD
        , Mac
        , Win ]

allLang :: [PL]
allLang = [ Haskell
          , Cpp
          , Python
          , CommonLisp ]

allProgrammer :: [Programmer]
allProgrammer = [Programmer os lang | os <- allOs, lang <- allLang]
module CowApplicative where

data Cow =
    Cow {
          name :: String
        , age :: Int
        , weight :: Int
        } deriving (Eq, Show)

nonEmpty :: String -> Maybe String
nonEmpty "" = Nothing
nonEmpty s = Just s

nonNegative :: Int -> Maybe Int
nonNegative n
  | n >= 0 = Just n
  | otherwise = Nothing

cowFromString :: String -> Int -> Int -> Maybe Cow
cowFromString name age weight =
    Cow <$> nonEmpty name
        <*> nonNegative age
        <*> nonNegative weight

-- instead of using the longger version of case af statement,
-- the applicative and functor combination will keep passing the
-- function into the same structure of its parameter, so explicit
-- checking is omitted.
module Currying where


nonsense :: Bool -> Integer
nonsense True = 999
nonsense False = 111

curriedF :: Integer -> Bool -> Integer
curriedF i b = i + (nonsense b)

uncurriedF :: (Integer, Bool) -> Integer
uncurriedF (i, b) = i + (nonsense b)

anonymous :: Integer -> Bool -> Integer
anonymous = \i b -> i + (nonsense b)

anonNested :: Integer -> Bool -> Integer
anonNested = \i -> \b -> i + (nonsense b)

-- cuuring and uncurrying
currying :: ((a, b) -> t) -> a -> b -> t
currying f a b = f (a, b)

addUncurried (a, b) = a + b
addCurried = currying addUncurried

g :: a -> b -> c -> b
g a b c = b

f :: (Num a, Num b) => a -> b -> b
f a b = b
-- f 1 1.0 :: Num b => b. the type system take the most polymorphic inference.
-- so f 1.0 1 :: Num b => b.

jackel :: (Ord a, Eq b) => a -> b -> a
jackel a b = a

-- parametricity
-- Two ways to implement puer a -> a -> a
f1 :: a -> a -> a
f1 a b = a

f2 :: a -> a -> a
f2 a b = b

-- implement a -> b -> b
f3 :: a -> b -> b
f3 a b = b

module DatabaseProcessing where

import Data.Time

data DatabaseItem = DbString String
                  | DbNumber Integer
                  | DbDate UTCTime
                  deriving (Eq, Ord, Show)

theDatabse :: [DatabaseItem]
theDatabse =
    [ DbDate (UTCTime
              (fromGregorian 1911 5 1)
              (secondsToDiffTime 34123))
    , DbDate (UTCTime
              (fromGregorian 1931 5 1)
              (secondsToDiffTime 34123))
    , DbDate (UTCTime
              (fromGregorian 1981 5 1)
              (secondsToDiffTime 34123))
    , DbNumber 9001
    , DbNumber 306
    , DbNumber 803
    , DbNumber 9003
    , DbNumber 904
    , DbNumber 1001
    , DbNumber 301
    , DbString "Hello, World!"
    , DbString "World!"
    , DbString "Hello!"
    , DbString "Jojo!"
    , DbDate (UTCTime
              (fromGregorian 1921 5 1)
              (secondsToDiffTime 34123))
    ]

filterDbDate :: [DatabaseItem] -> [UTCTime]
filterDbDate =
    foldr consDate []
        where consDate a b =
                case a of
                  (DbDate date) -> date:b
                  _ -> b

-- handle all cases. the pattern matching works just like branches.
filterDbNumber :: [DatabaseItem] -> [Integer]
filterDbNumber [] = []
filterDbNumber (DbNumber x:[]) = [x]
filterDbNumber (_:[]) = []
filterDbNumber (DbNumber x:xs) = x:filterDbNumber xs
filterDbNumber (_:xs) = filterDbNumber xs

mostRecent :: [DatabaseItem] -> UTCTime
mostRecent = maximum . filterDbDate

sumDb :: [DatabaseItem] -> Integer
sumDb = sum . filterDbNumber

avgDb :: [DatabaseItem] -> Double
avgDb x = fromIntegral
          (sum . filterDbNumber $ x)
          / (fromIntegral $ length $ filterDbNumber x)

module Deconstruct where

newtype Name = Name String deriving Show
newtype Acres = Acres Int deriving Show

data FarmerType = DairyFarmer
                | WheatFarmer
                | SoybeanFarmer deriving Show

data Farmer = Farmer Name Acres FarmerType deriving Show
data FarmerRec =
    FarmerRec { name :: Name
              , acres :: Acres
              , farmerType :: FarmerType } deriving Show

isDairyFarmer :: Farmer -> Bool
isDairyFarmer (Farmer _ _ DairyFarmer) = True
isDairyFarmer _ = False

isWheatFarmer :: FarmerRec -> Bool
isWheatFarmer farmer = case farmerType farmer of
                         WheatFarmer -> True
                         _ -> False


-- handle bottom for records
-- wrap the product case with bottom case into a new type
data Car = Car { make :: String
               , model :: String
               , year :: Integer } deriving (Eq, Show)

data Automobile = Null
                | Automobile Car
                deriving (Eq, Show)

-- define list
data List a = Nil | Cons a (List a) deriving (Eq, Show)




module Do where

import System.IO
import Control.Monad (when)

getName :: IO ()
getName = do
    hSetBuffering stdout NoBuffering
    putStr "Your Name: "
    name <- getLine
    putStrLn name

getName' :: IO ()
getName' =
  hSetBuffering stdout NoBuffering >>
    putStr "Your Name " >>
      getLine >>=
        \name ->
          putStrLn name

addStr :: IO String
addStr = do
    x1 <- getLine
    x2 <- getLine
    putStrLn (x1 ++ x2)
    return (x1 ++ x2)

addStr' :: IO String
addStr' =
  getLine >>=
    \x1 ->
      getLine >>=
        \x2 ->
          putStrLn (x1 ++ x2) >> return (x1 ++ x2)

twoo :: IO ()
twoo = do c <- getChar
          c' <- getChar
          when (c == c') $ putStrLn "True"
          -- if (c == c')
          --    then putStrLn "True"
          -- else return ()

twoo' :: IO ()
twoo' =
  getChar >>=
    \c ->
      getChar >>=
        \c' ->
          when (c == c') $ putStrLn "True"





fact 0 = 1
fact n = n * fact (n - 1)
module Flip where


flips :: (a -> b -> c) -> b -> a -> c
flips f x y = f y x

returnLast :: a -> b -> c -> d -> d
returnLast _ _ _ d = d

data Employee = Coder
              | Manager
              | Veep
              | CEO
              deriving (Eq, Ord, Show)

reportBoss :: Employee -> Employee -> IO ()
reportBoss e e' =
    putStrLn $ show e ++ " is the boss of " ++ show e'

employeeRank :: (Employee -> Employee -> Ordering)
             -> Employee
             -> Employee
             -> IO ()

employeeRank f e e' =
    case f e e' of
      GT -> reportBoss e e'
      EQ -> putStrLn "Neither emploee is the boss"
      LT -> reportBoss e' e

codersRuleCEOsDrool :: Employee -> Employee -> Ordering
codersRuleCEOsDrool Coder Coder = EQ
codersRuleCEOsDrool Coder _ = GT
codersRuleCEOsDrool _ Coder = LT
codersRuleCEOsDrool e e' = compare e e'

-- guard syntax use | pipe sign to begin a guard case.
newAbs :: Integer -> Integer
newAbs x
    | x < 0 = -x
    | otherwise = x

isRight :: (Num a, Eq a) => a -> a -> a -> String
isRight a b c
    | a^2 + b^2 == c^2 = "Right angle"
    | otherwise = "not right"

-- function composition (f. g) x = f (g x)
takeFirstFiveOdd :: (Integral a, Enum a) => a -> [a]
takeFirstFiveOdd = take 5 . filter odd . enumFrom

-- same function written without function composition
takeFirstFiveOdd1 :: (Integral a, Enum a) => a -> [a]
takeFirstFiveOdd1 n = take 5 (filter odd (enumFrom n))

-- same function in point free style in a sense ...
takeFirstFiveOddPointFree :: (Integral a, Enum a) => a -> [a]
takeFirstFiveOddPointFree = \n -> take 5 . filter odd . enumFrom $ n


-- rewrite to point free the point is to remove argument
foldPlus :: Int -> [Int] -> Int
foldPlus = foldr (+)

numOfA :: String -> Int
numOfA = length . filter (== 'A')


{-# LANGUAGE FlexibleInstances #-}
module FlipFunctor where

data Tuple a b =
    Tuple a b
    deriving (Eq, Show)

newtype Flip f a b =
    Flip (f b a)
    deriving (Eq, Show)

-- Flip Tuple Char b
-- Flip $ Tuple 1 'a'

-- this instance need GHC extension since Tuple is not a type variable.
instance Functor (Flip Tuple a) where
    fmap f (Flip (Tuple a b)) = Flip $ Tuple (f a) b




module Fold where

-- catamorphism

-- all this can be written by fold
-- they all have a base case as identity and then recursively build up.
sum0 :: [Integer] -> Integer
sum0 [] = 0
sum0 (x:xs) = x + sum0 xs

length0 :: [a] -> Integer
length0 [] = 0
length0 (_:xs) = 1 + length0 xs

product0 :: [Integer] -> Integer
product0 [] = 1
product0 (x:xs) = x * product0 xs

concat0 :: [[a]] -> [a]
concat0 [] = []
concat0 (x:xs) = x ++ concat0 xs

-- foldr, right associative
-- reduce to the right actually.
reducer :: (a -> b -> b) -> b -> [a] -> b
reducer f z [] = z
reducer f z (x:xs) = f x (reducer f z xs)

reducel :: (b -> a -> b) -> b -> [a] -> b
reducel f z [] = z
reducel f z (x:xs) = reducel f (f z x) xs

-- foldl has unconditional/forced recursion of the spine.
-- because the recursion happens on function passed in, not foldl it self.
-- foldl is bad for long or infinite list since it force evaluation.
-- use foldl' for foldl, which enforce the strict evaluation
-- strict evaluation means evaluate values inside con cells as it
-- traverses the spine, rather than accumulate unevaluated expressions.

scanl0 :: (a -> b -> a) -> a -> [b] -> [a]
scanl0 f q ls =
    q : (case ls of
           [] -> []
           x:xs -> scanl f (f q x) xs)


fibs = 1:scanl (+) 1 fibs
fibsN x = fibs !! x

-- scanl in reversed order.
facts = 1 : scanl (\x y -> case x == 2 of
                             True -> 6
                             False -> (*) ((+1) $ div x y) x)
                  2 facts







module Foldable where

data Optional a =
    Nada
  | Yep a deriving (Eq ,Show)

instance Foldable Optional where
    foldr _ z Nada = z
    foldr f z (Yep x) = f x z

    foldl _ z Nada = z
    foldl f z (Yep x) = f z x

    foldMap _ Nada = mempty
    foldMap f (Yep a) = f a


module Functor where

import Test.QuickCheck
-- Functor penerates the structure and apply function to
-- the content within the structure.
-- f a, kind of f must be * -> *

data FM a =
    FM
  | Pls a
  deriving (Eq, Show)


-- note it is FM not (FM a)
-- otherwise a will become a part of the functor sturcture,
-- the kind of (FM a) is *, but to be a functor it need to have
-- kind * -> *.
-- (FM a) will not compile.
instance Functor FM where
    fmap _ FM = FM
    fmap f (Pls a) = Pls (f a)

-- lift twice type checking.
-- (.) :: (b -> c) -> (a -> b) -> a -> c
--         fmap         fmap
-- fmap :: Functor f => (m -> n) -> f m -> f n
-- fmap :: Functor g => (x -> y) -> g x -> g y
-- g (f y)

data Two a b = Two a b deriving (Eq, Show)
data Or a b = Left' a
            | Right' b
            deriving (Eq, Show)

instance Functor (Two a) where
    fmap f (Two a b) = (Two a) $ (f b)

instance Functor (Or a) where
    fmap _ (Left' a) = Left' a
    fmap f (Right' b) = Right' (f b)

-- quickcheck
functorIdentity :: (Functor f, Eq (f a)) => f a -> Bool
functorIdentity f = fmap id f == f

functorComposition :: (Eq (f c), Functor f) =>
                        (a -> b) -> (b -> c) -> f a -> Bool
functorComposition f g x =
    fmap g (fmap f x) == fmap (g . f) x

main :: IO ()
main = do
    quickCheck $ \x -> functorIdentity (x :: String)
    quickCheck $ \x -> functorComposition (+1) (*2) (x :: Maybe Int)

module FunctorEx where

import Test.QuickCheck
import Test.QuickCheck.Function

newtype Identity a = Identity a deriving (Eq, Show)
data Pair a = Pair a a deriving (Eq, Show)
data Two a b = Two a b deriving (Eq, Show)
data Three a b c = Three a b c deriving (Eq, Show)
data Three' a b = Three' a b b deriving (Eq, Show)
data Four a b c d = Four a b c d deriving (Eq, Show)
data Four' a b = Four' a a a b deriving (Eq, Show)

-- Identity
instance Functor Identity where
    fmap f (Identity a) = Identity $ f a

genId :: Arbitrary a => Gen (Identity a)  -- Generate one arbitrary Identity a
genId = do
    a <- arbitrary
    return $ Identity a
instance Arbitrary a => Arbitrary (Identity a) where  -- typeclass for Arbitrary
    arbitrary = genId

-- Pair
instance Functor Pair where
    fmap f (Pair a b) = Pair (f a) (f b)
genPair :: Arbitrary a => Gen (Pair a)
genPair = do
    a <- arbitrary
    b <- arbitrary
    return $ Pair a b

instance Arbitrary a => Arbitrary (Pair a) where
    arbitrary = genPair

-- Two
instance Functor (Two a) where
    fmap f (Two a b) = (Two a) $ (f b)

genTwo :: (Arbitrary a, Arbitrary b) => Gen (Two a b)
genTwo = do
    a <- arbitrary
    b <- arbitrary
    return $ Two a b

instance (Arbitrary a, Arbitrary b) => Arbitrary (Two a b) where
    arbitrary = genTwo

instance Functor (Three a b) where
    fmap f (Three a b c) = (Three a b) $ (f c)
genThree :: (Arbitrary a, Arbitrary b, Arbitrary c) => Gen (Three a b c)
genThree = do
    a <- arbitrary
    b <- arbitrary
    c <- arbitrary
    return $ Three a b c
instance (Arbitrary a, Arbitrary b, Arbitrary c) =>
        Arbitrary (Three a b c) where
            arbitrary = genThree

 -- Three'
instance Functor (Three' a) where
    fmap f (Three' a b c) = Three' a (f b) (f c)
genThree' :: (Arbitrary a, Arbitrary b) => Gen (Three' a b)
genThree' = do
    a <- arbitrary
    b <- arbitrary
    c <- arbitrary
    return $ Three' a b c
instance (Arbitrary a, Arbitrary b) => Arbitrary (Three' a b) where
    arbitrary = genThree'

-- Four
instance Functor (Four a b c) where
    fmap f (Four a b c d) = (Four a b c) $ (f d)
genFour :: (Arbitrary a, Arbitrary b, Arbitrary c, Arbitrary d) =>
           Gen (Four a b c d)
genFour = do
    a <- arbitrary
    b <- arbitrary
    c <- arbitrary
    d <- arbitrary
    return $ Four a b c d
instance (Arbitrary a, Arbitrary b, Arbitrary c, Arbitrary d) =>
    Arbitrary (Four a b c d) where
        arbitrary = genFour

-- Four'
instance Functor (Four' a) where
    fmap f (Four' a b c d) = Four' a b c (f d)
genFour' :: (Arbitrary a, Arbitrary b) =>
            Gen (Four' a b)
genFour' = do
    a <- arbitrary
    b <- arbitrary
    c <- arbitrary
    d <- arbitrary
    return $ Four' a b c d
instance (Arbitrary a, Arbitrary b) => Arbitrary (Four' a b) where
    arbitrary = genFour'

-- functor check
functorIdentity :: (Functor f, Eq (f a)) => f a -> Bool
functorIdentity f = fmap id f == f

functorComposition :: (Functor f, Eq (f c)) =>
                         f a -> Fun a b -> Fun b c -> Bool
functorComposition x (Fun _ f) (Fun _ g) =
    (fmap g . fmap f) x == (fmap (g . f) x)

-- checking type signatures
type IntToInt = Fun Int Int
type IntFC = [Int] -> IntToInt -> IntToInt -> Bool
type IdFC = Identity Int -> IntToInt -> IntToInt -> Bool
type PairFC = Pair Int -> IntToInt -> IntToInt -> Bool
type TwoFC = Two Int Int -> IntToInt -> IntToInt -> Bool
type ThreeFC = Three Int Int Int -> IntToInt -> IntToInt -> Bool
type ThreeFC' = Three' Int Int -> IntToInt -> IntToInt -> Bool
type FourFC = Four Int Int Int Int -> IntToInt -> IntToInt -> Bool
type FourFC' = Four' Int Int -> IntToInt -> IntToInt -> Bool


main :: IO ()
main = do
    putStrLn "Functor [Int]"
    quickCheck (functorIdentity :: ([Int] -> Bool))
    quickCheck (functorComposition :: IntFC)
    putStrLn "Identity [Int]"
    quickCheck (functorIdentity :: (Identity Int -> Bool))
    quickCheck (functorComposition :: IdFC)
    putStrLn "Pair [Int]"
    quickCheck (functorIdentity :: (Pair Int -> Bool))
    quickCheck (functorComposition :: IdFC)
    putStrLn "Two [Int]"
    quickCheck (functorIdentity :: (Two Int Int -> Bool))
    quickCheck (functorComposition :: TwoFC)
    putStrLn "Three [Int]"
    quickCheck (functorIdentity :: (Three Int Int Int -> Bool))
    quickCheck (functorComposition :: ThreeFC)
    putStrLn "Three' [Int]"
    quickCheck (functorIdentity :: (Three' Int Int -> Bool))
    quickCheck (functorComposition :: ThreeFC')
    putStrLn "Four [Int]"
    quickCheck (functorIdentity :: (Four Int Int Int Int -> Bool))
    quickCheck (functorComposition :: FourFC)
    putStrLn "Four' [Int]"
    quickCheck (functorIdentity :: (Four' Int Int -> Bool))
    quickCheck (functorComposition :: FourFC')



module MonadListDemo where

-- list monad
twiceWhenEven :: [Integer] -> [Integer]
twiceWhenEven xs = do
    x <- xs
    if even x
       then [x * x, x * x]
       else []

twiceWhenEven' :: [Integer] -> [Integer]
twiceWhenEven' xs =
    xs >>=
        \x -> if even x
                 then [x * x, x * x]
                 else []

-- Maybe Monad
data Cow = Cow {
    name :: String
  , age :: Int
  , weight :: Int
  } deriving (Eq, Show)

noEmpty :: String -> Maybe String
noEmpty "" = Nothing
noEmpty str = Just str

noNegative :: Int -> Maybe Int
noNegative n
  | n >= 0 = Just n
  | otherwise = Nothing

weightCheck :: Cow -> Maybe Cow
weightCheck c =
    let w = weight c
        n = name c
     in if n == "Bess" && w > 499 then Nothing else Just c

mkSphericalCow :: String -> Int -> Int -> Maybe Cow
mkSphericalCow name age weight = do
    nammy <- noEmpty name
    agey <- noNegative age
    weighty <- noNegative weight
    weightCheck (Cow nammy agey weighty)

mkSphericalCow' :: String -> Int -> Int -> Maybe Cow
mkSphericalCow'  name age weight =
    noEmpty name >>=
        \namey ->
            noNegative age >>=
                \agey ->
                    noNegative weight >>=
                        \weighty ->
                            weightCheck (Cow namey agey weighty)



module MonoidDemo where

data Optional a =
    Nada
  | Only a
  deriving (Eq, Show)

-- Note that there is a Monoid constrain for a.

-- Semigroup is a superclass for Monoid
instance Monoid a => Monoid (Optional a) where
    mempty = Nada

instance Semigroup a => Semigroup (Optional a) where
    Nada <> (Only a) = Only a
    (Only a) <> Nada = Only a
    (Only a) <> (Only a') = Only (a <> a')
    Nada <> Nada = Nada




{-# LANGUAGE GeneralizedNewtypeDeriving #-}
module Moretypes where

data Price =
    Price Integer deriving (Eq, Show)

data Size =
    Size Integer deriving (Eq, Show)

data Manufacturer =
    Mini
  | Mazda
  | Tata
    deriving (Eq, Show)

data Airline =
    PapuAir
  | CatapultsR'Us
  | TakeYourChanceUnited
    deriving (Eq, Show)

data Vehicle = Car Manufacturer Price
             | Plane Airline Size
               deriving (Eq, Show)

isCar :: Vehicle -> Bool
isCar (Car _ _) = True
isCar _ = False

isPlane :: Vehicle -> Bool
isPlane (Plane _ _) = True
isPlane _ = False

areCars :: [Vehicle] -> Bool
areCars = all isCar

getManu :: Vehicle -> Manufacturer
getManu (Car x _) = x

-- newtypes checks

class TooMany a where
    tooMany :: a -> Bool

instance TooMany Int where
    tooMany n = n > 10
instance TooMany Bool where
    tooMany n = not n

newtype Goats =
    Goats Int deriving (Eq, Show, TooMany)
newtype Cow =
    Cow Int deriving (Eq, Show, TooMany)
newtype Flip =
    Flip Bool deriving (Eq, Show, TooMany)

-- record syntax for product type
data Person = MkPerson String Int deriving (Eq, Show)
namae :: Person -> String
namae (MkPerson s _) = s

-- record syntax allows named record fields.
data Homo =
    Homo { name :: String
         , age :: Int }
         deriving (Eq, Show)

-- algebra of datatypes

data Fiction = Fiction deriving Show
data Nonfiction = Nonfiction deriving Show
data BookType = FictionBook Fiction
              | NonfictionBook Nonfiction
              deriving Show

type AuthorName = String
-- this is not in normal form
-- data Author = Author (AuthorName, BookType)

data Author =
    Fiction AuthorName
  | Nonfiction AuthorName
  deriving (Eq, Show)

-- sum of product, normal form.
-- data Expr =
--     Number Int
--   | Add Expr Expr
--   | Minus Expr
--   | Mult Expr Expr
--   | Divide Expr Expr

-- a stircter represenation for normal form of Expr
type Number = Int
type Add = (Expr, Expr)
type Minus = Expr
type Mult = (Expr, Expr)
type Divide = (Expr, Expr)

type Expr =
    Either Number
        (Either Add
            (Either Minus
                Either Mult Divide))

data FlowerType =
    Gardenia
  | Daisy
  | Rose
  | Lilac
  deriving Show

type Gardener = String

data Garden =
    Garden Gardener FlowerType
    deriving Show

data NormalGarden =
    Gardienia Gardener
  | Daisy Gardener
  | Rose Gardener
  | Lilac Gardener
  deriving Show



module NaturalTransformation where




module NumersToWords where
import Data.List (intersperse)

digitToWord :: Int -> String
digitToWord n
    | n == 0 = "zero"
    | n == 1 = "one"
    | n == 2 = "two"
    | n == 3 = "three"
    | n == 4 = "four"
    | n == 5 = "five"
    | n == 6 = "six"
    | n == 7 = "seven"
    | n == 8 = "eight"
    | n == 9 = "nine"
    | otherwise = ""

digits :: Int -> [Int]
digits n
  | mod n 10 == n = (:[]) n
  | otherwise = let di = mod n 10
                    next = div n 10 in
                    (digits next) ++ [di]

wordNumber :: Int -> String
wordNumber n = concat . intersperse "-" . map digitToWord . digits $ n
module Penguins where

-- sum type
data WherePenguinsLive =
    Galapagos
  | Antarctica
  | Austrilia
  | SouthAfrica
  | SouthAmerica
  deriving (Eq, Show)

-- product type
data Penguin =
    Peng WherePenguinsLive
    deriving (Eq, Show)

isSouthAfrica :: WherePenguinsLive -> Bool
isSouthAfrica SouthAfrica = True
isSouthAfrica _ = True

gimmeWhereTheyLive :: Penguin -> WherePenguinsLive
gimmeWhereTheyLive (Peng whereitlives) = whereitlives

galapagosPenguin :: Penguin -> Bool
galapagosPenguin (Peng Galapagos) = True
galapagosPenguin _ = False

antarcticaPenguin :: Penguin -> Bool
antarcticaPenguin (Peng Antarctica) = True
antarcticaPenguin _ = False

antarcticaOrGalapagos :: Penguin -> Bool
antarcticaOrGalapagos p = (antarcticaPenguin p) || (galapagosPenguin p)

-- tuple unpacking with pattern matching.
f :: (a, b) -> (c, d) -> ((b, d), (a, c))
f (a, b) (c, d) = ((b, d), (a, c))

-- pattern matching with underscore
fst3 :: (a, b, c) -> a
fst3 (x, _, _) = x



module PossiblyFunctor where

-- Maybe Functor
data Possibly a =
    LolNope
  | Yeet a
  deriving (Eq, Show)

instance Functor Possibly where
    fmap _ LolNope = LolNope
    fmap f (Yeet a) = Yeet $ f a

-- Either Functor
data Or a b =
    First a
  | Second b
  deriving (Eq, Show)

instance Functor (Or a) where
    fmap f (Second b) = Second $ f b
    fmap _ (First a) = First a

-- Impossible, because the type argument a is part of the Functor structure.
-- instance Functor (Or a) where
--     fmap _ (Second b) = Second b
--     fmap f (First a) = First $ (f a)
module Print1 where

main :: IO()
main = putStrLn "hello world!"

module Print2 where

main :: IO ()
main = do
    putStrLn "Count to four for me:"
    putStr "one, two, "
    putStr "tree, and"
    putStrLn " four!"


module Print3 where

myGreeting :: [Char]
myGreeting = "hello" ++ " world!"

hello :: String
hello = "hello"

world :: String
world = "world!"

main :: IO()
main = do
    putStrLn myGreeting
    putStrLn secondGreegting
             where secondGreegting = concat [hello, " ", world]



module QcApplicative where

import Test.QuickCheck

data Bull =
    Fools
  | Twoo
  deriving (Eq, Show)

instance Arbitrary Bull where
    aribitrary =
        frequency [ (1, return Fools)
                  , (1, return Twoo) ]

instance Monoid Bull where
    mempty = Fools
    (<>) _ _ = Fools

main :: IO ()
main = undefined




module QuickCheck where

import Control.Monad
import Data.Monoid
import Test.QuickCheck

-- TESTING ASSOCIATIVITY
-- if want to use quickcheck, need to be careful that a specific type is denoted
-- otherwise GHC will pick up defualt type ().
monoidAssoc :: (Eq m, Monoid m) => m -> m -> m -> Bool
monoidAssoc a b c = a <> (b <> c) == (a <> b) <> c
-- check like this.
-- check = quickCheck (monoidAssoc :: String -> String -> String -> Bool)


-- TESTING IDENTITY
monoidIdLeft :: (Eq m, Monoid m) => m -> Bool
monoidIdLeft a = (mempty <> a) == a

monoidIdRight :: (Eq m, Monoid m) => m -> Bool
monoidIdRight a = a == (mempty <> a)

data Bull =
    Fools
  | Twoo
  deriving (Eq, Show)

-- define the Arbitrary instance
instance Arbitrary Bull where
    arbitrary = frequency [ (1, return Fools)
                          , (1, return Twoo)]

instance Monoid Bull where
    mempty = Fools

instance Semigroup Bull where
    Fools <> Twoo = Twoo
    Twoo <> Fools = Twoo
    Twoo <> Twoo = Twoo
    _ <> _ = Fools

type BullMappend = Bull -> Bull -> Bull -> Bool

-- TEST FOR my VERSION OF Maybe
-- data declaration
data Optional a =
    Nada
  | Only a
  deriving (Eq, Show)

-- define a single parameter newtype with record syntax.
-- record syntax can be very useful to create Product datatype.
-- here it is only used to access the value.
newtype First' a =
    First' { getFirst' :: Optional a }  -- value Optonal a can be accessed
                                        -- directly by getFirst' (Optional a)
    deriving (Eq, Show)

-- the helper function to generate (Optional a), by generating an arbitrary a.
genOnly :: Arbitrary a => Gen (Optional a)
genOnly = do
    x <- arbitrary  -- decude the value of arbitrary accroding to type.
    return $ Only x

-- use the previous helper function to implement Arbitrary tyclass instance
-- for (Optional a)
instance Arbitrary a => Arbitrary (Optional a) where
    arbitrary =
        frequency [ (1, genOnly)
                  , (1, return Nada)]

-- Do the same thing, implement Arbitrary for First'
-- First' as a wrapper newtype need to has arbitrary instance to do quickheck
genFirst :: Arbitrary a => Gen (First' a)
genFirst = do
    x <- arbitrary
    return First' { getFirst' = x }
instance Arbitrary a => Arbitrary (First' a) where
    arbitrary = genFirst


-- Semigroup is Superclass of Monoid, operations need to be defined there.
instance Monoid (First' a) where
    mempty = First' { getFirst' = Nada }

instance Semigroup (First' a) where
    -- pattern matching here also use record syntax.
    -- because you need to specify which value the pattern is corresponding with
    (First' { getFirst' = Nada }) <>
        (First' { getFirst' = Nada }) =
        (First' { getFirst' = Nada })

    (First' { getFirst' = Only a}) <>
        (First' { getFirst' = Nada }) =
        (First' { getFirst' = Only a})

    (First' { getFirst' = Nada }) <>
        (First' { getFirst' = Only a}) =
        (First' { getFirst' = Only a})

    (First' { getFirst' = Only a}) <>
        (First' { getFirst' = Only a'}) =
        (First' { getFirst' = Only a})

firstMappend :: First' a
             -> First' a
             -> First' a
firstMappend = mappend

type FirstMappend =
     First' String
  -> First' String
  -> First' String
  -> Bool

type FstId =
    First' String -> Bool

main :: IO ()
main = do
    -- use quick check to cheaply check the validity of laws.
    quickCheck (monoidAssoc :: FirstMappend)
    quickCheck (monoidIdLeft :: FstId)
    quickCheck (monoidIdRight :: FstId)

-- Magma: less strict than a semigroup.
module Recur where

factorial :: Integer -> Integer
factorial 0 = 1
factorial n = n * factorial (n - 1)

factorialGuard :: Integer -> Integer
factorialGuard n
  | n == 0 = 1
  | otherwise = n * factorialGuard (n - 1)

-- recursion
applyTimes :: (Eq a, Num a) => a -> (b -> b) -> b -> b
applyTimes 0 _ b = b
applyTimes n f b = f . applyTimes (n - 1) f $ b

incTimes :: (Eq a, Num a) => a -> a -> a
incTimes times n = applyTimes times (+1) n

-- use type Maybe
fMaybe :: Bool -> Maybe Int
fMaybe False = Just 0
fMaybe _ = Nothing

-- fibonacci
fibonacci :: Integral a => a -> a
fibonacci 0 = 0
fibonacci 1 = 1
fibonacci x = fibonacci (x - 1) + fibonacci (x - 2)

-- division with recursion
type Numerator = Integer
type Denominator = Integer
type Quotient = Integer

-- user defined data type to handle exceptions.
data DividedResult =
    Result Quotient
  | DividedByZero
  deriving (Eq, Show)

dividedBy :: Numerator -> Denominator -> DividedResult
dividedBy num deno = go num deno 0
    where go n d count
            | deno == 0 = DividedByZero
            | n < d = Result count
            | otherwise = go (n - d) d (count + 1)

-- go is an idiom of haskell

sumUp :: (Eq a, Num a) => a -> a
sumUp n
    | n == 1 = 1
    | otherwise = (+) n . sumUp $ (n - 1)

mulBy :: (Integral a) => a -> a -> a
mulBy a b = go a b 0
    where go a b product
            | b == 0 = product
            | otherwise = go a (b - 1) (product + a)

-- McCarthy 91 function
mc91 :: Integer -> Integer
mc91 n
    | n > 100 = n - 10
    | otherwise = mc91 . mc91 $ n + 11

module refactorWithTraverse where

data Query      = Query
data SomeObj    = SomeObj
data IoOnlyObj  = IoOnlyObj
data Err        = Err

decodeFn :: String -> Either Err SomeObj
decodeFn = undefined

fetchFn :: Query -> IO [String]
fetchFn = undefined

makeIoOnlyObj :: [SomeObj] -> IO [(SomeObj, IoOnlyObj)]
makeIoOnlyObj = undefined

-- before
pipelineFnOld :: Query
              -> IO (Either Err [(SomeObj, IoOnlyObj)])
pipelineFnOld query = do
    a <- fetchFn query
    case sequence (map decodeFn a) of
      (Left err) -> return $ Left $ err
      (Right res) -> do
          a <- makeIoOnlyObj res
          return $ Right a


-- new
pipelineFnNew :: Query
              -> IO (Either Err [(SomeObj, IoOnlyObj)])
pipelineFnNew query = do
    a <- fetchFn query
    traverse makeIoOnlyObj (mapM decodeFn a)


-- point free
pipelineFnM :: Query
            -> IO (Either Err [(SomeObj, IoOnlyObj)])
pipelineFnM = (traverse makeIoOnlyObj . mapM decodeFn =<<) fetchFn

-- traverse is more generic mapM
pipelineFn :: Query
           -> IO (Either Err [(SomeObj, IoOnlyObj)])
pipelineFn = (traverse makeIoOnlyObj
             . traverse decodeFn =<<)
             . fetchFn

module RegisteredUser1 where

newtype Username = Username String
newtype AccountNumber = AccountNumber Integer

data User = UnregisteredUser
          | RegisteredUser Username AccountNumber

-- RegisteredUser :: Username -> AccountNumber -> User
-- RegisteredUser is a function that constructs a User out of two args.
-- So it is called as data constructor
printUser :: User -> IO ()
printUser UnregisteredUser = putStrLn "UnregisteredUser"
printUser (RegisteredUser (Username name)
                          (AccountNumber accNum))
           = putStrLn $ name ++ " " ++ show accNum



module Reverse where

rvrs :: String -> String
rvrs x = concat [drop 9 x, " ", drop 6 (take 8 x), " ", take 5 x]

main :: IO ()
main = print $ rvrs "Curry is awesome!"
-- main = print (rvrs "Curry is awesome!")
sayHello :: String -> IO()
sayHello x = putStrLn ("Hello" ++ x ++ "!")

-- modulo consistency
(quot x y) * x + (rem x y) == x
(div x y) * x + (mod x y) == x


module TopOrLocal where

topLevelFunc :: Integer -> Integer
topLevelFunc x = x + woot + topLevelVal
    where woot :: Integer
          woot = 10

topLevelFuncLet :: Integer -> Integer
topLevelFuncLet x = let woot :: Integer
                        woot = 10
                        moot :: Integer
                        moot = 100
                  in x + woot + moot + topLevelVal

topLevelVal :: Integer
topLevelVal = 5



module TypeInference1 where

f :: Num a => a -> a -> a
f x y = x + y + 3



module TypeInference2 where

f x y = x + y + 3

module Typeclass where

data Trivial = Trivial'
instance Eq Trivial where
    Trivial' == Trivial' = True

-- sum type. the equivalence Enum in C is actually a partial function.
data DayOfWeek =
    Mon | Tue | Weds | Thu | Fri | Sat | Sun deriving Show

data Date =
    Date DayOfWeek Int deriving Show

instance Eq DayOfWeek where
    (==) Mon Mon = True
    (==) Tue Tue = True
    (==) Weds Weds = True
    (==) Thu Thu = True
    (==) Fri Fri = True
    (==) Sat Sat = True
    (==) Sun Sun = True
    (==) _ _ = False

instance Ord DayOfWeek where
    compare Fri Fri = EQ
    compare Fri _ = GT
    compare _ Fri = LT
    compare _ _ = EQ

instance Eq Date where
    (==) (Date weekday dayOfMonth)
         (Date weekday' dayOfMonth') =
             weekday == weekday' && dayOfMonth == dayOfMonth'

data Identity a = Identity a

instance Eq a => Eq (Identity a) where
    (==) (Identity v) (Identity v') = v == v'


-- exercises
-- write the Eq instance for following datatypes.
data TisAnInteger = TisAn Integer
instance Eq TisAnInteger where
    (==) (TisAn a)
         (TisAn a') =
             a == a'

-- avoid use two integers. a1, b1 are instance definition
data TwoIntegers = Two Integer Integer
instance Eq TwoIntegers where
    (==) (Two a b)
         (Two a' b') =
             a == a' && b == b'

-- avoid non exhaustive pattern matches (partial functions)
data StringOrInt =
    TisAnInt Int
  | TisAString String
instance Eq StringOrInt where
    (==) (TisAnInt a)
         (TisAnInt a') = a == a'
    (==) (TisAString a)
         (TisAString a') = a == a'
    (==) _ _ = False

-- 4. two variables need to be the same type
data Pair a =
    Pair a a
instance Eq a => Eq (Pair a) where
    (==) (Pair a a')
         (Pair b b') = a == b && a' == b'

-- 5. two variable can be different types
data Tuple a b =
    Tuple a b
instance (Eq a, Eq b) => Eq (Tuple a b) where
    (==) (Tuple a a')
         (Tuple b b') = a == b && a' == b'

-- 6.
data Which a =
    ThisOne a
  | ThatOne a

instance Eq a => Eq (Which a) where
    (==) (ThisOne a) (ThisOne a') = a == a'
    (==) (ThatOne a) (ThatOne a') = a == a'
    (==) _ _ = False

-- 7.
data EitherOr a b =
    Hello a
  | Goodbye b

instance (Eq a, Eq b) => Eq (EitherOr a b) where
    (==) (Hello a) (Hello a') = a == a'
    (==) (Goodbye a) (Goodbye a') = a == a'
    (==) _ _ = False

module Typeclass2 where

class Numberish a where
    fromNum :: Integer -> a
    toNum :: a -> Integer
    defaultNum :: a

newtype Age = Age Integer deriving (Eq, Show)
newtype Year = Year Integer deriving (Eq, Show)

instance Numberish Age where
    fromNum = Age
    toNum (Age n) = n
    defaultNum = Age 65  -- will not provide enough info for type inferrence

instance Numberish Year where
    fromNum = Year
    toNum (Year n) = n
    defaultNum = Year 1998

sumNumberish :: Numberish a => a -> a -> a
sumNumberish a a' = fromNum summed
    where integerOfA = toNum a
          integerOfAPrime = toNum a'
          summed = (+) integerOfA integerOfAPrime




module Typeclass3 where

add :: Num a => a -> a -> a
add x y = x + y

addWeird :: (Num a, Ord a) => a -> a -> a
addWeird x y =
    if x > 1
       then x + y
    else x

-- concret types imply all the typeclasses they provide
-- addInt :: Int -> Int -> Int
-- addWeirdInt :: Int -> Int -> Int

module Types where

data Mood = Blah | Woot deriving Show

-- pattern matching.
changeMood :: Mood -> Mood
changeMood Blah = Woot
changeMood _ = Blah
module Valid where

type Name = String
type Age = Integer
type ValidatePerson a = Either [PersonInvalid] a

data Person = Person Name Age deriving Show
data PersonInvalid = NameEmpty
                   | AgeTooLow
                   deriving (Eq, Show)

ageOk :: Age -> ValidatePerson Age
ageOk age = case age >= 0 of
              True -> Right age
              False -> Left [AgeTooLow]

nameOk :: Name -> ValidatePerson Name
nameOk name = case name /= "" of
              True -> Right name
              False -> Left [NameEmpty]

mkPerson name age =
    mkPerson' (nameOk name) (ageOk age)

mkPerson' :: ValidatePerson Name
          -> ValidatePerson Age
          -> ValidatePerson Person
mkPerson' (Right nameGood) (Right ageGood) =
    Right (Person nameGood ageGood)
mkPerson' (Left badName) (Left badAge) =
    Left (badName ++ badAge)
mkPerson' (Left badName) _ = Left badName
mkPerson' _ (Left badAge) = Left badAge









module VigenereCipher where
import Data.Char

shift :: Char -> Int -> Char
shift char n = chr . modAplhaBete (ord char) $ n
    where modAplhaBete :: Int -> Int -> Int
          modAplhaBete id n = (+97) . mod (id - 97 + n) $ 26

shiftChar :: Char -> Int
shiftChar key = (ord key) - 97

align :: Int -> Int -> Int
align strIdx keyLen = strIdx `mod` keyLen

encodeVingenere :: String -> String -> String
encodeVingenere key (x:xs) = go key (x:xs) 0
    where
        go _ "" _ = ""
        go k (a:as) count =
            shift a
                  (shiftChar $ key !! align count (length k))
            : go k as (count + 1)




module WrapFunctor where

data Wrap f a =
    Wrap (f a)
    deriving (Eq, Show)

instance  Functor f => Functor (Wrap f) where
    fmap f (Wrap fa) = Wrap (fmap f fa)


module WrepCall where

import Data.ByteString.Lazy hiding (map)
import Network.Wreq


module ZipListApplicative where

import Test.QuickCheck

-- List Applicative
data List a =
    Nil
  | Cons a (List a)
  deriving (Eq, Show)

instance Functor List where
    fmap _ Nil = Nil
    fmap f (Cons x xs) = Cons (f x) (fmap f xs)

instance Semigroup (List a) where
    Nil <> as = as
    as <> Nil = as
    (Cons a as) <> bs = Cons a $ as <> bs

instance Monoid (List a) where
    mempty = Nil

instance Applicative List where
    pure x = Cons x Nil
    Nil <*> _ = Nil
    _ <*> Nil = Nil
    Cons f fs <*> xs = (f <$> xs) <> (fs <*> xs)

take' :: Int -> List a -> List a
take' idx xs = go idx xs Nil 0
    where
        go :: Int -> List a -> List a -> Int -> List a
        go i Nil rs count = if count < i then Nil else rs
        go i (Cons a as) rs count
          | count == idx = rs
          | otherwise = go idx as (rs <> pure a) (count + 1)

-- ZipList
newtype ZipList a =
    ZipList (List a)
    deriving (Eq, Show)

instance Functor ZipList where
    fmap f (ZipList xs) = ZipList $ fmap f xs

instance Applicative ZipList where
    pure x = ZipList (pure x)
    ZipList Nil <*> _ = ZipList Nil
    _ <*> ZipList Nil = ZipList Nil
    ZipList (Cons f fs) <*> ZipList (Cons x xs) =
        ZipList (Cons (f x) (fs <*> xs) )


module Ch1 (
  wc
  ) where

-- 1.

wc = interact wordCount
  where
    wordCount input = show (length $ lines input) ++ "\n"
{-# LANGUAGE DeriveGeneric        #-}

-- https://stackoverflow.com/questions/8633470/illegal-instance-declaration-when-declaring-instance-of-isstring
-- Usually instance is declared as instance TypeClass Type where
-- and Type can't be type synonym or something nested like (May Int)
-- This extension relax the restriction.
-- In short, FlexibleInstances = TypeSynonymInstances + nested type.
{-# LANGUAGE FlexibleInstances    #-}

-- [Char] is a specialization of [a], normally we can't write
-- typeclass instance for it.
-- Enabling to write type instance for type String = [Char]
{-# LANGUAGE TypeSynonymInstances #-}

module Ch5
  ( JValue
  , renderJValue
  , JSON(..)
  ) where


import qualified Data.HashMap.Strict as HM
import qualified Data.List           as L
import           Data.Text
import           Data.Vector
import           GHC.Generics


data JValue = JString Text
            | JNumber Double
            | JBool Bool
            | JObject (HM.HashMap Text JValue)
            | JArray (Vector JValue)
            | JNull
            deriving (Eq, Ord, Generic)

type JError = String

instance Show JValue where
  show = renderJValue

renderJValue :: JValue -> String
renderJValue (JString s) = show s
renderJValue (JNumber n) = show n
renderJValue (JBool True) = "true"
renderJValue (JBool False) = "false"
renderJValue JNull = "null"
renderJValue (JObject o) = "{" <> (pairs . HM.toList) o <> "}"
  where
    pairs [] = ""
    pairs ps = L.intercalate ", " (renderJValue <$> ps)
    renderJValue (k, v) = show k <> ": "  <> show v

class JSON a where
  toJValue :: a -> JValue
  fromJValue :: JValue -> Either JError a


-- Implement typeclass instances whenver we see fits.
instance JSON Double where
  toJValue = JNumber
  fromJValue (JNumber n) = Right $ n
  fromJValue _           = Left "not a value"

instance JSON Int where
  toJValue = JNumber . realToFrac
  fromJValue (JNumber n) = Right $ round n
  fromJValue _           = Left "not a value"

instance JSON String where
  toJValue = JString . pack
  fromJValue (JString s) = Right $ unpack s
  fromJValue _           = Left "not a value"


-- Overlapping instances means given same type
-- GHC has multiple possible instance to choose.
-- By defeault this is not allowed because it make type
-- system undecidable.
-- Workaround with TypeSynonymInstances.
{-# LANGUAGE LambdaCase          #-}
{-# LANGUAGE ScopedTypeVariables #-}
module Ch7
  ( greeting
  , filerun
  , readLast
  , getLine'
  , putStrLn'
  , print'
  , runfs
  , withTempFile
  , fsAction
  ) where

import           Control.Exception (SomeException, catch, finally)
import           Data.Char         (toUpper)
import           System.Directory  (getTemporaryDirectory, removeFile)
import           System.IO


-- IO

greeting = do
  putStrLn "Hello, what's your name?"
  name <- getLine
  putStrLn $ "Hello, " <> name


-- Working with file handlers.
-- openFile :: FilePath -> IOMode -> IO Handle
-- hClose :: Handler -> IO ()
--
-- Why hClose?
-- 1. Haskell maintains an internal buffers for files, which
--    provides a performance boost when working with file io.
--    This implies that data might not be flushed into the file
--    until hClose is called.
-- 2. An dangling Handler takes up unnecessary resources.
filerun :: IO ()
filerun = do
  inh <- openFile "input.txt" ReadMode
  outh <- openFile "output.txt" WriteMode
  filerunLoop inh outh
  hClose inh
  hClose outh


filerunLoop :: Handle -> Handle -> IO ()
filerunLoop inh outh = hIsEOF inh >>= \case
    True -> return ()
    False -> do
      inpStr <- hGetLine inh
      hPutStrLn outh (toUpper <$> inpStr)
      filerunLoop inh outh


-- seek
readLast :: Int -> FilePath -> IO ()
readLast n path = do
  h <- openFile path ReadMode
  line <- lastLine n h
  print line

lastLine :: Int -> Handle -> IO String
lastLine lineWith h = do
  hSeek h SeekFromEnd (fromIntegral . negate $  lineWith)
  line <- hGetLine h
  return $ dropWhile (/= '\n') line

-- three predefined handle (file descriptors).
getLine' = hGetLine stdin
putStrLn' = hPutStrLn stdout

print' :: (Show a) => a -> IO ()
print' = hPrint stdout


-- Playing with filesystems
runfs :: IO ()
runfs = undefined

-- cheesy way of writing tmp file.
fsAction :: FilePath -> Handle -> IO ()
fsAction tmpname tmph = do
  putStrLn "Welcome to tmpfile.hs"


-- SomeException is the super class of all Other exceptions.
-- Exceptions generally used in IO monad. But there're also ways to
-- catch exceptions on pure code.
withTempFile :: String -> (FilePath -> Handle -> IO a) -> IO a
withTempFile pattern f = do
  tempdir <- catch getTemporaryDirectory
                   (\(_ :: SomeException) -> return ".tmp")
  (tempfile, temph) <- openTempFile tempdir pattern
  finally (f tempdir temph) (do hClose temph
                                removeFile tempfile)
module Ch8
  (
  ) where


module Main where

main :: IO ()
main = putStrLn "Hello, Haskell!"
import Distribution.Simple
main = defaultMain
{-# LANGUAGE DeriveFunctor #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE PolyKinds #-}

{-
   2020-09-05
   Report on Applicative programming with effects.
   http://www.staff.city.ac.uk/~ross/papers/Applicative.pdf
-}

module ApplicativeProgrammingWithEffects where

-------------------------------------------------------------
-- Define some SKI combinators.
-------------------------------------------------------------
s :: (env -> a -> b) -> (env -> a) -> env -> b
s x y z = (x z) (y z)

i :: a -> a
i a = a

k :: a -> b -> a
k = const

{-------------------------------------------------------
-- Some common applicative functor with monad.
   These are examples implemented in monad, but really
   is just applicative.
--------------------------------------------------------}

-- 1. seqence
seqIO :: [IO a] -> IO [a]
seqIO [] = return []
seqIO (x : xs) = do
  c <- x
  cs <- seqIO xs
  return $ c : cs

-- effect only
seqIO_ :: [IO a] -> IO ()
seqIO_ xs = seqIO xs >> return () -- just discard the effect

{-
2. transpose
    Primitive version
-}
transpose :: [[a]] -> [[a]]
transpose [] = repeat []
transpose (xs : xss) = zipWith (:) xs $ transpose xss

-- with zapp: "zippy application"
repeat' :: a -> [a]
repeat' x = x : repeat x

zapp :: [a -> b] -> [a] -> [b]
zapp (f : fs) (x : xs) = f x : zapp fs xs
zapp _ _ = []

transpose' :: [[a]] -> [[a]]
transpose' [] = repeat' []
transpose' (xs : xss) = repeat' (:) `zapp` xs `zapp` transpose xss

{-
3. Evaluating expression with applicative like monad.
   Notice addition, + is carry over the environment, and in this case
   k combinators act like const, which is similar to pure for reader.
   s is really a <*>.
-}
data Expr v where
  Var :: v -> Expr v
  Val :: Int -> Expr Int
  Add :: Expr v -> Expr v -> Expr v

eval :: (Integral v) => Expr v -> Expr v -> Int
eval (Var x) = const $ fromIntegral x
eval (Val i) = k i
eval (Add p q) = k (+) `s` eval p `s` eval q

{-------------------------------------------------------
  -- canonical form of applicative programming
  Computations have a fixed structure, given by the pure function and
  a sequence of sub computations, given by effectful arguments.
  Think it as normal function application, but carrying extra effects.
--------------------------------------------------------}

liftA2' :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
liftA2' f a b = pure f <*> a <*> b

-- Make applicative a functor. Similar as above.
fmap' :: Applicative f => (a -> b) -> f a -> f b
f `fmap'` m = pure f <*> m

-- use applicative style
-- note the partially applied function itself has an instance of Applicative.
seqIOA :: [IO a] -> IO [a]
seqIOA [] = pure []
seqIOA (c : cs) = pure (:) <*> c <*> sequence cs

evalA :: (Integral a) => Expr a -> Expr a -> Int
evalA (Var x) = eval (Var x)
evalA (Val i) = pure i
evalA (Add p q) = pure (+) <*> evalA p <*> evalA q

{-------------------------------------------------------
  -- Traverse data structure
--------------------------------------------------------}
-- 1. Applicative distributor
-- Pull context from list to the out most layer. This is the
-- motivation of Traversable.
--
-- Make the list part generic you get sequence
dist :: Applicative f => [f a] -> f [a]
dist [] = pure []
dist (v : vs) = pure (:) <*> v <*> dist vs

-- dist is often used with map, which is the motivation of traverse.
flakyMap :: Applicative f => (a -> f b) -> [a] -> f [b]
flakyMap f ss = dist (f <$> ss)

-- Generalize traversable to applicatives other than list.
data Tree a = Leaf | Node (Tree a) a (Tree a)

instance Functor Tree where
  fmap _ Leaf = Leaf
  fmap f (Node l a r) = Node (f <$> l) (f a) (f <$> r)

instance Foldable Tree where
  foldMap _ Leaf = mempty
  foldMap f (Node l a r) = (foldMap f l) <> f a <> (foldMap f r)

instance Traversable Tree where
  traverse f Leaf = pure Leaf
  traverse f (Node l x r) = Node <$> (traverse f l) <*> (f x) <*> (traverse f r)

{-------------------------------------------------------
  -- Monoids are phantom applicative functors
     Every monoids induces an applicative functor
--------------------------------------------------------}
-- first we define a phantom type. Only o will exist at term level.
newtype Accy o a = Acc {acc :: o} deriving (Functor)

-- then we define the applicative for Accy
-- Note that there is no value for type a, so really no application
-- what so ever. Only thing that happens is combine the monoid part.
instance Monoid o => Applicative (Accy o) where
  pure _ = Acc mempty
  Acc o' <*> Acc o'' = Acc $ o' <> o''

-- Acc . f :: a -> Acc o a
-- traverse (Acc . f) :: t a -> Acc o (t a)
-- But a is really nothing, so again eventually the <*> just combine
-- monoids o.
accumulate :: (Traversable t, Monoid o) => (a -> o) -> t a -> o
accumulate f = acc . traverse (Acc . f)

reduce :: (Traversable t, Monoid o) => t o -> o
reduce = accumulate id

-- use traversable to make some useful functions.
-- (:[]) :: a -> [a], and [a] is a monoid.
-- So in words it traverse the entire tree, turn each element into a
-- list with the element in it, and concat all lists.
flatten :: Tree a -> [a]
flatten = accumulate (: [])

concat' :: [[a]] -> [a]
concat' = reduce

{-------------------------------------------------------
  -- Comparision with monad
  -- 1.
      ap :: Monad m => m (a -> b) -> m a -> m b is application defined
      on monad. We can define an applicative functor for every single
      monad: as long as you define the ap you get applicative for free.
  -- 2.
      Some applicative can't be a monad. There're more appicative than
      monad because it's more generic.
  -- 3.
      For a monad, (>>=) :: m a -> (a -> m b) -> m b allows the value
      returned by one computation to influence the choice of another
      (in the form of parameter, and you can use the parmeter to change
      how the resulting monad should be).
      On the other hand, applicative only sequencing effects and  keep
      the computation structure unchange.
  -- 4.
      Applicative is closed under composition, but for monads it's not
      necessarily true.
      Because all monads are applicative, all monads can compose their
      effects as composition of applicative. However, a notable difference
      between applicative composition between applicatives and mondas is
      that for applicatives you must perform all effects, but for monad
      some effect might fail and abort the execution.
--------------------------------------------------------}
-- Monad bind allows the result of the first computation influence
-- the resulting monad.
-- In the example the result of mb determines whether mt or me is performed.
miffy :: Monad m => m Bool -> m a -> m a -> m a
miffy mb mt me = do
  b <- mb
  if b then mt else me

-- In the case of applicative all effects will be performed. You can't choose.
iffy :: Applicative f => f Bool -> f a -> f a -> f a
iffy fb ft fe = pure cond <*> fb <*> ft <*> fe
  where
    cond b t e = if b then t else e

-- Applicative is close under composition
-- Two monads might not compose to make another monad, but since all
-- monads are applicatives, you at least get a composition of applicatives.
-- So if you have monads you can always combine their effects.
newtype Comp f g a = Comp {comp :: (f (g a))} deriving (Functor)

instance (Applicative f, Applicative g) => Applicative (Comp f g) where
  pure x = Comp $ (pure . pure) x
  Comp fs <*> Comp xs = Comp $ pure (<*>) <*> fs <*> xs

{-------------------------------------------------------
  -- Conclusion
     The first intution of applicative is application under effects. With
     applicatives you can have a function apply on a sequence of effectful
     arguments. During the process of application you combine effects
     together.

     Applicative is less powerful than Monad in the sense that it must
     perform all effects it entails. For monad, you have the entire function
     of (a -> m b) to decide what to do with a --- the result of m a, but for
     applicative pure f <*> a <*> b ... means you will perform effects of a,
     b, ... sequentially, there is no control mechanism.
--------------------------------------------------------}

-- skipped : arrow
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE KindSignatures #-}

{-
   2020-09-19
   Report on Datatype-generic-programming
   http://www.cs.ox.ac.uk/jeremy.gibbons/publications/dgp.pdf
-}

module DatatypeGenericProgramming where

{- 1. Introduction
 - What is generic programming?
   So called polytypism. (type safe parameterization by a datatype)

 - Genericity and parameterization
   Genericity comes with parameterizations. being able to parameterize
   computation, we can reuse the same code without extra boilderplates.

   Genericity is relative to languages. Pass by value (parameterize by value)
   in C might be called generic programming for a assembly programmer;
   similarly, parametric polymorphism is generic in a java setting.
   For haskell generic programming means finding the same structures between
   different algebraic data types.
-}

{-------------------------------------------------------------------------
   - 2. Generic programming
   - Parameterization -
     From low level parameterization to higher level parameterization:
     - Parameterize by value is called pass by value:
         Your procedure can change it's behavior based on what parameters
         get passed in.

     - parameterize by function is called higher-order function;
         Think about cps, the continuation of the cmputation is determined
         by the function get passed in.
         Higher order fuction is still pass by value, but now it's a function
         value that can be applied to other data.
     - Parameterize by type is we normally called polymorphism;
         If you're writing C++, template<typename T> T add(T a, T b);
         parameterized the type T, so the concrete type of the function
         is determined by T passed in.
         // strictly speaking, in true polymorphic system, code only get
         // generated once, instead of being specialized multiple times
         // like c++. However c++'s monophormization approach has some
         // performance benefits.
     - Parameterize by shape
         Similar idea for parameterize by type as 'by function' to 'by value'.

   It's like building an isomorphism between different data types.
-}

-- without parameterization by type (parametric polymorphism) :(
data ListI a = NilI | ConsI Int (ListI Int)

data ListC a = NilC | ConsC Char (ListC Char)

-- with parameterize by type :)
data List a = Nil | Cons a (List a) deriving (Eq, Show)

-- some helper funr later use
headL (Cons x xs) = x
headL Nil = error "bad"

tailL (Cons x xs) = xs
tailL Nil = error "bad"

append :: List a -> List a -> List a
append xs Nil = xs
append xs (Cons y ys) = Cons y (append xs ys)

-- parameterize by functions
-- The most famous example should be generalizing recursing
-- with fold.
-- Check out these repeatative implementation
-- They all look like induction with base case and an inductive step.
map' :: (a -> b) -> List a -> List b
map' f Nil = Nil
map' f (Cons x xs) = Cons (f x) (map' f xs)

sum' :: Num a => List a -> a
sum' Nil = 0
sum' (Cons x xs) = x + (sum' xs)

-- why not
foldl'' :: (b -> a -> b) -> b -> List a -> b
foldl'' _ base Nil = base
foldl'' f base (Cons x xs) = f (foldl'' f base xs) x

-- and just
map'' f xs = foldl'' (Cons . f) Nil xs

sum'' xs = foldl'' (+) 0 xs

-- much better.

{-
   C++ template is an example for genericity by structure
   The need arrives from working with abstract data types.
   For instance, in STL you pass iterators to different algorithms witout
   needing to worry about what you're passing. In the context of
   std::algorithm, iterator is the only thing you need to care about.
-}

{-
    Genericity by property
     An extension on top of genericity by structure, and including
     equational constraints.

     Here is another implementation of state monad. Put it here is to
     indicate Monad implementation demonstrates genericity by
     property. Monad is not only a common interface over different data types,
     the implementation need to conform monad rules. Namely left identity,
     right identity and associativity.
-}
newtype State s a = State {runState :: s -> (a, s)}

instance Functor (State s) where
  fmap f ms = State $ \s ->
    let (a, s') = runState ms s
     in (f a, s')

instance Applicative (State s) where
  pure a = State $ \s -> (a, s)
  (State gs) <*> (State ms) = State $ \s ->
    let (f, s') = gs s
        (a, s'') = ms s'
     in (f a, s'')

instance Monad (State s) where
  return = pure
  (State ms) >>= f = State $ \s ->
    let (a, s') = ms s
     in (runState $ f a) s'

{-
   - Genericity by stage
     Genericity for metaprogramming. For instance, c++ template instantiate
     at compile time leads c++ program be executed in a two stage fashion.
     TemplateHaskell has the similar stagin concept.
-}

{-
   - 2.7 Genericity by shape
     Parameterization over different shapes. Say you have a tree and a list,
     and you can fold over both of them. But it's hard to write a generic
     fold to take both tree and list as input because this two algebraic data
     types have different shape.
     Data generic programming aim to parameterize shape of data type to
     make program works for types with different shapes.
-}

-- BTree and List above both have fold method, and they do very similar
-- thing. The reason we can't merge them together is because this two
-- algebraic data types have different shapes.
data BTree a = Tip a | Bin (BTree a) (BTree a)

-- with parmetric polymorphism this function can work for different types.
-- with higher order function the function application can be generalized.
foldB' :: (a -> b) -> (b -> b -> b) -> BTree a -> b
foldB' t b (Tip x) = t x
foldB' t b (Bin xs ys) = b (foldB' t b xs) (foldB' t b ys)

reflectB :: BTree a -> BTree a
reflectB = foldB' Tip nib
  where
    nib xs ys = Bin ys xs

-- one catch is this function cannot be merged with foldL even though
-- they are so similar.
-- The parameterization we need is a notion to accept different shape
-- yet perform the same computation.

-- Tool for us to achieve this is Bifunctor and Fix point,
-- fold :: Bifunctor s => (s a b -> b) -> Fix s a -> b
-- The shape parmeter s varies, and it determines the shape of the input data.
-- Fix s is used to represent recursive datatypes.
-- For one instantiation Fix s a is isomorphic with List a, on the other
-- it's isomorphic with Tree a.
-- With bifunctor we can state the conherence between instances of fold for
-- different shapes.
-- discuss later.

{-
   - 2.8 Universal vs ad-hoc genericity

-}

{-
   - 2.9 Another dimension of clssification.

-}

{-------------------------------------------------------------------------
   - 3 Origami programming
   Data structure determine program strucuture.
-}

-- 3.1 map and fold on list
mapL :: (a -> b) -> (List a) -> (List b)
mapL f Nil = Nil
mapL f (Cons x xs) = (Cons (f x) (mapL f xs))

foldL :: b -> (a -> b -> b) -> List a -> b
foldL e f Nil = e
foldL e f (Cons x xs) = f x (foldL e f xs)

-- simple application
filterL :: (a -> Bool) -> List a -> List a
filterL p = foldL Nil (add p)
  where
    add p x xs = if p x then Cons x xs else xs

-- 3.2 unfolds on list
-- unfold is a dual to fold. It unpack a data structure into a list.
-- p is the predicate to decide when unfolding stops.
-- f convert the current value to a value in the final list.
-- g determine what the input of f will be in the next iteration.
-- x is the base.
unfoldL :: (b -> Bool) -> (b -> a) -> (b -> b) -> b -> List a
unfoldL p f g x =
  if p x
    then Nil
    else Cons (f x) (unfoldL p f g (g x))

-- use of unfold
preds :: Int -> List Int
preds = unfoldL (0 ==) id pred
  where
    pred n = n - 1

takeWhile :: (a -> Bool) -> List a -> List a
takeWhile p = unfoldL (firstNot p) headL tailL
  where
    firstNot p Nil = True
    firstNot p (Cons x xs) = not (p x)

-- 3.3 origami for binary trees.
data Tree a = Empty | Node a (Tree a) (Tree a)

mapT :: (a -> b) -> Tree a -> Tree b
mapT f Empty = Empty
mapT f (Node x xs ys) = Node (f x) (mapT f xs) (mapT f ys)

-- fold tree into a value, again similar function as foldL, but
-- because List and Tree has different shapes we need to provde
-- another implementation
foldT :: b -> (a -> b -> b -> b) -> Tree a -> b
foldT e _ Empty = e
foldT e f (Node x xs ys) = f x (foldT e f xs) (foldT e f ys)

-- let's use foldT to collapse a tree into a list.
inorder :: Tree a -> List a
inorder = foldT Nil glue
  where
    glue x xs ys = append xs (Cons x ys)

unfoldT :: (b -> Bool) -> (b -> a) -> (b -> b) -> (b -> b) -> b -> Tree a
unfoldT p f g h x
  | p x = Empty
  | otherwise = Node (f x) (unfoldT p f g h (g x)) (unfoldT p f g h (h x))

-- calkin wilf tree
-- side note:  formal definition
--       a/b
--      /   \
-- a/(a+b)  (a+b)/b
-- (const False) tells you the tree expand forever.
cwTree :: Tree Rational
cwTree = unfoldT (const False) frac left right (1, 1)
  where
    frac (m, n) = m / n
    left (m, n) = (m, m + n)
    right (m, n) = (m + n, n)

-- 3.4 Holymorphism (higher order polymorphic).
--
-- anamorphism (unfold) followed by catamorphism (fold) to avoid building
-- intermediate data structures.
-- (Metamorphism is the opposite, whereares, fold and unfold.)
--
-- Unfold followed by a fold is very common. It's like in producer-consumer
-- model, on one hand you have a producer of the foldable, on the other hand
-- the fold function consumer the foldable.
-- p f g are for unfold
--e h are for fold
hyloL :: (b -> Bool) -> (b -> a) -> (b -> b) -> c -> (a -> c -> c) -> b -> c
hyloL p f g e h = foldL e h . unfoldL p f g

-- deforestrated version. avoid intermeiary all together.
hyloL' :: (b -> Bool) -> (b -> a) -> (b -> b) -> c -> (a -> c -> c) -> b -> c
hyloL' p f g e h x = if p x then e else h (f x) (hyloL' p f g e h (g x))

fact :: Integer -> Integer
fact = hyloL (0 ==) id pred 1 (*)

-- Similar definition of hylomorphism for binary trees.
-- find a trend, the more generalize a function is, the more crazy the
-- type signature will be.
hyloT ::
  (b -> Bool) ->
  (b -> a) ->
  (b -> b) ->
  (b -> b) ->
  c ->
  (a -> c -> c -> c) ->
  b ->
  c
hyloT p f g1 g2 e h x =
  if p x
    then e
    else h (f x) (hyloT p f g1 g2 e h (g1 x)) (hyloT p f g1 g2 e h (g2 x))

qsort :: Ord a => List a -> List a
qsort = hyloT (== Nil) headL littles bigs Nil glue
  where
    glue x xs ys = append xs (Cons x ys)
    littles (Cons x xs) = filterL (<= x) xs
    bigs (Cons x xs) = filterL (> x) xs

-- 3.5 Short-cut fusion
-- Short cut fusion allows elimination of intermediate data structures
-- using rewrite rules that can also be performed automatically during
-- compilation.
--
-- Simplify the deforestation optimization. (build is easier for compiler
-- to work with).
buildL :: (forall b. b -> (a -> b -> b) -> b) -> List a
buildL g = g Nil Cons

-- use buildL to make unfoldL
-- unfoldL' :: (b -> Bool) -> (b -> a) -> (b -> b) -> b -> List a
-- unfoldL' p f g b = buildL (h b)
--   where
--     h b n c = if p b then n else c (f b) (h (g b) n c)

-- use buildL to make reverse
reverseL xs = buildL (\n c -> foldL id (\x g -> g . c x) xs n)

buildT :: (forall b. b -> (a -> b -> b -> b) -> b) -> Tree a
buildT g = g Empty Node

-- 3.6 Datatype genericity

{-------------------------------------------------------------------------
   - Origami Patterns
     Since program structures is determined by data structures, it makes
     sense to abstract from the determining shape, leaving only what programs
     differet shape have in common.

-}

-- Let's look at fix as a function first.
-- this function repeat recursively apply f to another f.
-- Say fix (1:)
-- we get
-- let (x = (1:) x) in x
-- let (x = (1:) x) in (1:) x
-- let (x = (1:) x) in (1:) ((1:) x)
-- ...
fix :: (a -> a) -> a
fix f = let x = f x in x

-- For list and tree, they are both recursive data structure.
-- When we want to abstract over recursive data type, we use Fix
-- s: shape type. It's a higher kinded type
-- a: the data
data Fix (s :: * -> * -> *) a = In {out :: (s a (Fix s a))}

-- note another way to define fix
data Fix' (f :: *) = Fix' f (Fix' f)

-- For instance, for list
--   Fix ListF a
-- = ListF a (Fix ListF a)
-- = ListF a (ListF a (Fix ListF a))
-- ...

-- Let's use Fix to make list and tree.

data ListF s a = NilF | ConsF s a

data TreeF s a = EmptyF | NodeF s a a

data BTreeF s a = TipF s | BinF s a a

type ListFix a = Fix ListF a

type TreeFix a = Fix TreeF a

type BTreeFix a = Fix BTreeF a

-- 3.7 bifunctors
class Bifunctor s where
  bimap :: (a -> c) -> (b -> d) -> (s a b -> s c d)

{-------------------------------------------------------------------------
   - Essense of the iterator pattern

-}

{-------------------------------------------------------------------------
   - Conclusion

-}
module Main where

main :: IO ()
main = putStrLn "Hello, Haskell!"
import Distribution.Simple
main = defaultMain
// Contribution:
//  1. Specificatoin language for expressing functional properties of rust.
//  2. Using Pledges (novel specification construct that enables modular specification)
//  3. defined a verification technique encodes both capability information and user provided
//     assertion into `implicit dynamic frane logic`
//     (closely related to separatoin logic https://www.cs.cmu.edu/~jcr/seplogic.pdf)
//  4. The verification is translated from rust into viper itermediate verification language.
//  5. The technique is provided as a plugin for rust compiler.


// What properties need to be ensured so we can call this program correct?
// 1. shift_x increase p1.x by diff.    -- what need to be verified.
// 2. call doesn't modify p2.x
// 3. shift_x doesn't modify tuple segm.
// 4. data race free, the values of all memory locations are stable throughtout
//    the execution. (With the borrow rule, we don't need to verify special
//                    case in multi-threading)
//
// Now, verification will prove these properties in general (for rust)
// (Capabiliaty information) + (Statement semantics)
// 1. capability of memory location (mut ref or shared ref)
//  1. aliasing
//  2. side effect
//  3. framing
//  4. data race
// 2. information of values.
#[derive(Debug)]
pub struct Point {
    pub x: i32,
    pub y: i32,
}

pub fn shift_x(p: &mut Point, s: i32) {
    // take a mutable reference
    p.x = p.x + s;
}

// - Note: Box guarantee unique ownership of the boxed value.
//         so there will never be alias of other data.
// - Note: Since we can guarantee segm.0 and segm.1 are different points,
//         calling shift will guarantee segm.0 is chagned while segm.1 is
//         not touched.
pub fn align(mut segm: (Box<Point>, Box<Point>)) -> (Box<Point>, Box<Point>) {
    let diff = (*segm.1).x - (*segm.1).x;

    shift_x(&mut segm.1, diff); // borrows the ownership here.
                                // borrow expired after this line.

    // it's ok to use semg.2, since nothing is borrowing it now.
    assert!((*segm.1).x == (*segm.1).x);
    segm
}

pub fn run() {
    let seg = {
        let p1 = Point { x: 10, y: 20 };
        let p2 = Point { x: 100, y: 30 };

        let old = (Box::new(p1), Box::new(p2));
        println!("old: {:?}", old);
        old
    };
    let new = align(seg);
    println!("new: {:?}", new);
}

// Process of Verification
// Program + User specification --Concert--> Verification language
// --Verify--> Pass | Not pass
//
// What's different about prusti?
//  1. need to use separation logic for imperative language.
//      1. with verification condition generator
//          1. based on hoare logic.(relationship between precondition and postcondition).
//  2. rust has ownership (make things easier actually)
//  3. use viper's permission based on separation logic to express ownership and borrow.
//
// Liquid haskell
//  1. mainly solved with SMT solver
//  3.
//
//
// What's viper?
//  1. viper is a verification language. (theorem prover)
//
//
mod leveraging_rust_types_for_modular_specfication_and_verification;

fn main() {
    println!("Hello, world!");
}
#lang racket/base

#| Exercise 1.3: |#
#|  Define a procedure that takes three numbers |#
#| as arguments and returns the sum of the squares of the two |#
#| larger numbers. |#
(module basic racket/base
  (provide sum-large-two)
  (define (square x) (* x x))
  (define (sum-square a b) (+ (square a) (square b)))
  (define (sum-large-two a b c)
    (cond [(and (> a c) (> b c)) (sum-square a b )]
          [(and (> a b) (> c b)) (sum-square a c)]
          [(and (> b a) (> c a)) (sum-square b c)])))


#| Exercise 1.5: |#
#| Ben Bitdiddle has invented a test to determine |#
#| whether the interpreter he is faced with is using applicative- |#
#| order evaluation or normal-order evaluation. He defines the |#
#| following two procedures: |#

#| (define (p) (p)) |#
#| (define (test x y) |#
#| (if (= x 0) 0 y)) |#

#| Then he evaluates the expression |#

#| (test 0 (p)) |#

#| What behavior will Ben observe with an interpreter that |#
#| uses applicative-order evaluation? |#
;; Ans:
(module application-order racket/base
  (provide test)
  (define (p) (p))
  (define (test x y)
  (if (= x 0) 0 y)))
;;      In Applicative order the expression will never stop, since (p)
;;      doesn't terminates.
;;
;;      In Normal order the expression evaluates to 0.
;;      Because the expression is expanded first then eval the boolean
;;      which has a short circuit.



#| 1.1.7 Newton's method |#
(module newtons-method racket/base
  (provide average
           square
           good-enough?)
  (define (average . args) (/ (apply + args) (length args)))
  (define (square x) (* x x))
  (define (good-enough? pred guess x) (pred guess x 0.000001)))


(module sqrt-newtons-method racket/base
  (require 'newtons-method)
  (provide square-root)
  (define (sqrt-pred guess x t)
    (< (abs (- (square guess) x)) t))

  (define (square-improve guess x)
    (average guess (/ x guess)))

  (define (sqrt-iter guess x)
    (if (good-enough? sqrt-pred guess x) guess
      (sqrt-iter (square-improve guess x) x)))

  (define (square-root x)
    (sqrt-iter 1.0 x)))

#| Exercise 1.7: |#
#| The good-enough? test used in computing |#
#| square roots will not be very effective for finding the square |#
#| roots of very small numbers. Also, in real computers, arith- |#
#| metic operations are almost always performed with lim- |#
#| ited precision. This makes our test inadequate for very large |#
#| numbers. Explain these statements, with examples showing |#
#| how the test fails for small and large numbers. An alterna- |#
#| tive strategy for implementing good-enough? is to watch |#
#| how guess changes from one iteration to the next and to |#
#| stop when the change is a very small fraction of the guess. |#
#| Design a square-root procedure that uses this kind of end |#
#| test. Does this work better for small and large numbers? |#

;; Ans:
;     For small value, the fixed tolerance 0.001 might
;     not be significant enough. If x i 0.0001, 0.001 is 100%
;     larger, this will yield a huge inaccuracy.
;
;     For large value, the machine might not be able to store
;     enough digits, so at some points if the difference still
;     haven't hit the tolerance but the value generated doesn't
;     change anymore because it ignore smaller digits, then the
;     program will loop forever.
;
;     A relative tolerance change the tolerance by the delta of
;     one guess and the next. It can avoid 2 aforementioned problems.


#| Exercise 1.8: Newton’s method for cube roots is based on |#
#| the fact that if y is an approximation to the cube root of x, |#
#| then a better approximation is given by the value |#
#| x/y 2 + 2y   |#
#| -----------. |#
#|      3       |#
#| Use this formula to implement a cube-root procedure anal- |#
#| ogous to the square-root procedure. (In Section 1.3.4 we will |#
#| see how to implement Newton’s method in general as an |#
#| abstraction of these square-root and cube-root procedures.) |#
(module better-approximation-cube-root racket/base
  (require 'newtons-method) (provide cubic-root)
  (define (cubic x) (* x x x))
  (define (cubic-improve guess x)
    (average (/ x (square guess)) guess guess))

  (define (cubic-pred guess prev-guess t)
    (< (abs (- guess prev-guess)) (abs (* t guess))))

  (define (cubicroot-iter guess pre-guess x)
    (if (good-enough? cubic-pred guess pre-guess) guess
      (cubicroot-iter (cubic-improve guess x) guess x)))

  (define (cubic-root x)
    (cubicroot-iter 1.0 0 x)))


#| 1.2.1 Liear Recursion and Linear Iteration |#
(module rec-iter racket/base
  (provide factorial-rec factorial-iter)
  (define (factorial-rec n)
    (if (= n 1)
      1
      (* n (factorial-rec (- n 1)))))

  (define (factorial-iter n)
    (define (iter product count max-count)
      (if (> count max-count)
        product
        (iter (* product count)
              (add1 count)
              max-count)))
    (iter 1 1 n)))



#| Exercise 1.10: |#
#| The following procedure computes a math- |#
#| ematical function called Ackermann’s function. |#
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1) (A x (- y 1))))))
#| What are the values of the following expressions? |#
(A 1 10)
(A 2 4)
(A 3 3)
#| Consider the following procedures, where A is the proce- |#
#| dure defined above: |#
(define (f n) (A 0 n))
(define (g n) (A 1 n))
(define (h n) (A 2 n))
(define (k n) (* 5 n n))
#| Give concise mathematical definitions for the functions com- |#
#| puted by the procedures f , g , and h for positive i |#

; NOTE fixed point algorithms.

(module fixed-point racket/base
  (provide fixed-point
           average-damping
           cubic-root)
  (define tolerance 0.0001)

  (define (average a b) (/ 2 (+ a b)))
  (define (square x) (* x x))

  (define (fixed-point f first-guess)
    (define (close-enough? v1 v2)
      (< (abs (- v1 v2))
         tolerance))
    (define (try guess)
      (let [(next (f guess))]
        (if (close-enough? guess next)
          next
          (try next))))
    (try first-guess))


  ; average damping method
  (define (average-damping f)
    (lambda (x) (average x (f x))))

  ; NOTE use abstractions defined previously
  ; to find sqrt
  (define (cube-root x)
    (fixed-point
      (average-damping
        (lambda (y) (/ x (square y)))
        0.1))))

#lang racket

; closure property:
;   The results of combining things with a
;   operation can be combined with that
;   operation.
;   // come from abastract algera.
;   // pair is close in cons

(module lists racket/base
  (define (_list-ref items n)
    (if (= n 0)
      (car items)
      (_list-ref (cdr items) (- n 1))))

  (define (_len items)
    (if (null? items)
      0
      (+ 1 (_len (cdr items)))))

  (define (_append list1 list2)
    (if (null? list1)
      list2
      (cons
        (car list1)
        (_append (cdr list1) list2))))

  (define (_last-pair items)
    (if (null? (cdr items))
      items
      (_last-pair (cdr items))))

  ; NOTE use parameter res as a stack.
  (define (_reverse items)
    (define (rev-stack res items)
      (if (null? items) res
        (rev-stack (cons (car items) res)
                   (cdr items))))
    (rev-stack '() items))

  (define (same-parity . z)
    (define parity?
      (if (even? (car z)) even? odd?))
    (define (parity-cons l)
      (cond ((null? l) '())
            ((parity? (car l))
             (cons (car l)
                   (parity-cons (cdr l))))
            (else (parity-cons (cdr l)))))
    (parity-cons z))

  (define (_map proc items)
    (if (null? items) '()
      (cons (proc (car items))
            (_map proc (cdr items)))))

  (define (scale-list items factor)
    (_map (lambda (x) (* x factor)) items))


  (define (square-list items)
    (_map (lambda (x) (* x x)) items))

  (define (_for-each proc items)
    (if (null? (_map proc items)) #f #t))

  (define (count-leaves x)
    (cond ((null? x) 0)
          ((not (pair? x)) 1)
          (else (+ (count-leaves (car x))
                   (count-leaves (cdr x))))))

  (define (deep-reverse items)
    (if (pair? items)
      (_reverse (map deep-reverse items)) items))

  (define (fringe tree)
    (cond ((null? tree) '())
          ((not (pair? tree)) (list tree))
          (else (append
                  (fringe (car tree))
                  (fringe (cdr tree))))))

  ; for nested tree structure
  ; there are base case null and
  ; flatened case where we reached the elements
  ; stored in tree.
  (define (scale-tree-nomap tree factor)
    (cond ((null? tree) '())
          ((not (pair? tree) (* factor tree)))
          (else
            (cons
              (scale-tree-nomap (car tree) factor)
              (scale-tree-nomap (cdr tree) factor))
            )))

  ; tree is a list too, so map can be a
  ; very powerful auxiliary for help.
  (define (scale-tree tree factor)
    (map (lambda (sub)
           (if (pair? sub)
             (scale-tree sub factor)
             (* sub factor)))
         tree))

  (define (square-tree tree)
    (map (lambda (sub)
           (if (pair? sub)
             (square-tree sub)
             (* sub sub)))
         tree))

  ; some abstraction here
  (define (tree-map proc tree)
    (map (lambda (sub)
           (if (pair? sub)
             (tree-map proc sub)
             (proc sub)))
         tree))

  ; NOTE let with recursion. Very concise.
  ; logic here is split the powerset into
  ; power set without the first element and the
  ; power set with the first element.
  (define (powerset s)
    (if (null? s)
      (list '())
      (let ((rest- (powerset (cdr s))))
        (append rest-
                (map (lambda (x)
                       (cons (car s) x))
                     rest-)))))
  )

(module sequence-interface racket
  (define (acc op ini seq)
    (if (null? seq)
      ini
      (op (car seq)
          (acc op ini (cdr seq)))))

  (define (sieve pred seq)
    (cond ((null? seq) '())
          ((pred (car seq))
           (cons (car seq)
                 (sieve pred (cdr seq))))
          (else (sieve pred (cdr seq)))))


  ; NOTE an optimization algorithm for eval polynomial.
  ; it is proved that evaluation of any polynomial
  ; take at least the same amount of additions and
  ; multiplication as horner-eval do.
  (define (horner-eval x coeff-seq)
    (acc
      (lambda (coeff higher-term)
        (+ coeff (* x higher-term)))
      0
      coeff-seq))
  )

(module matrices racket
  (define (vec . z) (apply list z))

  ; map used as zip.
  (define (acc-n op ini seqs)
    (if (null? (car seqs))
      '()
      (cons (foldr op ini
                   (map car seqs))
            (acc-n op ini
                   (map cdr seqs)))))

  (define (dot-product v w)
    (foldr + 0 (map * v w)))

  (define (matrix-*-vector m v)
    (map (lambda (x)
           (dot-product v x))
         m))

  (define (transpose mat)
    (acc-n cons '() mat))

  (define (matrix-*-matrix m n)
    (let ((cols (transpose n)))
      (map (lambda (v)
             (matrix-*-vector cols v))
           m)))

  ; use an extra parameter as stack
  ; very common technic when you want to
  ; reverse the order of enumerate over lists.
  (define (foldleft op ini seq)
    (define (iter res rest-)
      (if (null? rest-)
        res
        (iter (op res (car rest-))
              (cdr rest-))))
    (iter ini seq))
  )

(module pair-sum-prime racket

  (define (xrange low high)
    (if (>= low high)
      '()
      (cons low (xrange (+ 1 low) high))))

  (define (prime? x)
    (define (prime-iter x v)
      (cond ((or (zero? (remainder x v)) (< x 2))
             #f)
            ((< x (* v v))
             #t)
            (else
              (prime-iter x (+ 1 v)))))
    (prime-iter x 2))

  (define (prime-sum? pair)
    (prime? (+ (car pair) (cadr pair))))

  ; nested sequence.
  ; map proc to seq then collect results
  ; into the empty list to flaten it.
  ; NOTE: map here is a zip since seq is nested.
  (define (flatmap proc seq)
    (foldr append '() (map proc seq)))

  (define (make-pair-sum pair)
    (list (car pair) (cadr pair)
          (+ (car pair)
             (cadr pair))))

  ; nested map with flat map.
  (define (prime-sum-pairs n)
    (map make-pair-sum
         (filter prime-sum?
                 (flatmap
                   (lambda (i)
                     (map (lambda (j)
                            (list i j))
                          (xrange 1 (- i 1))))
                   (xrange 1 n)))))

  ; deeply nested sequence.
  ; recursively generate S - x
  ; then adjoing x to the front of each one.
  (define (permutations s)
    (if (null? s) (list '())
      (flatmap (lambda (x)
                 (map (lambda (p) (cons x p))
                      (permutations (remove x s))))
               s)))

  (define (unique-pairs n)
    (flatmap (lambda (i)
               (map (lambda (j)
                      (list i j))
                    (xrange 1 (+ 1 i))))
             (xrange 1 (+ 1 n))))

  ; ordered-triples the sum = s
  (define (ordered-triples n s)
    (let ((interval (xrange 1 (+ n 1)))
          (is-sum? (lambda (trp) (= s (apply + trp)))))
      (filter is-sum?
              (flatmap (lambda (i)
                         (flatmap (lambda (j)
                                    (map (lambda (k)
                                           (list i j k))
                                         interval))
                                  interval))
                       interval))))
  )

#| (module eight-queens-pack racket |#

#|   (define (queens board-size) |#

#|     (define (empty-board) |#
#|       (map (lambda (_) #f)) (range 1 board-size)) |#

#|     (define ) |#

#|     (define (queen-cols k) |#
#|       (if (= k 0) (list empty-board) |#
#|         (filter |#
#|           (lambda (positions) (safe? k positions)) |#
#|           (flatmap |#
#|             (lambda (rest-of-queens) |#
#|               (map (lambda (new-row) |#
#|                      (adjoin-position |#
#|                        new-row k rest-of-queens)) |#
#|                    (range 1 board-size))) |#
#|             (queen-cols (- k 1)))))) |#
#|     (queen-cols board-size)) |#

#|   ) |#
; from chapter 2.
; Data abstraction.

; implement pair with function alone.
#lang racket

(module ractinoals racket/base
  (require rationals-core)
  (provide make-rat
           numer
           denom
           add-rat
           sub-rat
           mul-rat
           div-rat)

  (module rationals-core racket/base
    (provide make-rat
             numer
             denom)
    (define (_gcd a b)
      (if (= b 0) a
        (_gcd b (remainder a b))))
    (define (make-rat n d)
      (cons n d))
    (define (numer x)
      (let ((g (_gcd (car x) (cdr x))))
        (/ (car x)) g))
    (define (denom x)
      (let ((g (_gcd (car x) (cdr x))))
        (/ (cdr x) g))))

  (define (print-rat x)
    (newline)
    (display (numer x))
    (display "/")
    (display (denom x)))

  (define (add-rat x y)
    (make-rat (+ (* (numer x)
                    (denom y))
                 (* (numer y)
                    (denom x)))
              (* (denom x) (denom y))))

  (define (sub-rat x y)
    (make-rat (- (* (numer x)
                    (denom y))
                 (* (numer y)
                    (denom x)))
              (* (denom x) (denom y))))

  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))

  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y)))))

(module different-cons racket/base
  ; Ver 1.
  ; NOTE  As long as the upper layer of abstraction
  ; barrier can access all the interface the
  ; data structure provides, then it is a valid
  ; data abstraction.
  (provide cons-callback-choose
           car-callbak-choose
           cdr-callbak-choose
           cons-local-var
           car-local-var
           cdr-local-var
           cons-int
           car-int
           cdr-int)

  (define (cons-local-var x y)
    (define (dispatch m)
      (cond ((= m 0) x)
            ((= m 1) y)
            (else (error "Invalid argument"))))
    dispatch)

  (define (car-local-var z) (z 0))
  (define (cdr-local-var z) (z 1))


  (define pair1 (cons-local-var 1 2))
  (displayln (car-local-var pair1))


  ; Ver 2.
  ; NOTE Support all procudures for cons
  ; thus the implementation is an acceptable
  ; cons.
  (define (cons-callback-choose x y)
    (lambda (m) (m x y)))

  (define (car-callbak-choose z)
    (z (lambda (p q) p)))

  (define (cdr-callbak-choose z)
    (z (lambda (p q) q)))

  (define pair2 (cons-callback-choose 1 2))
  (displayln (car-callbak-choose pair2))


  ; E2.5
  ; represent int pair with only numbers and
  ; arithmetic operations if we represent pari
  ; a b as procuduct 2^a3^b

  (define (cons-int a b)
    (* (expt 2 a) (expt 3 b)))

  (define (div3 x) (= (remainder x 3) 0))
  (define div2 even?)
  (define (exclusive? z)
    (not (and (div3 z)
              (div2 z))))

  (define (car-int z)
    (if (exclusive? z) (log z 2)
      (car-int (/ z 3))))

  (define (cdr-int z)
    (if (exclusive? z) (log z 3)
      (cdr-int (/ z 2))))

  (define pair3 (cons-int 8 9))
  (displayln (car-int pair3)))

(module church-numeral racket/base
  ; church numerals to encode non negative numbers.
  ; Alonzon Chruch.
  (define (add-1 n)
    (lambda (f)
      (lambda (x)
        (f ((n f) x)))))
  (define zero (lambda (f) (lambda (x) x)))
  (define one (lambda (f) (lambda (x) (f x))))
  (define two (lambda (f) (lambda (x) (f (f x) x)))))

(module interval-arithmetic racket/base
  (define (make-interval lower upper)
    (cons lower upper))

  (define (lower-bound x) (max (car x) (cdr x)))
  (define (upper-bound x) (max (cdr x) (cdr x)))

  (define (add-interval x y)
    (make-interval (+ (lower-bound x)
                      (lower-bound y))
                   (+ (upper-bound x)
                      (upper-bound y))))

  (define (sub-interval x y)
    (make-interval (- (lower-bound x)
                      (upper-bound y))
                   (- (upper-bound x)
                      (lower-bound y))))

  (define (mul-interval x y)
    (let ((p1 (* (lower-bound x) (lower-bound y)))
          (p2 (* (lower-bound x) (upper-bound y)))
          (p3 (* (upper-bound x) (lower-bound y)))
          (p4 (* (upper-bound x) (upper-bound y))))

      (make-interval (min p1 p2 p3 p4)
                     (max p1 p2 p3 p4))))

  (define (div-interval x y)
    (mul-interval
      x
      (if (and (> (upper-bound y) 0)
               (< (lower-bound y) 0))
        (error "divide interval that across zero")
        (make-interval (/ 1.0 (upper-bound y))
                       (/ 1.0 (lower-bound y)))))))


#lang racket



#lang racket
(require typed/racket)

#| block
   commane
|#

999999  ; intergers
#b111   ; binary => 7
#o111   ; octal => 73
#x111   ; hex => 273
3.14    ; reals
6.0e+23
1/2   ; rationals
1+2i  ; complex

'(+ 1 2) ; a literal list
(+ 1 1)
(quotient 5 2) ; => 2
(remainder 5 2) ; => 1
(exact->inexact 1/3) ; => 0.3333
(+ 1+2i 2-3i) ; => 3-1I

#t
#f
(not #t)
; short circuit.
(and 0 #f (error "doesn't get here"))
(or #f 0 (error "doesn't get here"))


;; characters
#\λ
#\u30BB

;; String
"Hello world!"

(string-append "append" " " "me")
(string-ref "Apple" 3)
(format "~a can be ~a" "strings" "formatted")
(printf "Racket is cool!\n")


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Variables
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(printf "Variable: \n\n")
(define some-var 10)
some-var

(define ⊆ subset?)
(⊆ (set 3 4) (set 4 2 3))

(printf "Local Binding: \n\n")
; local bind
(let ([me "Bob"])
  "Alice"
  me)

; bind for later bindings
(let* ([x 1]
       [y (+ x 1)])
      (* x y))

; define recursive and mutually recursive funtions.
(letrec ([is-even? (λ (n)
                      (or (zero? n)
                          (is-odd? (sub1 n))))]
         [is-odd? (λ (n)
                     (and (not (zero? n))
                          (is-even? (sub1 n))))])
  (is-even? 12))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Struct and Collections
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; structs
; structs are by default immutable
(printf "Struct: \n\n")

(struct dog
  ([name : String]
   [breed : String]
   [age : Integer]))
(define joge
  (dog "joge" "corgi" 5))
joge
; data accessor
(dog? joge)
(dog-name joge)

; define mutable struct
(struct rgba-color
  ([r : Integer]
   [g : Integer]
   [b : Integer]
   [a : Real]) #:mutable)
(define burgundy
  (rgba-color 144 0 32 1.0))
(set-rgba-color-g! burgundy 10)
(rgba-color-g burgundy)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Pairs (immutable)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(printf "Pairs: \n\n")
(cons 1 2)
(car (cons 1 2))
(cdr (cons 1 2))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; List are linked list
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(printf "Lists: \n\n")
(cons 1 (cons 2 (cons 3 null)))

; convienience data constructor for list
(list 1 2 3)

; quiasiquote: use backtick to eval function
(printf "Quiasiquote: \n\n")
`(1 ,(+ 1 1) 3)

(car '(1 2 3))
(cdr '(1 2 3))
(cadr (list 1 2 3))
(car (cdr (list 1 2 3)))
(cddr (list 1 2 3 4))
(cdr (cdr(list 1 2 3 4)))
(cadddr (list 1 2 3 4 5 6))

(append '(1 2) '(3 4))  ; like extend in python

(map add1 '(1 2 3))
(map + '(1 2 3) '(10 20 30))
(filter even? '(1 2 3 4))
(count even? '(1 2 3 4))
(take '(1 2 3 4) 2)
(drop '(1 2 3 4) 2)

;; Vectors are fixed-length arrays
(printf "Vectors\n\n")
#(1 2 3)
(vector-append #(1 2 3) #(4 5 6))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Set
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(printf "Sets\n\n")
(list->set '(1 2 3 4 5 6 7 1 2 3 4))

(set-add (set 1 2 3) 4)
(set-remove (set 1 2 3) 1)
(set-member? (set 1 2 3) 2)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Hashes
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(printf "Hashtable\n\n")
; create a immutable hashtable
(define m (hash 'a 1 'b 2 'c 3))
(hash-ref m 'a)

; extend hash table
(define m2 (hash-set m 'd 4))

(hash-remove m 'a)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(printf "Fucntions\n\n")
(lambda () "hello")
(define world (lambda () "world"))

(: hello-world (-> String))
(define hello-world
  (lambda () (string-append "hello" " " (world))))
(hello-world)

; multi-variadic functions with case-lambda
(printf "multi-variadic functions: \n\n")
(define hello
  (case-lambda
    [() "Hello world"]
    [(name) (string-append "Hello" " " name)]))

(hello)
(hello "Jimmy")

; optional arg
(define (hi [name "World"])
  (string-append "Hi" " " name))

(hi)

; pack args up in a list
(define (count-args . args)
  (format "You passed ~a args: ~a" (length args) args))
(count-args 1 2 3)

; desugared form:
(define count-args2
  (lambda args
    (format "You passed ~a args: ~a" (length args) args)))
(count-args2 1 2 3)

; With keywords
(define (hi-k #:name [name "World"]
              #:greeting [g "Hi"]
              . args)
  (format "~a ~a ~a extra args" g name (length args)))
(hi-k 1 2 #:greeting "Hi" #:name "Jimmy" 3 9)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Equality
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(printf "Equality\n\n")
; number equality
(= 3 3.0)
(= 2 1)

; #t if two args refer to same obj in memory
(eq? '() '())
(let ([x '()]
      [y '()])
  (eq? x y))

(let ([x (list 3)]
      [y (list 3)])
  (eq? x y))

(let* ([x (list 3)]
       [y x])
  (eq? x y))

; `eqv?` compare num and character types
; for other types `eqv?` and `eq?` act the same.
(eqv? 3 3.0)
(eqv? (expt 2 100) (expt 2 100))
(eqv? (string-append "foo" "bar") (string-append "foo" "bar"))

; `equal?` for string bytestrings, pairs, mutable pairs, vectors, boxes.
(equal? 3 3.0)
(equal? (string-append "foo" "bar") (string-append "foo" "bar"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Control flow
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(printf "Control Flow: \n\n")
(if #t
  "True"
  "False")
(if (member 'Groucho '(Harpo Groucho Zeppo))
  'yep
  'nope)

; cond chains a series of tests
(cond [(> 2 2) (error "wrong")]
      [(< 2 2) (error "wrong again")]
      [else 'ok])

; pattern matching

(define (fizzbuzz? n)
  (match (list (remainder n 3) (remainder n 5))
    [(list 0 0) 'fizzbuzz]
    [(list 0 _) 'fizz]
    [(list _ 0) 'buzz]
    [_ #f]))
(fizzbuzz? 15)

; looping with tail recursion
(define (loop i)
  (when (< i 10)
    (printf "i=~a\n" i)
    (loop (add1 i))))
(loop 6)

(printf "\n")
; for form
(for ([i 2])
  (printf "i=~a\n" i))

(printf "\n")

(for ([i (in-range 5 10)])
  (printf "i=~a\n" i))

; iteration over different sequences
(for ([i (in-list '(l i s t))])
  (displayln i))
(for ([i (in-vector #(v e c t o r))])
  (displayln i))
(for ([i (in-string "string")])
  (displayln i))
(for ([i (in-set (set 'x 'y 'z))])
  (displayln i))
(for ([(k v) (in-hash (hash 'x 1 'y 2 'z 3))])
  (printf "key: ~a, value: ~a\n" k v))

(for ([i 1000]
      #:when (> i 5)
      #:unless (odd? i)
      #:break (> i 10))
  (printf "i=~a\n" i))

; list comprehensions
(for/list ([i '(1 2 3)]) (add1 i))
(for/list ([i '(1 2 3)] #:when (even? i)) i)
(for/list ([i 10] [j '(x y z)]) (list i j))
(for/hash ([i '(1 2 3)]) (values i (number->string i)))
(for/sum ([i (in-range 1 101)]) i)
(for/and ([i 10] [j (in-range 10 20)]) (< i j)) ; all
(for/fold ([sum 0]) ([i '(1 2 3 4)]) (- sum i)) ; foldl

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Exceptions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(printf "Control Flow: \n\n")

(with-handlers ([exn:fail? (lambda (exn) "bad")]) (+ 1 "2"))
(with-handlers ([exn:break? (lambda (exn) " no time")])
               (sleep 0.1)
               "phew")
(with-handlers ([number? identity]) (+ 1 (raise 2)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Mutation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(printf "Mutation \n\n")
(define n 5)
(set! n (add1 n))  ; assign new val to existing value
n

; box for explicit mutable values (like a reference)
(define n* (box 5))
(set-box! n* (add1 (unbox n*)))
(unbox n*)

; create mutable vector
(define vec (vector 2 2 3 4))
(define wall (make-vector 10 'bottle-of-beer))
(vector-set! vec 0 1)  ; update a vecotr slot
(vector-set! wall 8 'down)
vec
wall

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Modules.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(module cake racket/base
  (provide print-cake)
  (define (print-cake n)
    (show "    ~a     " n #\.)
    (show "  .-~a-.   " n #\|)
    (show " |  ~a  |  " n #\space)
    (show " ---~a---  " n #\-))

    (define (show fmt n ch)
      (printf fmt (make-string n ch))
      (newline)))

(require 'cake)
(print-cake 10)

; create mutable hashtable
(define m3 (make-hash))
(hash-set! m3 'a 1)
(hash-ref m3 'c 3)
(hash-remove! m3 'a)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Classes and Objects
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; create a class fish% (-% is idiomatic for class binding)
(define fish%
  (class object%
    (init size) ; init arg
    (super-new) ; superclass init
    (define current-size size)
    (define/public (get-size) current-size)
    (define/public (grow amt)
      (set! current-size (+ amt current-size)))
    (define/public (eat other-fish)
      (grow (send other-fish get-size)))))

(define charlie
  (new fish% [size 10]))

(printf "before ~a\n" (send charlie get-size))
(send charlie grow 6)
(printf "after ~a\n" (send charlie get-size))

; mixins
(define (add-color c%)
  (class c%
    (init color)
    (super-new)
    (define my-color color)
    (define/public (get-color) my-color)))
(define colored-fish% (add-color fish%))
(define charlie2 (new colored-fish% [size 10] [color 'red]))

(send charlie2 get-color)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Macros
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; add a while loop
(define-syntax-rule (while condition body ...)
  (let loop ()
    (when condition
      body ...
      (loop))))

(let ([i 10])
  (while (< i 10)
         (displayln i)
         (set! i (add1 i))))

; hygienic macros. You cannot clobber existing variables.
(define-syntax-rule (swap! x y) ; ! is idiomatic for mutation
  (let ([tmp x])
    (set! x y)
    (set! y tmp)))

(define tmp 2)
(define other 3)
(swap! tmp other)
(printf "tmp = ~a; other = ~a\n" tmp other)
; variable tmp is renamed to tmp_1 to avoid name
; conflict of tmp within the macros.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Contracts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; contracts impose constraints on values exported from modules

(module bank-account racket
  (provide (contract-out
             [deposit (-> positive? any)] ; always positive
             [balance (-> positive?)]))
  (define amount 0)
  (define (deposit a) (set! amount (+ amount a)))
  (define (balance) amount))
(require 'bank-account)
(deposit 5)
(balance)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Input and output
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; port, similar to file descriptor
(system "rm /tmp/tmp.txt")
(define out-port (open-output-file "/tmp/tmp.txt"))
(displayln "Racket is very dope" out-port)
(close-output-port out-port)

; append
(set! out-port (open-output-file "/tmp/tmp.txt" #:exists 'append))
(displayln "Hola mundo" out-port)
(close-output-port out-port)

; read
(define in-port (open-input-file "/tmp/tmp.txt"))
(displayln (read-line in-port))
(close-input-port in-port)

; context manager
(call-with-output-file "/tmp/tmp.txt"
                       #:exists 'update
                       (lambda (out)
                         (displayln "WOrld HeLlo" out)))

(call-with-input-file "/tmp/tmp.txt"
                      (lambda (in)
                        (displayln (read-line in))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Typed racket
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(struct pt
  ([x : Real]
   [y : Real]))

(: distance (-> pt pt Real))
(define (distance p1 p2)
  (sqrt (+ (sqrt (- (pt-x p2) (pt-x p1)))
           (sqrt (- (pt-x p2) (pt-x p1))))))


import Distribution.Simple
main = defaultMain
module Main where

main :: IO ()
main = undefined

module UntypedArithmeticExpr where

data Term =
    TmTrue
  | TmFalse
  | TmIf Term Term Term
  | TmZero
  | TmSucc Term
  | TmPred Term
  | TmIsZero Term
  deriving (Show, Eq)

isval :: Term -> Bool
isval term = case term of
  TmTrue   -> True
  TmFalse  -> True
  TmZero   -> True
  TmSucc _ -> True
  _        -> False

-- single evaluation
eval1 :: Term -> Term

-- if true then t2 else t3 -> t2
-- if false then t2 else t3 -> t3
--                t1 -> t1'
-- -------------------------------------------------
--  if t1 then t2 else t3 -> if t1' then t2 else t3
eval1 (TmIf t1 t2 t3) | not $ isval t1 = TmIf (eval1 t1) t2 t3
eval1 (TmIf TmTrue  t2 _ )             = t2
eval1 (TmIf TmFalse _  t3)             = t3

--       t1 -> t1'
--
-- ---------------------
--   succ t1 -> succ t1'
eval1 (TmSucc t1) | not $ isval t1 = TmSucc $ eval1 t1
                  | otherwise      = TmSucc t1

-- pred 0 -> 0
-- pred (succ v) -> v
--       t1 -> t1'
-- ---------------------
--   pred t1 -> pred t1'
eval1 (TmPred t1) | not $ isval t1   = TmPred $ eval1 t1
eval1 (TmPred TmZero    )            = TmZero
eval1 (TmPred (TmSucc v))            = v

-- iszero 0 -> true
-- iszero (succ v) -> false
--       t1 -> t1'
-- ---------------------
--   iszero t1 -> iszero t1'
eval1 (TmIsZero t1) | not $ isval t1 = TmIsZero $ eval1 t1
eval1 (TmIsZero TmZero    )          = TmTrue
eval1 (TmIsZero (TmSucc _))          = TmTrue

-- const(t)
eval1 n | isval n                    = n
eval1 _                              = error "Unknown term"

-- eval motor
eval :: Term -> Term
eval t = let t' = eval1 t in if isval t' then t' else eval t'
module UntypedLambdaCalculus where


module Spec where


import UntypedArithmeticExpr
import Test.Hspec

main :: IO ()
main = do
  hspec $ describe "UntypedArithmeticExpr" untypedArithmeticExprSpec

untypedArithmeticExprSpec :: Spec
untypedArithmeticExprSpec = do
    it "eval> " $ do
      let expr1 = TmTrue
      let expr2 = TmIsZero TmZero
      let expr3 = TmIf TmFalse TmTrue TmFalse
      let expr4 = TmSucc $ TmSucc TmZero
      let expr5 = TmPred $ TmSucc TmZero
      eval expr1 `shouldBe` TmTrue
      eval expr2 `shouldBe` TmTrue
      eval expr3 `shouldBe` TmFalse
      eval expr4 `shouldBe` (TmSucc $ TmSucc TmZero)
      eval expr5 `shouldBe` TmZero

import Distribution.Simple
main = defaultMain
module Main where


main :: IO ()
main = undefined
module Algorithms.MergeSort where

mergeSort :: Ord a => [a] -> [a]
mergeSort [] = []
mergeSort [x] = [x]
mergeSort xs = merge (mergeSort as) (mergeSort bs)
  where (as, bs) = splitHalf xs

splitHalf :: [a] -> ([a], [a])
splitHalf [] = ([], [])
splitHalf [x] = ([x], [])
splitHalf (x:y:xys) = (x:xs, y:ys)
  where (xs, ys) = splitHalf xys

merge :: Ord a => [a] -> [a] -> [a]
merge xs [] = xs
merge [] ys = ys
merge (x:xs) (y:ys) = if x < y
                         then x : merge xs (y:ys)
                         else y : merge ys (x:xs)
module Algorithms.Other where

import Control.Monad
import Control.Monad.Trans.Except

-- https://stackoverflow.com/questions/17264360/how-do-i-break-out-of-a-loop-in-haskell

type Set a = [a]

-- the powerset
powerset :: Set a -> Set (Set a)
powerset [] = [[]]
powerset (x : xs) =
  let current = [x : ps | ps <- powerset xs]
      rest = powerset xs
   in current ++ rest

-- loop
loop :: (Monad m) => ExceptT e m a -> m e
loop = fmap (either id id) . runExceptT . forever

quit :: (Monad m) => e -> ExceptT e m r
quit = except . Left

ls :: [Int]
ls = [1, 2, 3, 4]
{-# LANGUAGE AllowAmbiguousTypes #-}

module Cat.AlternativeandMonadPlus where


import           Control.Applicative
import           Control.Monad

-- experiement target
data Option a = Some a | None
data List a = Cons a (List a) | End

--  Some thoughts about.
--  A way to look at it is to override a super generic operator
--  you can shove any type of conceivable computation into it.
--  the only law it needs to hold is align the type of
--  m a -> (a -> m b) -> m b
--
--    1. It's generic, what does (a -> m b) do is totally unlimited.
--    2. It can be chained. since m b is able to be feed into another
--      (b -> m c)
--    3. It can manage a external state. since m can carries a environment
--       through out the chain.
--       Do notation is a sugar for construct such a chain.
--  compare with functor: (a -> b) -> f a -> f b:
--    1. It cannot carry enviroment. The function part (a -> b) can operate
--       on value f holds, but it can not access the context itself.
--    2. it can chain operation. since f b is returned, one can
--       f3 <$> (f2 <$> (f1 <$> x))
--    3. it is also generic. (it's the bottom line when talking about
--       algebraic structure anyway..)
--  compare with applicative f (a -> b) -> f a -> f b
--    1. It can carry environment. f (a -> b) have some implication of
--       f for a -> b to use.
--    2. It can chain
--    3. generic.
--
--   So applicative is also very generic. But why use monad but not applicative?
--
--   Notice one important feature of monad is short circuit failure within the
--   computation.
--   for (>>=) :: m a -> (a -> m b) -> m b, consider m a is the value for the
--   past and m b is the value in the future. For this transition the stepper
--   (a -> m b) must be evaluated. But (a - m b) implies a must exist. For
--   instance, for Either a b, if Either is Left b, a is not present, then the
--   monad chain will short circuit to Left b immediately.
--
--   But for applicative, (<*>) impose no restriction on value of the past.
--   It can combine like Right id <$> Left 1 <*> Left 2<*>, the result could be
--   Left [1, 2] or whatever you defined, but cannot be 1.


-- divide and conquer.
-- a list is [] or _:_,
-- and since _:_ is a list of list it can
-- also be divided as []:_ or _:_
concatList :: List (List a) -> List a
concatList End                    = End
concatList (Cons End xss)         = concatList xss
concatList (Cons (Cons x xs) xss) = Cons x $ concatList (Cons xs xss)

instance Functor Option where
  fmap f (Some a) = Some $ f a
  fmap f None     = None

instance Monad Option where
  return = Some
  (Some a) >>= f = f a
  None >>= f     = None

instance Applicative Option where
  pure = return
  (<*>) = ap

instance Functor List where
  fmap f (Cons a xs) = Cons (f a) (fmap f xs)
  fmap f End         = End

instance Monad List where
  return a = Cons a End
  End >>= f = End
  xs >>= f  = concatList $ fmap f xs

instance Applicative List where
  pure = return
  (<*>) = ap

instance Semigroup (List a) where
  End <> a = a
  a <> End = a
  a <> b   = concatList $ (Cons a (Cons b End))

instance Monoid (List a) where
  mempty = End

-- Alternative captures 'amalgamation' in a general way.
-- empty: the unit
-- <|>:   binary operator combines two computations.

instance Alternative Option where
  empty = None
  None <|> None     = None
  Some x <|> None   = Some x
  None <|> Some x   = Some x
  Some x <|> Some y = Some x

-- use monoid for Alternative direcly.
instance Alternative List where
  empty = End
  (<|>) = (<>)

-- example of parallel parsing.
-- parser libraries use Alternatives a lot to proivdes
-- rich operations to combine different outputs.
digit :: Int -> String -> Option Int
digit _ [] = None
digit i (c : _)
  | i > 9 || i < 0 = None
  | otherwise = if [c] == show i then Some i else None

binChar :: String -> Option Int
binChar s = digit 0 s <|> digit 1 s <|> digit 2 s

-- MonadPlus like a Alternative for Monad.
-- mzero
-- mplus
-- historical legacy. It now conventionally be regard as
-- something is both an Alternative and a Monad.

-- Basic Laws.
-- like any monoid.
neutral_empty_law u = (empty <|> u) == u && (u <|> empty) == u

associative_law u v w = (u <|> (v <|> w)) == ((u <|> v) <|> w)

-- addtional Law to work with Monad.
-- This implies if a failure happens within a chain of monadic
-- computation the whole will fail.

monad_law1 f = (mzero >>= f) == mzero
monad_law2 m = (m >> mzero) == mzero

-- Useful functions.
-- alternative sum
my_asum :: (Alternative f, Foldable t) => t (f a) -> f a
my_asum = foldr (<|>) empty

-- guard
-- this can be used to mimic fitlering in list comprehension.

-- list comprehension version
my_guard :: Alternative m => Bool -> m ()
my_guard True = pure ()
my_guard _    = empty

pyth1 =
  [ (x, y, z)
    | z <- [1 ..],
      x <- [1 .. z],
      y <- [x .. z],
      x ^ 2 + y ^ 2 == z ^ 2
  ]

-- list monad -do block
-- very similar form with guard
-- Key point here:
--  1. guard will return empty if predicate is false.
--  2. by law
--       monad_law1 f = (mzero >>= f) == mzero
--       monad_law2 m = (m >> mzero) == mzero
--     any empty in the do block will cause the entire
--     computation return empty
--
--  3. guard return [()] when predicate is true.
--  4. look at the desugared version,
--     if my_guard(x^2 + y^2 == z^2) is empty, the computation
--     evaluated as emtpy immediately.
--     if my_guard(x^2 + y^2 == z^2) is [()], execution can
--     pass through, x, y, z are all in scope, thus return
--     works as usual.
--
--  Notice how wierd the list monad behaves. Nowhere specified
--  a loop like operation but it can traverse the entire list. its
--  because the mapping mechanism is implemented in list monad
--  and implied by >>= operator.

pyth2 = do
  z <- [1..]
  x <- [1..z]
  y <- [x..z]
  my_guard (x^2 + y^2 == z^2)
  return (x, y, z)

-- desugared version
pyth3 = do
  [1..] >>= \z ->
    [1..z] >>= \x ->
      [x..z] >>= \y ->
        my_guard (x^2 + y^2 == z^2) >> return (x, y, z)
{-# LANGUAGE Arrows #-}

module Cat.ArrowPractice where

import           Control.Arrow
-- a b c : some computation with input b and c

{-@ First let's check the arrow properties @-}
-- TODO

{-@ For each arrow you can draw a digram
              y
    x  +--(f)----+
    ---+         + --->
       +--(g)----+
              g
@-}

-- proc create an arrow. -< apply is arrow application
addA :: Arrow a => a b Int -> a b Int -> a b Int
addA f g = proc x -> do
  y <- f -< x
  z <- g -< x
  returnA -< y + z

-- without arrow syntax
addA' :: Arrow a => a b Int -> a b Int -> a b Int
addA' f g = arr (\x -> (x, x)) >>>
  first f >>> arr (\(y, x) -> (x, y)) >>>
  first g >>> arr (\(z, y) -> y + z)

addA'' :: Arrow a => a b Int -> a b Int -> a b Int
addA'' f g = f &&& g >>> arr (uncurry (+))


{-@ Mini arrow tutorial from
    https://stackoverflow.com/questions/4191424/what-are-arrows-and-how-can-i-use-them
@-}

{-@ Circuit practice from haskell wiki @-}
{-# LANGUAGE DeriveFunctor      #-}
{-# LANGUAGE DeriveGeneric      #-}
{-# LANGUAGE GADTs              #-}
{-# LANGUAGE PolyKinds          #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# OPTIONS_GHC -fenable-rewrite-rules #-}
{-# OPTIONS_GHC -Wno-inline-rule-shadowing #-}
module Cat.Arrows where

{-@ Arrow, new abstracation
    Arrow represents composition and data flow.

   --|f|-->
@-}


import           Data.Coerce        (coerce)
import           Data.Type.Coercion
import           Data.Type.Equality
import qualified GHC.Base           (id, (.))
import           GHC.Generics       (Generic, Generic1)
import           Prelude            hiding (id, (.))

infixr 9 .
infixr 1 >>>, <<<
infixr 3 ***
infixr 3 &&&

-- a category is like a category in cat theory.
-- category has identity morphism and morphism composition.
class Category cat where
  id :: cat a a
  (.) :: cat b c -> cat a b -> cat a c

-- rewrite rules, helps you to optimize your program.
-- rule name + rule form
{-# RULES
"identity/left"  forall p. id . p = p
"identity/right" forall p. p . id = p
"association"    forall p q r. (p . q) . r = p . q . r
#-}

instance Category (->) where
  id = GHC.Base.id
  (.) = (GHC.Base..)

instance Category Coercion where
  id = Coercion
  (.) Coercion = coerce


-- | right to left composition
(<<<) :: Category cat => cat b c -> cat a b -> cat a c
(<<<) = (.)

(>>>) :: Category cat => cat a b -> cat b c -> cat a c
f >>> g = g . f


{-@ Arrow typeclass @-}
class Category a => Arrow a where
  {-# MINIMAL arr, (first | (***)) #-}
  arr :: (b -> c) -> a b c

  first :: a b c -> a (b, d) (c, d)
  first = (*** id)

  second :: a b c -> a (d, b) (d, c)
  second = (id ***)

  -- split
  (***) :: a b c -> a b' c' -> a (b, b') (c, c')
  f *** g = first f >>> arr swap >>> first g >>> arr swap
    where swap ~(x, y) = (y, x)

  -- fallout
  (&&&) :: a b c -> a b c' -> a b (c,c')
  f &&& g = arr (\b -> (b,b)) >>> f *** g

-- some nice optimization
{-# RULES
"compose/arr"   forall f g . arr f . arr g = arr (f . g)
#-}


instance Arrow (->) where
  arr f = f
  (***) f g ~(x, y) = (f x, g y)

-- define the kleisli arrow for composition.
newtype Kleisli m a b = Kleisli { runKleisli :: a -> m b }

deriving instance Generic (Kleisli m a b)
deriving instance Generic1 (Kleisli m a)
deriving instance Functor m => Functor (Kleisli m a)
module Cat.Cat.C1 where


import           Data.Void

-- can't give an instance of void, this function will never be called.
-- from falsity follows anything
-- f -> t
absurd' :: Void -> a
absurd' a = undefined

f44 :: () -> Integer
f44 () = 44

-- function return void really means it's for side effect
-- so in haskell the equivalent is IO ()
-- function reuturn purely () doesn't do anything special.

funit :: () -> ()  -- utterly useless
funit () = ()

fsideeffect :: () -> IO ()
fsideeffect () = do
  putStrLn "hi"

-- a commuative diagram with only Void, (), and Bool
--
--    // just represent with graph, since it's hard to draw with ascii
--               Void -> ()
--               Void -> Bool
--               Void -> Void
--
--               () -> Bool
--               () -> ()
--
--               Bool -> () 1
--               Bool -> () 2
--               Bool -> Bool
module Cat.CoMonads where

-- ------------------------------
-- costate | comonad | coalgebra
-- ------------------------------
-- oopish stuffs.
--

module Cat.ContMonad where

-- So called mother of all monads.
-- http://blog.sigfpe.com/2008/12/mother-of-all-monads.html

-- CPS transform:
-- We have value x :: a, in direct passing style to use it we just use it.
-- e.g (foo :: a -> b) (x)
-- To cps transform the program, we need to make x a suspend operation
-- x' :: ((a -> r) -> r). The value x is passed (or think it as returned) to
-- the continuation passed in.
--
-- 1. all program can be cps transformed
-- 2. some implicit properties are exposed explicitly in cps
--    - intermediate values are all named
--    - procedure return is explicit
--    - tail call becomes calling the continuation


import Data.Char
import Control.Monad.Cont

------------------------------------------------------------------
-- cps basics

---------------------
-- direct style
-- NOTE:
--   1. the return is implicit. we return when the entire expression is evaluated
--   2. the order of evaluation of arguments is implicit. It depends on
--      implementation
--   3. the intermediate value x * x, y * y, (x * x) + (y * y) is implicit,
--      they don't have a name and we can't refer to them.
pyth1 x y = sqrt ((x * x) + (y * y))

-- cps transformed
-- NOTE:
--  1. the return is explicit. It returns we call k.
--     k is the continuation of the entire program, and once it's called the
--     current call stack can be elimiated.
--  2. the order of evaluation is explicit. x is evaluated before y due to
--     the order of nesting
--  3. intermediate values are explicit. Note now we have control to x2, y2,
--     x2y2, which are all implicit in direct passing style.
pythcps x y k =
  multcps x x $ \x2 ->
  multcps y y $ \y2 ->
  addcps x2 y2 $ \x2y2 ->
  sqrtcps x2y2 k
  where
    multcps x y k = k (x * y)
    addcps x y k = k (x + y)
    sqrtcps x k = k (sqrt x)

-- compositions
type Suspend a r = ((a -> r) -> r)
type Continuation a r = a -> r
type MonadicOperatio m a b = m a -> (a -> m b)
type Pipeline a b = a -> b
-- it's very similar with monad, the control is passed to the next function
-- (actually monad)

------------------------------------------------------------------
-- A polymorphic monad.
prog1 :: Monad m => m Int
prog1 = do
  a <- return 1
  b <- return 10
  return (a + b)

-- be careful about monomorphization.
runProg1 run = run prog1

runProg1Cont = runProg1 (\prog1 -> runCont prog1 show)
runProg1Maybe = runProg1 (\prog1 -> prog1 :: (Maybe Int))
runProg1List = runProg1 (\prog1 -> prog1 :: [Int])

-- >>> runProg1Cont
-- >>> runProg1Maybe
-- >>> runProg1List
-- "11"
-- Just 11
-- [11]

--  not look at the prog2. we have a hole! The value of ahole will be used
--  in (a + b). Passing ahole direclty is still a direct passing style.
--  How to use continuation to give us access ahole?
-- ------------------
prog2 :: Monad m => Int -> m Int
prog2 b = do
  a <- return 1
  return (a + b)


-- now replace return with it's implementation in ConT monad:
-- the Continuation k gives us control of the surrounding computation.
-- k works similarly as prog2.
prog3 = do
  a <- return 1
  b <- (ContT $ \k -> k 10)
  return (a + b)

-- >>> runCont prog3 show
-- "11"

-- If we choose not to run k at all, the program will come to end at b.
-- The surrounding computation will not run at all.
-- Another way to look at it is we changed the control flow by returning early.
-- This is what we can't do in prog3
prog4 = do
  a <- return 1
  b <- (ContT $ \_ -> "escape")
  return (a + b)

-- >>> runContT prog4 show
-- "escape"

-- We can call the continuation twice.
prog5 = do
  a <- return 1
  b <- (ContT $ \k -> k 10 ++ k 20)
  return (a + b)

-- >>> runContT prog5 show
-- "1121"

-- ------------------
prog5_1 = do
  a <- return 1
  b <- [10, 20]
  return (a + b)

-- >>> prog5_1
-- [11,21]

prog5_2 = do
  a <- return 1
  b <- (ContT $ \s -> concat [s 10, s 20])
  return (a + b)

-- >>> runContT prog5_2  (\x -> [x])
-- [11,21]

-- ------------------
prog5_3 = do
  a <- ["a1", "a2"]
  b <- ["b1", "b2"]
  return (a ++ b)

-- >>> prog5_3
-- ["a1b1","a1b2","a2b1","a2b2"]

-- check the order.
prog5_4 = do
  a <- (ContT $ \k -> k "a1" ++ k "a2")
  b <- (ContT $ \k -> k "b1" ++ k "b2")
  return (a ++ b)

-- >>> runContT prog5_4 show
-- "\"a1b1\"\"a1b2\"\"a2b1\"\"a2b2\""

prog5_5 = do
  a <- return 1
  b <- (ContT $ \k -> [10, 20] >>= k)
  return (a + b)

-- >>> runContT prog5_5 return
-- [11,21]


-- ------------------
-- use ContT to simulate other monad
run :: Monad m => ContT r m r -> m r
run m = runContT m return

-- it's saying we want to apply x to the continuation.
-- The behavior depends on the monad instance.
i :: Monad m => m a -> ContT b m a
i x = ContT $ \k -> x >>= k

v1 = run $ do
  a <- i [1, 2]
  b <- i [10, 20]
  return (a + b)

-- >>> v1

-- Maybe
v2 = run $ do
  a <- i (Just 10)
  b <- i (Just 20)
  return (a + b)

-- >>> v2

-- Conclusion:
--   1. Continuation expose the surrounding computation
--   2. CPS can be used to simulate monad
--   3. Langauges doesn explicitly support monad can support monad with cps.

pythagoras :: Int -> Int -> ContT m r String
pythagoras a b = do
  a' <- square a
  b' <- square b
  show <$> add a' b'
  where
    add x y = return $ (x + y)
    square x = return $ (x * x)

-- >>> runContT (pythagoras 11 10) id
-- "221"

------------------------------------------------------------------
-- Cont Monad actually hid the control flow.
-- One way to gain back control is to define ContT k explicitly.
-- or we can use callCC to expose the  current continuation

foo :: Int -> ContT m r String
foo x = callCC $ \k -> do
  let y = x ^ 2 + 3
  when (y > 20) $ k "over twenty"
  return (show $ y - 4)

-- >>> runContT (foo 2) id
-- >>> runContT (foo 20) id
-- "3"
-- "over twenty"

-- 1. the whole expression is (Int -> ContT m r Int)
-- 2. yet k is also (Int -> ContT m r Int)
-- 3. we wrapped the actually implementation as the paramter to k
-- 4. k is the current continuation
square' :: Int -> ContT m r Int
square' n = callCC $ \k -> k (n * 2)

-- Complex control flow
-- callCC really is just a convinent way to say (ConT k)

fun :: Int -> String
fun n = (`runCont` id) $ do
  str <- callCC $ \exit1 -> do
    when (n < 10) $ exit1 (show n)
    let ns = fmap digitToInt (show (n `div` 2))
    n' <- callCC $ \exit2 -> do
      when ((length ns) < 3) (exit2 (length ns))
      when ((length ns) < 5) (exit2 n)
      when ((length ns) < 7) $ do
        let ns' = map intToDigit (reverse ns)
        exit1 (dropWhile (=='0') ns')
      return $ sum ns
    return $ "ns = " ++ (show ns) ++ ") " ++ (show n')
  return $ "Answer: " ++ str

-- We no longer in monad with ConT alone.
-- callCC gives us nested continuation
fun' :: Int -> String
fun' n = (`runContT` id) $ do
  str <- ContT $ \k1 ->
    if (n < 10)
       then k1 "end"
       else "not end"
  return str
{-# LANGUAGE DefaultSignatures          #-}
{-# LANGUAGE DerivingStrategies         #-}
{-# LANGUAGE FlexibleContexts           #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE FunctionalDependencies     #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE KindSignatures             #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE StandaloneDeriving         #-}
{-# LANGUAGE UndecidableInstances       #-}

module Cat.ErrorHandling where

import           Control.Exception
import           Control.Monad
import           Control.Monad.Identity
import           Control.Monad.Reader
import           Control.Monad.Trans
import           Control.Monad.Trans.State.Lazy
import           Control.Monad.Writer
import           Data.Char                      as Char
import           Data.List

-- helper name. This is how it's defined in mtl.
-- How to catch an exception?
-- catch an exception means takes a monad that may throws an exception, and a
-- function that can turn an exception back into a ok value.
-- return the same (m a) if no error, other return the return value of (e -> m a)
type Catch e m a = m a -> (e -> m a) -> m a

-- what is an exception? exception is something that either be an intended value or
-- an exceptional value.
--
-- what is an exceptT? ExceptT is some monadic computation that return eitehr a intended
-- value or an exceptional value.
--
-- what is an exceptional value? It's a value that is not expected in a successful execution path.
-- we can use it to throw useful information of how the exception happened.
newtype ExceptT e (m :: * -> *) a = ExceptT {runExceptT :: m (Either e a)}

instance Monad m => Functor (ExceptT e m) where
  fmap f (ExceptT m) = ExceptT ((fmap . fmap) f m)

instance Monad m => Applicative (ExceptT e m) where
  pure = return
  (<*>) = ap

instance Monad m => Monad (ExceptT e m) where
  return = ExceptT . return . Right
  m >>= k = ExceptT $ do
    a <- runExceptT m
    case a of
      Left e  -> (return . Left) e
      Right a -> runExceptT (k a)

-- what is a monad transformer instance for ExceptT e ?
-- Monad transformer instance for  ExceptT e is a monad that supports lift.
--
-- what is lift?
-- lift is a funtion that lift a monadic computation to ExceptT so it can be
-- performed at the same level.
--
-- what does it mean to perform monadic computation at the same level?
-- it means propagate the value of the result of the underlying computation.
-- In this case, the underlying monad will produce a value, to bring it up to
-- ExceptT means wrap it in ExceptT . Right.
--
-- lift a monad by one layer into ExceptT
instance MonadTrans (ExceptT e) where
  lift = ExceptT . fmap Right

-- monad transfromer is explained in Eh.hs
instance MonadIO m => MonadIO (ExceptT e m) where
  liftIO = lift . liftIO

-- with these ingradients we can simulate try catch.
-- By defualt, lift propagate Right.
-- But what if we want to propagate an error?
--
-- We need another function to do that. This function is essentially the same as lift, just
-- return a Left value instead of Right.
throwE :: Monad m => e -> ExceptT e m a
throwE = ExceptT . return . Left -- return but for Left value.

catchE :: Monad m => ExceptT e m a -> (e -> ExceptT e' m a) -> ExceptT e' m a
m `catchE` h = ExceptT $ do
  a <- runExceptT m
  case a of
    Left e  -> runExceptT (h e)
    Right r -> return (Right r)

class Monad m => MonadError e m | m -> e where
  throwError :: e -> m a
  catchError :: m a -> (e -> m a) -> m a

-- use mtl to generalize some existed error handling monads
instance MonadError IOException IO where
  throwError = ioError
  catchError = catch

instance MonadError e (Either e) where
  throwError = Left
  Left e `catchError` h  = h e
  Right r `catchError` _ = Right r

instance Monad m => MonadError e (ExceptT e m) where
  throwError = throwE
  catchError = catchE

liftEither :: MonadError e m => Either e a -> m a
liftEither = either throwError return

-- To make MonadError work with another monad transformer,
-- we need to make an instance for that transformer as well.
--
-- To make MonadError work with 2 other monads transformer,
-- we need to make 2 instances for those transformers .
-- this is the n square instance problem.

liftCatchReaderT :: Catch e m a -> Catch e (ReaderT r m) a
liftCatchReaderT f m h =
  ReaderT $ \r -> f (runReaderT m r) (\e -> runReaderT (h e) r)

-- this requires undecidable instance
instance MonadError e m => MonadError e (ReaderT r m) where
  throwError = lift . throwError
  catchError = undefined

-- examples
-- look at the type, you see:
-- 1. this function is possible to fail.
-- 2. you can use throwError to Indicate a failure
-- 3. The caller can call catchError with a handler to handle
--    the faliure case.

-- test 1 --
throwMe1 :: Int -> Either String Int
throwMe1 n
  | n > 100 = Left "Too big"
  | n < 0 = Left "too small"
  | otherwise = Right n

catchMe1 :: MonadError e m => Int -> (Int -> m Int) -> m Int
catchMe1 n f = catchError (f n) (\_ -> return (-1))

-- testing Eitehr
try1 = catchMe1 10 throwMe1
try2 = catchMe1 (-1) throwMe1
try3 = catchMe1 (999) throwMe1

-- test 2 --
throwMe2 :: Int -> ExceptT String IO Int
throwMe2 n = do
  liftIO (putStr "It's a transformer stack with except on top of IO")
  go n
  where
    go :: Int -> ExceptT String IO Int
    go n
      | n > 100 = throwError "Too big"
      | n < 0 = throwError "too small"
      | otherwise = return n

catchMe2 :: (MonadError e m, MonadIO m) => Int -> (Int -> m Int) -> m Int
catchMe2 n f =
  catchError
    (f n)
    ( \e -> do
        liftIO (putStr "Error occured")
        return (-1)
    )

-- testing ExceptT
try4 = runExceptT $ catchMe2 10 throwMe2
try5 = runExceptT $ catchMe2 (-1) throwMe2
try6 = runExceptT $ catchMe2 111 throwMe2

-- some bigger example to combine multiple mondas together.
-- validate input email --

data NameError
  = EmptyName
  | InvalidChar String
  | NameTooLong Int
  | BannedWords
  deriving (Show)

-- | check if email is valid
-- for our purpose, the valid form should be "[\w\d]+@\.com]"
validateFormat :: (MonadError NameError m) => String -> m String
validateFormat input =
  if fst (runState check input)
    then return input
    else throwError (InvalidChar input)
  where
    isValidChar = Char.isAlphaNum
    check :: State String Bool
    check = do
      input <- get
      case input of
        (x : xs) ->
          if isValidChar x
            then return (evalState check xs)
            else return False
        [] -> return True

validateLength :: (MonadError NameError m) => String -> m String
validateLength input
  | length input > 30 = throwError (NameTooLong (length input))
  | length input == 0 = throwError (EmptyName)
  | otherwise = return input

validateBandedWords :: (MonadError String m) => String -> m String
validateBandedWords input
  | and [w `elem` input' | w <- banned] = throwError ""
  | otherwise = return input
  where
    input' = words input
    banned = ["peepee", "poopoo", "woowoo"]
module Cat.FAlgebra where


module Cat.FreeMonad where


-- If we have a functor, we get a monad for free.

data Free f a = Pure a | Roll (f (Free f a))


-- operations maps between the functor and free monad.
liftFree :: Functor f => f a -> Free f a
liftFree = undefined

foldFree :: Functor f => (f r -> r) -> Free f r -> r
foldFree = undefined



{-# LANGUAGE DerivingStrategies         #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase                 #-}

module Cat.MTLPractise where

import           Control.Monad.Reader
import           Control.Monad.State
import           Control.Monad.Writer
import           Data.Bits
import           Data.Int

-- An example that combined read, write, and state monads all
-- together.

-- 1. Reader monad when you want to read something from the
-- environment without needing to passing the environment around.
--
-- 2. Writer monad when you want to write to some value without
-- explicity passing where to write.
--
-- 3. State monad when you have some state needs to be modified
-- but you don't want to explicitly pass then around.
-- What if I want them all!?

-- This is a simple virtual machine.
-- Read from Program, Act on the Stack, and output to Output.
data Instr = Push Int | Pop | Puts | Add | Sub | Mul | Div | ShiftL | ShiftR
type Stack = [Int]
type Output = [Int]
type Program = [Instr]

-- build up the transformer stack.
-- it's really ugly to be honest.
type VM a = ReaderT Program (
            WriterT Output (
            State Stack)) a

newtype Comp a = Comp {unComp :: VM a}
  deriving newtype (Functor, Applicative, Monad, MonadState Stack, MonadReader Program, MonadWriter Output)

evalInstr :: Instr -> Comp ()
evalInstr = \case
  Pop -> modify tail
  Push n -> modify (n :)
  Puts -> do
    tos' <- get
    case tos' of
      [] -> tell [-1]
      _  -> tell [head tos']
  Add -> binary (+)
  Sub -> binary (-)
  Mul -> binary (*)
  Div -> binary div
  ShiftR -> binary shiftR
  ShiftL -> binary shiftL
  where
    binary apply = do
      a1 <- gets head
      evalInstr Pop
      a2 <- gets head
      evalInstr Pop
      evalInstr $ Push (apply a2 a1)

eval :: Comp ()
eval = do
  instr <- ask
  case instr of
    [] -> return ()
    (i : is) -> do
      evalInstr i
      local (const is) eval

-- again, the idiom for monad transformers is to wrap them in newtypes, so
-- you can derive stuffs, have oquaue abstractions, etc.
-- But this means if you want to run a stack, you need to unwrap it's layers
-- one by one.
--
-- We are writing functional language, the entire program is a giant function.
-- and here is really the entrance. We provide the initial states, environment
-- and everything else that the program might need.
-- Then it just unwrap all layers in the monad transformer stack,
-- which perform their own effects.

execVM :: Program -> Output
execVM = flip evalState [] . execWriterT . runReaderT (unComp eval)

program :: Program
program =
  [ Push 47,
    Push 27,
    Add,
    Puts,
    Push 2,
    Push 3,
    ShiftL,
    Puts
  ]

run :: IO ()
run = mapM_ print $ execVM program
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
module Cat.MTLPractise1 where

import Control.Monad.Reader
import Control.Monad.Writer
import Control.Monad.Except

type UserInput = String

{-@ Had some problem to derive both readerT and exceptT
    Some experiments.
@-}

-- Derive one
newtype Foo a = Foo {unFoo :: ReaderT UserInput IO a}
  deriving (Functor, Applicative, Monad, MonadReader UserInput)

foo :: Foo String
foo = do
  res <- ask
  case res of
    (x : xs) -> return ("stitch with: " ++ xs)
    _ -> return "no"

tryfoo = runReaderT (unFoo foo) "tthis"

newtype Bar a = Bar {unBar :: ExceptT String IO a}
  deriving (Functor, Applicative, Monad, MonadError String)

bar :: Bar String
bar = throwError "err"

trybar = runExceptT (unBar bar)

-- now try to derive two together

newtype Woo a = Woo {unWoo :: ReaderT String (WriterT String IO) a}
  deriving (Functor, Applicative, Monad, MonadReader String, MonadWriter String, MonadIO)

woo :: Woo String
woo = do
  val <- ask
  tell ("written: " ++ val)
  return val

trywoo = runWriterT (runReaderT (unWoo woo) "read")

newtype Woo' a = Woo' {unWoo' :: ExceptT String (ReaderT String IO) a}
  deriving (Functor, Applicative, Monad, MonadError String, MonadReader String)
{-# LANGUAGE DataKinds                  #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE FunctionalDependencies     #-}
{-# LANGUAGE GADTs                      #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE PartialTypeSignatures      #-}
{-# LANGUAGE TypeFamilies               #-}
{-# LANGUAGE TypeOperators              #-}
{-# LANGUAGE UndecidableInstances       #-}

{-# LANGUAGE DeriveFunctor              #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE ScopedTypeVariables        #-}
module Cat.MonadTransformer where

import           Control.Applicative
import qualified Control.Exception      as E
import           Control.Monad
import           Control.Monad.IO.Class
import           Control.Monad.Trans

{-@ Recap, let's make some monad transformers
    First is the maybe monad.
 @-}
newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }

instance Monad m => Monad (MaybeT m) where
  return = MaybeT . return . Just
  x >>= f =  MaybeT $ do
    value <- runMaybeT x
    case value of
      Just value' -> runMaybeT $ f value'
      Nothing     -> return Nothing

instance Monad m => Applicative (MaybeT m) where
  pure = return
  (<*>) = ap

instance Monad m => Functor (MaybeT m) where
  fmap = liftM

instance Monad m => Alternative (MaybeT m) where
  empty = MaybeT $ return Nothing
  x <|> y = MaybeT $ do
    x_val <- runMaybeT x
    case x_val of
      Nothing -> runMaybeT y
      Just _  -> return x_val

{-@ Then let's make some exceptions
    This time we can also practice some mtl style interface
 @-}

-- Monad transformer.
-- 1. general form is:
--    Monad m => Monad e => m (f a)
--    m is the wrapper monad, f is the base monad.
--
--    base monad means the monad that determine the functionality
--    of the monad.
--
--    wrapper monad means whatever monad that stack on top of it.
--
-- 2. to hold pieces together we use newtype to wrap
--    stuffs into a new type (ha).
--
--    Some code are just noise to deal with new type itself.
--
-- 3. it really works like linked list
--
--    We know different monads have different semantics. Dealing with
--    a single monad is simple, we can just work with it alone.
--    But what about multiple monads
--    Say Monad1 Monad2, Monad3, Monad4 all doing different things. We
--    want a mega monad that can do all of them.
--
--    (In non pure languages you don't need to stack anything, the whole
--    program is a gigantic monad that works for everything.
--      pros: easier to work with
--      cons: can't split side effects, so can't be pure.
--            effects not in type, less explicit on what effects to perform.
--    )
--
--    newtype MonadTransformer1 m a = MonadTransformer1 (m (Monad1 a))
--    newtype MonadTransformer2 m a = MonadTransformer2 (m (Monad2 a))
--    newtype MonadTransformer3 m a = MonadTransformer3 (m (Monad3 a))
--
--    type MegaMonad' a
--      =  MonadTransformer1 (
--         MonadTransformer2 (
--         MonadTransformer3 (
--           Monad4 a
--         )))
--
--   To be honest I hate the syntax. the nested structure is hard to deal with.
--   Also monads don't compose well so sometimes the order matters. (IO->Except/Except->IO)
--
--
--   Anyway. we have the representation of the mega monad. The next thing to do is to
--   hide the internal make it works as a solid piece. Again we use newtype.
--
--   newtype MegaMonad a = MegaMonad { unMega :: MegaMonad' a }
--
--   then we can derive lots of typeclass to lift things for us automatically.

newtype ExceptT e m a = ExceptT { runExceptT :: m (Either e a) }

-- runExceptT exists only for newtype. If we don't have newtype wrapper
-- we don't need this.
-- It's not the core of the semantic of a monad transformer.

instance (Monad m) => Functor (ExceptT e m) where
  fmap f (ExceptT m) = ExceptT ((fmap . fmap) f m)

instance (Monad m) => Applicative (ExceptT e m) where
  pure = return
  (<*>) = ap

instance (Monad m) => Monad (ExceptT e m) where
  return = ExceptT . return . Right
  m >>= f = ExceptT $ do
    val <- runExceptT m
    case val of
      Left e  -> return . Left $ e
      Right a -> runExceptT $ f a


-- again, what's the semantic of an action that can have exception?
-- it can return a normal value, or return a exceptional value.
--
-- what do we want to do with exceptions?
-- When some conditions holds, we want to throw an exception to indicate something
-- wrong.
--
-- And somewhere at the call site we want to recognize the exception and handle it.
--
-- Thus we need a pair of operations:
--    throw to throw exception from nowhere
--    catch to handle exception and bring the program back to normal again.
throwE :: (Monad m) => e -> ExceptT e m a
throwE = ExceptT . return . Left

catchE :: (Monad m) => ExceptT e m a -> (e -> ExceptT e' m a) -> ExceptT e' m a
m `catchE` e = ExceptT $ do
  val <- runExceptT m
  case val of
    Left e' -> runExceptT (e e')
    Right a -> return . return $ a

-- fmap a function into a monad transformer means lift over
-- all this three layers.
--
-- What is a functor?
-- A functor holds a context, and allows a function to apply to
-- value in the context.
--
-- What is a functor for ExceptT?
-- A functor for exceptT holds a context m that can be arbitray side effects,
-- which return a (Either e a).
--
-- This implies that we actually have two layers of monds.
-- the first one is m, the second one is (Either e)
--
-- so to map f into the inter most value, we need to lift it
-- twice.
--
-- And finally, ExceptT is a newtype, we have to do the newtype thing:
-- A dummy constructor.
instance MonadTrans (ExceptT e) where
  lift = ExceptT . (fmap Right)

-- generalize the idea of throwing and catching exceptions.
-- we make it a mtl style type class.

-- What is a MonadError type class?
-- a MonadError e m is a monad on m with exception of type e that
-- supports throwError and catchError.
--
-- What is throwError, what is catchError?
-- throwError takes an exceptional value, base on that return (m a) that
--  the carries exception informaotion.
--
-- catchError takes a monad, a function that handles exceptional value so
--  it can return a normal value, return a normal value.
--
-- Why you want this?
--  MonadError abstract away what monad can throw errors. Now any monad can
--  possibly throw an error.
--  Specifically, if we have a monad transfromer stack, it's a different monad
--  from any other monads defined in base.
--  It's possible that some layer in the stack can throw an error, but we need to
--  lift it.
--
--  Instead, if we implement this typeclass on top of the transformer, we can
--  1. indirectly call the underlyng throw and catch.
--  2. or we can do totally different thing, it doesn't matter since it's just
--     saying there exists overloads for this monad.
--
-- Why we need funciontal dependencies? avoid ambigious types.

class (Monad m) => MonadError e m | m -> e where
  throwError :: e -> m a
  catchError :: m a -> (e -> m a) -> m a

-- let's write some MonadError interface for conveneince.

instance MonadError e (Either e) where
  throwError = Left
  Left l `catchError` h  = h l
  Right r `catchError` _ = Right r

instance MonadError E.IOException IO where
  throwError = ioError
  catchError = E.catch

instance Monad m => MonadError e (ExceptT e m) where
  throwError = throwE
  catchError = catchE

instance (Monad m, MonadIO m) => MonadIO (ExceptT e m) where
  liftIO = lift . liftIO

{-@ Possible use case @-}

-- throw in the code (If there is an error wrap it in Left.)
throwMeEither:: Int -> Either String Int
throwMeEither n |  n > 100 = Right n
  | otherwise = Left "Bad bad"

throwMeExcept :: Int -> ExceptT String IO Int
throwMeExcept n | n > 100 = return n
  | otherwise = throwError "Bad bad except"

-- capture with an handler. With monad error we can't capture
-- Either and ExceptT with the same function.
catchMe :: MonadError e m => Int -> (Int -> m Int) -> m Int
catchMe n f = catchError (f n) (\_ -> return 1)

{-@ Some exampels @-}
-- define your own exception
data LengthError = EmptyString
                 | StringTooLong Int
                 | OtherError String

instance Show LengthError where
  show EmptyString = "the string is empty"
  show (StringTooLong len) = "The length of the string " ++ (show len) ++ " is too long"
  show (OtherError msg) = msg

newtype Length a = Length { unLengh :: ExceptT LengthError IO a }
  deriving (Functor, Applicative, Monad, MonadError LengthError, MonadIO)

-- note it's not necessary to catch every throw, since throw is really
-- just a pure for the error case anyway.
stringLengthExample  :: IO ()
stringLengthExample = do
  r <- runExceptT (unLengh calculateLength)
  report r

report :: Either LengthError Int -> IO ()
report (Right len) = putStrLn ("length of the str is: " <> show len)
report (Left e)    = putStrLn ("Error: " ++ show e)

calculateLength :: Length Int
calculateLength = do
  liftIO . putStrLn $ "Please enter a string"
  s <- liftIO getLine
  if null s
    then throwError EmptyString
    else let len = length s
          in if len > 50
                then throwError $ StringTooLong len
                else return len

-- catchMe 10 (\n -> if n == 10 then throwError "bad bad" else return 1)

{-@ quirks when catching IO @-}

-- this will crash.
-- First the thunk head [] is created, then it will live for the entire time until you
-- evaluate it, which in this case is never. Essentially no exception happend in the code,
-- the exception happend when ghci try to print the value out.
catchWithReturn = E.catch (return $ head []) $ \(_ :: E.SomeException) -> return "good"

-- This wont crash, because ghci doesn't need to print anything, the exceptional code (head [])
-- is still there like a bomb.
catchWithReturnUnit = E.catch (return $ head []) $ \(_ :: E.SomeException) -> return ()

-- evaluate force it's argument to be evaluated into weak head normal form.
-- this means (head []) get evaluated in place, and it get returned directly.
catchWithEvaluate = E.catch (E.evaluate $ head []) $ \(_ :: E.SomeException) -> return "good"
module Cat.MonadWithoutTypeclass where

import           Data.Function

-- ref: The essence of functional programming (Phil Walder)

{-@ Using monad to extend a simple interpreter.
    Monads with only basic algebraic data type and functions.
    because there is no typeclass, we can't overload >>=, instead
    each monad has it's own bind.

    A monad can be thought as a triple (M, unitM, bindM), where M is the
    constructor.
@-}


-- you can convert this to scott encoding to make the entire implementation only
-- rely on function
data Position = Pos { col :: Int, line :: Int } deriving (Eq, Show)

-- We are describing effect with functons and data types only, it's clear to
-- see where the verbosity of monad appears.
--
-- The most annoying part is you always need to lift an operation to the right
-- level of the monad stack.
--
-- Typeclass already removed a lot of boilerplates, but there are still a lot of
-- extra code needs to be written.

-- starts from the identity monad.
-- We can gradually adding more functionalities.
--
-- I monad: Identify --------------------------
data I a = I a

-- Monad Instance --
-- monad has two operations bind and unit.
unitI :: a -> I a
unitI = I

bindI :: I a -> (a -> I b) -> I b
bindI (I a) f =  f a
------------------------------------------------

-- E monad: Error ------------------------------

data E a = Success a | Error String deriving (Eq, Show)


-- Monad Instance --
unitE a = Success a
(Success a) `bindE` k = k a
(Error e) `bindE` _   = Error e

-- | For error monad, we have an additional operation errorE.
-- | We call this method to signal the error.
errorE s = Error s
------------------------------------------------


-- PE monad: Position + Error  -----------------
--
-- Mannually crank up a monad transformer.
-- PE :: Position -> E a
newtype PE a = PE { unPE :: (Position -> E a) }

-- Monad Instance --
unitPE a = PE $ \_ -> unitE a

bindPE :: PE a -> (a -> PE b) -> PE b
m `bindPE` k = PE $ \p ->
  (unPE m) p `bindE` (\x ->
    (unPE (k x)) p)

-- Position.
-- | reset position
resetPE :: Position -> PE x -> PE x
resetPE pos (PE m) = PE (\p -> m pos)

-- lifting
errorPE s = PE $ \p -> errorE (s ++ ", Position:" ++ show p)
------------------------------------------------


-- SPE monad: Position + Error + State Transformer
-- SPE :: s -> Position -> E (a, s)
newtype SPE s a = SPE { unSPE :: (s -> PE (a, s)) }

unitSPE a = SPE $ \s -> unitPE (a, s)

bindSPE :: SPE s a -> (a -> SPE s b) -> SPE s b
m `bindSPE` k = SPE $ \s ->
  (unSPE m $ s) `bindPE` (\(a, s') ->
    (unSPE (k a) $ s') `bindPE` (\(b, s'') ->
      unitPE (b, s'')))

-- test1 (seems work)
-- to unwrap a monad transformer, we need to do it outside in.
t1 = (unPE (unSPE t "initial state")) (Pos 0 0)
  where
    t = (unitSPE 1) `bindSPE` (\x ->

      -- sequence. The monadic function doesn't use the input, but an effect is performed
      -- by putSPE implicitly.
      -- Effect is accessible within the funciton now.
      putSPE "state" `bindSPE` (\_ ->
      modifySPE (\s -> "modified state") `bindSPE` (\_ ->
      errorSPE ("It just throws an error for some reason"))))

t2 = (unPE (unSPE t "initial state")) (Pos 0 0)
  where
    t = (unitSPE 1) `bindSPE` (\x ->
      putSPE "state" `bindSPE` (\_ ->
      modifySPE (\s -> "modified state") `bindSPE` (\_ ->
      unitSPE 10)))


-- State specifics

modifySPE :: (s -> s) -> SPE s ()
modifySPE f = SPE $ \s -> unitPE ((), f s)

putSPE :: s -> SPE s ()
putSPE s' = SPE $ \s -> unitPE ((), s)

getSPE :: SPE s s
getSPE = SPE $ \s -> unitPE (s, s)

-- lifting:
-- error
errorSPE a = SPE $ \s -> errorPE a

-- reset
resetSPE :: Position -> SPE s x -> SPE s x
resetSPE pos (SPE m) = SPE $ \s -> resetPE pos (m s)

------------------------------------------------

-- OSPE monad: Position + Error + State Transformer + Output
-- OSPE :: s -> Position -> E ((String, a), s)

newtype OSPE s a = OSPE { unOSPE :: SPE s (String, a) }

unitOSPE a = OSPE . unitSPE $ ("", a)

bindOSPE :: OSPE s a -> (a -> OSPE s b) -> OSPE s b
m `bindOSPE` k = OSPE $
  (unOSPE m) `bindSPE` (\(out, a) ->
    unOSPE (k a) `bindSPE` (\(out1, b) ->
      unitSPE (out ++ out1, b)))


-- Output monde
outOSPE :: Show a => a -> OSPE s (SPE b ())
outOSPE a = OSPE .unitSPE $ (show a ++ "; ", unitSPE ())


-- lifting, eh...
-- State specifics
modifyOSPE :: (s -> s) -> OSPE s ()
modifyOSPE f = OSPE $
  modifySPE f `bindSPE` (\_ ->
  unitSPE ("", ()))


putOSPE :: s -> OSPE s ()
putOSPE s = OSPE $
  putSPE s `bindSPE` (\_ ->
  unitSPE ("", ()))


getOSPE :: OSPE s s
getOSPE = OSPE $
  getSPE `bindSPE` (\s ->
    unitSPE ("", s))


-- more lifting:
-- error
errorOSPE a = OSPE $ errorSPE a

-- reset
resetOSPE pos (OSPE m) = OSPE $ resetSPE pos m

--   (o, resetSPE pos m)

t3 = (unPE (unSPE (unOSPE t) "initial state")) (Pos 0 0)
  where
    t = unitOSPE 1 `bindOSPE` (\x ->
      putOSPE "new state" `bindOSPE` (\_ ->
      modifyOSPE (++ ", appened with this") `bindOSPE` (\_ ->
      outOSPE ("new message" ++ show x) `bindOSPE` (\_ ->
      outOSPE ("another message") `bindOSPE` (\_ ->
      errorOSPE "done")))))

t4 = (unPE (unSPE (unOSPE t) "initial state")) (Pos 0 0)
  where
    t = unitOSPE 1 `bindOSPE` (\x ->
      putOSPE "new state" `bindOSPE` (\_ ->
      modifyOSPE (++ ", appened with this") `bindOSPE` (\_ ->
      outOSPE ("new message" ++ show x) `bindOSPE` (\_ ->
      outOSPE ("another message") `bindOSPE` (\_ ->
      unitOSPE "done")))))


------------------------------------------------

type M = OSPE Int
unitM = unitOSPE
bindM = bindOSPE
unM s t = (unPE (unSPE (unOSPE t) s)) (Pos 0 0)

errorM = errorOSPE
resetM = resetOSPE

modifyM = modifyOSPE
getM = getOSPE
putM = putOSPE

outM :: Show a => a -> M (SPE s ())
outM = outOSPE

-- additional operation for all monads
--
-- functor
mapForM :: (a -> b) -> M a -> M b
mapForM f m = m `bindM` (\a -> unitM (f a))

-- join nested monads.
-- >>= once consume one layer.
joinM :: M (M a) -> M a
joinM z = z `bindM` id

tickM :: M ()
tickM = modifyOSPE (\s -> s + 1)


{-@ Monad Laws
    Left identity:
      pure a >>= k = k a

    Right identity:
      m >>= pure = m

    Associativity:
      m >>= (\a -> k a >>= (\b -> k b))
      =
      (m >>= \a -> k a) >>=)\b -> k b

    A law abiding monad compose!
@-}
t5 = (unPE (unSPE (unOSPE t) "initial state")) (Pos 0 0)
  where
    -- by left identity law: (pure a) >>= k = k a
    -- in practice left identify means if you just want to shove a value into a
    -- monadic computation, just use the mnadic function is enough, no bind is needed.
    t = 1 & (\x ->
      putOSPE "new state" `bindOSPE` (\_ ->
      modifyOSPE (++ ", appened with this") `bindOSPE` (\_ ->

      -- by associativity law
      -- in practice it means you can carve an expression in the middle, define it
      -- somewhere else, and refer to it in the big expression.
      (outOSPE ("new message" ++ show x) `bindOSPE` (\_ ->
      outOSPE ("another message")) `bindOSPE` (\_ ->
      unitOSPE "done")))))

-------------------------------------------------------------------------------

--------- language -----------------------------------
type Name = String

data Term  = Var Name
           | Cont Int
           | Add Term Term
           | Lam Name Term
           | App Term Term
           | Cout
           | At Position Term
           | Out Term

data Value = Wrong
           | Num Int
           | Fun (Value -> M Value)

type Env = [(Name, Value)]

showval :: Value -> String
showval Wrong   = "<wrong>"
showval (Num i) = show i
showval (Fun f) = "<function>"

instance Show Value where
  show = showval

eval :: Term -> Env -> M Value
eval (Var x) e = lookup' x e

eval (Cont i) e = unitM (Num i)

eval (Add u v) e = eval u e `bindM` \a ->
                   eval v e `bindM` \b ->
                   add a b
eval (Lam x v) e = unitM . Fun
                 $ \a -> eval v ((x, a): e)
eval (App t u) e = eval t e `bindM` \f ->
                   eval u e `bindM` \a ->
                   apply f a

eval (Cout) e = getOSPE `bindM` (\s -> unitM (Num s))

-- effecful operations

-- print the value to the output, and return the value unchanged.
eval (Out u) e = eval u e `bindM` (\a ->
                 outOSPE a `bindM` (\_ -> unitM a))

-- modify the position info
eval (At p t) e = resetOSPE p (eval t e)

lookup' :: Name -> Env -> M Value
lookup' x [] = errorOSPE "not in environment"
lookup' x ((y, b):e)
  | x == y = unitM b
  | otherwise = lookup' x e

add :: Value -> Value -> M Value
add (Num i) (Num j) = tickM `bindM` (\_ -> unitM $ Num (i + j))
add _ _             = errorOSPE "Arguments need to be Num"

apply :: Value -> Value -> M Value
apply (Fun k) a = tickM `bindM` (\_ -> k a)
apply _ _       = errorOSPE "wrong application"


-- test
t' = unM 0 $ eval (At (Pos 1 2) (App (Cont 1) (Cont 2))) []

t'' = unM 0 $ eval (Out
  (Add
    (Add (Out (Cont 1)) (Out(Cont 2)))
    (Add (Out Cout) (Out Cout)))) []

t''' = unM 0 $ eval (Out (Cont 1)) []

t6 = unM 0 $ eval (App (Lam "x" (Add (Var "x") (Var "x"))) (Cont 1)) []


{-@ Call by name and monad @-}
-- argument of the function is just a value.
foo :: a -> m b
foo = undefined

-- turn argument of the function into a computation
bar :: m a -> m b
bar = undefined

{-# LANGUAGE DeriveFunctor              #-}
{-# LANGUAGE DerivingStrategies         #-}
{-# LANGUAGE GADTs                      #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE KindSignatures             #-}
{-# LANGUAGE RankNTypes                 #-}
module Cat.Monads where

{-@ 2020-04-30
    Functor: morphism between categories
    Endofunctor: A functor from a category to itself.
    Natural transformation: 2-morphism between two functors.
@-}

import           Control.Applicative
import           Control.Monad
import           Control.Monad.Trans


-- Simple monad transformer.
-- 1. Monad transformers are themselves, monad transformers
-- 2. Monad transformers works sort like like a list. m in m (Maybe a)
--    is a monad, which of course can itself be another monad t ransformer.
-- 3. Stacking monad transformers allows you combine possible actions.
newtype MaybeT m a = MaybeT {runMaybeT :: m (Maybe a)}


-- what does it means to be a monad?
-- 1. it's are also functor and applicative
-- 2. being a functor means you can lift operation over the context
-- 3. being an applcative means:
--    1. You can shove any values into the context.
--    2. You can apply functions in a context / Function application with effects.
-- 4. being an monad means you can performance actions in sequence.
--    it's a consequence of nesting. When you have a structure as m (m a) and
--    reduce it to (m a), you need to remove the outer layer first.

-- normal bind:
(>>==) :: m a -> (a -> m b) -> m b
(>>==) = undefined

-- where join is:
join' :: Monad m => m (m a) -> m a
join' m = m >>= id


-- then:
join'' m = m >>=== id
  where
    -- imagine instantiate bind like this:
    -- m (m a) is just a (m b)
    (>>===) :: m (m a) -> (m a -> m a) -> m a
    (>>===) = undefined

-- monad law

-- 1. (return x) >>= f ≡ f x
--      shove a value into the context then bind to f is the same as apply f directly.
--      implication:
--        any value shoulbe be able to directly engage in a monadic operation by using pure.
leftId1 x f = do { x' <- return x;
                   f x'
                 }
leftId2 x f = do { f x }

-- 2. m >>= return ≡ m
--      shove m into return, which takes the value and put it back to a new monad.
--      implication:
--        bind a monad to return should have no effect.
rightId1 m = do { x <- m ;
                  return x
                }
rightId2 m = do { m }


-- 3. (m >>= f) >>= g ≡ m >>= (× -> f \x >>= g)
--      bind is associative.
--      implication:
--        the order to group mandic functions dosen't matter. You can: pick a part of the chain and make
--        it another function, then use the newly defined function in the same place, still works.
-- If a block has return value, then it of course all these three are equivalent:
assoc1 m f g = do { y <- do { x <- m;
                              f x
                            };
                    g y
                  }
assoc2 m f g = do { x <- m;
                    do { y <- f x ;
                         g y
                       }
                  }
assoc3 m f g = do { x <- m;
                    y <- f x;
                    g y
                  }

-- see how do block resembles a normal imperative code.
-- Monad law is important because the compiler inlines based on it. (at least compiler can rely on it
-- to perform code transformation).


{-@ Everything boilds down to functions:
      Programming is just programming, does matter how much fancy words you are using, everything goes down
      to some basic concepts. You perform instructions, you branch, you jump, you loop. No matter what you are using:
      a purely functional langauge or assembhly; these things are always around you.

      Though monad is a concept from cat theory, if it's widely applciable on programming, it must relates to
      those basic notaions some how. It's like, Arithmetics are also abstracted concepts. we talk about it because
      it models daily life situations nicely.

      Haskell has a fancy type system and a large set of syntax that makes it looks super complicated at the
      first glance. However, the fundation of all of these is just lambda calculus: It is still a lambda calculus based language.
      All abstractions you can play with essentially boil down to functions.

      Some exceptions like builtin types like integers and algebraic data types, which can also
      be encoded in lambda calculus. (chruch encoding, scott encoding etc.). At least, conceptually
      everything can be treated as functions, and thinking in this way makes a lot of thing much easier.
      (At least the language design is much more uniform, and the fundation is more thourough)

@-}

{-@
      A side note before goes into Monad: typeclass:
        what is typeclass?
          1. Typeclass consists two parts: type level constraint and term level function overloading.
          2. You can have typeclass with not term level definiton. Then it just says a type needs to be something.
          3. If a typeclass has term level funtion, you overload it. Overloading implies if you call the funcion
             on a value that is constrainted to be in typeclass, the right verision of the function will be invoked.
          4. typeclass help us to describe Monad eaiser, as the term level definition can to reflected to the type level.
          5. But really, it has nothing to do with monad itself. Nice thing to have but not necessasry.
          ok.

      So what's monad?

      when you see a type Monad m => m a, it means m is a monad,
        which means it supports at least >>= and return,
        which means it has a well defined way to remove a layer of structure and get the value out.

        NOTE: Given a monad you can join nested layers (join :: m (m a) -> m a),
          - the process of removing a layer of m implies you need to perform some computations.

        NOTE: we can define a helper function (>>= :: m a -> (a -> m b) -> m a) helps us to perform
              multiple computations on monads on after another. (chain them up!)

            we have m a and (a -> m b) as parameters. To run (a -> m b), we need to perform m a and get a.
            which means
              1. we need some how do (m a) -> a and get the a.
              2. we pass a as argument to (a -> m b)
              3. we get a new monad (m b) where >>= still applies.
            and
              step 1 perform the monad operation
              step 2 perform your arbitray operations based on the result of them monadic computation
@-}

-- put it here otherwise the comment is too long :)
-- Monad transfromer is still a monad.
instance Monad m => Monad (MaybeT m) where
  return = MaybeT . return . Just
  x >>= f = MaybeT $ do
    maybe_value <- runMaybeT x
    case maybe_value of
      Nothing    -> return Nothing
      Just value -> runMaybeT $ f value

-- Monad requirements.
instance Monad m => Applicative (MaybeT m) where
  pure = return
  (<*>) = ap

instance Monad m => Functor (MaybeT m) where
  fmap = liftM


{-@
      what are implicit operations?
        Look at Maybe. you can see it as an side effect denotes success and failure. Or you can view merely
        by it's definiton: a container that can be any value or Nothing; when using it, it return some of the any value,
        or Nothing, base on some branching logics.
        The branching logic can be implied when chaining operations.

      what's the point of having implicit operations performed?

          - Get rid of boiler plates.
            if you write c, how do you handle errors?
            you write a fuction.
            you return a value, if it is not some magic value  (e.g #define ERR = -1), you take it as success. If it is,
            you handle it or propagate it.
              int foo(int a) {
                if (a < 0) {
                   return -1;
                }
                return sqrt(a);
              }

              int bar(int a) {
                if (a < 0 || isprime(a)) {
                   return -1;
                }
                return a;
              }

              int main() {
                int res = foo(-1);
                if (res) {
                  printf("error!");
                } else {
                  printf("meh, ok%d", res);
                }
                return 0;
              }

              The if else pattern for handling propagates everywhere, but it can be abstracted away.
              Inheritently, function foo and bar are functions that are possible to fail.
              The failure is singaled to it's called via return type.
              So what is a fuction that can fail?
                1. A function has an intended return type.
                2. The intended return type describe a set of intended return values.
                3. becuse the function maybe fail, it either return a intended value, or something
                  that can singal a failure. In another word, sucess or failure.
                4. As caller, if we receive the signal a failure signal, we know the computation failed,
                  so the whole computation needs to cease.
                  other wise, we can obtain a value of the intended type, the computation continue.
                  (this is the branching logic)
                5. This logic should be able to be chained up. Say I have functions f1, f2, f3 that all may
                  fail, I want to perform in order as f1 -> f2 -> f3. If any one of these functions signal a
                  failure, the computation stops. otherwise value propagates until we get the result.

              There are lots of choices to indicate a possible failure. The most used way is to use sum type.
              If something wrong, we indicate it as Nothing.
                (A thing to note: `Nothing` is the result of a computation that failed. it's a static representation of
                 failure. For the example above, bar fails as an consequence of the input being less than 0.
                 Implication:
                  1. caller can't know what's exactly wrong with the function,
                  2. Nothing itself is not a failure, it's a indicator of failure.)
              With the reprenstation, we can check if something goes wrong as a caller by check if the function return
              Just or Nothing:
                  run x =
                    case foo . bar $ x of
                      Just x -> putStrLn (show x)
                      Nothing -> putStrLn "peepeepoopoo"

              At this point it's just the same as C... Pattern matching looks fancy but it is still branching logic, you still
              need to do the checking by hand. What up?

              We hope we don't need to write the branching our self, instead just use the resulting value of a function that possible
              to fail. if anything goes wrong, evaluate the whole thing as Nothing, other wise proceed (point 4)
              In another word, we want the checking of Nothing to be implicit. Ah implicit! A monad!

              We just need to overload the bind (>>= :: m a -> (a -> m b) -> m b) for (Maybe a). In bind, when m a gives a, keep going,
              otherwise we return Nothing. This way, we only need to combine a (Maybe a)  with another function that returns a (Maybe b).
              In the function we can pretent (Maybe a) succeed. If it's failed, it's handled by (>>=).

              -- If we wrap the intended return value into another type that dedicated to handle errors, we can chain
              -- two may-failed operations with the same error handing logic.


          - Another view: chain Side effects:
              - what are side effects

                normally people give you examples like: mutation is side effect. performing io is side effect.
                but what's the difference between mutation and calcualte 1 + 2? what draws a line between side effect and
                non side effect?

                  We normally heard haskell functions are pure functions. Pure functions are referential transparent.

                  we know referential transparency: one input determines one output. f(1) = 1, f(1) = 2 is not a function.

                  but in c for example, lots of functions doesn't perform this way:
                    int foo(int x) {
                      int a;
                      scanf("%d\n", &a);
                      return a + x;
                    }
                  in this case, you don't know what gonna come with scanf. can you?
                  you can't! you can't predict the future, and there is no rule to govern how scanf work. From the view of out
                  program, the value of a comes from a different world!

              - how to represent side effects in a purely functional language?
                We don't need to explicit describe the sideffect in C, because purity is not part of it's design goal.
                so type of foo is just int -> int.

                However in haskell, all functions are pure. How do you make the return value of foo the same even the value Int
                change all the time?

                trick: We don't return Int anymore, we return a computation that yields Int.
                  thus we have foo :: Int -> IO Int

                This way, given any Int, we have the same value: A monad, a computation that gives a Int. the tricky part is in
                haskell we can't see the definition of IO, we only know it exists and it yields x.
                since the IO m is the same value, we keep the referential transparency. But what Int does IO Int give us is a
                different story.

              - So how is this related to monad?
                Given:
                  foo :: Int -> IO Int
                  bar :: Int -> Int -> IO Int
                  quux :: Int -> IO Int -> IO Int
                we know they are just "purified" functions that works on Int. In c they all have the same signature
               (quux might not, but doesn't matter now)

                But after we purified them, these function nolonger work with each other anymore. How to make it work again?
                we need to take the value in (IO Int) out (perform the IO action and get a Int), then use the Int as paramter
                for the next computation. Because we cannot directly control the process, this happens implicilty.
                What does it sounds like?

                if we make IO a monad, we can >>= it.
                  main :: IO Int
                  main = do
                    i <- foo 10
                    quux i (bar i 20)

                how does IO actually get performed? we don't care. at least in the language level it's not a concern.

            Can pure function has free variable?
              consider this case
                x = 10
                f y = x
              then f 1 = 10, f 2 = 10. is this a pure function?
              Is just a constant, the function application is redundent.
@-}

{-@
      What does it mean to be "in a monad m"
        Again let's use Maybe as example. With the notion of "possibly failed computation", we have
          1. A function that returns (Maybe a), the function can either succeed or fail. The return value record
             the senario of the execution process.
          2. A function that takes a (Maybe a), the parameter maybe valid or not valid.
          In


      Every monad has it's semantics.
        When talking about semantics you might think of the semantics of a programming langue in genral. But of course each
        component of a language has it's own semantics!

        Monad allows you to separate different semantics, and define them on their own.
          Maybe monad represents a computation that might fail, you can talk about monad now.
          Reader monad represents a computation that needs to use read in an environment, you can use it for passing implicit config.
          Pause Monad etc...

      What does it mean that monad allows you to describe sequencing?
        when you see a type (m (m a)), it can be thought as two layers of funcition stack on top of
        each other, each one perform some computations.

        then `join :: m (m a) -> m a` apparently needs to `call` the first layer to get rid of the first m!
        Essentially the only way to perform operations in sequence is by nesting.

@-}

-- some handy class
-- Alternative is like a monoid with different semantic.
instance Monad m => Alternative (MaybeT m) where
  empty = MaybeT $ return Nothing
  x <|> y = MaybeT $ do
    maybe_value <- runMaybeT x
    case maybe_value of
      Nothing -> runMaybeT y
      Just _  -> return maybe_value

instance Monad m => MonadPlus (MaybeT m) where
  mzero = empty
  mplus = (<|>)

{-@ Monad is defined with join, but
    in haskell you get >>= instead.
    reason explained above.
@-}

-- kind signature helps you to tell the kindness of type variable
class (Applicative m) => Monadish (m :: * -> *) where
  merge :: m (m a) -> m a
  bind :: m a -> (a -> m b) -> m b
  bind m f = merge (fmap f m)
  {-# MINIMAL merge #-}

newtype Kleisli m a b = Kleisli (a -> m b)

kbind :: Monad m => Kleisli m a b -> Kleisli m b c -> Kleisli m a c
kbind (Kleisli f) (Kleisli g) = Kleisli $ join . fmap g . f

-- bind' :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
-- bind' f g = join . fmap g . f

-- unsafePerformIO is a cokleisli arrow.
newtype Cokleisli w a b = Cokleisli (w a -> b)

class Functor w => Comonad w where
  (=>=) :: (w a -> b) -> (w b -> c) -> (w a -> c)
  extract :: w a -> a
{-# LANGUAGE RankNTypes #-}
module Cat.Monads1 where

import           Data.Function
import           Data.Maybe


{-@ How do you write mtl like interface?
    (Although it's called mtl like interface, MonadFix, MonadFail and
     MonadIO are all in the prelude. The library is so inconsistent and
     takes you extra effort to understand a simple thing...)
    Here is some little practise
@-}

-- First of all, if you want mtl you need multiparameter type classes
-- and functional dependencies.
{-# LANGUAGE FunctionalDependencies     #-}
{-# LANGUAGE MultiParamTypeClasses      #-}

-- Of course the entire mtl is based on newtype deriving
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE StandaloneDeriving         #-}
{-# LANGUAGE DefaultSignatures #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE GADTs #-}

module Cat.MyMTL where
import           Control.Monad.IO.Class     (MonadIO (liftIO))
import           Control.Monad.Trans.Class  (MonadTrans (lift))
import           Data.Functor.Classes       (Eq1 (..), Ord1 (..), Read1 (..),
                                             Show1 (..), compare1, eq1,
                                             readsData, readsPrec1,
                                             readsUnaryWith, showsPrec1,
                                             showsUnaryWith)
import           Data.Functor.Contravariant
import           Data.Functor.Identity

import Control.Monad.Except
import Control.Monad.State
import Control.Monad.Reader
import Control.Monad.Writer
import Control.Monad.Trans.Maybe
import Data.List

import qualified Prelude (readFile, writeFile)
import Prelude hiding (readFile, writeFile)


-- Identity --
-- This is probably the best example to play around with mtl facilities

newtype IdentityT f a = IdentityT { runIdentityT :: f a }

instance Eq1 f => Eq1 (IdentityT f) where
  liftEq eq (IdentityT x) (IdentityT y) = liftEq eq x y
  {-# INLINE liftEq #-}

instance Ord1 f => Ord1 (IdentityT f) where
  liftCompare comp (IdentityT x) (IdentityT y) = liftCompare comp x y
  {-# INLINE liftCompare #-}

instance Read1 f => Read1 (IdentityT f) where
  liftReadsPrec rp r1 = readsData $
    readsUnaryWith (liftReadsPrec rp r1) "IdentityT" IdentityT

instance Show1 f => Show1 (IdentityT f) where
  liftShowsPrec sp s1 d (IdentityT m) =
    showsUnaryWith (liftShowsPrec sp s1) "IdentityT" d m

-- use Eq1, Ord1... etc to implement Eq, Ord... directly
instance (Eq1 f, Eq a) => Eq (IdentityT f a) where
  (==) = eq1
instance (Ord1 f, Ord a) => Ord (IdentityT f a) where
  compare = compare1
instance (Read1 f, Read a) => Read (IdentityT f a) where
  readsPrec = readsPrec1
instance (Show1 f, Show a) => Show (IdentityT f a) where
  showsPrec = showsPrec1

instance (Functor m) => Functor (IdentityT m) where
  fmap f = mapIdentityT (fmap f)
  {-# INLINE fmap #-}

instance (Foldable f) => Foldable (IdentityT f) where
  foldMap f (IdentityT t) = foldMap f t
  {-# INLINE foldMap #-}

  foldr f z (IdentityT t) = foldr f z t
  {-# INLINE foldr #-}

  foldl f z (IdentityT t) = foldl f z t
  {-# INLINE foldl #-}

  foldr1 f (IdentityT t) = foldr1 f t
  {-# INLINE foldr1 #-}

  foldl1 f (IdentityT t) = foldl1 f t
  {-# INLINE foldl1 #-}


-- | lift an unary operator to the new monad.
mapIdentityT :: (m a -> n b) -> IdentityT m a -> IdentityT n b
mapIdentityT f = IdentityT . f . runIdentityT
{-# INLINE mapIdentityT #-}

instance Traversable f => Traversable (IdentityT f) where
  traverse f (IdentityT a) = IdentityT <$> traverse f a
  {-# INLINE traverse #-}

instance Applicative m => Applicative (IdentityT m) where
  pure x = IdentityT (pure x)
  (<*>) = undefined


-------------------------------------------------------------------------------
-- we can provide default implementation

class Monad m => MonadFileSystem m where
  readFile :: FilePath -> m String
  writeFile :: FilePath -> String -> m ()

  default readFile :: (MonadTrans t, MonadFileSystem m', m ~ t m')
                   => FilePath
                   -> m String
  readFile a = lift $ readFile a

  default writeFile :: (MonadTrans t, MonadFileSystem m', m ~ t m')
                    => FilePath
                    -> String
                    -> m ()
  writeFile a b = lift $ writeFile a b

-- we need to provide an instance with every other monad transformers,
instance MonadFileSystem m => MonadFileSystem (ExceptT e m)
instance MonadFileSystem m => MonadFileSystem (MaybeT m)
instance MonadFileSystem m => MonadFileSystem (ReaderT r m)
instance MonadFileSystem m => MonadFileSystem (StateT s m)
instance (MonadFileSystem m, Monoid w) => MonadFileSystem (WriterT w m)

instance MonadFileSystem IO where
  readFile = Prelude.readFile
  writeFile = Prelude.writeFile

newtype InMemoryFileSystemT m a = InMemoryFileSystemT (StateT [(FilePath, String)] m a)
  deriving (Functor, Applicative, Monad, MonadError e, MonadReader r, MonadWriter w)

instance Monad m => MonadFileSystem (InMemoryFileSystemT m) where
  readFile path = InMemoryFileSystemT $ do
    vfs <- get
    case lookup path vfs of
      Just contents -> pure contents
      Nothing -> error ("readFile: no such fille" ++ path)

  writeFile path contents = InMemoryFileSystemT $ modify $ \vfs ->
    (path, contents) : delete (path, contents) vfs

-------------------------------------------------------------------------------
-- Freer monad

data FileSystem r where
  ReadFile :: FilePath -> FileSystem String
  WriteFile :: FilePath -> String -> FileSystem ()
module Cat.TypeclassLaws where

-- laws on typeclass specifies the property certain operation should have. It
-- cannot be enforced by haskell's type system, but it's important because it
-- affect the semantics of typeclasses.


------------------------------------------------------------------------------
-- Functor Law:

class Functor' f where
  fmap' :: (a -> b) -> f a -> f b
  (<$) :: a -> f b -> f a
  (<$) = fmap' . const


-- 1. identity:
--      fmap id = id
-- 2. homomorphic:
--      fmap (g . h) = (fmap g) . (fmap h)
--
-- These two laws enforecs functors to map while preserves the structure.
-- A thing to note is that (f a) and (f b) are essentially different types,
-- just they share the common structure f.
--
-- So the most natural map from (f a) to (f b) should not change the structrure
-- of f.
--
-- e.g
--  1. of course this holds
--     fmap (id . id) = fmap id . fmap id
--
--  2. fmap (const "a") (Just 1) = Just "a"
--     The structure of Maybe is not chagned, but all values from Int
--     maps to one value "a".
--
--  3. fmap fmaps between types with the same structure. You don't map from
--     Maybe Int to [Int].
--     An arbitrary map between functors requires us to handle in a case by case
--     manner.

------------------------------------------------------------------------------
-- Applicative Law:

class Functor' f => Applicative' f where
  pure :: a -> f a
  infixl 4 <*>, *>, <*

  (<*>) :: f (a -> b) -> f a -> f b
  (*>) :: f a -> f b -> f b
  (<*) :: f a -> f b -> f a

-- Laws
-- 1. identity
--      pure id <*> v = v
-- 2. homomorphic
--      pure f <*> pure x = pure (f x)
-- 3. interchange
--      u <*> pure y = pure ($ y) <*> u
-- 4. u <*> (v <*> w) = pure (>) <*> u <*> v <*> w

-- all applicatives should also be a funtor. that means we can always count on
-- simple structure preserving mapping. The reason why we can claim this is
-- because we can easily define fmap with (<*>) and pure.
-- given a function f :: a -> b we just to do \f m -> (pure f) <*> m to get fmap
--
-- In another word, stronger abstractions provides more facilities that allows
-- us to simulate simpler one.
--
--

{-# LANGUAGE CPP #-}
module GHCs.Bench where

import           Criterion.Main

-- bench our own indexing operator

#ifdef NAIVE_VERSION
infixl 9 !?
_ !? n | n < 0 = Nothing
[] !? _ = Nothing
(x:_) !? 0 = Just x
(_:xs) !? n = xs !? (n - 1)
#endif

infixl !?

-- whnf measures how quick the code reaches the position.
-- nf measures the full evaluation time.

-- note (\x r k -> ...) as type a -> b -> c -> d -> a -> (b -> c) -> d
-- b -> c is our base case
(!?) :: Num a => [a] -> Int -> Maybe a
xs !? n
  | n < 0 = Nothing
  | otherwise = foldr (\x r k -> case k of
                                   0 -> Just x
                                   _ -> r (k - 1)) (const Nothing) xs n
{-# INLINABLE (!?) #-}
{-# SPECIALIZE (!?) :: [Integer] -> Int -> Maybe Integer #-}


xs :: [Integer]
xs = [1..9999]

-- when doing benchmarking in haskell, it's important to think about if you want to benchmark
-- the value get evaluated to weak head normal form or normal form.

main :: IO ()
main = defaultMain [ bench "index list 9999" $ whnf (xs !!) 9998
                   , bench "index list maybe index 9999" $ whnf (xs !?) 9998
                   ]

xs1 :: [Integer]
xs1 = [1..9999] ++ [undefined]

-- nf on xs1 will evaluate the undefined.
main1 :: IO ()
main1 = defaultMain [ bench "index list maybe index 9999" $ whnf (xs1 !?) 9999 -- ok
                    , bench "index list 9999" $ whnf (xs1 !!) 9999  -- crash
                    , bench "index list maybe index 9999" $ nf (xs1 !?) 9999  -- crash
                    ]

-- you need nf for map beacuse you also want to know the overhead of f.
main2 :: IO ()
main2 = defaultMain [ -- 12.63ns all it evals to is _:_
                      bench "map to list whnf" $ whnf (map (+1)) xs
                    , bench "map to list nf" $ nf (map (+1)) xs]      -- 1.133 ms
{-# LANGUAGE DefaultSignatures #-}
{-# LANGUAGE DerivingVia #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE TypeFamilies #-}

module GHCs.DeriveVia where

import Data.Coerce

-- --------------------------------------------------------------------------
-- heat up
-- --------------------------------------------------------------------------

-- first rule: we can't derive things witout an implementation of course. no magic
-- second rule: we can derive things based on default implementation
class Pretty a where
  ppr :: a -> String
  default ppr :: (Show a) => a -> String
  ppr = show

data T = MkT1 Int | MkT2 Bool deriving (Show)

instance Pretty T

-- --------------------------------------------------------------------------
-- use derive via.
-- --------------------------------------------------------------------------

-- first, define a wrapper newtype
-- we can parameterized this X.
newtype X a = X a

instance Show a => Pretty (X a) where
  ppr (X x) = "Pretty" ++ show x

-- we use the shape of ShowPretty to define the instance Pretty for T
--
-- essentially we are saying:
--  how Pretty instance works for G is the same as how ShowPretty G instance works .
data G = MkT3 Int | MkT4 Bool
  deriving (Show)
  deriving (Pretty) via X G

newtype L = MkT5 Double
  deriving (Show)
  deriving (Pretty) via X L

{-@ First just let's see how is derive via is really used @-}

{-@ Equality constraint and Coercible constraint

    before talk about Dirive via,

    - type context: current enviroment (includes typeclass etc.)
      a set S with all other types we can access. It's Γ.

    - what's equality constraint ?
      ∀ t1, t2 ∈ S, t1 ~ t2

    - what's coerce? (coercible constraint)
      t1 ~ t2 => t1 coerciable to t2 in a type safe way.
@-}

-- side:
--
-- Multi parameter type class + functional dependencies VS type family + equality constraint
-- for expression a determine an unique b:
class C' a b | a -> b
class (F a ~ b) => C a b where
  type F a

{-@ Coerce
    The coerce function in Data.Coerce has nothing to do with
    C++ style coercion, it only does safe coerce.

    coerce :: Coerciable a b => a -> b.

    Thus to be able to coerce a to b, there must exist a instance
    Coercible instance between a and b.
 @-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE StandaloneDeriving #-}


-- paper on haskell inliner 20 years ago..
-- https://www.microsoft.com/en-us/research/wp-content/uploads/2002/07/inline.pdf
module GHCs.InlineAndSpecialization where

-- INLINEABLE pragma:
--    1. causes the function be included into the
--       interface file
--    2. the function will be specialized at call sites.
--       even cross modules.

bar :: Int -> Int -> Int
bar a b = a + b
{-# INLINEABLE bar #-} -- this will appear in interface file.

-- INLINE
--    1. like INLINABLE, functions are  included in the
--       interface file.
--    2. GHC will be very keen to inline these functions
--    3. bloat compile time. compile each inlined call site
--       once.
--    4. inlining a function that doesn't trigger any optimization
--       further will have no benefits. Rather than saving a function
--       call.
--    5. If a function is inlined, and within the context it can trigger
--       more compiler optimization than being stand alone, it's the best.
--    6. use INLINE to force RULES to fire.
bar' :: Int -> Int -> Int
bar' a b = a + b
{-# INLINE bar' #-} -- this will appear in interface file and very likely to be
-- inlined

bar'' :: Int -> Int
bar'' a = a + 1 -- this will automatically inlined. And it will be an optmized unfolding.

-- Unfolding
--    unfolding of a function f is what f is replaced by after it is inlined.
--    usually the definiton of f. But it can also be a rewrite rule.
--
--    when will unfolding be added to interface files?
--    1. a function is small and GHC see it fits.
--    2. INLINE and INLINABLE
--    3. -fexpose-all-unfoldings

-- Optmized and unoptimized unfolding
--    GHC will include some small unfolding in interface files.
--    those unfolding (definitions) are optimized first to avoid repeatedly optmize
--    the same code.
--
--    NOTE: unfolding included by INLINABLE and INLINE is unoptimized so they
--    works better with RULES. That's why inlined function compiles so slow.
--    You are forced to recompile again.

-- How does Typeclass constraints get implemented?
-- Given this haskell function.
-- foo :: Show a => a -> a -> Bool
-- foo x y = show x == show y
--
-- GHC generates the core as:
-- foo = \ @a $dShow x y -> eqString (show $Show x) (show $Show y)
-- where @a is a type, d$Show is a dictionary with Show method of type @a.
--
-- So at run time, the typeclass constraints will actually be a extra dictionary with
-- methods in it get passed as an argument.

data Show' a = Show' {show' :: a -> String}

data Foo
  = Foo
  | Bar

-- this will be passed at runtime
showa :: Show' Foo
showa =
  Show'
    { show' = \case
        Foo -> "<Foo>"
        Bar -> "<Bar>"
    }

-- at runtime if we see a is Foo it's specialized like this.
foo' :: Show' Foo -> Foo -> String -> String
foo' showa foo xs = (show' showa foo) ++ xs

-- in normal haskell
foo :: Show a => a -> String -> String
foo a xs = show a ++ xs

-- Specialization
-- again,
-- foo :: Show a => a -> a -> Bool
-- if we know what a is, we can specialize a ahead of time, which generates much better code.
-- much better in the sense that you no longer need to pass a dictionary at runtime, but rather
-- hard code the specialized type.

-- When does specialization occurs?
--    1. INLINABLE or INLINE
--    2. -fspecialise-aggressively.
--    Bascially for most of the time it doesn't occur.
--    But if you use inline all the time it occurs everywhere.
--    There is a trade off you need to balance.

-- for foo, if we can specialize type a to be Foo at compile time, the further optimization
-- can directly insert the body of Show' Foo into foo at compile time.

-- SPECIALIZE works like template full specialization. You replace the polymorphic parameter
--            with a concrete type, and let the further optimization pass to handle it.

deriving instance Show Foo

foo''' :: Show a => a -> String -> String
foo''' a xs = show a ++ xs
{-# SPECIALIZE foo''' :: Foo -> String -> String #-} -- here foo''' get specialized.

-- think about code transformation.

-- inlining can cause code bloat?
--   1. same function body every where, of couse code bloat.
--   2. but inlining can reduce code size if it trigger some optization.
module GHCs.Laziness where

-- haskell is not really lazy, it's non-strict.
--
-- Lazy: call by need, memoize everything.
-- Non-struct: call by name, don't need to memoize everything.
--
-- But this definition is a bit nit picky.

itsok = fst (1, undefined)
bomb = snd (1, undefined)   -- you can load this.

-- evalution order.
-- strict: inside out
-- non strict: outside in.

true :: a -> a -> a
true = \a -> (\b -> a)

false :: a -> a -> a
false= \a -> (\b -> b)

-- mightBoom true will force the evaluation inward of the definition.
-- >>> mightBoom true
-- 1
-- >>> mightBoom false
-- Prelude.undefined
mightBoom = \f -> f fst snd (1, undefined)

-- force strict evaluaton with seq

hypo :: IO ()
hypo = do
  let x :: Integer
      x = undefined     -- when it's lazily evalute this function is fine.
  s <- getLine
  case x `seq` s of     -- force to evaluate the bottom here.
    "hi" -> print x
    _    -> putStrLn "Hello"

-- this is ok. y is not forced, so seq is also not invoked.
wc x z = let y = undefined `seq` 'y' in x

-- create a chain that eventually trigger the undefined.
wc' x z = let y = undefined `seq` 'y' in let z = y `seq` 'z' in z

foo _ = 1

_ = foo undefined -- this is ok, _ pattern will not force evaluation.

{-@ use -ddump-simpl to see the "core dump" from GHC
   use -dsuppress-all to get cleaner output
   notice, seq will be compiled into a case expression. case
   are strict in core, so that make senses.
@-}

-- try it out
-- :set -dump-simpl

discriminatory1 :: Bool -> Int
discriminatory1 b =
  let x = undefined
   in case b of
        False -> 0
        True -> 1

discriminatory2 :: Bool -> Int
discriminatory2 b =
  let x = undefined
   in case x `seq` b of
        False -> 0
        True -> 1


-- 1. A thunk can have a bottom within.

-- call by name call by need
-- call by name is non-strict and call by need is full lazyness.
-- meaning you have full memoization for call by need.

{-@ try :sprint [1,2,3], this will print the fully evalutated list.
    this is because GHC will optimize the case when everything is just
    data constructor. data constructor is known as constant since they never
    change.

    Note: when data constructor is not applied it act as a function, but as it's
          applied it's treated as constant.

    So for :psrint [1,2,3], the whole thing is const, so evaluate to weak head normal
    form means evaluate the whole thing.
@-}

-- sharing
-- when the result of an evaluation is named, it can be safely shared by any other
-- uses without re-evaluation.

-- What promotes sharing?
--   same name

-- TODO
module GHCs.Profiling where

f :: IO ()
f = do
  print ([1..] !! 99999)
  putStrLn "f"

g :: IO ()
g = do
  print ([1..] !! 999999)
  putStrLn "g"

main :: IO ()
main = do
  f
  g
{-# LANGUAGE RankNTypes #-}
{-# OPTIONS_GHC -Wno-inline-rule-shadowing #-}
{-# OPTIONS_GHC -fenable-rewrite-rules #-}

module GHCs.Rules where

import Prelude hiding (foldl, foldr, map, sum)

{-@
    https://www.microsoft.com/en-us/research/wp-content/uploads/2001/09/rules.pdf
    https://wiki.haskell.org/GHC/Using_rules

    Rewrite rules, helps you to write specfic optimization.
    use --ddump-simpl-stats to see what rules fired.
    more details with --ddump-rule-firings.
    --ddump-rule-rewrites shows you what does the code look like
    before and after rewrite.
@-}
-- allow programmers to write domain specific optimizing rules.
-- e.g integerToInt (intToInteger x) = x
-- compiler doesn't knows the correlation between this two functions,
-- but we can add a rule to force this relationship.

-- although we will never hand write code like this one, but it's possible that
-- after some inlining some code ended up in this form.
-- If it's the case, rewrite rule can further shrink the code.

intToInteger :: Int -> Integer
intToInteger n = fromIntegral n

integerToInt :: Integer -> Int
integerToInt n = fromIntegral n

{-# RULES "intToInteger/id1" forall x. integerToInt (intToInteger x) = x #-}

{-# RULES "integerToInt/id2" forall x. intToInteger (integerToInt x) = x #-}

-- say we define a map now
map f [] = []
map f (x : xs) = f x : map f xs

-- and the compiler see this:
-- map f (map g xs)

-- we know it's just map (f . g) xs
-- This form is more efficent, the first solution has 2N runtime.
-- but compiler doesn't know.
--
-- What we want to do is essentially ask the compiler whenever find this pattern,
-- transform the code into what we want.

{-# RULES
"map/map" forall f g xs.
  map f (map g xs) =
    map (f . g) xs
  #-}

-- express identities programmers know true, but compiler doesn't.

-- THIS IS BAD. Compilation doesn't terminate.
foo x y = x

{-# RULES "commute" forall x y. foo x y = foo y x #-}

-- rewrite rules are embeded in hi files, the client code doesn't need to be aware of
-- it at all, but GHC still able to perform the rewrite.

-- short cut deforestation --
-- or list fusion.
-- We want to cut intermediate lists from problem.

foldr :: (a -> b -> b) -> b -> [a] -> b
foldr k z [] = z
foldr k z (x : xs) = k x (foldr k z xs)

build :: (forall b. (a -> b -> b) -> b -> b) -> [a]
build g = g (:) []

{-# RULES
"foldr/build" forall k z (g :: forall b. (a -> b -> b) -> b -> b).
  foldr k z (build g) =
    g k z
  #-}

-- use the rewrite rule to eliminate intermediate list.

sum :: [Int] -> Int
sum xs = foldr (+) 0 xs

down :: Int -> [Int]
down v = build (\c n -> down' v c n)

-- scott encoding of a list
down' 0 cons nil = nil
down' v cons nil = cons v (down' (v - 1) cons nil)

-- how will these get expanded?
-- sum (down 5)
--
-- ==> inline sum
-- foldr (+) 0 (down 5)
--
-- ==> inline down
-- foldr (+) 0 (build (down' 5))
--
-- ==> apply rewrite rule
-- (down' 5) (+) 0
val = sum (down 5)

-- another example:

threePartitions :: Int -> [(Int, Int, Int)]
threePartitions m =
  [ (i, j, k) | i <- [0 .. (m `div` 3)], j <- [i .. (m -1 `div` 2)], let k = m - (i * j) ]

-- fun fact, GHC will compile the list comprehension into a build call.
-- so anything with nested list comprehension can be benefit from using rewrite rule.


-- Quirks --
-- Things about compiler optimization is never that simple... Once you add one rule you need
-- to think about it's interaction with whole bunch of other optimization passes.
--
-- A fire of Rewrite rules might depends on some inline is triggerred.
-- but if a piece of code is inlined too much, it might miss the pattern that is rewriteble.
-- You need to know INLINE and rewrite quite well to be able to put them to the most use.

-- Phrases --
-- this is how you control the application of rules.
-- you can force some rules to be triggerd at phase 0, 1, or 2.
-- it seems so unflexible...
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE RankNTypes       #-}
module Libs.Asyncs where

import qualified Conduit                     as C
import           Control.Applicative
import qualified Control.Concurrent          as CC
import qualified Control.Concurrent.Async    as Async
import           Control.Exception
import           Control.Monad.Reader
import           Control.Monad.Trans.Control
import           Data.Foldable
import           Data.Void

import           Control.Concurrent.STM

import qualified Data.Text                   as T
import qualified Data.Text.IO                as T
import           System.IO

import qualified Data.ByteString.Char8       as S8
import           Data.Text                   (Text, pack)
import           Data.Text.Encoding          (encodeUtf8)


say :: Text -> IO ()
say = S8.putStrLn . encodeUtf8


{-@ simple @-}

lazyStringIsNotThreadSafe = Async.mapConcurrently_  worker [1..10]
  where
    worker n = replicateM_ 5 $ putStrLn $ "Hi I'm worker " ++ show n

textByDefaultAlsoNotThreadSafe = Async.mapConcurrently_ worker [1..10]
  where
    worker n = replicateM_ 5
             $ T.putStrLn
             $ T.pack
             $ "Hi I'm worker " ++ show n

setBufferingSolvesIt = do
  hSetBuffering stdout LineBuffering
  Async.mapConcurrently_ worker [1..10]
  hSetBuffering stdout NoBuffering
  where
    worker n = replicateM_ 5
             $ T.putStr
             $ T.pack
             $ "Hi I'm worker " ++ show n ++ "\n"

{-@ Async prelimiary @-}

-- run action1 and two asynchronously.
asyncTemplate :: (forall a b. Show a => Show b => IO a -> IO b -> IO ()) -> IO ()
asyncTemplate action = do
  action action1 action2
  where
    action1 :: IO Int
    action1 = do
      CC.threadDelay 80000
      return 5
    action2 :: IO String
    action2 = do
      CC.threadDelay 1000000
      return "action 2"

-- concurrently runs two IO actions concurrently.
-- concurrently ::  IO a -> IO b -> IO (a, b)
basicAsync = asyncTemplate
           $ \a1 a2 -> do
             res <- Async.concurrently a1 a2
             print res

-- return the one that finished first
-- race ::  IO a -> IO b -> IO (Either a b)
-- this will alwasy return Left 5
raceAsync = asyncTemplate
          $ \a1 a2 -> do
            res <- Async.race a1 a2
            print res


{-@ Concurrently newtype wrapper.
@-}

concurrentlyNewType :: IO ()
concurrentlyNewType = do
  res1 <- Async.runConcurrently $ (,)     -- applicative for concurrently
      <$> Async.Concurrently action1
      <*> Async.Concurrently action2
  print res1

  res2 <- Async.runConcurrently           -- alternative for race.
        $ (Left <$> Async.Concurrently action1)
      <|> (Right <$> Async.Concurrently action2)
  print res2
  where
    action1 :: IO Int
    action1 = do
      CC.threadDelay 80000
      return 5
    action2 :: IO String
    action2 = do
      CC.threadDelay 1000000
      return "action 2"


{-@ Concurrently write multiple into files
@-}
type Score = Int
data Person = P FilePath Score

ppls :: [Person]
ppls = [ P "alice.txt" 10 , P "bob.txt" 20 , P "cici.txt" 30 ]

writePerson :: Person -> IO ()
writePerson (P fp score) = writeFile fp (show score)

-- note we need to wrap IO () in Concurrently newtype to work on a collection.
writePeople :: [Person] -> IO ()
writePeople = Async.runConcurrently . traverse_ (Async.Concurrently . writePerson)

writeMany :: IO ()
writeMany = writePeople ppls

{-@ handle exception
    when a child thread throws an exception, it's thrown to the other thread.
@-}

handleException :: IO ()
handleException = do
  res <- Async.concurrently action1 action2
  print res
  where
    action1 :: IO Int
    action1 = throwIO (Async.AsyncCancelled)  -- throw exception

    action2 :: IO String
    action2 = handle onerr $ do
      CC.threadDelay 500000
      return "acton2 complete"
      where
        onerr e = do
          putStrLn $ "actoin2 was killed by: " ++ displayException e
          throwIO (e :: SomeException)

{-@ Companion infinite threads
    (detach async version)
@-}

counter :: IO a   -- this runs forever.
counter =
  let loop i = do
        putStrLn $ "counter: " ++ show i
        CC.threadDelay 1000000
        loop $! i + 1
   in loop 1


-- inner never return eailer than counter
-- nice!
withCounter :: IO a -> IO a
withCounter inner = do
  res <- Async.race counter inner
  return $ either (const $ absurd (error "never happen")) id res

runCompanion :: IO ()
runCompanion = do
  putStrLn "Before withCounter"
  CC.threadDelay 2000000
  withCounter $ do
    withDelay 2000000 (putStrLn "Inside withCounter")
  withDelay 2000000 (putStrLn "After withCounter")
  putStrLn "Bye!"
  where
    withDelay :: Int -> IO () -> IO ()
    withDelay t a = CC.threadDelay t >> a >> CC.threadDelay t

{-@ Use monad control to run companion thread with another read that's
    on some monad transformer stack.
@-}

-- embed a transformer into a monad.
withCounter' :: MonadBaseControl IO m => m a -> m a
withCounter' inner = control $ \runInIO -> do   -- cps based
  res <- Async.race counter (runInIO inner)
  return $ either (const (absurd (error "never happen"))) id res

runCompanionAnotherThreadNotInIO :: IO ()
runCompanionAnotherThreadNotInIO = do
  putStrLn "Before withCounter'"
  CC.threadDelay 2000000
  flip runReaderT "some string" $ withCounter' $ do
    liftIO $ CC.threadDelay 2000000
    str <- ask
    liftIO $ putStrLn $ "Inside with string: " ++ str
    liftIO $ CC.threadDelay 2000000
  CC.threadDelay 2000000
  putStrLn "After withCounter'"
  CC.threadDelay 2000000
  putStrLn "Exit"

runCompanionNoCounter :: IO ()
runCompanionNoCounter = do
  putStrLn "Before withCounter'"
  CC.threadDelay 2000000
  flip runReaderT "some string" $ do
    liftIO $ CC.threadDelay 2000000
    str <- ask
    liftIO $ putStrLn $ "Inside with string: " ++ str
    liftIO $ CC.threadDelay 2000000
  CC.threadDelay 2000000
  putStrLn "After withCounter'"
  CC.threadDelay 2000000
  putStrLn "Exit"


{-@ Async represents an action running in a different thread which if success will
    give an result of type a.
@-}

talker :: String -> IO ()
talker str = forever $ do
  say . pack $ str
  CC.threadDelay 500000

getResult :: IO Int
getResult = do
  say . pack $ "Doing some big computation..."
  CC.threadDelay 200000
  say . pack $ "Done!"
  return 42

getResult1 :: IO Int
getResult1 = do
  say . pack $ "Doing some big computation..."
  CC.threadDelay 200000
  say .pack $ "Done!"
  return 41

asyncRun :: IO ()
asyncRun = do
  async1 <- Async.async $ talker "async"    -- method 1, you need to kill the thread with cancel

  -- always try withAsync. it's also exception safe
  Async.withAsync (talker "withAsync") $ \async2 -> do -- method 2
    async3 <- Async.async getResult
    res <- Async.poll async3
    case res of
      Nothing        -> say . pack $ "getResult still running"
      Just (Left e)  -> say . pack $ "getResult failed: " ++ show e
      Just (Right x) -> say . pack $ "getResult finished: " ++ show x

    res <- Async.waitCatch async3
    case res of
      Left e  -> say . pack $ "getResult failed: " ++ show e
      Right x -> say . pack $ "getResult finished: " ++ show x
    res <- Async.wait async3
    say . pack $ "getResult finished: " ++ show res

  say . pack $ "With async should be dead"
  CC.threadDelay 200000

  say . pack $ "Now killing async talker"
  Async.cancel async1

  CC.threadDelay 200000
  say . pack $ "good byte"


{-@ Composing with STM
    use STM instead of IO.
@-}

stmRun :: IO ()
stmRun = Async.withAsync getResult $ \a -> do
  res <- atomically $ Async.pollSTM a
  case res of
    Nothing        -> say . pack $ "getResult still running"
    Just (Left e)  -> say . pack $ "getResult failed: " ++ show e
    Just (Right x) -> say . pack $ "getResult fnished: " ++ show x

  res <- atomically $ Async.waitCatchSTM a
  case res of
    Left e  -> say . pack $ "getResult failed: " ++ show e
    Right x -> say . pack $ "getResult finished: " ++ show x

  res <- atomically $ Async.waitSTM a
  say . pack $ "getResult finished: " ++ show res

stmRunCompose :: IO ()
stmRunCompose = do
  res <- Async.withAsync getResult $ \a1 ->
         Async.withAsync getResult1 $ \a2 ->
         Async.withAsync getResult $ \a3 ->
         Async.withAsync getResult1 $ \a4 ->
         atomically $ Async.waitSTM a1
                  <|> Async.waitSTM a2
                  <|> Async.waitSTM a3
                  <|> Async.waitSTM a4

  say . pack $ "getResult finished: " ++ show res

{-@ breaking async exceptions @-}
evil :: IO ()
evil = forever $ do
  eres <- try $ CC.threadDelay 100000
  say . pack $ show (eres :: Either SomeException ())

evilRun :: IO ()
evilRun = Async.withAsync evil $ const $ return ()


{-@ linking
    Deamon thread that if goes down, also bring down the main thread.
@-}

data Work = Work T.Text

-- keep reading from the chan.
jobQueue :: TChan Work -> IO a
jobQueue chan = forever $ do
  Work t <- atomically $ readTChan chan
  say t

runQueue :: IO ()
runQueue = do
  chan <- newTChanIO
  a <- Async.async $ jobQueue chan
  Async.link a  -- link the async task to the current thread.
  forever $ do
    atomically $ do
      writeTChan chan . Work . pack $ "Hello"
      writeTChan chan . Work . pack $ undefined
      writeTChan chan . Work . pack $ "World"
    CC.threadDelay 100001
module Libs.Concurrent where


import           Control.Concurrent
import           Control.Concurrent.Chan
import           Control.Concurrent.MVar
import           Control.Concurrent.STM
import           Control.Monad
import           Control.Monad.Trans.Class
import           Control.Monad.Trans.Except
import           Data.IORef
import           System.IO
import           Text.Printf

{-@ Preliminaries
@-}

-- The rts run threads for a "time slice" and then switch to the next one.
p1 = do
   hSetBuffering stdout NoBuffering
   forkIO (replicateM_ 10000 $ putChar '-')
   replicateM_ 10000 $ putChar 'B'


p2 = do
   hSetBuffering stdout LineBuffering
   forkIO (replicateM_ 10000 $ putChar '-')
   replicateM_ 10000 $ putChar 'B'

{-@ set remainder
@-}


loop :: Monad m => ExceptT e m a -> m e
loop = liftM (either id id) . runExceptT . forever

quit :: Monad m => e -> ExceptT e m a
quit = throwE

reminder :: IO ()
reminder = loop $ do
  s <- lift getLine
  when (s == "q") $ quit ()
  lift . forkIO $ setReminder s

setReminder :: String -> IO ()
setReminder s = do
  let t = read s :: Int
  printf "Ok, I'll remind you in %d seconds\n" t
  threadDelay (10^6 * t)
  printf "%d seconds elasped\BEL\n" t



{- MVar t
    A mutable that is either empty or contains a value of t. MVar is the
    most primitive notion in haskell concurrency model.

    takeMVar will empty MVar if there is value in it, otherwise it will block.
    putMVar will fill the MVar if it's empty, otherwise block.

    MVar's usage
      1. sychronized mutable variable
      2. as a channel.
      3. MVar () as a binary semaphore

    Note:
      Value in MVar is lazy, but there is also strict MVar.
      You can rely on the lexical order of MVar.
-}

-- use MVar as mutex
mutex = newEmptyMVar :: IO (MVar ())
acquire m = putMVar m
release m = takeMVar m

-- Skip channel
-- transmit source of high bandwidth information (like mouse movement)
-- Contains two MVars
-- first MVars has it's current value, and a list of semaphores to notify
-- second MVars is a semaphore for this particular reader. Full if there is a value
-- not read yet.
-- Writing to the channel never block. Reading block if there are no new values.

data SkipChan a = SkipChan (MVar (a, [MVar ()])) (MVar ())

-- create an empty skip channel.
newSkipChan :: IO (SkipChan a)
newSkipChan = do
  sem <- newEmptyMVar
  main <- newMVar (undefined, [sem])
  return $ SkipChan main sem

putSkipChan :: SkipChan a -> a -> IO ()
putSkipChan (SkipChan main _) v = do
  (_, sems) <- takeMVar main
  putMVar main (v, [])
  mapM_ (\sem -> putMVar sem ()) sems   -- release all.

-- note if get from a newly created skip chan,
-- it will hit the bottom.
getSkipChan :: SkipChan a -> IO a
getSkipChan (SkipChan main sem) = do
  takeMVar sem
  (v, sems) <- takeMVar main
  putMVar main (v, sem:sems)
  return v

-- multiple readers
dupSkipChan :: SkipChan a -> IO (SkipChan a)
dupSkipChan (SkipChan main _) = do
  sem <- newEmptyMVar
  (v, sems) <- takeMVar main
  putMVar main (v, sem:sems)
  return $ SkipChan main sem


{-@ Threads
    Haskell has both lightweight thread and OS thread.
    Lightweight thread system schedule logical threads on available
    Operating system threads.

    Lightweight threads are also called unbound thread, while
    a native operating system thread is called an bound thread, since
    it bounds to one os thread.

    Unbound threads are manged in a cooperative fashion by the rts's IO manager.
    When one unbound thread is blocked or locked it will call `yield` and yield
    to another runnable thread.

    A thread can wait with `threadDelay`


@-}

{-@ How are green threads implemented?
    Green threads needs a support from the run time. You need to shove in a system
    into the binary to manage green threads.

    Also green threads are cooperative multitasking, typically get implemneted as
    coroutine.

    This implies compiler needs to insert yeild point in functions to be able to hand
    over control back and forth.

    If a green thread is pinned to a OS thread, it's basically an OS thread.
@-}


{-@ IORef
    Simplest mutable reference.
    It's like unprotected shared memory in most other languages.
    You might want a `MVar ()` to provide mutual exclusion on a
    concurrent read/write on it.

    you also have `atomicWriteIORef` and `atomicModifyIORef` to
    perform atomic operatoins.
@-}

iorefDemo :: IO Integer   -- it's
iorefDemo = do
  account1 <- newIORef  1000
  account2 <- newIORef  2000
  transfer 400 account1 account2
  readIORef account1
  where -- thread safe transfer
    transfer :: Integer -> IORef Integer -> IORef Integer -> IO ()
    transfer n from to = do
      atomicModifyIORef from $ (flip (,) ()) . (+ (- n))
      atomicModifyIORef to $ (flip (,) ()) .(+ n)


{-@ TVar and STM
    A transactional mutable variable. A TVar is able to be read and written
    in the STM monad.

    The idea of STM is to treat memory as database and operation to access
    then as transactions.
    STM provides two key operations:
      1. atomically
      2. retry:      rerun when the runtime fails to commit a transaction.

    Besides being able to be used in STM, TVar also has the same semantics
    as MVar. You can use `putTMVar`, `takeTMVar`, and use it exactly like
    a MVar.

  STM:
    focus on atomicity, consistency, and isolation.
    There can be multiple potential "transactions" waiting to get
    executed concurrently.
    If two transactions doesn't use any shared TVars at the same time,
    they will commit their transaction and finish execution.
    If two transactions are both using a shared TVar and conflict occurs,
    this transaction fails and get discard, and need to be retried.

  Difference between TVar and MVar.
    1. TVar live in STM, which make sure their will be no deadlock.
       MVar is just a value assoicated with a lock, and can cause deadlock.
    2. TVar ais less performed than MVar
    3. In STM, a long runing transaction is possible to starve other short
       running transactions (it's a scheduling problem after all).
@-}

tvarDemo :: IO Integer
tvarDemo = do
  account1 <- atomically $ newTVar 1000
  account2 <- atomically $ newTVar 2000
  atomically $ transfer 500 account1 account2 >> readTVar account1
  where
    transfer :: Integer -> TVar Integer -> TVar Integer -> STM ()
    transfer n from to = do
      modifyTVar from (+ (-n))
      modifyTVar to (+ n)

{-@ Chan
    Unbounded queues implemented with MVars
@-}
chanDemo :: IO ()
chanDemo = do
  hSetBuffering stdout LineBuffering
  run
  where
    run = do
      chan <- newChan
      sequence [forkIO (consumer chan) | _ <- [0..3]]
      forkIO $ producer chan
      pure ()
    producer :: Chan Integer -> IO ()
    producer chan = forM_ [1..10000] $ \i -> do
      writeChan chan i
      putStrLn "write to channel"
    consumer :: Chan Integer -> IO ()
    consumer chan = forever $ do
      val <- readChan chan
      thread <- myThreadId
      putStrLn $ "Received: " ++ show val ++ ", tid: " ++ show thread
{-# LANGUAGE MultiWayIf #-}
{-# LANGUAGE RankNTypes #-}
module Libs.Conduits where

import           Control.Lens
import           System.Process

import           Conduit
import qualified Control.Concurrent       as CC
import qualified Control.Concurrent.Async as Async
import           Control.Monad
import           Control.Monad.Trans
import           Data.Char
import           Data.Conduit
import qualified Data.Conduit.Binary      as CB
import qualified Data.Conduit.List        as CL
import qualified Data.Conduit.Process     as CP
import           Data.Functor.Identity

import qualified Data.ByteString          as B

-- there are similar libraryies for handling effectful streams.
-- pipe and streaming are two famous ones.

{-@ Why using conduit if we already have lazyness?

    - Laziness doesn't allow you to perform IO inbetween each chunks.
    - Lazy IO is problematic.
      - Side effect in the middle of the pure code. (possibility of Exception in IO)
      - Nondeterministic resource handling

    Essentially laziness is not a feature that works well with side effect.
    But in some senarios that we need stream data, perform IO between chunks
    is very important. Conduit makes the work a bit easier.
@-}

{-@ Conduit
    Conduit provides stream like mechanism, so you can load infinite
    data without load all of them into the memory at once.

    Although haskell already has lazy list, but you can't directly
    perform IO on top of it.

    Or maybe you can use lazy IO, but that's proven causes too many
    suprises. The most well known example is hWithFile.

    Conduit solve both problems above.

    ConduitT i o m r
      where
        r is the result.
        i, o represent two end of the conduit
        m is for monad transformer.
@-}

{-@ simple example: @-}


-- Explain:
-- A conduit with no input data type. This implies it's the source of
-- the entire conduit.
-- The conduit has no result, so it's not the end of the conduit.
-- This conduit will yield Int to the next conduit connect to it.
-- You can perform IO operation in this conduit Monad.
source :: ConduitT () Int IO ()
source = CL.sourceList [1..100]

-- Notice it's a recursive function and doesn't halt.
-- However the entire conduit still halt eventually.
-- Because when does the conduit halt only depends on the source.
-- This conduit is merely a component perform some logic.
conduitFizzBuzz :: ConduitT Int String IO ()
conduitFizzBuzz = do
  val <- await
  case val of
    Nothing -> return ()
    Just n -> do
      if | n `mod` 15 == 0 -> yield "FizzBuzz"
         | n `mod` 5 == 0  -> yield "Fizz"
         | n `mod` 3 == 0  -> yield "Buzz"
         | otherwise       -> return ()
      conduitFizzBuzz

conduitAlertIfBuzz :: ConduitT String String IO ()
conduitAlertIfBuzz = do
  val <- await
  case val of
    Nothing -> return ()
    Just n -> do
      when (n == "Buzz") $ liftIO (putStrLn "== I found Buzz!! ==")  -- lift effect in the middle)
      yield n
      conduitAlertIfBuzz

conduitToUpper :: ConduitT String String IO () -- add a ne conduit
conduitToUpper = do
  val <- await
  case val of
    Nothing -> return ()
    Just n -> do
      yield $ toUpper <$> n
      conduitToUpper

conduitQuoteInTag :: ConduitT String String IO ()
conduitQuoteInTag = do
  val <- await
  case val of
    Nothing -> return ()
    Just n -> do
       yield $ "<" ++ n ++ ">"
       conduitQuoteInTag

sink :: ConduitT String o IO ()
sink = CL.mapM_ putStrLn

-- two end of the conduit are called source and sink.
-- the previous conduit is called upstream, next conduit is called
-- downstream.
run :: IO ()
run = runConduit $ source
    .| conduitFizzBuzz
    .| conduitAlertIfBuzz
    .| conduitToUpper
    .| conduitQuoteInTag
    .| sink


{-@ Conduit 2 @-}

source1 :: ConduitT () Int IO ()
source1 = CL.sourceList [1..100]

conduit1 :: ConduitT Int String IO ()
conduit1 = do
  val <- await
  case val of
    Nothing -> return ()
    Just n -> do
      liftIO (putStrLn (show n))
      yield (show n)
      conduit1

sink1 :: ConduitT String o IO ()
sink1 = CL.mapM_ putStrLn

run1 :: IO ()
run1 = runConduit $ source1 .| conduit1 .| sink1


{-@ Conduit @-}
run2 = yieldMany [1..10] .| sumC
     & runConduitPure
     & print
{-# LANGUAGE TemplateHaskell #-}
module Libs.LensPractice where

import           Control.Lens
import           Data.Char
import qualified Data.Map     as Map

t1 = ("hello", "world") ^. _2
t2 = set _2 42 ("hello", "world")
t3 = set (_2._1) 100 ("hello", ("world", "!!!"))
t4 = "hello" ^. to length   -- on liner lens

-- compose lenses
t5 =  ("hello", ("world", "!!!")) ^. _2._2.to length
t6 = view (_2._2.to length) ("hello", ("world", "!!!"))

-- .~ for set
t7 = _1 .~ "hello" $  ((), "world")
t8 = (_2._1) .~ 100 $ ("hello", ("world", "!!!"))
t9 = _2 .~ "hello" $ ("hello", "world")

t10 = Map.fromList [("hello", "there")] ^.at "hello"

-- this two are the same. & is for the reverse application.
t11 = Map.fromList [("hello", "there")] & at "hello" ?~ "world"
t12 = at "hello" ?~ "world" $ Map.fromList [("hello", "there")]

-- reverse application, works like |>. It's been there for the entire time just
-- nobody use it fro some reason.
t13 = [1..10]
    & fmap (+1)
    & foldr (+) 0


-- over works a bit like fmap
t14' = fmap succ [1, 2, 3]
t14 = mapped %~ succ $ [1, 2, 3]

t15' = fmap (\(a, b) -> (a, succ b)) [(1, 2), (1, 2), (2, 3)]
t15 = mapped._2 %~ succ $ [(1, 2), (1, 2), (2, 3)]

-- use template haskell to create dummy lenses.
data Bar a = Bar { _foo  :: [Int]
                 , _buzz :: Int
                 }
                 deriving Show
makeLenses ''Bar

data Foo a = Foo { _bar  :: Bar a
                 , _baz  :: Int
                 , _quux :: Int
                 }
                 deriving Show
makeLenses ''Foo

foo1 = Foo (Bar [12, 13, 14] 20) 10 10
t16 = foo1 ^. bar
t17 = foo1 ^. bar.buzz
t18 = foo1 ^. bar.foo.to length
t19 = foo1 ^. bar.foo.to sum
t20 = foo1 ^. bar.foo.to(length . map (+1))

t21 = foo1 & baz .~ 20

-- complex modification get composed.
t22 = foo1
    & bar.foo.traversed.index 2 .~ 2
    & bar.foo.traversed.index 1 .~ 10
    & quux .~ 8
    & baz .~ 99
    & (^. (bar.foo))
    & traversed.index 1 .~ 88


t23 = [1, 2, 3] & mapped %~ succ

t24 = ["abc", "def", "ghi"] & ix 1 . ix 2 %~ toUpper

t25 = "abc" & mapped .~ 'x'

t26 = Map.empty & at 3 ?~ (Just 10)

t27 = Map.empty ^? at 3

t28 = (('a', 'b', "asd"), "xyz") ^. _1 . _3

t29 = ('a', 'b') ^. _1 . (to (:"c"))

{-# LANGUAGE DeriveGeneric     #-}
{-# LANGUAGE OverloadedStrings #-}
module Libs.Misc where

-- data structures from the container.
import           Control.Monad
import qualified Data.Array                  as A
import qualified Data.HashMap.Lazy           as HM
import qualified Data.Map                    as M
import qualified Data.Sequence               as SQ
import qualified Data.Set                    as S
import           Data.Vector                 ((//))
import qualified Data.Vector                 as V

import           Control.Monad.ST
import qualified Data.Vector.Unboxed         as UV

import qualified Data.Vector.Generic.Mutable as GM
import qualified Data.Vector.Mutable         as MV

import qualified Data.ByteString             as BS

import qualified Data.Text                   as T
import qualified Data.Text.Lazy              as TL

import qualified Data.Text.IO                as TIO
import qualified Data.Text.Lazy.IO           as TLIO

import qualified System.IO                   as SIO

import qualified Data.Text.Encoding          as TE

import qualified Codec.Compression.GZip      as GZip
import qualified Data.ByteString.Lazy        as BL

import qualified Data.ByteString.Char8       as B8
import qualified Data.ByteString.UTF8        as UTF8

import           Criterion.Main


import           Data.Typeable
import           GHC.Generics

{-@ Map is implemented as a biary tree.
    has struct key and lazy value.
    The size of the subtree is also encoded at each node
@-}

type Size = Int
data MyMap k a = MapBin {-# UNPACK #-} !Size !k a !(MyMap k a) !(MyMap k a)
               | MapTip

-- benchmarking lookup on list
-- time                 147.6 μs   (146.9 μs .. 148.5 μs)
--                      1.000 R²   (1.000 R² .. 1.000 R²)
-- mean                 147.8 μs   (147.4 μs .. 148.6 μs)
-- std dev              2.044 μs   (1.264 μs .. 3.381 μs)

-- benchmarking lookup on Map
-- time                 264.8 ns   (264.6 ns .. 265.2 ns)
--                      1.000 R²   (1.000 R² .. 1.000 R²)
-- mean                 265.1 ns   (264.9 ns .. 265.9 ns)
-- std dev              1.325 ns   (469.4 ps .. 2.488 ns)

mapBench :: IO ()
mapBench = defaultMain [ bench "lookup on list" $ whnf (lookup "doesntExist") pairList
                       , bench "lookup on Map" $ whnf (M.lookup "doesntExist") testMap
                       ]
  where

    genList :: Int -> [(String, Int)]
    genList n = go n []
      where
        go 0 xs  = ("0", 0) : xs
        go n' xs = go (n' - 1) ((show n', n') : xs)

    pairList :: [(String, Int)]
    pairList = genList 9001

    testMap :: M.Map String Int
    testMap = M.fromList pairList


-- Set

-- benchmarking member with Map
-- time                 246.4 ns   (245.7 ns .. 247.2 ns)
--                      1.000 R²   (1.000 R² .. 1.000 R²)
-- mean                 246.8 ns   (246.2 ns .. 248.9 ns)
-- std dev              3.678 ns   (1.396 ns .. 7.302 ns)
-- variance introduced by outliers: 16% (moderately inflated)

-- benchmarking member with Set
-- time                 244.4 ns   (242.8 ns .. 246.3 ns)
--                      1.000 R²   (0.999 R² .. 1.000 R²)
-- mean                 243.7 ns   (242.7 ns .. 247.7 ns)
-- std dev              5.620 ns   (1.948 ns .. 12.17 ns)
-- variance introduced by outliers: 32% (moderately inflated)


data MySet a
  = SetBin {-# UNPACK #-} !Size !a !(MySet a) !(MySet a)
  | SetTip


bumpIt (i, v) =  (i + 1, v + 1)

m :: M.Map Int Int
m = M.fromList $ take 10000 stream
  where stream = iterate bumpIt (0, 0)

s :: S.Set Int
s = S.fromList $ take 10000 stream
  where stream = iterate (+1) 0

memberMap :: Int -> Bool
memberMap i = M.member i m

memberSet :: Int -> Bool
memberSet i = S.member i s

setBench = defaultMain [ bench "member with Map" $ whnf memberMap 9999
                       , bench "member with Set" $ whnf memberSet 9999
                       ]


-- Sequence (finger tree.)
-- good for cons and append to both end, concatenation

newtype Seq a = Seq (FingerTree (Elem a))

newtype Elem a = Elem { getElem :: a }

data Digit a
  = One a
  | Two a a
  | Three a a a
  | Four a a a a
  deriving (Show, Generic)

data Node a = Node2 !Int a a | Node3 !Int a a a

data FingerTree a
  = Empty
  | Single a
  | Deep {-# UNPACK #-} !Int !(Digit a)  (FingerTree (Node a)) !(Digit a)

lists :: [[Int]]
lists = replicate 10 [1..100000]

seqs :: [SQ.Seq Int]
seqs = replicate 10 (SQ.fromList [1..100000])

-- benchmarking lists:
-- time                 9.481 ms   (9.414 ms .. 9.529 ms)
--                      0.999 R²   (0.999 R² .. 1.000 R²)
-- mean                 9.750 ms   (9.686 ms .. 9.866 ms)
-- std dev              234.9 μs   (155.4 μs .. 372.7 μs)

-- benchmarking seq:
-- time                 8.809 ms   (8.791 ms .. 8.824 ms)
--                      1.000 R²   (1.000 R² .. 1.000 R²)
-- mean                 8.818 ms   (8.809 ms .. 8.832 ms)
-- std dev              30.38 μs   (20.65 μs .. 51.14 μs)


seqBench1 = defaultMain [ bench "lists:" $ nf mconcat lists
                        , bench "seq: " $ nf mconcat seqs
                        ]


-- benchmarking lists:
-- time                 22.05 μs   (22.04 μs .. 22.07 μs)
--                      1.000 R²   (1.000 R² .. 1.000 R²)
-- mean                 22.06 μs   (22.05 μs .. 22.08 μs)
-- std dev              53.36 ns   (30.97 ns .. 91.95 ns)

-- benchmarking seq:
-- time                 100.2 ns   (100.1 ns .. 100.2 ns)
--                      1.000 R²   (1.000 R² .. 1.000 R²)
-- mean                 100.2 ns   (100.2 ns .. 100.3 ns)
-- std dev              180.7 ps   (150.0 ps .. 210.6 ps)

-- accessing is much faster.
seqBench2 = defaultMain [ bench "lists:" $ whnf (\xs -> xs !! 9001)  [1..100000]
                        , bench "seq: " $ whnf (flip SQ.index 9001) (SQ.fromList [1..100000])
                        ]

-- note: sequence has worse memory locality.

data MyVec a = Vector {-# UNPACK #-} !Int
                      {-# UNPACK #-} !Int
                      {-# UNPACK #-} !(A.Array Int a)
                      deriving (Typeable)

-- vector supports efficient slicing.

listSlice :: Int -> Int -> [a] -> [a]
listSlice from len xs = take len (drop from xs)


-- benchmarking list slicing
-- time                 415.4 ns   (415.0 ns .. 415.8 ns)
--                      1.000 R²   (1.000 R² .. 1.000 R²)
-- mean                 415.0 ns   (414.4 ns .. 415.6 ns)
-- std dev              1.931 ns   (1.565 ns .. 2.362 ns)

-- benchmarking vector slicing
-- time                 57.98 ns   (57.90 ns .. 58.12 ns)
--                      1.000 R²   (1.000 R² .. 1.000 R²)
-- mean                 58.26 ns   (58.13 ns .. 58.40 ns)
-- std dev              430.1 ps   (343.9 ps .. 638.6 ps)

vecBench1 = defaultMain [ bench "list slicing" $ whnf (head . listSlice 100 900) [1..1000]
                        , bench "vector slicing" $ whnf (V.head . V.slice 100 900) (V.fromList [1..1000])
                        ]


-- updating persistent vectors with fusion


testV' :: Int -> V.Vector Int
testV' n = fmap (+n) . fmap (+n) . fmap (+n) . fmap (+n) $ V.fromList [1..100000]

testV :: Int -> V.Vector Int
testV n = fmap ((+n) . (+n) . (+n) . (+n)) $ V.fromList [1..100000]

vecBench2 = defaultMain [ bench "vector composed: " $ whnf testV' 9998
                        , bench "vector fused by lib: " $ whnf testV 9998
                        ]

-- bactch update of vector.

-- benchmarking slow
-- time                 41.16 ms   (34.98 ms .. 45.55 ms)
--                      0.906 R²   (0.741 R² .. 0.977 R²)
-- mean                 39.41 ms   (35.41 ms .. 45.53 ms)
-- std dev              10.15 ms   (6.738 ms .. 15.71 ms)
-- variance introduced by outliers 79% (severely inflated)

-- benchmarking batch update:
-- time                 6.480 ms   (6.441 ms .. 6.528 ms)
--                      0.999 R²   (0.998 R² .. 1.000 R²)
-- mean                 6.307 ms   (6.254 ms .. 6.357 ms)
-- std dev              150.8 μs   (121.9 μs .. 194.4 μs)

-- update one by one
slow :: Int -> V.Vector Int
slow n = go n (V.fromList [1..100000])
  where go 0 v = v
        go n v = go (n - 1) (v // [(n, 0)])

batch :: Int -> V.Vector Int
batch n = (V.fromList [1..100000]) // updates
  where updates = fmap (\n -> (n, 0)) [0..n]

vecBench3 = defaultMain [ bench "slow: " $ whnf testV' 9998
                        , bench "batch update: " $ whnf testV 9998
                        ]


-- vector mutable update
mutableUpdateIO :: Int -> IO (MV.MVector RealWorld Int)
mutableUpdateIO n = do
  mvec <- GM.new (n + 1)
  go n mvec
  where
    go 0 v = return v
    go n v = (MV.write v n 0) >> go (n - 1) v


mutableUpdateST :: Int -> V.Vector Int
mutableUpdateST n = runST $ do
  mvec <- GM.new (n + 1)
  go n mvec
  where
    go 0 v = V.freeze v
    go n v = (MV.write v n 0) >> go (n - 1) v

-- note the STRep
-- type STRep s a = GHC.Prim.State# s -> (# GHC.Prim.State# s, a #)

-- benchmarking mutable vecotor through IO:
-- time                 5.371 ms   (5.362 ms .. 5.381 ms)
--                      1.000 R²   (1.000 R² .. 1.000 R²)
-- mean                 5.371 ms   (5.364 ms .. 5.383 ms)
-- std dev              27.65 μs   (17.44 μs .. 46.86 μs)

-- benchmarking mutable vecotor through ST:
-- time                 5.432 ms   (5.424 ms .. 5.442 ms)
--                      1.000 R²   (1.000 R² .. 1.000 R²)
-- mean                 5.439 ms   (5.436 ms .. 5.443 ms)
-- std dev              11.01 μs   (8.061 μs .. 16.66 μs)

-- persistent batch update is about 9x slower then mutable update.

vecBench4 = defaultMain [ bench "mutable vecotor through IO:" $ whnfIO (mutableUpdateIO 9998)
                        , bench "mutable vecotor through ST:" $ whnf mutableUpdateST 9998
                        ]

{-@ Strings @-}

-- Text has compact representation in memory and supports efficient indexing.


-- lazy. only lod on read.
dwords :: IO String
dwords = SIO.readFile "/usr/share/dict/cracklib-small"

-- load all content upfront.
dwordsT :: IO T.Text
dwordsT = TIO.readFile "/usr/share/dict/cracklib-small"

dwordsTL :: IO TL.Text
dwordsTL = TLIO.readFile "/usr/share/dict/cracklib-small"


readFileAndPrint :: IO ()
readFileAndPrint = do
  replicateM_  10 (dwords >>= print)
  replicateM_  10 (dwordsT >>= TIO.putStrLn)
  replicateM_  10 (dwordsTL >>= TLIO.putStrLn)

-- bytestring

input :: BL.ByteString  -- lazy bytestring
input = "123123123"

compressed :: BL.ByteString   -- also lazy
compressed = GZip.compress input

compressInput :: IO ()
compressInput = do
  TIO.putStrLn $ TE.decodeUtf8 (BL.toStrict input)
  TIO.putStrLn $ TE.decodeUtf8 (BL.toStrict (GZip.decompress compressed))
  TIO.putStrLn $ TE.decodeUtf8 (BL.toStrict compressed) -- will faile


-- bytestring Char8 is not UTF8 encoded, they are really just C char type.

utf8s :: String
utf8s = "\12371\12435\12395\12385\12399\12289\20803\27671\12391\12377\12363\65311"

utf8ThenPrint :: BS.ByteString -> IO ()
utf8ThenPrint =
  putStrLn . T.unpack . TE.decodeUtf8

-- you can't pack string to bytestring like this.
-- bytestring: char[], contains ByteString.Char8
--  Char8 is not made for Unicode, don't bother to use it with
--  things other than ascii.
-- text: contains Char which is for each utf8 codepoint.
throwsException :: IO ()
throwsException = utf8ThenPrint (B8.pack utf8s)   -- pack is only for ascii data.

-- this works only because we are using ascii.
worksButWrongWithB8 :: IO ()
worksButWrongWithB8 = utf8ThenPrint (B8.pack "blah")

bytesByWayoFText :: BS.ByteString
bytesByWayoFText = TE.encodeUtf8 (T.pack utf8s)

libDoesTheWork :: BS.ByteString
libDoesTheWork = UTF8.fromString utf8s

thisWorks :: IO ()
thisWorks = utf8ThenPrint bytesByWayoFText

alsoWorks :: IO ()
alsoWorks = utf8ThenPrint libDoesTheWork
{-# LANGUAGE FlexibleContexts      #-}
{-# LANGUAGE FlexibleInstances     #-}
{-# LANGUAGE MagicHash             #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE RankNTypes            #-}

module Libs.MyArray where

{-@ My array implemnetation
    the array package is implemented based on GHC.IOArray and GHC.Arr,
    which in turn are implemented based on Arrays implemented on GHC.Exts.
    Because a mutable array is fundamentally mutable, you need some ghc support
    to work with it.
 @-}


import           Control.Monad.ST.Lazy
import qualified Control.Monad.ST.Lazy as Lazy (ST)
import           Data.Ix               (Ix, index, range, rangeSize)
import           Foreign.C.Types
import           Foreign.Storable
import           GHC.Base              (IO (..), divInt#, Array#)
import           GHC.ST                (ST (..), runST)


data MyArray i e = MyArray !i !i {-# UNPACK #-} !Int (Array# e)
module Libs.Ptrs where

import           Control.Exception     (SomeException, try)
import           Control.Monad         (forM_)
import           Data.Char             (chr)
import           Data.Word             (Word8)
import           Foreign.ForeignPtr    (ForeignPtr, newForeignPtr,
                                        newForeignPtr_, withForeignPtr)
import           Foreign.Marshal.Alloc (free, malloc)
import           Foreign.Ptr           (FunPtr, Ptr, plusPtr)
import           Foreign.Storable      (alignment, peek, poke, sizeOf)
import           System.IO.MMap        (Mode (..), mmapFileForeignPtr)

{-@ Ptr a
--  - Represent a pointer to an obj or an array of obj
--  - Type a usually can be marshalled from and to haskell object.
--  - a usually will have an instance for Storable
--  - Storable provides marshalling operations.
--  - Note Storable is not necessary, you can
--    write your own implementation for marshalling.
@-}

{-@ ForeignPtr a
--  - similar to Ptr
--  - reference to object that is not managed by haskell rts
--  - associated with a finalizer
--  - finalizer is invoked when the ForeignPtr is gc'ed
--  - usually finalizer calls a routine in foreign lang to free rescource.
@-}

-- Note with Ptr alone you can only play with the address, but can't do
-- anything with values.
-- Storable is necessary because you need that to manipulate data in haskell
-- world.

-- FunPtr a
--  - A ptr to a function callable from foreign code.
--    e.g pfree :: FunPtr (Ptr a -> IO ())

foreign import ccall "stdlib.h &free"
  pfree :: FunPtr (Ptr a -> IO ())

-- this can be an example of finalizer from other language.
--
-- Example of using pfree as finalizer for a foreign ptr
-- This function takes a heap allocated integer, read it's
-- value, add 10 to it and store it back.
-- Finally when the function is finished free the mem of the integer.

readStuff :: Ptr Word8 -> IO ()
readStuff p = do
  val <- peek p               -- Storable peek.
  let align = alignment val
  let sz = sizeOf val
  putStrLn $ "alignment for int: " <> show align
  putStrLn $ "size of int: " <> show sz
  -- there are also peekEleOff, peekByteOff etc for c ptr arrays.
  poke p $ 10 + val           -- Storable poke.


-- allocate stuffs

allocateStuff :: IO ()
allocateStuff = do
  p <- malloc :: IO (Ptr Word8)
  value <- peek p
  putStrLn $ "newly malloced word8, the value is " ++ show value
  poke p $ value + 128

  newval <- peek p
  putStrLn $ "new value is of malloced word8 is " ++ show newval
  free p


doStuff :: ForeignPtr Word8 -> Int -> IO ()
doStuff fp i =
  withForeignPtr fp $ \p -> do
    let addr = p `plusPtr` i
    val <- peek addr :: IO Word8
    print (addr, val, chr $ fromIntegral val)
    readStuff p
    return ()


run :: IO ()
run = do
  (p, offset, size) <- mmapFileForeignPtr path mode range
  forM_ [0 .. size - 1] $ \i -> do
    doStuff p (offset + i)
  mapM_(\_ -> do allocateStuff) [0..10]
  where
    path = "/tmp/input.dat"
    mode = ReadWrite
    range = Nothing
module Libs.Read where


{-# LANGUAGE FlexibleInstances    #-}
{-# LANGUAGE UndecidableInstances #-}
module Libs.ReadFile where



import           Control.Exception
import           System.IO

-- Lazy IO give you suprise, in terms of (Not having RAII behavior although
-- you are using a RAII idiom)
--
-- Lazyness is a property for purity, not for side
-- effects.

doLoop = do
  putStrLn "Enter a command rFn wFN or q to quit"
  command <- getLine
  case command of
    'q':_ -> return ()
    'r':filename -> do putStrLn ("Reading " ++ filename)
                       doRead filename
                       doLoop
    'w':filename -> do putStrLn ("Writing " ++ filename)
                       doWrite filename
                       doLoop
    _ -> doLoop

doRead filename =
  bracket (openFile filename ReadMode) hClose
          (\h -> do contents <- hGetContents h
                    putStrLn "The first 100 characters: "
                    putStrLn (take 100 contents))

doWrite filename = do
  putStrLn "Enter text to go into the file:"
  contentes <- getLine
  bracket (openFile filename WriteMode) hClose
          (\h -> hPutStrLn h contentes)
{-# LANGUAGE DeriveFunctor     #-}
{-# LANGUAGE MagicHash         #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes        #-}
module Libs.ReadP where

-------------------------------------------------------------------------------
-- inefficient ReadS implementation

import           Control.Applicative
import           Control.Monad       (ap)
import           Data.List.NonEmpty  as NonEmpty
import           GHC.Base            hiding (many)
import           GHC.Unicode         (isSpace)
import           Prelude             hiding (ReadP, ReadS)

infixr 5 +++, <++

type ReadS a = String -> [(a, String)]

-------------------------------------------------------------------------------
-- P is a datatype that encodes operations of a parser.
-- What can P do?
-- P can:
--  - consume char from the input stream
--  - lookup in the input stream
--  - return a result on success
--  - return fail on faliure
--  - return a final state of the parser and finish parsing.
-- We encode these notions into a data type.
-- It's easy to encode data. E.g To indicate the parser is failed we only need
-- an empty data constructor Fail; To indicate the parser is finished we need
-- Final constructor with the current state of everything.
--
-- But get and lookup are behaviors, how do we encode those into a datatype? The
-- only thing we can do is to embed functions into each data constructor.

-- Get :: (a -> P a)
data P a
  = Get (Char -> P a)
  | Look (String -> P a)
  | Fail
  | Result a (P a)
  | Final (NonEmpty (a, String))
  deriving Functor

instance MonadFail P where
  fail _ = Fail

instance Applicative P where
  pure x = Result x Fail
  (<*>) = ap

-- P is a monad
-- It's clear that you can have list as a monad, or maybe be a monad.
-- But what does it mean to have P to be a monad? It's a sum type with  5
-- branches...
--
-- Well, you can compose these data constructors with each other. The type just
-- indicates we are working with these 5 consturcors, it doesn't convey other
-- information. For each constructor, we can define it's special
-- bind implementation: how does it interact with other constructor.
--
-- k : a -> P a: is a polymorphic function over P, so it works on all possible
-- constructor of P. Our monad defines given a constructor of P, a monadic
-- function k, what to do next.
--
-- In this sense, k can be though as continuation, and The monad is an
-- interpreter defines a small language that is described in haskell algebraic
-- data type.
--
-- So essentially we defined a dsl for a parser, and use monad to conpose
-- elements in the dsl. The dsl is static.
instance Monad P where
  (Get f) >>= k           = Get $ \c -> f c >>= k
  (Look f) >>= k          = Look $ \s -> f s >>= k
  Fail >>= _              = Fail
  (Result x p) >>= k      = k x <|> (p >>= k)
  (Final (r :| rs)) >>= k = final [ys' | (x, s) <- (r:rs) , ys' <- run (k x) s]

-- Define what happens when we have two operations side by side.
-- another way to compose.
-- Alternative doesn't care what's inside the applicative. It just combines two
-- applicatives like monoid.
instance Alternative P where
  empty = Fail
  Get f1 <|> Get f2          = Get $ \c -> f1 c <|> f2 c  -- combine two Gets

  Result x p <|> q           = Result x (p <|> q)     -- results are delivered asap
  p <|> Result x q           = Result x (p <|> q)

  Fail <|> p                 = p
  p <|> Fail                 = p

  Final r <|> Final t        = Final (r <> t)
  Final (r :| rs) <|> Look f = Look $ \s -> Final (r :| (rs ++ run (f s) s))
  Final (r :| rs) <|> p = Look $ \s -> Final (r :| (rs ++ run p s))
  Look f <|> Final r = Look $ \s -> Final (case run (f s) s of
                                             []     -> r
                                             (x:xs) -> (x :| xs) <> r)

  Look f <|> Look g = Look $ \s -> f s <|> g s
  Look f <|> p = Look $ \s -> f s <|> p
  p <|> Look f = Look $ \s -> p <|> f s

-- Now our P is a Monad, Applicative, and Alternative. So how does it evaluates?
-- 1. the dsl program consists of sequence of monadic functions k :: (a -> P b).
-- Each time we get a new P a, we need it to k and get a P b, and so on.
-- (a -> P b) give us the opportunity ot work with element within the monad.
--
-- Note monadic function means it takes a values, do something, return a new
-- value with some effects. This is essentially what imperative langauges does,
-- in fact, monad is one of the best way to get denotional semantic of
-- imperative programs.
--
-- 2. when we have two P a, we can combine them to get a single P a. Different
-- from monoid, alternatives carries effect, so combine two P a means also
-- perform the effect .
--
-- e.g
--
-- let x = (P a)
--     >>= (\a -> ... (P b))
--     >>= (\b -> ... (P c))
-- let y = (P a')
--     >>= (\a -> ... (P b'))
--     >>= (\b -> ... (P c'))
-- let z = x <|> y
--
-- this is the basic flow of the interpreter.

-- only return final if the list is non empty
final :: [(a, String)] -> P a
final []     = Fail
final (r:rs) = Final (r :| rs)

-- run a (P a) parser.
run :: P a -> ReadS a
run (Get f) (c:cs) = run (f c) cs
run (Look f) s     = run (f s) s
run (Result x p) s = (x, s) : run p s     -- run result appends result
run (Final rs) _   = NonEmpty.toList rs   -- parser end
run _ _            = []

-- There are really two components for ReadP. We want to compose effectful
-- computation, so it's a monad. We want to combine two P, so it's alternative.
--
-- If we think typeclass as function from type to terms, we can appreciate the
-- abstraction better:
--    Type P is monad and applicative. -> It can compose with effectful
--    operations; two value of type P can be combinesd.
-- The implementation is something we worry later on.

-- Note there are not only one datatype that works like P. Many others also
-- works in a similar way:
--
--  1. a type T
--  2. T is a monad
--  3. T is an alternative
--
-- In the sense maybe works the same way as P, list works the same way as P,
-- State works the same way as P, etc...
--
-- They're different in the sense of their specific implementations, and that's
-- what gives a datatype concrete semantics.

-------------------------------------------------------------------------------
-- ReadP
-- If an action takes parameters, it's (a -> P b)
-- if it doesn't it's (\_ -> P b). Either way is captured. by the type.
--
-- Note here although (a -> P b) -> P b is a function, we can't just use
-- functions instance because it has different semantics.

newtype ReadP a = R (forall b. (a -> P b) -> P b)

instance Functor ReadP where
  fmap h (R f) = R $ \k -> f (k . h)

instance Applicative ReadP where
  pure x = R (\k -> k x)
  (<*>) = ap

instance Monad ReadP where
  R m >>= f = R $ \k -> m $ \a -> let R m' = f a in m' k

instance MonadFail ReadP where
  fail _ = R $ \_ -> Fail

instance Alternative ReadP where
  empty = pfail
  (<|>) = (+++)

-------------------------------------------------------------------------------
-- ReadP Operations

-- consume and return the next character Failes if there is no input left.
get :: ReadP Char
get = R Get

-- look ahead wihtout consuming
look :: ReadP String
look = R Look

pfail :: ReadP a
pfail = R (\_ -> Fail)

-- choice
(+++) :: ReadP a -> ReadP a -> ReadP a
R f1 +++ R f2 = R $ \k -> f1 k <|> f2 k

-- left baised choice. the right parser is discard. as long as left parser
-- produce any result
(<++) :: ReadP a -> ReadP a -> ReadP a
R f' <++ q = do
  s <- look
  probe (f' return) s 0#
  where
    probe (Get f) (c:cs) n   = probe (f c) cs (n +# 1#)
    probe (Look f) s n       = probe (f s) s n
    probe p@(Result _ _) _ n = discard n >> R (p >>=)
    probe (Final r) _ _      = R (Final r >>=)
    probe  _ _ _             = q    -- if all others failes

    discard 0# = return ()
    discard n  = get >> discard (n -# 1#)

-- take a parser, return a parser that does the samething but also character
-- read.
gather :: ReadP a -> ReadP (String, a)
gather (R m) = R $ \k -> gath id (m (\a -> return (\s -> k (s, a))))
  where
    gath :: (String -> String) -> P (String -> P b) -> P b
    gath l (Get f)      = Get $ \c -> gath (l.(c:)) (f c)
    gath _ Fail         = Fail
    gath l (Look f)     = Look $ \s -> gath l (f s)
    gath l (Result k p) = k (l mempty) <|> gath l p
    gath _ (Final _)    = errorWithoutStackTrace "no readS_to_P"


-------------------------------------------------------------------------------
-- combinators

satisfy :: (Char -> Bool) -> ReadP Char
satisfy p = get >>= (\c -> if p c then return c else pfail)

char :: Char -> ReadP Char
char c = satisfy (== c)

eof :: ReadP ()
eof = look >>= \s -> if null s then pfail else return ()

string :: String -> ReadP String
string this = do
  s <- look
  scan this s
  where
    scan [] _ = return this
    scan (x:xs) (y:ys) | x == y = get >> scan xs ys
    scan _ _ = pfail

-- parser the first zero ore more characters satisfying the predicate
munch :: (Char -> Bool) -> ReadP String
munch p = look >>= scan
  where
    scan (c:cs) | p c = get >> scan cs >>= \s -> return (c:cs)
    scan _ = return ""

munch1 :: (Char -> Bool) -> ReadP String
munch1 p = undefined

choice :: [ReadP a] -> ReadP a
choice = undefined

skipSpaces :: ReadP ()
skipSpaces = undefined

count :: Int -> ReadP a -> ReadP [a]
count = undefined

between :: ReadP open -> ReadP close -> ReadP a -> ReadP a
between = undefined

option :: a -> ReadP a -> ReadP a
option = undefined

optional :: ReadP a -> ReadP ()
optional = undefined

many :: ReadP a -> ReadP [a]
many = undefined

many1 :: ReadP a -> ReadP [a]
many1 = undefined

skipMany :: ReadP a -> ReadP ()
skipMany = undefined

skipMany1 :: ReadP a -> ReadP ()
skipMany1 = undefined

sepBy :: ReadP a -> ReadP sep -> ReadP [a]
sepBy = undefined

sepBy1 :: ReadP a -> ReadP sep -> ReadP [a]
sepBy1 = undefined

endBy :: ReadP a -> ReadP sep -> ReadP [a]
endBy = undefined

endBy1 :: ReadP a -> ReadP sep -> ReadP [a]
endBy1 = undefined

chainr :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a
chainr = undefined

chainl :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a
chainl = undefined

chainr1 :: ReadP a -> ReadP (a -> a -> a) -> ReadP a
chainr1 = undefined

chainl1 :: ReadP a -> ReadP (a -> a -> a) -> ReadP a
chainl1 = undefined

manyTill :: ReadP a -> ReadP end -> ReadP [a]
manyTill p end = undefined


-------------------------------------------------------------------------------
-- conversion

readPtoS :: ReadP a -> ReadS a
readPtoS (R f) = run (f return)

readStoP :: ReadS a -> ReadP a
readStoP r = R $ \k -> Look (\s -> final [bs'' | (a, s') <- r s, bs'' <- run (k a) s'])
{-# LANGUAGE ScopedTypeVariables #-}
module Libs.Refs where

{-@ There are several references type in haskell @-}

import Data.IORef
import Data.STRef
import Control.Monad.ST
import GHC.Arr
import Control.Monad


-- local state with ST.
-- this it's like the local version of unsafePerformIO.
sumST :: Num a => [a] -> a
sumST xs = runST $ do
  n <- newSTRef 0
  forM_ xs $ \x -> do
    modifySTRef n (+x)
  readSTRef n
{-# LANGUAGE CPP #-}
{-# LANGUAGE BangPatterns #-}

module Libs.Seq where

-- Data.Sequence is a general purpose finite sequences.  It's finite and has
-- strict operation.
module Libs.StgDumpExperiment where

data DataType = A Int | B Int Int | C String

module Libs.Stm where

-- https://www.fpcomplete.com/haskell/library/stm/

-- these are higher level concurrent abstraction, you don't particularly need
-- to write locks.
import           Control.Applicative
import           Control.Concurrent
import           Control.Concurrent.Async
import           Control.Concurrent.STM

import qualified Data.ByteString.Char8    as S8
import qualified Data.Text                as T
import qualified Data.Text.Encoding       as T
import qualified Data.Text.IO             as T

import           System.IO.Unsafe         (unsafePerformIO)

import           Control.Monad
import           Network.HTTP.Simple

import           Data.Foldable            (for_)

-- actions need to be performed atomically are group together.
-- each write to a varaible is tracked. After the block is done, the runtime will check if
-- any value is changed again. If there is any change, means a race condition,
-- thus we need to discard the current result and rerun.
-- Otherwise we can go ahead ahd commit the change into the memory.

-- STM keeps trakc of mutation on TVar.

say :: T.Text -> IO ()
say = S8.putStrLn . T.encodeUtf8

{-@ atomically works kind like performUnsafeIO or runST ...
    IO (IO Int) let us hold the reference to the same TVar in
    the IO value returned.
@-}
makeCounter :: IO (IO Int)
makeCounter = do
  var <- newTVarIO 9
  return . atomically $ do
    i <- readTVar var
    writeTVar var (i + 1)
    return i

run1 :: IO ()
run1 = do
  counter <- makeCounter
  replicateM_ 10 $ counter >>= print

{-@ failure, retry and alternative
@-}

check' :: Bool -> STM ()   -- if the state is invalid retry the transaction.
check' b = if b then return () else retry

runAliceBob :: IO ()
runAliceBob = do
  aliceVar <- newTVarIO 0     -- note this create a TVar in IO directly.
  bobVar <- newTVarIO 0
  charlieVar <- newTVarIO 0

  withAsync (pay aliceVar "alice" 100000 5) $ \_ ->
    withAsync (pay aliceVar "alice" 100000 5) $ \_ ->
      withAsync (pay bobVar "bob" 150000 8) $  \_ -> do
      atomically $ transfer 200 aliceVar charlieVar
               <|> transfer 200 bobVar charlieVar

      finalAlice <- atomically $ readTVar aliceVar
      finalBob <- atomically $ readTVar bobVar
      finalCharlie <- atomically $ readTVar charlieVar

      say . T.pack $ "Final Alice: " ++ (show finalAlice)
      say . T.pack $ "Final Bob: " ++ (show finalBob)
      say . T.pack $ "Final Charlie: " ++ (show finalCharlie)

pay :: TVar Int -> String -> Int -> Int -> IO ()
pay var name interval amount  = void . forever $ do
  threadDelay interval
  atomically $ do
    current <- readTVar var
    let updatedAmount = current + amount
    writeTVar var updatedAmount
  say . T.pack $ " paid: " ++ name

transfer :: Int -> TVar Int -> TVar Int -> STM ()
transfer amount from to = do
  currentFrom <- readTVar from
  check (currentFrom > amount)
  writeTVar from (currentFrom - amount)
  currentTo <- readTVar to
  writeTVar to (currentTo + amount)

{-@ EVIL
   why newTVarIO instead of atomically . newTVar?
   @-}

-- TVar can only be used under one atomically (their STM environment) because of their
-- implemnetation.

-- so this TVar cannot be used anywhere else since it outlive the STM environment that
-- creates it.
callCount :: TVar Int
callCount = unsafePerformIO . atomically $ newTVar 0

-- but this is ok because it's created outside of any STM.
callCount' :: TVar Int
callCount' = unsafePerformIO $ newTVarIO 0

someFunction :: TVar Int -> IO ()
someFunction c = do
  count <- atomically $ do
    modifyTVar c (+1)
    readTVar c
  putStrLn $ "this is really bad, beacuse we are using TVar from other STM"

runSomeFuncton :: IO ()
runSomeFuncton = do
  replicateM_ 10 $ someFunction callCount'  -- this works
  replicateM_ 10 $ someFunction callCount   -- this doesn't
{-# LANGUAGE QuasiQuotes     #-}
{-# LANGUAGE TemplateHaskell #-}
module Libs.TH.QQHtml where

import           Language.Haskell.TH
import           Language.Haskell.TH.Quote
import           Language.Haskell.TH.Syntax
import           Text.Parsec
import           Text.Parsec.String


data Node = Tag String [Node]
          | Text String
          deriving Show

-- first defien a normal parser
textNode :: Parser Node
textNode = Text <$> many1 (satisfy (/= '<'))

tagNode :: Parser Node
tagNode = do
  tagName <- char '<' *> many1 letter <* char '>'
  children <- many $ try tagNode <|> textNode
  string "</" *> string tagName *> char '>'
  return $ Tag tagName children

instance Lift Node where
  lift (Text t)            = [| Text t |]
  lift (Tag name children) = [| Tag name children |]

htmlExpr :: String -> Q Exp
htmlExpr str = do
  filename <- loc_filename <$> location
  case parse tagNode filename str of
    Left _    -> lift "error"
    Right tag -> [| tag |]

-- quasi quotes for patterns
htmlPat :: String -> Q Pat
htmlPat "<_>"   = [p| Tag _ children |]
htmlPat "<strong>"   = [p| Tag "strong" children |]
htmlPat "#text" = [p| Text text |]
htmlPat ('<':rest) = return $
  ConP (mkName "HTML.tag")
    [ LitP (StringL (init rest))
    , VarP (mkName "children")]

html :: QuasiQuoter
html = QuasiQuoter
  htmlExpr
  htmlPat
  undefined
  undefined
{-# LANGUAGE QuasiQuotes     #-}
{-# LANGUAGE TemplateHaskell #-}
module Libs.TH.QQHtmlRunner where

import           Libs.TH.QQHtml

{-@ Using the quasi quoters from QQHtml.
    process:
      1. html :: QuasiQuoter
      2. html run meta function htmlExpr :: String -> Q Exp
      3. the html get dumped into htmlExpr
      4. htmlExpr call tagNode, which is our parser.
      5. the parser parse the html string, and yields an html AST.
      6. the html ast then get lifted over and get a Q Exp
      7. the met function evaluate, the parsed html ast get shoved in call site.
@-}

-- use String -> Q Expr
doc :: Node
doc = [html|<html>Hello, <strong>Template haskell</strong>! </html>|]

-- use String -> Q Pat
markdown [html|<strong>|] = "**" ++ concatMap markdown children ++ "**"
markdown [html|<_>|]   = concatMap markdown children
markdown [html|#text|] = text

run = print . markdown $ doc
{-# LANGUAGE GADTs           #-}
{-# LANGUAGE LambdaCase      #-}
{-# LANGUAGE TemplateHaskell #-}

module Libs.TH.TemplateH where

import           Control.Monad
import           Language.Haskell.TH
import           Libs.TH.QQHtml


{-@ play with template haskell
    template function are also called meta functions.
    the code they generate is called object functions.

    In template haskell you can manipulate AST elements, constructing
    new AST with their constructors.

    For instance, you can create an identity function by writing
      do
        x <- newName "x"
        return $ LamE [VarP x] (VarE x)

    This at compile time becomes \x -> x
    ast elements ended with an E means it's a expression. P means a pattern,
    D means a declaration

    We have four main ast types
      Exp, Dec, Pat, Type

@-}
-- it basically works like macro in lisp. Different from
-- c++ templates, you build up AST in haskell templates.

-- a tempalt to generate curry functions. --

-- curryN is defined as a meta program, it will run at the compile time --

curryN :: Int -> Q Exp
curryN n = do
  f <- newName "f"
  xs <- replicateM n (newName "x")
  let args = map VarP (f:xs)
      ntup = TupE (map  (Just . VarE) xs)
  return $ LamE args (AppE (VarE f) ntup)

-- use abstract syntax directly
getCurries1 :: Int -> Q [Dec]
getCurries1 n = traverse mkCurryDec [1..n]
  where
    mkCurryDec ith = do
      curry <- curryN ith
      let name = mkName $ "curry" ++ show ith
      return $ FunD name [Clause [] (NormalB curry) []]

-- use syntax function
-- in this case you don't need to manually bind in Q monad.
getCurries2 :: Int -> Q [Dec]
getCurries2 n = traverse mkCurryDec [1..n]
  where
    mkCurryDec ith = funD name [clause [] (normalB (curryN ith)) []]
      where name = mkName $ "curry" ++ show ith

fstN :: Int -> Q Exp
fstN n = do
  x <- newName "x"
  return $ LamE [TupP $ VarP x : replicate (n - 1) WildP] (VarE x)

-- use syntax bracket
getId :: Q Exp
getId = [| id |]

-- a longer exaple
getTrueCase :: Q Exp
getTrueCase = [| \case
      True -> True
      _    -> error "not true"
  |]

getHOAS :: Q [Dec]
getHOAS =  [d|
  data ExprHOAS a where
    Con :: a -> ExprHOAS a
    Lam :: (ExprHOAS a -> ExprHOAS b) -> ExprHOAS (a -> b)
    App :: ExprHOAS (a -> b) -> ExprHOAS a -> ExprHOAS b

  i :: ExprHOAS (a -> a)
  i = Lam id

  k :: ExprHOAS (a -> b -> a)
  k = Lam (\x -> Lam . const)

  s :: ExprHOAS ((a -> b -> c) -> (a -> b) -> (a -> c))
  s = Lam (\x -> Lam (\y -> Lam (\z -> App (App x z) (App y z))))

  skk = App (App s k) k

  eval :: ExprHOAS a -> a
  eval (Con v)     = v
  eval (Lam f)     = \x -> eval . f . Con
  eval (App e1 e2) = eval e1 (eval e2)
  |]

{-# LANGUAGE StandaloneDeriving #-}
module Libs.TraversableFoldable where

import           Data.Foldable
import           Data.Monoid

import           Data.Ix

-- the namespace of traversable and foldable is
-- really messy in haskell, as important combinators
-- scatter around different modules.

xs = [1, 2, 3, 4, 5, 10]


-- fmap first
t1 = fmap (+1) xs

-- traverse
t2 = traverse putStrLn (fmap show xs)

-- fold
t4 = foldl' (-) 0 xs -- -21
-- foldl is strict by nature. you can perform op and get a value
-- immediately.
-- foldl means we folding to the left. In this  example we folding
-- towards the direction of the base case.
-- (((0 - 1) - 2) - 3 ...)

t3 = foldr (-) 0 xs  -- -3
-- foldr goes finite, it's lazy by nature.
-- foldr means folding to the right. In this case we fold to the
-- uneavluated expression.
-- Thunks will accumulate and eventually bloat the stack.
-- (1 - (2 - (3 - ... (6 - 0))))

{-@ Which fold to use?
    foldr: right foldr works on infinite lists as it's shown in the example above.
           foldr matches on the structure of the list, so it's can be efficient when
           working with list.

           In constrast left fold will never return, because it will try to apply op
           to all elements first then do the evalution.

    foldl': Strict version of left fold.

    foldl: just don't use it. It doesn't make sense to have a lazy left fold.
           what it does is it build up bunch of thunks when applying foward, and
           when it evaluates back those thunk, values will accumulate in the stack
           and you get stack overfloat.
@-}


-- scanl prefix sum
t5 = scanl (-) 0 xs
t6 = scanr (-) 0 xs

-- from Data.Foldable

{-@ fold and foldMap
    if a list is not a list of monoid already, you have two choices:
       1. fmap a function (f :: a -> m) on the list then fold it
       2. foldMap the list with (f :: a -> m)
    foldMap is just a shorthand to convert all elements into monoids and
    then fold.

    For folding elements without a base, being a monoid is important.

    In imperative code it's also sometime awkward that you can't have a empty
    value as the accumulator.
@-}

-- fold a list of monoid.
-- it's the same as mconcat.
t7 = getProduct $ fold (fmap Product xs)
t8 = getProduct $ mconcat (fmap Product xs)

-- foldMap just convert t a to t m and fold on it.
-- with foldMap it's even shorter.
t9 = getProduct $ foldMap Product xs

-- Foldable.toList convert a Foldable to a list
-- every Foldable is isomorphic to some list.
t10 = toList (Just 1)

-- Some short hands for foldables.
t11 = maximum xs
t12 = min xs
t13 = sum xs
t14 = product xs

-- foldl1 and foldr1 versions that doesn't need base but the length of the
-- list must greater than 1.
t15 = foldl1 (-) xs
t16 = foldr1 (-) xs


{-@ traverse is mapM
    traverse_ discard the content.

    for_ is flip traverse_.
@-}
-- traverse_ :: (a -> f b) -> t a -> f (t b)
-- map into a foldable and combine effects.
f17 = traverse_ putStrLn (fmap show xs)

-- worth mentioning mapM_ is the same as traverse_
-- bascially traverse is mapM, it's a map that performs some computation on
-- each element, and combine all effects together at the end.
f17' = mapM_ putStrLn (fmap show xs)

-- use for_ or traversable depends on which expresion is longer.
-- the function or the foldable.
f18 = for_ (fmap show xs) putStrLn
f18' = forM_ (fmap show xs) putStrLn

-- foldr that perform some actions on it's binop.
f19 = foldrM (\a b -> if a > b then Just (a + b) else Nothing ) 0 xs
f19' = foldrM (\a b -> if a /= b then Just (a + b) else Nothing ) 0 xs

-- common utility from foldable.
f21 = find (==1) xs
f22 = notElem 1 xs

-- and or / any all, very common
f23 = and (fmap (\x -> x `mod` 2 == 0) xs)
f24 = or (fmap (\x -> x `mod` 2 == 0) xs)
f25 = any (\a -> a `mod` 2 == 0) xs
f26 = all (\a -> a `mod` 2 == 0) xs

-- what is sequence?
-- Evaluating each element of the traversable and collecting the result.
-- Why it's it called sequencing?
-- It's the same as semi colon in imperative langauge. Ref to materials on the
-- operational semantics of SIMP (simple imperative programming langauge), the
-- operator ; is used as separator in a list of statement.
--
-- So in our case, sequence can be though as perform all sequencing operator ;
-- at once, or really just run the program.
f20 = sequence (fmap (putStrLn . show) xs)
f20' = sequenceA (fmap (putStrLn . show) xs)
f20''' = sequence_ (fmap (putStrLn . show) xs)
f20'''' = sequenceA_ (fmap (putStrLn . show) xs)


{-@ Some other functions in -base-.
@-}

-- a generator.
f27 = take 10 $ iterate (+1) 1

-- infinite generator
-- drop and take are dual.
f28 = drop 5 $ take 10 $ repeat 1

f29 = replicate 10 10

-- make infinite circular list.
-- useful for things like mod index.
f30 = cycle [1, 2, 3]

-- span separat the list from the frist element that the predicate
-- is false.
f31 = span (< 3) xs
f32 = splitAt 3 xs
f33 = zip xs xs
f34 = zip3 xs xs xs
f35 = zipWith (+) xs xs
f36 = unzip (zip xs xs)


{-@ Ix@-}

-- ok we do have range.
f37 = range (1, 10)
f38 = index (1, 10) 3
f39 = inRange (1, 10) (zipWith3 (\a b c -> a + b + c) xs xs xs !! 0)
f40 = rangeSize (0, length xs)

-- We can derive Ix from a Enum, which is pretty nice.
data Color = Red | Orange | Yellow | Green | Blue | Indigo | Violet deriving (Enum, Ord, Eq, Show)
deriving instance Ix Color

f41 = range (Red, Yellow)
module MiniProject.EchoServer where

-- mini echo server with low level interfaces
module MiniProject.Haskell99 where

import           Data.Foldable
import           Data.List
import           Data.Traversable

import           Control.Monad.ST
import           Data.IORef
import           Data.STRef
import           Debug.Trace
import           System.Random

import           Data.Ord

import           Data.Maybe

import           Data.Function

import           Control.Applicative
import           Control.Monad

import           System.IO.Unsafe    (unsafePerformIO)

import           Test.Hspec


{-@ Question 1 to 10 List
@-}

-- 1.   ----------------------------------------
-- ---------------------------------------------
-- (*) Find the last element of a list.
-- (Note that the Lisp transcription of this problem is incorrect.)

-- >>> last_ [1..10]
-- 10
last_ :: [a] -> a
last_ []     = error "oh"
last_ [a]    = a
last_ (x:xs) = last_ xs

-- >>> last_' [1..10]
-- 10
last_' :: [a] -> a
last_' = foldr1 (flip const)

-- >>> last_'' ['a'..'z']
-- 'z'
last_'' :: [a] -> a
last_'' = head . reverse

-- >>> last_'' ['a'..'z']
-- 'z'
last_''' :: [a] -> a
last_''' = foldr1 (curry snd)

-- 2.   ----------------------------------------
-- ---------------------------------------------
-- (*) Find the last but one element of a list.

-- >>> butLast_ [1..10]
-- 9
butLast_ :: [a] -> a
butLast_ []       = error "oh"
butLast_ [a]      = error "oh"
butLast_ (a:x:[]) = a
butLast_ (x:xs)   = butLast_ xs


-- >>> butLast_' [1..10]
-- 9
butLast_' :: [a] -> a
butLast_' = last . init


-- >>> butLast_'' [1..10]
-- 9
butLast_'' :: [a] -> a
butLast_'' = head . tail . reverse


-- 3.   ----------------------------------------
-- ---------------------------------------------
-- (*) Find the K'th element of a list. The first element in the list is number 1.

-- >>> elementAt_ [1..10] 2
-- 3
-- >>> elementAt_ [1..10] (-1)
-- index can't be smaller than 0
elementAt_ :: [a] -> Int -> a
elementAt_ [] _ = error "empty list"
elementAt_ (x:xs) n
  | n == 0 = x
  | n < 0 = error "index can't be smaller than 0"
  | otherwise = elementAt_ xs (n - 1)

-- >>> elementAt_' [1..10] 2
-- 3
elementAt_' :: [a] -> Int -> a
elementAt_' xs n = xs !! n


-- >>> elementAt_'' [1..10] 2
-- 2
elementAt_'' :: [a] -> Int -> a
elementAt_'' xs n
  | n < 0 = error "n should be larger than 0"
  | otherwise = snd . head . dropWhile (\(idx, _) -> idx < n) $ (zip [1..] xs)


-- 4.   ----------------------------------------
-- ---------------------------------------------
-- (*) Find the number of elements of a list.

-- >>> length_ [1..10]
-- 10
length_ :: [a] -> Int
length_ []     = 0
length_ (x:xs) = 1 + (length_ xs)

-- >>> length_' [1..10]
-- 10
length_' :: [a] -> Int
length_' = foldr (\_ b -> b + 1) 0

-- >>> length_'' [1..10]
-- 10
length_'' :: [a] -> Int
length_'' = sum . (fmap $ const 1)


-- 5.   ----------------------------------------
-- ---------------------------------------------
-- (*) Reverse a list.

-- >>> reverse_ [1..10]
-- [10,9,8,7,6,5,4,3,2,1]
reverse_ :: [a] -> [a]
reverse_ []     = []
reverse_ (x:xs) = (reverse_ xs) ++ [x]

-- >>> reverse_' [1..10]
-- [10,9,8,7,6,5,4,3,2,1]
reverse_' :: [a] -> [a]
reverse_' = foldr (\a b -> b ++ [a]) []

-- >>> reverse_'' [1..10]
-- [10,9,8,7,6,5,4,3,2,1]
reverse_'' :: [a] -> [a]
reverse_'' = foldl (\b a -> a:b) []

-- >>> reverse_''' [1..10]
-- [10,9,8,7,6,5,4,3,2,1]
reverse_''' :: [a] -> [a]
reverse_''' xs = runST $ do
  listRef <- sequence $ fmap newSTRef xs
  let len = length_ xs
      mid = (len `div` 2) - 1
  traverse_ (\i -> swap (listRef !! i) (listRef !! (len-1-) i)) [0..mid]
  traverse readSTRef listRef
  where
    swap :: STRef s a -> STRef s a -> ST s ()
    swap ref1 ref2 = do
      r1 <- readSTRef ref1
      r2 <- readSTRef ref2
      writeSTRef ref2 r1
      writeSTRef ref1 r2
      return ()


-- 6.   ----------------------------------------
-- ---------------------------------------------
-- (*) Find out whether a list is a palindrome. A palindrome can be read forward or backward;
--     e.g. (x a m a x).

-- >>> isPalindrome [1, 2, 3, 2, 1]
-- True
-- >>> isPalindrome [1, 2, 3, 2, 1, 2]
-- False
isPalindrome :: Eq a => [a] -> Bool
isPalindrome xs = xs == (reverse xs)

-- >>> isPalindrome' [1, 2, 3, 2, 1]
-- True
isPalindrome' :: Eq a => [a] -> Bool
isPalindrome' = liftA2 (==) id reverse


-- 7.   ----------------------------------------
-- ---------------------------------------------
--  (**) Flatten a nested list structure.
-- Transform a list, possibly holding lists as elements into
-- a `flat' list by replacing each list with its elements (recursively).

data NestedList a = E a | L [NestedList a]

-- >>> flattern (E 5)
-- [5]
--
-- >>> flattern (L [E 1, L [E 2, L [E 3, E 4], E 5]])
-- [1,2,3,4,5]
--
-- >>> flattern (L [])
-- []
flattern :: NestedList a -> [a]
flattern (L [])        = []
flattern (E x)         = [x]
flattern (L (E x: xs)) = x : (mconcat . fmap flattern $ xs)


-- concatMap map f to each elements and concat the result.
flattern' :: NestedList a -> [a]
flattern' (E x)  = [x]
flattern' (L xs) = concatMap flattern' xs

-- foldMap can be thought as the generalization of concatMap.
flattern'' :: NestedList a -> [a]
flattern'' (E x)  = [x]
flattern'' (L xs) = foldMap flattern'' xs

-- bind for list is just concatMap.
flattern''' :: NestedList a -> [a]
flattern''' (E x)  = return x
flattern''' (L xs) = xs >>= flattern'''



-- 8.   ----------------------------------------
-- ---------------------------------------------
-- (**) Eliminate consecutive duplicates of list elements.

-- >>> compress "aaaabccaadeeee"
-- "abcade"
--
compress :: Eq a => [a] -> [a]
compress = foldr op []
  where
    op a b
      | b == [] = a : b
      | otherwise = case b of
                      x:xs -> if x == a then x:xs else a:x:xs


-- >>> compress' "aaaabccaadeeee"
-- "abcade"

compress' :: Eq a => [a] -> [a]
compress' []          = []
compress' t@(x:xs) = let rest = (dropWhile (==x) t)
                      in x:compress' rest

-- >>> compress' "aaaabccaadeeee"
-- "abcade"
compress'' :: Eq a => [a] -> [a]
compress'' = map head . group



-- 9.   ----------------------------------------
-- ---------------------------------------------
-- (**) Pack consecutive duplicates of list elements into sublists.
-- If a list contains repeated elements they should be placed in separate sublists.

-- >>> pack ['a', 'a', 'a', 'a', 'b', 'c', 'c', 'a', 'a', 'd', 'e', 'e', 'e', 'e']
-- ["aaaa","b","cc","aa","d","eeee"]

pack :: Eq a => [a] -> [[a]]
pack = foldr op []
  where
    op a [] = [[a]]
    op a (b:bs)
      | a == head b = (a : b) : bs
      | otherwise = [a] : (b:bs)

-- span separate a list into two, the first half stop at the first element satisfies
-- predicate.
--
-- NOTE: A typical use case is to recursively separate a list until empty.
--
-- >>> pack' ['a', 'a', 'a', 'a', 'b', 'c', 'c', 'a', 'a', 'd', 'e', 'e', 'e', 'e']
-- ["aaaa","b","cc","aa","d","eeee"]
pack' :: Eq a => [a] -> [[a]]
pack' (x:xs) = let (first, rest) = span (==x) xs
                in (x:first) : pack rest
pack' [] = []


-- 10.  ----------------------------------------
-- ---------------------------------------------
-- (*) Run-length encoding of a list. Use the result of problem P09 to implement the
-- so-called run-length encoding data compression method. Consecutive duplicates of
-- elements are encoded as lists (N E) where N is the number of duplicates of the element E.

-- >>> encode "aaaabccaadeeee"
-- [(4,'a'),(1,'b'),(2,'c'),(2,'a'),(1,'d'),(4,'e')]
--
encode :: Eq a => [a] -> [(Int, a)]
encode = foldr op []
  where
    op a [] = [(1, a)]
    op a xs@((i, b):bs)
      | a == b = (i + 1, b) : bs
      | otherwise = (1, a) : xs


-- >>> encode' "aaaabccaadeeee"
-- [(4,'a'),(1,'b'),(2,'c'),(2,'a'),(1,'d'),(4,'e')]
encode' :: Eq a => [a] -> [(Int, a)]
encode' = fmap (\a -> (length a, head a)) . group

-- use applicative to partially apply
-- >>> encode'' "aaaabccaadeeee"
-- [(4,'a'),(1,'b'),(2,'c'),(2,'a'),(1,'d'),(4,'e')]
--
encode'' :: Eq a => [a] -> [(Int, a)]
encode'' = fmap ((,) <$> length <*> head) . group

{-@ Question 11 to 20 Lists, continued
@-}

-- 11.  ----------------------------------------
-- ---------------------------------------------
-- (*) Modified run-length encoding.


-- >>> encodeModified "aaaabccaadeeee"
-- [Multiple 4 'a',Single 'b',Multiple 2 'c',Multiple 2 'a',Single 'd',Multiple 4 'e']
--
data Dup a = Multiple Int a | Single a deriving (Show, Eq)

encodeModified :: Eq a => [a] -> [Dup a]
encodeModified = fmap f . group
  where
    f a
      | length a == 1 =  Single . head $ a
      | otherwise = Multiple (length a) (head a)

-- >>> encodeModified' "aaaabccaadeeee"
-- [Multiple 4 'a',Single 'b',Multiple 2 'c',Multiple 2 'a',Single 'd',Multiple 4 'e']
encodeModified' :: Eq a => [a] -> [Dup a]
encodeModified' = fmap f . encode
  where
    f (1, x) = Single x
    f (n, x) = Multiple n x


-- 12.  ----------------------------------------
-- ---------------------------------------------
-- (**) Decode a run-length encoded list.

-- >>> decodeModified [Multiple 4 'a',Single 'b',Multiple 2 'c', Multiple 2 'a',Single 'd',Multiple 4 'e']
-- "aaaabccaadeeee"
decodeModified [] = []
decodeModified (Single x:xs) = x:decodeModified xs
decodeModified ((Multiple 2 x):xs) = x : decodeModified ((Single x):xs)
decodeModified ((Multiple n x):xs) = x : decodeModified ((Multiple (n - 1) x):xs)

-- >>> decodeModified' [Multiple 4 'a',Single 'b',Multiple 2 'c', Multiple 2 'a',Single 'd',Multiple 4 'e']
-- "aaaabccaadeeee"
decodeModified' :: [Dup a] -> [a]
decodeModified' = concatMap f
  where
    f (Single x)     = [x]
    f (Multiple n x) = replicate n x


-- 13.  ----------------------------------------
-- ---------------------------------------------
-- (**) Run-length encoding of a list (direct solution).

-- >>> encodeDirect "aaaabccaadeeee"
-- [Multiple 4 'a',Single 'b',Multiple 2 'c',Multiple 2 'a',Single 'd',Multiple 4 'e']
--
encodeDirect :: Eq a => [a] -> [Dup a]
encodeDirect = foldr op []
  where
    op a []                = [Single a]
    op a xs@((Single b):bs)
      | a == b = (Multiple 2 a) : bs
      | otherwise = (Single a):xs
    op a xs@((Multiple n b):bs)
      | a == b = (Multiple (n + 1) a) : bs
      | otherwise = (Single a):xs


-- 14.  ----------------------------------------
-- ---------------------------------------------
-- (*) Duplicate the elements of a list.

-- >>> dupli [1, 2, 3]
-- [1,1,2,2,3,3]
dupli :: [a] -> [a]
dupli []     = []
dupli (x:xs) = x:x:dupli xs

-- >>> dupli' [1, 2, 3]
-- [1,1,2,2,3,3]
dupli' :: [a] -> [a]
dupli' = foldr (\a b -> a:a:b) []

-- >>> dupli'' [1, 2, 3]
-- [1,1,2,2,3,3]
dupli'' :: [a] -> [a]
dupli'' = foldMap (\a -> [a, a])

-- NOTE: monad for list is foldMap / concatMap
-- >>> dupli''' [1, 2, 3]
-- [1,1,2,2,3,3]
dupli''' :: [a] -> [a]
dupli''' xs = xs >>= \x -> [x, x]

-- NOTE: apply applicative over functions is a very common technique
--       Note <*> for function:
--        f <*> g => \x -> (f x) (g x)
--        ap f g x = ap (f x) (g x)
--        both function f, g waiting for the same input x.
--        the result of (g x) is used as paramter of (f x)
--
--          ((.) <$> (:) <*> (:))
--       => ((.) . (:) <*> (:))
--       => (\x -> (.) (x:)) <*> (:)
--       => \y -> (\x -> (.) (x:)) y (y:)
--       => \y -> ((.) (y:)) (y:)
--       => \y -> (y:) (y:)
--       => \y -> \z -> (y:) ((y:) z)
--       => y z y:y:z
--
-- >>> dupli'''' [1, 2, 3]
dupli'''' :: [a] -> [a]
dupli'''' = foldr ((.) <$> (:) <*> (:)) []


-- 15.  ----------------------------------------
-- ---------------------------------------------
-- (**) Replicate the elements of a list a given number of times.

-- >>> repli "abc" 3
-- "aaaabbbbcccc"
repli :: [a] -> Int -> [a]
repli [] _ = []
repli xs n = foldMap (go n) xs
  where
    go 0 x = [x]
    go n x = x : go (n - 1) x

-- feels like cheating
-- >>> repli' "abc" 3
-- "aaabbbccc"
--
repli' :: [a] -> Int -> [a]
repli' xs n = foldMap (replicate n) xs

-- >>> repli'' "abc" 3
-- "aaabbbccc"
repli'' :: [a] -> Int -> [a]
repli'' xs n = xs >>= replicate n

-- fold is really powerful..?!
-- >>> repli''' "abc" 3
-- "aaabbbbcccc"
repli''' :: [a] -> Int -> [a]
repli''' [] _     = []
repli''' (x:xs) n = foldr (const (x:)) (repli xs n) [1..n]


-- 16.  ----------------------------------------
-- (**) Drop every N'th element from a list.

-- >>> dropEvery ['a'..'z'] 3
-- "abdeghjkmnpqstvwyz"
dropEvery :: [a] -> Int -> [a]
dropEvery [] _ = []
dropEvery xs n = take (n - 1) xs ++ dropEvery (drop n xs) n


-- 17.  ----------------------------------------
-- (*) Split a list into two parts; the length of the first part is given.

-- >>> split [1..10] 3
-- ([1,2,3],[4,5,6,7,8,9,10])
--
split :: [a] -> Int -> ([a], [a])
split xs = go ([], xs)
  where
    go :: ([a], [a]) -> Int -> ([a], [a])
    go (acc, xs) 0   = (acc, xs)
    go (acc, x:xs) n = go (acc ++ [x], xs) (n - 1)

-- >>> split' [1..10] 3
-- ([1,2,3],[1,2,3,4,5,6,7,8,9,10])
split' :: [a] -> Int -> ([a], [a])
split' xs n = let xs' = (zip xs [1..])
                  lpred = (<=n) . snd
                  rpred = (>n) . snd
               in (,) <$> fmap fst . takeWhile lpred <*> fmap fst . dropWhile rpred $ xs'

-- >>> split'' [1..10] 3
-- ([1,2,3],[4,5,6,7,8,9,10])
split'' :: [a] -> Int -> ([a], [a])
split'' xs n = (take n xs, drop n xs)


-- 18.  ----------------------------------------
-- (**) Extract a slice from a list.

-- the question asking for slice from 1, a bit weird.

-- >>> slice ['a'..'z'] 3 7
-- "cdefg"
-- >>> slice ['a'..'z'] 0 7
-- invalid range
-- >>> slice ['a'..'z'] 1 7
-- "abcdefg"
-- >>> slice ['a'..'z'] 2 7
-- "bcdefg"
--
slice :: [a] -> Int -> Int -> [a]
slice [] _ _ = []
slice xs l r = take (r-l+1) . drop (l - 1) $ xs

-- >>> slice' ['a'..'z'] 3 7
-- "cdefg"
slice' :: [a] -> Int -> Int -> [a]
slice' xs l r
  | l < 1 || r < 1 || r < l  = error "invalid range"
  | r - l > length xs = error "range too large"
slice' xs l r = let (_, rest) =  splitAt (l - 1) xs
                    (initial, _) = splitAt (r - l + 1) rest
                 in initial

-- >>> slice'' ['a'..'z'] 3 7
-- "cdefg"
-- >>> slice'' ['a'..'z'] 0 7
-- invalid range
-- >>> slice'' ['a'..'z'] 1 7
-- "abcdefg"
-- >>> slice'' ['a'..'z'] 2 7
-- "bcdefg"
slice'' :: [a] -> Int -> Int -> [a]
slice'' xs l r
  | l < 1 || r < 1 || r < l  = error "invalid range"
  | r - l > length xs = error "range too large"
slice'' xs l r = fmap (fst)
               . filter ((\i -> i >= l && i <= r ) . snd)
               $ (zip xs [1..])


-- 19.  ----------------------------------------
-- (**) Rotate a list N places to the left.

-- >>> rotate ['a'..'g'] 3
-- "defgabc"
--
rotate :: [a] -> Int -> [a]
rotate xs n = slice xs (n + 1) (length xs) ++ slice xs 1 n

-- >>> rotate' ['a'..'g'] 3
-- "defgabc"
rotate' :: [a] -> Int -> [a]
rotate' xs n = let (ls, rs) = splitAt n xs
                in rs ++ ls

-- >>> rotate'' ['a'..'g'] 3
-- "defgabc"
rotate'' :: [a] -> Int -> [a]
rotate'' xs n = let (l, r) = go [] xs n
                 in l ++ reverse r
  where
    go acc xs 0     = (xs, acc)
    go acc (x:xs) n = go (x:acc) xs (n - 1)


-- 20.  ----------------------------------------
-- (*) Remove the K'th element from a list.


-- >>> removeAt [1..10] 3
-- [1,2,3,5,6,7,8,9,10]
--
removeAt :: [a] -> Int -> [a]
removeAt [] _     = []
removeAt (x:xs) 0 = xs
removeAt (x:xs) n = x : removeAt xs (n - 1)

-- >>> removeAt' [1..10] 3
-- [1,2,3,5,6,7,8,9,10]
--
removeAt' :: [a] -> Int -> [a]
removeAt' xs n = let (ls, rs) = splitAt n xs
                  in ls ++ tail rs

-- >>> removeAt'' [1..10] 3
-- [1,2,3,5,6,7,8,9,10]
--
removeAt'' :: [a] -> Int -> [a]
removeAt'' xs n = fmap fst . filter ((/=(n+1)) . snd) $ zip xs [1..]


{-@ Question 21 to 28 List again
@-}

-- 21.  ----------------------------------------
-- Insert an element at a given position into a list.

-- TODO one off.
-- >>> insertAt 'X' "abcd" 2
-- "aXbcd"
--
insertAt :: a -> [a] -> Int -> [a]
insertAt x xs n = let (ls, rs) = splitAt (n-1) xs
                   in ls ++ (x:rs)

-- 22.  ----------------------------------------
-- Create a list containing all integers within a given range.

-- avoid use length when work with infinite list.
-- >>> range 4 9
-- [4,5,6,7,8,9]
--
range :: Int -> Int -> [Int]
range l r = slice [1..] l r

-- >>> range' 4 9
-- [4,5,6,7,8,9]
range' :: Int -> Int -> [Int]
range' l r
  | l == r = [r]
  | l < r = l : range (l + 1) r
  | otherwise = error "invalid"

-- >>> range'' 4 9
-- [5,6,7,8,9]
range'' :: Int -> Int -> [Int]
range'' l r = take (r - l) . drop l $ [1..]


-- 23.  ----------------------------------------
-- Extract a given number of randomly selected elements from a list.

-- oh I guess the quesition is asking non replace selecting, well,
-- >>> unsafePerformIO $ rndSelect ['a'..'f'] 3
-- "bcc"
-- "ccb"
-- "dae"
--
rndSelect :: [a] -> Int -> IO [a]
rndSelect xs n
  | n < 0 = error "n can't be negative"
  | otherwise = do
    idxs <- sequence [randomRIO (0, length xs - 1) | _ <- [1..n]]
    return $ fmap (xs !!) idxs


-- >>> unsafePerformIO $ rndSelect' ['a'..'f'] 3
-- "aec"
-- "bcf"
-- "bbd"
--
rndSelect' :: [a] -> Int -> IO [a]
rndSelect' [] _ = return []
rndSelect' xs n
  | n < 0 = error "n can't be negative"
  | otherwise = do
    idxs <- replicateM n . getStdRandom $ randomR (0, length xs - 1)
    return [xs !! i | i <- idxs]


-- 24.  ----------------------------------------
-- Lotto: Draw N different random numbers from the set 1..M.

-- replicateM can be more useful than traverse sometimes.
-- it's like dotimes
-- >>> diffSelect 10 60
-- [6,51,29,22,26,45,30,15,26,46]
-- [53,53,57,51,2,42,9,29,17,47]
--
diffSelect :: Int -> Int -> IO [Int]
diffSelect n ub = replicateM n (randomRIO (1, ub))

-- >>> diffSelect' 10 60
-- [22,11,33,18,58,43,28,7,15,6]
-- [45,30,52,35,4,32,33,15,19,36]
--
diffSelect' :: Int -> Int -> IO [Int]
diffSelect' n ub = replicateM n . getStdRandom $ randomR (1, ub)

-- >>> diffSelect'' 10 60
-- [18,48,60,17,38,43,48,57,20,35]
-- [39,18,50,11,39,59,50,45,41,22]
--
diffSelect'' :: Int -> Int -> IO [Int]
diffSelect'' n ub = traverse (const . randomRIO $ (1, ub)) [1..n]

-- >>> diffSelect''' 10 60
diffSelect''' :: Int -> Int -> IO [Int]
diffSelect''' n ub = sequence (fmap (\a -> randomRIO (1, ub)) [1..n])



-- 25.  ----------------------------------------
-- Generate a random permutation of the elements of a list.

-- use pure combinators we made so far.
-- >>> rndPermu [1..10]
-- [3,7,5,8,9,1,10,2,4,6]
-- [1,3,2,5,7,4,8,9,6,10]
-- [6,1,3,4,8,5,9,2,7,10]
rndPermu :: [a] -> IO [a]
rndPermu xs = do
  idxs <- traverse (const . randomRIO $ (0, size)) [1..size]
  return $ go xs idxs
  where
    size = length xs
    shuffle' xs j = let x = head xs
                     in insertAt x (removeAt xs 0) j
    go xs []      = xs
    go xs (i:idx) = go (shuffle' xs i) idx


-- >>> rndPermu' [1..10]
-- [10,9,7,4,5,8,1,6,3,2]
-- [7,2,3,4,8,6,1,5,9,10]
-- [1,6,9,2,8,3,5,7,4,10]
rndPermu' :: [a] -> IO [a]
rndPermu' xs = do
  let n = length xs - 1
  xsRef <- traverse newIORef xs
  replicateM_ n $ do
    i <- randomRIO (0, n)
    j <- randomRIO (0, n)
    x <- readIORef (xsRef !! i)
    y <- readIORef (xsRef !! j)
    writeIORef (xsRef !! j) x
    writeIORef (xsRef !! i) y
  traverse readIORef xsRef



-- 26.  ----------------------------------------
-- (**) Generate the combinations of K distinct objects chosen from the N elements of a list
-- 1 2 3 4 5
-- 1 2 3 / 1 2 4 / 1 2 5 / 1 3 4 / 1 3 5 / 1 4 5
-- 2 3 4 / 2 3 5 / 2 4 5
-- 3 4 5


-- >>> combinations 3 [1..5]
-- [[1,2,3],[1,2,4],[1,2,5],[1,3,4],[1,3,5],[1,4,5],[2,3,4],[2,3,5],[2,4,5],[3,4,5]]
--
combinations :: Int -> [a] -> [[a]]
combinations 1 xs = fmap (:[]) xs
combinations n t@(x:xs)
  | length t < n = []
  | otherwise = fmap (x:) (combinations (n - 1) xs) ++ (combinations n xs)


-- >>> combinations' 3 [1..5]
-- [[1,2,3],[1,2,4],[1,3,4],[2,3,4],[1,2,5],[1,3,5],[2,3,5],[1,4,5],[2,4,5],[3,4,5]]
combinations' :: Int -> [a] -> [[a]]
combinations' n xs = filter ((n==) . length) (subsequences xs)


-- >>> combinations'' 3 [1..5]
-- [[1,2,3],[1,2,4],[1,2,5],[1,3,4],[1,3,5],[1,4,5],[2,3,4],[2,3,5],[2,4,5],[3,4,5]]
--
combinations'' :: Int -> [a] -> [[a]]
combinations'' _ [] = [[]]
combinations'' 0 _ = [[]]
combinations'' n (x:xs) = let begin = [x : rest | rest <- combinations'' (n - 1) xs]
                              rest = if n <= length xs then combinations'' n xs else []
                           in begin ++ rest


-- 27.  ----------------------------------------
-- Group the elements of a set into disjoint subsets.

-- >>> group' [2,3,4] ["aldo","beat","carla","david"]
-- [[["aldo","beat"],["aldo","carla"],["aldo","david"],["beat","carla"],["beat","david"],["carla","david"]],[["aldo","beat","carla"],["aldo","beat","david"],["aldo","carla","david"],["beat","carla","david"]],[["aldo","beat","carla","david"]]]
group' :: [Int] -> [a] -> [[[a]]]
group' ns xs =  fmap (flip combinations $ xs) ns


-- 28.  ----------------------------------------
-- Sorting a list of lists according to length of sublists

-- Naive approach. if you're really out of idea, at least one thing you can
-- do is to tag information as a tuple.
-- Doing so the code will become messier, but it's easier to come up a solution this
-- way. You can access more information.
-- >>> lsort ["abc","de","fgh","de","ijkl","mn","o"]
-- ["o","de","de","mn","abc","fgh","ijkl"]
lsort :: [[a]] -> [[a]]
lsort [] = []
lsort xs = fmap snd . sortBy (compare `on` fst)  $ (zip (fmap length xs)  xs)

-- >>> lsort' ["abc","de","fgh","de","ijkl","mn","o"]
-- ["o","de","de","mn","abc","fgh","ijkl"]
lsort' :: [[a]] -> [[a]]
lsort' = sortBy (comparing length)


-- >>> lsort'' ["abc","de","fgh","de","ijkl","mn","o"]
-- ["o","de","de","mn","abc","fgh","ijkl"]
--
lsort'' :: [[a]] -> [[a]]
lsort'' = sortBy (compare `on` length)


-- this is really hard to debug tbh...
-- again, keeping too much information makes the code more complicated than it
-- should be.
-- on takes (a -> a -> c) and a (a -> b), and convert the binop into (b -> b -> c)
--
-- >>> lfsort ["abc","de","fgh","de","ijkl","mn","o"]
-- ["o","ijkl","abc","fgh","de","de","mn"]
lfsort :: [[a]] -> [[a]]
lfsort = fmap snd
       . sortBy (compare `on` fst)
       . mconcat
       . fmap (\xs -> fmap (\ys -> (length xs,  snd ys)) xs)
       . groupBy ((==) `on` fst)
       . sortBy (compare `on` fst)
       . fmap ((,) <$> length <*> id)


-- >>> lfsort ["abc","de","fgh","de","ijkl","mn","o"]
lfsort' :: [[a]] -> [[a]]
lfsort' = mconcat . lsort' . groupBy ((==) `on` length) . lsort



{-@ Question 31 to 40 Arihtmeic
@-}
-- 31.  ----------------------------------------
-- (**) Determine whether a given integer number is prime.


-- Primality test is really based on cases.
-- You need to break it down and consider different possiblities separately.
-- >>> filter ((==) <$> snd <*> const True)(zip [1..20] (isPrime <$> [1..20]))
-- [(2,True),(3,True),(5,True),(7,True),(11,True),(13,True),(17,True),(19,True)]
isPrime :: Integer -> Bool
isPrime n
  | n <= 3 = n > 1
  | even n = False
  | otherwise = not . any (==0) . fmap (n `mod`) $ uniqueDivisors
  where
    uniqueDivisors  = [ i | i <-  [2..floor . sqrt . fromIntegral $  n] ]


-- 32.  ----------------------------------------
-- (**) Determine the greatest common divisor of two positive integer numbers. Use Euclid's algorithm.

-- >>> gcd' 36 63
-- 9
gcd' :: Integer -> Integer -> Integer
gcd' a 0 = a
gcd' a b = gcd b (a `mod` b)


-- 33.  ----------------------------------------
-- (*) Determine whether two positive integer numbers are coprime. Two numbers are coprime if their greatest common divisor equals 1.

-- >>> coprime 36 63
-- False

-- >>> coprime 36 61
-- True

coprime :: Integer -> Integer -> Bool
coprime a b = gcd a b == 1


-- 34.  ----------------------------------------
-- (**) Calculate Euler's totient function phi(m).

-- >>> totientPhi 10
-- 4
-- >>> totientPhi 10090
-- 4032
totientPhi :: Integer -> Integer
totientPhi 1 = 1
totientPhi n = fromIntegral . length . filter (coprime n)  $ [1..n]


-- 35.  ----------------------------------------
-- (**) Determine the prime factors of a given positive integer. Construct a flat list containing the prime factors in ascending order.


-- we test primes in [2, n/2]. If a prime is larger than half of n, the other possible
-- prime factor must be smaller n/2 which we already tested.
-- >>> primeFactors 315
-- [3,3,5,7]
--
-- >>> primeFactors 6
-- [2,3]
--
-- >>> primeFactors 2
-- []
--
-- >>> primeFactors 10090
-- [2,5,1009]
primeFactors :: Integer -> [Integer]
primeFactors n
  | isPrime n = []
  | otherwise = let primes = filter isPrime . reverse $ [2..n `div` 2]
                 in go n primes []
  where
    go 1 _ factors = factors
    go n (x:xs) factors
      | n `mod` x == 0 = go (n `div` x) (x:xs) (x:factors)
      | otherwise = go n xs factors


-- 36.  ----------------------------------------
-- (**) Determine the prime factors of a given positive integer.

-- >>> primeFactorsMult 315
-- [(3,2),(5,1),(7,1)]
--
-- >>> primeFactorsMult 10090
-- [(2,1),(5,1),(1009,1)]
primeFactorsMult :: Integer -> [(Integer, Int)]
primeFactorsMult = fmap ((,) <$> head <*> length) . group . primeFactors


-- 37.  ----------------------------------------
-- (**) Calculate Euler's totient function phi(m) (improved).

-- >>> phiImproved 10
-- 4
--
-- >>> phiImproved 16
-- 8
--
-- >>> phiImproved 10090
-- 4032
phiImproved :: Integer -> Integer
phiImproved 1 = 1
phiImproved n = foldr op 1 (primeFactorsMult n)
  where
    (p, m) `op` y = ((p - 1) * p ^ (m - 1)) * y


-- 38.  ----------------------------------------
-- (*) Compare the two methods of calculating Euler's totient function.

-- refl

-- 39.  ----------------------------------------
-- (*) A list of prime numbers.

-- >>> primeR [10, 20]
primeR :: Integer -> Integer -> [Integer]
primeR n m = filter isPrime [n..m]


-- 40.  ----------------------------------------
-- (**) Goldbach's conjecture.

-- >>> goldbach 28
-- (5,23)
-- >>> goldbach 6
-- You disproved goldbach!
goldbach :: Integer -> (Integer, Integer)
goldbach n
  | odd n || n == 2 = error "goldbach takes positive even numbers > 2 "
  | otherwise = let primes = filter isPrime $ [2..n]
                    (ls, rs) = if n < 8 then (primes, primes) else span (<= n `div` 2) primes
                    go [] _ = error "You disproved goldbach!"
                    go (x:xs) [] = go xs rs
                    go (x:xs) (y:ys)
                      | x + y == n = (x, y)
                      | otherwise = go (x:xs) ys
                 in go ls rs

-- essentially the first verioon manually wired cartesion product...
-- if you need cartesian product just use list comprehension.
goldbach' :: Integer -> (Integer, Integer)
goldbach' n = head [(x, y) | x <- primes, y <- primes, x + y == n]
  where
    primes = filter isPrime $ [2..n]


-- 41.  ----------------------------------------
-- (**) Given a range of integers by its lower and upper limit, print a list of all even numbers and their Goldbach composition.

-- >>> goldbachList 10 20
-- >>> goldbachList 10 40
goldbachList :: Integer -> Integer -> [(Integer, Integer)]
goldbachList l m = fmap goldbach . filter even $ [l..m]


{-@ Question 46 to 50 logic and codes
@-}

-- 46.  ----------------------------------------
-- Do you know conbinational logic (described by boolean) is the simplest form of
-- computational model? Output is a pure function of input.
--
-- The next more powerful model is finite automata
--
-- (**) Define predicates and/2, or/2, nand/2, nor/2, xor/2, impl/2 and equ/2
-- (for logical equivalence) which succeed or fail according to the result of their
-- respective operations; e.g. and(A,B) will succeed, if and only if both A and B succeed.

and' :: Bool -> Bool -> Bool
and' True True = True
and' _ _       = False

or':: Bool -> Bool -> Bool
or' False False = False
or' _ _         = True

xor':: Bool -> Bool -> Bool
xor' True False = True
xor' False True = True
xor' _ _        = False

nor':: Bool -> Bool -> Bool
nor' a b = not $ or' a b

nand':: Bool -> Bool -> Bool
nand' a b = not $ and' a b

not' :: Bool -> Bool
not' True  = False
not' False = True

implies':: Bool -> Bool -> Bool
implies' a b = (not' a) `or'` b

equ':: Bool -> Bool -> Bool
equ' True True   = True
equ' False False = True
equ' _ _         = False


-- truth table
-- >>> table (\a b -> (and' a (or' a b)))
--
table :: (Bool -> Bool -> Bool) -> IO ()
table f = sequence [ putStrLn (show i ++ " " ++ show j ++ " " ++ show (f i j))
                   | i <- bs, j <- bs ] >> return ()
  where
    bs = [True, False]


-- 47.  ----------------------------------------
-- (*) Truth tables for logical expressions (2).

table2 :: (Bool -> Bool) -> IO ()
table2 f = sequence [ putStrLn (show i ++ " " ++ show (f i)) | i <- bs] >> return ()
  where
    bs = [True, False]



-- 48.  ----------------------------------------
-- (**) Truth tables for logical expressions (3).

table3 :: ([a] -> Bool) -> IO ()
table3 f = undefined



-- 49.  ----------------------------------------
-- (**) Gray codes.

gray :: Int -> [String]
gray = undefined


-- 50.  ----------------------------------------
-- (***) Huffman codes.

huffman :: [(Char, Int)] -> [(Char, Int)]
huffman = undefined

{-@ Question 54A to 60 binary trees
@-}

data Tree a = Empty | Branch a (Tree a) (Tree a) deriving (Eq)

-- draw tree
instance Show a => Show (Tree a) where
  show = undefined


branch x l r = Branch x l r
leaf x = Branch x Empty Empty

-- 54A.  ---------------------------------------
-- Check whether a given term represents a binary tree

-- Not a problem in Haskell... So why list it in the question set though...?

-- 55.  ----------------------------------------
-- Construct completely balanced binary trees

-- for a complete tree, |left subtree| - |right subtree| <= 1.
--

cbalTree :: Int -> [Tree a]
cbalTree = undefined

-- 56.  ----------------------------------------
-- Symmetric binary trees

isSymmetric :: Tree a -> Bool
isSymmetric = undefined

-- 57.  ----------------------------------------
-- Binary search trees (dictionaries)

mkBinarySearchTree :: Ord a => [a] -> Tree a
mkBinarySearchTree = undefined


-- 58.  ----------------------------------------
-- Generate-and-test paradigm

symCbalTrees :: Int -> Tree a
symCbalTrees = undefined

-- 59.  ----------------------------------------
-- Construct height-balanced binary trees

hbalTree :: a -> Int -> Tree a
hbalTree = undefined

-- 60.  ----------------------------------------
-- Construct height-balanced binary trees with a given number of nodes

hbalTreeNodes :: a -> Int -> Int
hbalTreeNodes = undefined


{-@ Question 61 to 69 binary trees continued
@-}

-- 61.  ----------------------------------------
-- Count the leaves of a binary tree

countLeaves :: Tree a -> Int
countLeaves = undefined


-- 61A.  ---------------------------------------
-- Collect the leaves of a binary tree in a list

leaves :: Tree a -> [a]
leaves = undefined

-- 62.  ----------------------------------------
-- Collect the internal nodes of a binary tree in a list

internals :: Tree a -> [a]
internals = undefined


-- 62B. ----------------------------------------
-- Collect the nodes at a given level in a list

atLevel :: (Tree a) -> Int -> [a]
atLevel = undefined

-- 63.  ----------------------------------------
-- Construct a complete binary tree

completeBinaryTree :: Int -> Tree a
completeBinaryTree = undefined


-- 64.  ----------------------------------------
--  a layout algorithm for binary tree 1
tree64 = Branch 'n'
                (Branch 'k'
                        (Branch 'c'
                                (Branch 'a' Empty Empty)
                                (Branch 'h'
                                        (Branch 'g'
                                               (Branch 'e' Empty Empty)
                                                Empty)
                                        Empty))
                        (Branch 'm' Empty Empty))
                (Branch 'u'
                        (Branch 'p'
                                Empty
                                (Branch 's'
                                        (Branch 'q' Empty Empty)
                                        Empty))
                        Empty)

layout :: Tree a -> Tree a
layout  = undefined

-- 65.  ----------------------------------------
--  another layout algorithm for binary tree 1

tree65 = Branch 'n'
                (Branch 'k'
                        (Branch 'c'
                                (Branch 'a' Empty Empty)
                                (Branch 'e'
                                        (Branch 'd' Empty Empty)
                                       (Branch 'g' Empty Empty)))
                        (Branch 'm' Empty Empty))
                (Branch 'u'
                        (Branch 'p'
                                Empty
                                (Branch 'q' Empty Empty))
                        Empty)


layout1 :: Tree a -> Tree a
layout1  = undefined


-- 66.  ----------------------------------------
--  yet another layout algorithm for binary tree 1

layout2 :: Tree a -> Tree a
layout2  = undefined


-- 67A. ----------------------------------------
-- A string representation of binary trees

treeToString :: Tree a -> String
treeToString = undefined

stringToTree :: String -> Tree a
stringToTree = undefined


-- 68.  ----------------------------------------
-- Preorder and inorder sequences of binary trees.
-- We consider binary trees with nodes that are identified by single lower-case letters,
-- as in the example of problem P67.

preorder :: Tree a -> [a]
preorder = undefined

inorder :: Tree a -> [a]
inorder = undefined



-- 69.  ----------------------------------------
-- Dotstring representation of binary trees.



{-@ Question 70B to 73 multiway trees
@-}
data MTree a = Node a [MTree a] deriving (Eq, Show)


-- 70B. ----------------------------------------
-- (*) Check whether a given term represents a multiway tree.


-- 70C. ----------------------------------------
-- (**) Tree construction from a node string.


-- 71.  ----------------------------------------
-- (*) Determine the internal path length of a tree.


-- 72.  ----------------------------------------
-- (*) Construct the bottom-up order sequence of the tree nodes.


-- 73.  ----------------------------------------
-- (**) Lisp-like tree representation.


{-@ Question 80 to 89 graphs
@-}

-- 80.   ----------------------------------------
-- (***) Conversions


-- 81.   ----------------------------------------
-- (**) Path from one node to another one


-- 82.   ----------------------------------------
-- (*) Cycle from a given node


-- 83.   ----------------------------------------
-- (**) Construct all spanning trees


-- 84.   ----------------------------------------
-- (**) Construct the minimal spanning tree



-- 85.   ----------------------------------------
-- (**) Graph isomorphism


-- 86.   ----------------------------------------
-- (**) Node degree and graph coloration


-- 87.   ----------------------------------------
-- (**) Depth-first order graph traversal (alternative solution)


-- 88.   ----------------------------------------
-- (**) Connected components (alternative solution)


-- 89.   ----------------------------------------
-- (**) Bipartite graphs



{-@ Question 90 to 94 Miscellaneous problems
@-}
-- 90.   ----------------------------------------
-- (**) Eight queens problem


-- 91.   ----------------------------------------
-- (**) Knight's tour


-- 92.   ----------------------------------------
-- (***) Von Koch's conjecture

-- 93.   ----------------------------------------
-- (***) An arithmetic puzzle


-- 94.   ----------------------------------------
-- (***) Generate K-regular simple graphs with N nodes


{-@ Question 85 to 99 Miscellaneous continued
@-}


-- 95.   ----------------------------------------
-- (**) English number words


-- 96.   ----------------------------------------
-- (**) Syntax checker


-- 97.   ----------------------------------------
-- (**) Sudoku

-- 98.   ----------------------------------------
-- (***) Nonograms


-- 99.   ----------------------------------------
-- (***) Crossword puzzle

{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeSynonymInstances #-}
{-# LANGUAGE ViewPatterns #-}

module MiniProject.Lens2048 where

-- this is incomplete, still need to add logic to add cubes

-- dependencies:
--  1. linear, a library for doing linear algebra.
--  2. lens. the full lens library.

-- https://www.nmattia.com/posts/2016-08-19-lens-linear-2048.html

import Control.Lens
import Control.Monad
import Control.Monad.State
import Data.Default
import Data.Maybe
import Data.Monoid (Sum (..), getSum)
import Linear
import System.Console.ANSI
import qualified Text.PrettyPrint.Boxes as Boxes
import Text.Read hiding (get)

type Board = M44 (Maybe (Sum Integer))

type Game = StateT Board IO ()

-- need type synonym instance and flexible context for this.

instance Default Board where
  def = V4 n n n n
    where
      n = V4 Nothing Nothing Nothing Nothing

main :: IO ()
main = evalStateT loop def
  where
    loop :: Game
    loop = forever $ do
      liftIO clearScreen
      get >>= liftIO . Boxes.printBox . mkBox
      liftIO getLine >>= \case
        "h" -> rows %= merge
        "j" -> locs %= merge
        "k" -> cols %= merge
        "l" -> wors %= merge
        (parseCell -> Just (lx, ly, val)) -> lx . ly .= Just (Sum val)

    parseCell (words -> [x, y, v]) =
      (,,) <$> parseLens x
        <*> parseLens y
        <*> readMaybe v
    parseCell _ = Nothing

    parseLens "x" = Just _x
    parseLens "y" = Just _y
    parseLens "z" = Just _z
    parseLens "w" = Just _w

-- --------------------------------------------------------------------------
-- Draw
-- --------------------------------------------------------------------------

class Box a where
  mkBox :: a -> Boxes.Box

instance Box Board where
  mkBox v = Boxes.vsep 1 Boxes.center1 $ v ^.. traverse <&> mkBox

instance Box (V4 (Maybe (Sum Integer))) where
  mkBox v = Boxes.hsep 2 Boxes.center1 $ v ^.. traverse <&> Boxes.text . f
    where
      f = maybe "X" (show . getSum)

-- --------------------------------------------------------------------------
-- Game
-- --------------------------------------------------------------------------

instance Reversing (V4 a) where
  reversing v = V4 (v ^. _w) (v ^. _z) (v ^. _y) (v ^. _x)

merge :: (Eq a, Monoid a) => [a] -> [a]
merge (x : x' : xs) | x == x' = (x <> x') : merge xs
merge (x : xs) = x : merge xs
merge [] = []

-- imagine a 4x4 board, we want to access rows cols, reveresed rows, reversed
-- columns from these board.
-- It's a single source multiple foci situation. Traversal comes in handy
-- four traversales
rows, wors, cols, locs :: Traversal' (M44 (Maybe a)) [a]
rows = traverse . list
wors = traverse . reversed . list
cols = transposed . rows
locs = transposed . wors

transposed :: Iso' (M44 a) (M44 a)
transposed = iso transpose transpose

list :: Iso' (V4 (Maybe a)) [a]
list = iso toList fromList
  where
    toList v = reverse $ catMaybes $ foldl (flip (:)) [] v
    fromList (xs :: [a]) = V4 (xs ^? ix 0) (xs ^? ix 1) (xs ^? ix 2) (xs ^? ix 3)
{-# LANGUAGE NoMonomorphismRestriction #-}
{-# LANGUAGE RankNTypes                #-}
{-# LANGUAGE TemplateHaskell           #-}
module MiniProject.LensPong where


import           Control.Lens                         hiding (at, (:>))
import           Control.Monad                        (when)
import           Control.Monad.State                  (State, execState, get)

import           Data.Conduit                         (ConduitT)

import qualified Data.Conduit                         as C

import           Data.Set                             (Set, empty)

import           Graphics.Gloss                       hiding (display)
import           Graphics.Gloss.Data.Point.Arithmetic as Pt
import           Graphics.Gloss.Interface.Pure.Game

import           System.Random                        (newStdGen, randomRs)


gameSize = 300 :: Float
windowWidth = 800 :: Int
windowHeight = 600 :: Int

ballRadius = 0.02 :: Float
accelearattion = 1.2 :: Float
losingAccuracy = 0.9 :: Float
winningAccuracy = 0.1 :: Float
initialSpeed = 0.6 :: Float
paddleWidth = 0.02 :: Float
paddleHeight = 0.3 ::Float
paddleSpeed = 1 :: Float

textSize = 0.001 :: Float


data Pong =
  Pong { _ballPos   :: Point
       , _ballSpeed :: Vector
       , _paddle1   :: Float
       , _paddle2   :: Float
       , _score     :: (Int, Int)
       , _vectors   :: ConduitT () () Identity Vector
       , _keys      :: Set Key
       }

makeLenses ''Pong

s :: ConduitT () () Identity (Int, Int)
s = return (0, 0)

-- rename tuple length
_x = _1
_y = _2

initial :: Pong
initial = Pong (0, 0) (0, 0) 0 0 (0, 0) (return (0, 0)) empty
module MiniProject.PythagoreanNTuple where



-- three ways to categorize a number
-- A: even numbers which is only powers of 2.
-- B: odd numbers consists of powers of any primes.
-- C: even numbers with both power of m and other primes.
import Data.List
import Control.Applicative
import Data.Maybe
import Control.Monad

-- helper functions.
isPrime :: Integer -> Bool
isPrime n =
  (n > 1) && null [ x | x <- [2..floor.sqrt.fromIntegral $ n], n `mod` x == 0]

primeFactors :: Integer -> [Integer]
primeFactors n = factors n 2
  where factors 1 _ = []
        factors n f
          | n `mod` f == 0 = f : factors (n `div` f) f
          | otherwise = factors n (f + 1)

type M = Integer
type R = Integer
type P = Integer
type S = Integer
type K = Integer

data Case = A M
          | B P S K  -- T depend on cases.
          | C M P S K
          deriving (Eq, Show)

aDeltaConstraint a delta = a > delta
deltaFactorConstraint a delta = a^2 `mod` delta == 0

-- check which category a lands on and decompose into the corresponding form.
decompose :: Integer -> [Case]
decompose a
  | all (==2) factors = [A (toInteger $ length factors)] -- a = 2^m, ∆ = 2^r where r = 1
  | 2 `notElem` factors =                                -- a = p^s * k, ∆ = p^t
    let ps = getps factors                               -- where t = 0 or t = 2s
     in (\(p, s) -> B p s (a `div` p^s)) <$> ps
  | otherwise =                                          -- a = 2^m * p^s, ∆ = 2^r*p^t
    let oddFactors = filter odd factors
        evenFacors = filter even factors
        ps = getps oddFactors
        m = toInteger . length $ evenFacors
     in (\(p, s) -> C m p s (a `div` (p^s * 2 * m))) <$> ps
  where factors = primeFactors a
        getps fs = let l = group fs in
          zip (head <$> l) (fromIntegral . length <$> l)


check a = liftA2 (&&) (aDeltaConstraint a) (deltaFactorConstraint a)

-- calculate delta by given cases
getdelta :: Case -> [Maybe Integer]
getdelta (A _) = [Just 2]
getdelta (B p s k) =
  let d1 = p^(2*s)
      a = p ^ s * k
   in if check a d1
         then Just <$> [d1, 1]
      else  [Just 1]
getdelta (C m p s k) =
  let dmGTr1 = 2                        -- if m > r, r = 1, t = 0 or t = 2s
      dmGTr2 = 2 * (p ^ (2*s))
      dmLTr1 = 2 ^ (2*m-1)              -- if m < r, r = 2m - 1, t = 0 or t = 2s
      dmLTr2 = 2 ^ (2*m-1) * p ^ (2*s)
      a =  p ^ s * k * 2^m
   in Just <$> filter (check a) (nub [dmGTr1, dmGTr2, dmLTr1, dmLTr2])



getdeltas :: Integer -> [Maybe Integer]
getdeltas a = nub $ getdelta =<< decompose a


getTrple :: Integer -> Maybe [(Integer, Integer, Integer)]
getTrple a = if a <=2 then Nothing else triple

  where deltas = fromMaybe [] (sequenceA $ filter (/=Nothing) (getdeltas a))
        b de = (a^2 - de^2) `div` (2*de)
        bs = b <$> deltas
        cs = zipWith (+) bs deltas
        triple = Just $ zipWith ((,,) a) bs cs
{-# LANGUAGE DeriveFunctor              #-}
{-# LANGUAGE DerivingStrategies         #-}
{-# LANGUAGE FlexibleContexts           #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE GADTs                      #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE RankNTypes                 #-}
{-# LANGUAGE TypeFamilies               #-}

module MiniProject.TicTacToe where
import           Control.Monad       (join, when)
import           Control.Monad.State
import           Data.Foldable       (fold)
import           Data.List           (subsequences, (\\))
import           Data.Maybe
import           Debug.Trace         (trace)


-- print and return
traceThis :: (Show a) => String ->  a -> a
traceThis msg x = trace (msg ++ " " ++ show x) x

{-@ Let's write a tic tac toe @-}
--  -OOO-
--  -XXX-


-- | Tictactoe game
-- v: phamtom type for solution
-- a: return type

newtype TicTacToe' v a = TicTacToe (Three -> Three -> a) deriving Functor
type TicTacToe v = TicTacToe' v (Maybe Bool)
type Board = [(Three, Three, Maybe Bool)]

-- (Z3, +)
data Three  = Zero | One | Two deriving (Eq, Show, Enum)


-- board
instance Semigroup (TicTacToe v) where
  TicTacToe a <> TicTacToe b = TicTacToe $ \x y ->
    case b x y of
      Nothing -> a x y
      Just v  -> Just v
instance Monoid (TicTacToe v) where mempty = TicTacToe . const . const $ Nothing


-- utils
showXO n | n = "X" | otherwise = "O"

instance Show (TicTacToe v) where
  show (TicTacToe b) = concatMap draw positions where
      positions = zip [1..9] [(n, m) | n <- enumFrom Zero,  m <- enumFrom Zero]
      draw (idx, (x, y)) = let marker =  maybe "_" showXO (b x y)
                            in if idx `mod` 3 == 0 then marker <> "\n" else marker

combinations :: Int -> [a] -> [[a]]
combinations = (. subsequences) . filter . (. length) . (==)

fullBoard :: TicTacToe v -> Board
fullBoard (TicTacToe b) = [(n, m, b n m) | n <- enumFrom Zero,  m <- enumFrom Zero]

maskBoard :: Bool -> Three -> Three -> TicTacToe v
maskBoard v x y = TicTacToe go
  where
    go i j | x==i && y==j = Just v
      | otherwise =  Nothing

printBoard :: TicTacToe v -> IO ()
printBoard = putStr . show

data KebabState = Kebab | NoKebab | NoMoreKebab  deriving (Show, Eq)

instance Semigroup Three where a <> b =  let [a', b'] = fromEnum <$> [a, b]
                                          in toEnum $ (a' + b') `mod` 3
instance Monoid Three where mempty = Zero

-- Three solutions to overload
data Symmetric
data LinAlg
data TreePrunning

class HasKebab a where
  type KebabStrategy a :: *
  hasKebab :: Bool -> a -> KebabState
  whatStrategy :: a -> String

-- | This implementation uses the fact that forall a, b \in  (Z3, +)
-- By rotating and fliping "shape" of the multiplication table, we can form D8. But because elements
-- in the table are symmetic along -- two diagnoses too, it turns out D and D' are the same as I and R180,
-- so we only have 6 unique elements in the group, call it G, G = D8 - {D, D'}.  for all x \in G,
-- sum of each straight column, row, or diagnose is always 0, we can use this property to test for solution
-- But there are some unwanted cases also sum up to zero. For example, say we have this table:
--     0 1 2, 1 2 0, 2 0 1
-- Case1: 0 1 _ In this case, 0 1 => 0 + 1 + 2 = 0 (mod 3). We can get rid of cases like this by also
--        _ 2 _ compute the sum of the same location in R90. If all pieces are in a row | column | diagnose,
--        _ _ _ the sum will be 0 in both tables.

rotateTicTacToe :: TicTacToe v -> TicTacToe v
rotateTicTacToe (TicTacToe d) = TicTacToe $ \i j ->
  case (i, j) of { (Zero, Zero) -> d Zero Two; (Zero, Two) -> d Two Two
                 ; (Two, Two) -> d Two Zero; (Two, Zero) -> d Zero Zero
                 ; (One, Two) -> d Two One; (Two, One) ->  d One Zero
                 ; (One, Zero) -> d Zero One; (Zero, One) -> d One Two
                 ; (a, b) -> d a b }
-- Case2: 0 _ _  This case is hard because it's symmetric along the diagnose. No matter how you rotate or flip
--        _ _ 0  the table the sum will always be 0. The best way I find so far is just manually exclude these
--        _ 0 _  cases. (There are four cases in total)

sameSet :: Eq a => [a] -> [a] -> Bool
sameSet x y = null (x \\ y) && null (y \\ x)

-- 00 12 21, 02 10 21, 20 01 12, 22 01 10
excludeDiagonalSymmetric :: [[(Three, Three)]]-> [[(Three, Three)]]
excludeDiagonalSymmetric = filter needToExclude
  where
    needToExclude xs | length xs /= 3 = False
      | and (fmap (sameSet xs) excludeList) = False
      | otherwise = True
    excludeList = [[(Zero, Zero), (One, Two), (Two, One)]
                  ,[(Zero, Two), (One, Zero), (Two, One)]
                  ,[(Two, Zero), (Zero, One), (One, Two)]
                  ,[(Two, Two), (Zero, One), (One, Zero)]]

instance HasKebab (TicTacToe Symmetric) where
  type KebabStrategy (TicTacToe Symmetric) = Symmetric
  hasKebab marker b | hasKebab' = Kebab
    | length [v | (_, _, v) <- fullBoard b, isNothing v] == 1 = NoMoreKebab
    | otherwise = NoKebab
    where
        roll f = join
               $ (fmap . fmap) (\(a, b) -> a <> b )
               $ excludeDiagonalSymmetric . combinations 3
               $ [ (x, y) | (x, y, v) <- fullBoard (f b), v == Just marker ]
        hasKebab' = elem (Zero, Zero) (zip (roll id) (roll rotateTicTacToe))
  whatStrategy _ = "Symmetic"

instance HasKebab (TicTacToe LinAlg) where
  type KebabStrategy (TicTacToe LinAlg) = LinAlg
  hasKebab = undefined
  whatStrategy _ = "LinAlg"

instance HasKebab (TicTacToe TreePrunning) where
  type KebabStrategy (TicTacToe TreePrunning) = TreePrunning
  hasKebab = undefined
  whatStrategy _ = "TreePrunning"


-- symmetric + exclude cases.
--
checkKebab :: Bool -> TicTacToe Symmetric -> KebabState
checkKebab marker b | hasKebab' = Kebab
  | length [v | (_, _, v) <- fullBoard b, isNothing v] == 1 = NoMoreKebab
  | otherwise = NoKebab
  where markers = [ x <> y | (x, y, v) <- fullBoard b, v == Just marker ]
        hasKebab' = Zero `elem` fold (combinations 3 markers)

-- linear algebra

-- tree and pruning

data GameState :: * -> * where
  GameState :: forall v. HasKebab (TicTacToe v) => { gameHistory :: [TicTacToe v]
                                                   , turn :: Bool
                                                   } -> GameState v

type GM v a = StateT (GameState v) IO a
newtype Game v a = Game { unGame :: GM v a }
  deriving newtype (Functor, Applicative, Monad, MonadState (GameState v), MonadIO, MonadFail)

tictactoeLoop :: HasKebab (TicTacToe v) => Game v ()
tictactoeLoop = do
      t <- gets turn
      liftIO . putStr $ showXO t <> "> "
      input <- liftIO readInput
      case input of
        [x, y] -> do
            games <- gets gameHistory
            let game = head games
                newgame = maskBoard t x y <> game
            liftIO . printBoard $ newgame
            put $ GameState (newgame : games) (not t)
            liftIO . print $ hasKebab t newgame
            case hasKebab t newgame of
              NoKebab     -> tictactoeLoop
              Kebab       -> liftIO . putStrLn $ (showXO t <> " Get kebab!!")
              NoMoreKebab -> liftIO . putStrLn $ "No more Kebab TAT"
  where
    readInput = fmap (toEnum . read) . words <$> getLine :: IO [Three]

runTicTacToe :: IO (GameState Symmetric)
runTicTacToe = execStateT (unGame tictactoeLoop) (GameState [mempty] False)
module Models.Actors where

{-@ Mail box based model.
@-}
module Models.CPSForCoroutine where

{-@ Use continuation to implement coroutine.
@-}



{-@ Coroutine is:
    1. a generalization of subroutine.

    2. yield instead of return. resume to go back to last
       exit point.
    3. yield not return also means coroutine holds states.

    4. the interaction between two coroutines can be similar
       to mutual recursive, but it's more efficient as the call
       doesn't need to be at the tail position, coroutine holds
       states so no need to pass state as parameters etc.

    5. k

    6. Coroutine can be implemented with goto or continuation.
       We are in haskell so we takes the cps approach, but goto
       is essentially the same.
@-}


-- The history of coroutine actually way back to lat 1950s. The first
-- coroutine was done in assembly implemented with jmp. The idea was
-- simply to have a subroutine that can exit and re-enter with it's state
-- preserved.

{-@ Use coroutine as the fundation to implementes many things:

    1. Easy to read state machine...
    2. actor model
    3. coinductive types (generators, conduit)
    4. communicating sequential processes. (csp)
    5. exception.
    6. events.

@-}

{-@ Cooperative multitasking.

    1. First we have preemtive multitasking, where programs
       run on separate threads, and the scheduler descide which
       thread gain the control and for how long.

    2. In cooperative multitaksing there is no scheduler, each
       subprogram voluntarily gives up the control to some other
       subprogram.

    3. non preemptive multitasking means you don't need to worry about
       thread safty as you do with mutexes and threads.

@-}
module Models.CPSForEventDriven where

module Models.CSP where

module Models.CoroutineForEventDriven where


{-@ Use coroutine to implement event system. @-}
module Models.Coroutines where


{-# LANGUAGE OverloadedStrings #-}

module Models.NoclosableChannel where

-- the default putStrLn for string works on lazy list and print char by cahr,
-- Text.putStrLn by default uses nobuffering.
-- this is an attempt to implement thread safe print line function.
-- https://www.snoyman.com/blog/2016/11/haskells-missing-concurrency-basics/

import           Control.Concurrent
import           Control.Concurrent.Async
import           Control.Monad            (forever)
import qualified Data.ByteString.Char8    as S8
import           Data.Text                (Text, pack)
import           Data.Text.Encoding       (encodeUtf8)


say :: Text -> IO ()
say = S8.putStrLn . encodeUtf8

{-@ Naive implementation that blocks @-}

workerNaive :: Chan Int -> Int -> IO ()
workerNaive chan num = forever $ do
  i <- readChan chan
  say . pack . mconcat $
    [ "Worker #"
    , show num
    , " received value "
    , show i
    ]

-- producers don't know if consumers are finished, this will hang.
runNaive :: IO ()
runNaive = do
  chan <- newChan
  mapConcurrently (workerNaive chan) [1..5] `concurrently` mapM_ (writeChan chan) [1..10]
  return ()

{-@ use stm to singal the producer to finish @-}
{-# LANGUAGE BangPatterns #-}
module Models.Par1 where

import           Control.DeepSeq
import           Control.Parallel
import           Control.Parallel.Strategies

import           Criterion                   as C
import           Criterion.Main              as CM

import           Data.Foldable               (foldl')

{-@ A normal seq will only evaluate data to their weak head normal form.
    deepseq evaluate it all the way to normal form.
    In parallel programming it's important to ensure pending work doesn't
    migrate to the wrong thread.
@-}


{-@ First style of controlling parallelization is with Eval monad and strategies.
@-}

sum' :: Foldable m => Num a => m a -> a
sum' = foldl' (+) 0

--   return here
-- sum x |--------------
-- sum y |--------
-- return immediately, doesn't wait either f x or f y.
run1 :: () -> (Int, Int)
run1 _ =  runEval $ do
  a <- rpar (sum' x)
  b <- rpar (sum' y)
  return (a, b)
  where
    x = [1..90000000]
    y = [1..10000]

-- This is a contrived example. For a real task, how do you know
-- task b finished faster than task a?
-- sum x -------|------
-- sum y -------|
-- return after y is done.
run2 :: () -> (Int, Int)
run2 _ = runEval $ do
  a <- rpar (sum' x)
  b <- rseq (sum' y)
  return (a, b)
  where
    x = [1..90000000]
    y = [1..10000]

-- rseq rseq make sure return after all tasks are finished.
-- this essentially put a barrier on all tasks.
-- sum x --------------|
-- sum y --------      |
-- return after y is done.
run3 :: () -> (Int, Int)
run3 _ = runEval $ do
  a <- rpar (sum' x)
  b <- rpar (sum' y)
  rseq a
  rseq b
  return (a, b)
  where
    x = [1..90000000]
    y = [1..10000]


-- turn into () to force recaluation.
run123 = CM.defaultMain [ C.bench "rpar: " $ C.nf  run1 ()
                        , C.bench "rseq: " $ C.nf run2 ()
                        , C.bench "rseqall: " $  C.nf run3 ()
                        ]
module Nice.LoopBreak where


import           Control.Concurrent
import           Control.Concurrent.Async
import           Control.Monad
import           Control.Monad.Trans.Class
import           Control.Monad.Trans.Except
import           Control.Monad.Trans.State

import           Data.Functor.Identity

import qualified Data.ByteString.Char8      as S8
import           Data.Function              ((&))
import           Data.Text                  (Text, pack)
import           Data.Text.Encoding         (encodeUtf8)


say :: Text -> IO ()
say = S8.putStrLn . encodeUtf8

-- Note here we are not using monad transformer so everthing needs to be lifted mannually.

-- break the loop of arbitrary applicative.
-- a nice little use csae of polymorphism.

-- m can be any monads.
loop :: Monad m => ExceptT e m a -> m e
loop = fmap (either id id) . runExceptT . forever

quit :: Monad m => e ->  ExceptT e m a
quit = throwE

worker :: Chan Int -> Int -> IO ()
worker chan num = loop $ do
  i <- lift $ readChan chan
  when (i == (-1)) $ do     -- little sentinel
    lift $ writeChan chan (-1)
    quit ()
  lift . say . pack . mconcat $
    [ "Worker #"
    , show num
    , " received value "
    , show i ]


run1 :: IO ()
run1 = do
  chan <- newChan
  mapConcurrently (worker chan) [1..5] `concurrently`
    mapM_ (writeChan chan) ([1..20] ++ [(-1)])
  return ()


-- use ExceptT loop to calculate fib with dp
-- see there are three layers here. But we can still work with
-- it quit easily.
-- the key of dealing effects with monad transformers is to
-- understand the logic behind wrap and unwrap. It's quit linear so not
-- to hard.

fibdp :: Int -> [Integer]
fibdp n = runIdentity $ go [0, 1] [] n
  where
    go :: [Integer] -> [Integer] -> Int -> Identity [Integer]
    go s m i = flip evalStateT (s, m, i) . loop $ do
      state <- lift get
      case state of
        ([a, b], res, i) -> do
          let c = a + b
          if i == 0 then quit res else do lift $ put ([b, c], a:res, i - 1)
        _ -> quit []
{-# LANGUAGE DeriveFunctor #-}
module Nice.Pause where

import           Control.Monad
import           Control.Monad.Trans

-- pause type

-- what is pause?
-- a pausable action is an action that can be stopped and resumed.
-- meaning, there are two states: either being paused or finished.
--
-- if the action is finished, there is nothing left to do.
-- if it's paused, it has some undone computation left, which itself can
-- be another pausable action.
data Pause m
 = Run (m (Pause m))    -- holds another pause with the same effect.
 | Done

pauseDemo1 :: Pause IO
pauseDemo1 = Run $ do
  putStrLn "begin"
  putStrLn $ "#1"
  return $ Run $ do
    putStrLn $ "#2"
    return $ Run $ do
      putStrLn "#3"
      return Done

-- how to run a pausable action?
-- a pasuable action can be separated into different steps.
runN' :: Monad m => MonadFail m => Int -> Pause m -> m (Pause m)
runN' 0 p = return p
runN' n (Run m)
  | n < 0 = fail "n < 0!"
  | otherwise = do
      a <- m
      runN' (n - 1) a
runN' _ Done = return Done

runAll' :: Monad m => Pause m -> m ()
runAll' Done    = return ()
runAll' (Run m) = m >>= runAll'


-- build an action that can run for a while, pause, and resume
-- from where it paused last time.
--
-- This is a preamble of coroutine.


data PauseT m r
  = RunT (m (PauseT m r))
  | DoneT r
  deriving Functor

instance Monad m => Applicative (PauseT m) where
  (<*>) = ap
  pure = return

instance Monad m => Monad (PauseT m) where
  return a = DoneT a
  DoneT r >>= f = f r
  RunT m >>= f  = RunT $ fmap (>>= f) m

instance MonadTrans PauseT where
  lift = RunT . (fmap DoneT)

pause :: Monad m => PauseT m ()
pause = undefined

joinP :: Monad m => PauseT m (PauseT m a) -> PauseT m a
joinP = undefined


main :: IO ()
main = undefined
module Notes.All.Dice where

import Control.Monad
import Control.Applicative
import System.Random
import Control.Monad.State

-- use random with IO.
-- state is stored outside the program.
rollDice :: IO (Int, Int)
rollDice = liftA2 (,) (randomRIO (1, 6)) (randomRIO (1, 6))

-- get rid of IO
-- manage state inside the program.
-- The functor return a value and a new state.
-- Purpose of State monad is to manage the state.
-- like how to feed the new state to random again to generate new
-- random number.
clumsyRollDice :: (Int, Int)
clumsyRollDice = (n, m)
  where
    (n, g) = randomR (1, 6) (mkStdGen 0)
    (m, _) = randomR (1, 6) g  -- how to use the newly generated g'?
module Notes.All.Files where

import System.IO
import Control.Exception

doloop :: IO ()
doloop = do
  putStrLn "Enter a command r<filename> w<filename> or q to quit:"
  command <- getLine
  case command of
    'q':_ -> return ()

    'r':filename -> do
      putStrLn ("Reading " ++ filename)
      doRead filename
      doloop

    'w':filename -> do
      putStrLn ("Writing " ++ filename)
      doWrite filename
      doloop
    _ -> doloop

doRead :: FilePath -> IO ()
doRead filename =
  withFile filename ReadMode
          (\h -> do contents <- hGetContents h
                    putStrLn "The first 100 chars"
                    putStrLn (take 100 contents))

doWrite :: FilePath -> IO ()
doWrite filename = do
  putStrLn "Enter text to go into the file: "
  contents <- getLine
  writeFile filename (contents ++ "\n")
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE FunctionalDependencies #-}

module Notes.All.Fundeps where

class Extract container elem | container -> elem where
  extract :: container -> elem

instance Extract (a, b) a where
  extract (x, _) = x


module Notes.Lang.Applicative.Interactive where

import Text.Read

interactiveDoubling :: IO ()
interactiveDoubling = do
  putStrLn "Choose a number"
  s <- getLine
  let mx = readMaybe s :: Maybe Double
  case mx of
    Just x -> putStrLn ("The double of " ++ show x ++ " is " ++ show (2 * x))
    Nothing -> putStrLn "THis is not a valid number, try again..."
  interactiveDoubling

-- IO as functor
interactiveSumming :: IO ()
interactiveSumming = do
  putStrLn "Choose two numbers:"
  mx <- readMaybe <$> getLine
  my <- readMaybe <$> getLine
  case (+) <$> mx <*> my :: Maybe Double of
     Just z -> putStrLn $ "The sum of your number: " ++ show z
     Nothing -> putStrLn "Invalid number, Retry..."
  interactiveSumming

-- IO as Applicative
interactiveConcatenating :: IO ()
interactiveConcatenating = do
  sz <- putStrLn "Concat two Strings" *> ((++) <$> getLine <*> getLine)
  putStrLn "Result:" *> putStrLn sz

{-# LANGUAGE GADTs #-}
-- Generalised Algebraic Data Structures

module Notes.Lang.GHCLangExtensions.GADTs where

-- some random typeclass need to be implemented
class Vector a where
  add :: a -> a -> a

-- some random typeclass
class C a where
  d :: a -> a -> a

-------------------------------------------------------
-- normal way to add type constrain in instance implement
newtype T a = Cons a deriving (Eq, Show)

instance C (T a) where
  d (Cons x) (Cons y) = Cons y

instance (C a) => Vector (T a) where
  add (Cons x) (Cons y) = Cons (d x y)


-------------------------------------------------------
-- what if I want to impose the type constraint on a?
--                                                 ^
-- use GADTs extension to add implicit context to data
-- constructor
-- now Cons requres context C on a instread of T'
data T'' a where
  Cons'' ::(C a, Show a) => a -> T'' a

instance Show (T'' a) where
  show (Cons'' x) = "T''" ++ show x

instance C (T'' a) where
  d (Cons'' a) (Cons'' b) = Cons'' a

instance Vector (T'' a) where  -- now don't need to specify here.
  add (Cons'' x) (Cons'' y) = Cons'' (d x y)
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE OverloadedStrings #-}
module Notes.Lang.GHCLangExtensions.OverloadedStrings where

-- text:       unicode
-- bytestring: ascii

import Data.String

import qualified Data.Text as T
import qualified Data.Text.Lazy as TL

import qualified Data.ByteString as BS
import qualified Data.ByteString.Lazy as BL

import qualified Data.ByteString.Char8 as C
import qualified Data.ByteString.Lazy.Char8 as CL

import Data.Text.Encoding.Error as TE

import qualified Data.Text.IO as TIO
import qualified Data.Text.Lazy.IO as TLIO

import qualified Data.ByteString.Short.Internal as BSI

newtype Cat = Cat T.Text deriving (IsString, Show, Eq)

newtype Dog = Dog BSI.ShortByteString deriving (IsString, Show, Eq)

-- Overloaded works here
fluffy :: Cat
fluffy = "Fluffy"

soft :: Dog
soft = "Soft"

-- soft' :: String -> Dog  -- this gives an error for some reasons.
-- soft' name = Dog name

decodeUtf8' :: BS.ByteString -> Either TE.UnicodeException T.Text
decodeUtf8' = undefined

decodeUtf8With :: TE.OnDecodeError -> BS.ByteString -> T.Text
decodeUtf8With = undefined
{-# LANGUAGE RankNTypes #-}
module Notes.Lang.GHCLangExtensions.RankNTypes where


length' :: forall a. [a] -> Int
length' =  foldr (\a b -> b + 1) 0

fst' :: forall a b. (a, b) -> a
fst' (a, b) = a

snd' :: forall a b. (a, b) -> b
snd' (a, b) = b

map' :: forall a b. (a -> b) -> [a] -> [b]
map' _ [] = []
map' f (x:xs) = (f x) : map' f xs
module Notes.Lang.Monads.IO where

import Data.Char (toUpper)
import Control.Monad

-- IO is not a function, it is an action.
-- All haskell functions are pure
-- Effecful actions are sealed in type.
-- and the pure function handle the effecful value by
-- manipulating the monad.

toUpperCase :: IO ()
toUpperCase = putStrLn "Write your string: " >> fmap shout getLine >>= putStrLn
  where
    shout = map toUpper

fiveGetLines = replicateM 5 getLine
module Notes.Lang.Monads.ListMonad where

-- source from:
-- https://en.wikibooks.org/wiki/Haskell/Understanding_monads/List

-- bunny invasion
-- n ^ g numbers of bunny in generation g and population n

bunnyInvasion :: Int -> Int -> [String] -> [String]
bunnyInvasion n g bunny = bunny >>= genBunnies g
 where
  generation = replicate n
  genBunnies :: Int -> String -> [String]
  genBunnies c b | c == 1    = generation b
                 | c < 1     = [b]
                 | otherwise = generation b >>= genBunnies (c - 1)

-- [1, 2, 3] => [1, 2, 2, 3, 3, 3]
themselveTimes :: [Int] -> [Int]
themselveTimes = (f =<<)
  where f n = [n | _ <- [1..n]]


-- list coprehensions
module Notes.Lang.Monads.MaybeMonad where

-- source
-- https://wiki.haskell.org/Maybe

not0 :: Int -> Maybe Int
not0 0 = Nothing
not0 x = Just x

not100 :: Int -> Maybe Int
not100 100 = Nothing
not100 x = Just x

h :: Int -> Maybe Int
h x = do n <- not0 x
         not100 n
module Notes.Lang.Monads.MonadLaw where

import Control.Applicative
import Control.Monad

{- HLINT ignore -}
-- source no where.
-- just a monad that check if the monadic rule wholes.

-- instance Functor MonadCheck where
--   fmap f (MonadCheck m) = MonadCheck $ f m
rightUnitLaw :: (Monad m, Eq (m a)) => m a -> Bool
rightUnitLaw m = (m >>= return) == m

leftUnitLaw :: (Monad m, Eq (m a)) => a -> (a -> m a) -> Bool
leftUnitLaw x f = (return x >>= f) == f x

associativityLaw :: (Monad m, Eq (m a)) => m a -> (a -> m a) -> (a -> m a) -> Bool
associativityLaw m f g = ((m >>= f) >>= g) == (m >>= (\x -> f x >>= g))

bind :: (Monad m) => m a -> (a -> m b) -> m b
bind m g = join (fmap g m)

join1 x = x >>= id
module Notes.Lang.Monads.Monads where


-- source
-- https://wiki.haskell.org/All_About_Monads

-- Example 1
data Sheep = Sheep
  { name :: String
  , father :: Maybe Sheep
  , mother :: Maybe Sheep
  }
  deriving (Eq, Show)

ggfather = Sheep "ggf" Nothing Nothing
grandfather = Sheep "gf" (Just ggfather) Nothing
mom = Sheep "mom" (Just grandfather) Nothing
kid = Sheep "kid" Nothing (Just mom)

-- without monad bind
mothersPaternalGrandFather' :: Sheep -> Maybe Sheep
mothersPaternalGrandFather' s =
  case (mother s) of
    Nothing -> Nothing
    Just m -> case (father m) of
                Nothing -> Nothing
                Just m -> Just m

-- with monad bind
mothersPaternalGrandFather :: Sheep -> Maybe Sheep
mothersPaternalGrandFather s = (Just s) >>= mother >>= father

-- do notation as syntatic sugar
mothersPaternalGrandFatherdo :: Sheep -> Maybe Sheep
mothersPaternalGrandFatherdo s = do
  m <- mother s
  gf <- father m
  father gf

-- equivalence with bind
mothersPaternalGGrandFather :: Sheep -> Maybe Sheep
mothersPaternalGGrandFather s =
  mother s >>= (\m ->
    father m >>= (\gf ->
      father gf))

-- list monad
dupThemselves ::  Int -> [a] -> [a]
dupThemselves n = (replicate n =<<)

-- monad law

module Notes.Lang.Monads.StateMonad where

import Control.Monad.State

-- source
-- https://wiki.haskell.org/State_Monad

-- state game

type GameValue = Int
type GameState = (Bool, Int)  -- game is on / off & current score

playGame :: String -> State GameState GameValue
playGame [] = do
  (_, score) <- get
  return score

playGame (x:xs) = do
  (on, score) <- get
  case x of
    'a' | on -> put (on, score + 1)
    'b' | on -> put (on, score - 1)
    'c'      -> put (not on, score)
    _ -> put (on, score)
  playGame xs

startState = (False, 0)

run = print $ evalState (playGame "abcaaacbbcabbab") startState
{-# LANGUAGE NoImplicitPrelude #-}

module Notes.NoPrelude.State where

{-# LANGUAGE CPP #-}
{-# LANGUAGE ScopedTypeVariables #-}
module Notes.Perf.Wc where
import System.Environment
import qualified Data.ByteString.Internal as BS
import qualified Data.ByteString.Char8 as B
import qualified Data.ByteString.Lazy.Char8 as L
import System.IO
import Foreign
import Foreign.ForeignPtr
import Data.Word

-- different wc with different performance.
standardwc :: IO ()
standardwc = print . length . lines =<< getContents

-- fascter [char]
-- without duplication involved in lenth . lines
fascterwc :: IO ()
fascterwc = interact (count 0)
  where count i []          = show i
        count i ('\n':xs)   = count (i+1) xs
        count i (_:xs)      = count i xs

-- with bytestring
-- it uses packed byte arrys rather than heap allocated [Char] to
-- represent string.
bswc :: IO ()
bswc = B.getContents >>= print . B.count '\n'

-- lazy list of strict, L1-cache-sized chunks of bytes.
lbswc :: IO ()
lbswc = L.getContents >>= print . L.count '\n'

-- ptr hacking
#define STRICT4(f) f a b c d | a `seq` c `seq` d `seq` False = undefined
ptrhacking :: IO ()
ptrhacking = head <$> getArgs >>= B.readFile >>= \(BS.PS x _ l) ->
  withForeignPtr x $ \p -> go p l 0 0
    where
      go :: Ptr Word8 -> Int -> Int -> Int -> IO ()
      STRICT4(go)
      go p l n i
        | n >= l = print i
        | otherwise = do
            (w::Word8) <- peek (p `plusPtr` n)
            go p l (n+1) $ if w == 0x0a  then i+1 else i

run :: IO ()
run = do
  arg <- getArgs
  case arg !! 1 of
    "std" -> standardwc
    "faster" -> fascterwc
    "bs" -> bswc
    "lbs" -> lbswc
    "ptrhack" -> ptrhacking
  putStrLn "End"
{-# LANGUAGE FlexibleInstances     #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TemplateHaskell       #-}
module Other.AbstractAlgebra where


import           Prelude (Bool, Eq, (==))


-- use it to review some abstract algebra.

{-@  First we have semigroup @-}
-- A semigroup is a set with a bianry associative operation
--
-- in haskell you can view it as declaring a semigroup with
-- elements in set a. a is polymorphic, you can specialize it
-- to any types as long as you define the binary operator.
--
-- Semigroup has no rules, it's whole point is to better define
-- associativity. (Now you have an entire algebraic strucuture
-- with associativity only)
--
-- - Associativity
-- Associativity implies the order of assoication doesn't matter.
-- With this rule in hand we hand group arbitrary elements together
-- and evaluate them in different order.
--
-- But one thing to notice is you don't guarantee commutivity in
-- a semigroup.
--
-- We say a <> b a mutiply b, and the result is their product. even
-- though now it as nohting to do with real number multiplication.
-- You can also call them sum, or other things, that's the whole
-- point of being abstract.

class Semigroup a where
  (<>) :: a -> a -> a

semigroup_assoc :: (Semigroup a, Eq a) => a -> a -> a -> Bool
semigroup_assoc a b c = ((a <> b) <> c) == (a <> (b <> c))


{-@ On top of that we have monoid @-}
-- a monoid is a set with a binary operation has associativity and identity.
-- A monoid must first be a semigroup, so you get associativity for free.
-- Identity means there exists an element such that anything in the monoid
-- applies with it you get the element back.
--
-- Identity is the most special elemnet in an algebra.

class (Semigroup a) => Monoid a where
  mempty :: a

-- you also have left id and right id, don't show here.
monoid_id :: (Monoid a, Eq a) => a -> Bool
monoid_id a = (mempty <> a) == a


{-@ On top of that we have group @-}

-- All elements in a group can have an inverse.
-- And just these three properties so far, we openned the gate to
-- the entire group theory.
class (Monoid a) => Group a where
  inverse :: a -> a


{-@ Group homomorphism! @-}
-- Some groups can be similar to the other, and some of them are
-- exactly the same.
-- When we define homomorphism, we define it as
-- f : A -> B
-- with the property f(xy) = f(x)f(y)
-- What this implies is the mapping doesn't touch the underlying
-- algebraic structure. After all the interaction between elements
-- form an algebra. And if you can map an element from one group
-- to another without their algebraic properties, this mapping
-- must be somehitng interesting.

-- In haskell we can have multiparameter typeclass to model
-- the relationship between two types.
-- This gives you much more freedom then just map an element to
-- another, but homomorphism only requires this.

group_inverse :: (Group a, Eq a) => a -> Bool
group_inverse a = (a <> inverse a) == mempty

-- elemnents of a group form a set. We have either finite group or
-- infinite group, just like set.

-- We have this very abstract notion here, but what are some examples of
-- a group?

-- First lets define some finite set.
-- Because we don't have integer, let's use enum to represent them.
-- Introducing integer modulo N. a + b mode n
data Z3 = Z3_0 | Z3_1 | Z3_2

-- here we can define all the possible combination of elements in the
-- group. This effectively give us the multiplication table of Z3.
instance Semigroup Z3 where
  Z3_0 <> a    = a
  a <> Z3_0    = a
  Z3_1 <> Z3_1 = Z3_2
  Z3_2 <> Z3_2 = Z3_1
  Z3_1 <> Z3_2 = Z3_0
  Z3_2 <> Z3_1 = Z3_0

-- you merely give identity a name here. Operation of idenity is
-- still defined on Semigroup.
instance Monoid Z3 where
  mempty = Z3_0

-- to be a group we need inverse.
instance Group Z3 where
  inverse Z3_0 = Z3_0
  inverse Z3_1 = Z3_1
  inverse Z3_2 = Z3_2

-- There we defined a complete group. It' tedious so later we will generate
-- it with template hasekll.

-- Look at the group, you find, we not only have associativity, if I pick
-- 1 <> 2 = 0, 2 <> 0, it seems we also have commutivity.
-- a group with commutitive binary opeartor is called an abelian group.

class (Group a) => AbelianGroup a where

-- TODO
-- further more, this is a cyclic group

class (AbelianGroup a) => CyclicGroup a where
  generator :: [a]


class (Group a, Group b) => Homomorphism a b where
  homomorphism :: a -> b

-- Looking at a map from a to b, you might wonder if there is an
-- inverse to it.
-- Notice the homomorphism we define is only one way, a to b. In
-- general, homomorphism doesn't guarantee has an inverse.
--
--
module Other.ContAndMonad where

-- monad
foo :: Maybe Int
foo =
  Just 5 >>= \x ->
    Just 6 >>= \y ->
      return (x + y)

-- continuation
add :: Int -> Int -> (Int -> Int) -> Int
add x y k = k (x + y)

bar :: Int
bar =
  add 1 2 $ \x ->
    add x 4 $ \y ->
      y

-- meaningless comparision...

-- why continuation and monad are similar?
--
--   why monad and cps both keep sequetential order?
--   it's not because you can do it step by step, it's
--   simply because there they both have nested structures.
--
--   How do you keep sequence of evaluation in LC?
--   there is nothing you can do to directly express it, but what
--   you can do is nest on function in another.

{-# LANGUAGE GADTs              #-}
{-# LANGUAGE RankNTypes         #-}
{-# LANGUAGE StandaloneDeriving #-}

-- random:
-- what's good?
--  1. code lens eval and prop test
--  2. wingman and case split
--  3. virtual text for types.
--  4. type holes and relevant binding
--  5. stylish-haskell
--  6. type definition
--  7. telescope: (file, grep, mark)
--  8. quickfix for import

module Other.DSL1 where

import           Control.Monad (ap)
import           Prelude       hiding (succ, exp)

-------------------------------------------------------------------------------
-- untyped typed lambda calculus with dsl
-- basically it's partial evalution with defuntionalization.

-- We shove programs into dataype so they are defunctionalized and properly
-- typed for specific problem. This allows us to create a program without
-- evluating it, and it brings some benefits:
--  1. we can write program to build up programs.
--  2. we can shove in useful information when building up the program.
--  3. we can control when to evaluate the program.
--  4. we can write different combinators that supports different features,
--     all compile to the same data type, so single source of truth.
--
-- The dsl has it's original semantics, to restore it, we define an evaluation
-- function that actually evaluate the constructed data type.
--
-- To some extend it's like the reverse of macro, instead of handling all
-- program with macro, we define a small language with limited functionalities,
-- and handle the construction of the program as normal datat type.
-- Not like macro, we need to manually convert the program back to haskell to
-- run it.
--
-- Here we try to implement a simplyed typed lambda calculus with HOAS.
-- (higher order abstract syntax) which reuse the meta languages' binder for
-- the object language. Here haskell is the meta language, and LCExpr is the
-- object language. Of course, it's important only when the object langauge
-- has the conecpt of a binder (lambda binds a name as parameter).
-- HOAS is simply to write, but the idea of define a small language and
-- "compile" to it works the same for all embeded dsl.


data LCExpr a where
  Const :: a -> LCExpr a
  Abst :: (LCExpr a -> LCExpr b) -> LCExpr (a -> b)
  App :: LCExpr (a -> b) -> LCExpr a -> LCExpr b

-- Base line interpreter:
-- A eval functions that restores the original semantic of the program.
eval :: LCExpr a -> a
eval (Const a) = a
eval (Abst f)  = eval . f . Const
eval (App f e) = eval f (eval e)

showConst :: Show a => LCExpr a -> String
showConst (Const a) = show a
showConst _         = error "can't show"

-- all we need is to pull the value out, apply f and box it back
-- the monadic interface helps us to compose function that generate data type.
instance Functor LCExpr where
  fmap f x = Const . f $ eval x

instance Applicative LCExpr where
  pure a = Const a
  (<*>) = ap

instance Monad LCExpr where
  return = pure
  m >>= k = k . eval $ m


-- prop> eval (Const 1) == 1
-- +++ OK, passed 1 test.

-- >>> let f = (Abst (\x -> Const $ eval x + 1))
-- prop> eval (App f (Const 1)) == 2
-- +++ OK, passed 1 test.

-------------------------------------------------------------------------------
-- lanaguage

class LC m where
  apply :: m (a -> b) -> m a -> m b
  lambda :: (m a -> m b) -> m (a -> b)
  val :: a -> m a

instance LC LCExpr where
  apply = App
  lambda = Abst
  val = Const

-- >>> let f = (lambda (\x -> return $ eval x + 1))
-- prop> (eval $ apply f (val 3)) == 4
-- +++ OK, passed 1 test.

-------------------------------------------------------------------------------
-- church encoding

-- note the LCExpr type essentially defunctionalized lambda application so
-- we have a data type that represents lambdas to work with.
-- All other operations are based on partial evaluates to the data type.

z :: LCExpr ((a -> b) -> a -> a)
z = lambda . const . lambda $ id

succ :: LCExpr (((a -> c) -> b -> a) -> (a -> c) -> b -> c)
succ = lambda $ \n -> lambda $ \f -> lambda $ \x -> f <*> (n <*> f <*> x)

-- handy
n1 = succ <*> z
n2 = succ <*> n1
n3 = succ <*> n2
n4 = succ <*> n3
n5 = succ <*> n4
n6 = succ <*> n5
n7 = succ <*> n6
n8 = succ <*> n7
n9 = succ <*> n8

plus :: LCExpr ((a -> b) -> (a -> c) -> (c -> a) -> c -> b)
plus = lambda $ \m -> lambda $ \n -> lambda $ \f -> lambda $ \x ->
  m <*> (f <*> (n <*> (f <*> x)))

mult n = lambda $ \m -> lambda $ \n -> lambda $ \f -> lambda $ \x ->
  m <*> (n <*> (f <*> x))

exp :: LCExpr (a -> (a -> b) -> b)
exp = lambda $ \m -> lambda $ \n -> n <*> m

pred :: LCExpr ((((c -> a) -> (a -> b) -> b) -> (x -> z) -> (y -> y) -> d) -> c -> z -> d)
pred =
  lambda $ \n ->
  lambda $ \f ->
  lambda $ \x ->
    n <*> (lambda $ \g ->
           lambda $ \h ->
             h <*> (g <*> f))
      <*> (lambda $ \u -> x)
      <*> (lambda $ \u -> u)

toInt n = eval $ n <*> lambda ((+1) <$>) <*> (val 0)
-- >>> toInt n4
-- 4

-- >>> let x = n5 <*> lambda ((+1) <$>) <*> (val 0)
-- >>> let n16 = (exp <*> n2 <*> n4)
-- >>> let y = n16 <*> lambda ((+1) <$>) <*> (val 0)
-- prop> eval x == 5
-- +++ OK, passed 1 test.
-- prop> eval y == 16
-- +++ OK, passed 1 test.


-------------------------------------------------------------------------------
-- scott encoding


-------------------------------------------------------------------------------
-- HOAS to target, so called correct by construction compiler.
-- How to compile HOAS representation?
-- Reuse binder of the host language.
-- Two transformations:
--  1. closure conversion.
--  2. hoisting.
--  3. do cps transform.
-- More on this:
-- https://www.iro.umontreal.ca/~monnier/tp-compile.pdf
compileToJs :: Show a => LCExpr a -> String
compileToJs c@(Const _) = showConst c
compileToJs (Abst f) = undefined
compileToJs (App f e) = undefined

jsLambda :: (Show p, Show body) => LCExpr p -> LCExpr body -> String
jsLambda p body = "(" <> compileToJs p  <> ") => (" <> compileToJs body <> ")"
-- >>> jsLambda (val "a") (val "a")
-- "(\"a\") => (\"a\")"


-- BTW the abstract syntax doesn't use HOAS is called
-- FOAS (first order abstact syntax), and it's basically the ast you first think
-- of.


-------------------------------------------------------------------------------
-- In FOAS how do we encode binder informations? We uses de bruijn indices to
-- indicate the scope (which layer the paramter is at).
-- What is De brujin indice?
-- well:
-- \x.\y.x => \ \2
-- \x.\y.\z.x z (y z) => \ \ \ 3 1 (2 1)
-- \z.(\y.y(\x.x))(\x.z x) => \ (\ 1 (\ 1)) (\ 2 1)
--
-- number represenest the index of lambda head it's referring to. Note the
-- free variale z in the thrid example.
--
-- FOAS + de brujin indices is hard to implement. You need to deal with
-- 1. renaming
-- 2. unique new name generator
-- 3. capture avoiding substitutino (alpha conversion)
{-# OPTIONS_GHC -Wno-deferred-type-errors #-}

-- https://www.cs.purdue.edu/homes/rompf/papers/cong-icfp19.pdf
-- https://en.wikipedia.org/wiki/Defunctionalization
-- https://www.youtube.com/watch?v=vNwukfhsOME
-- https://ncatlab.org/nlab/show/defunctionalization
-- https://homepages.inf.ed.ac.uk/wadler/papers/papers-we-love/reynolds-definitional-interpreters-1998.pdf
-- http://www.mlton.org/References.attachments/060916-mlton.pdf

-- Def: convert higher order function in to data type.
-- so you don't have higher order fuction in the program
-- Then you implement an apply function to interpret the data type.
-- this way you don't need to pass function but just passing data.

-- In addition, if you do a cps transformation, the rest of the program will be a higher order
-- function.
-- So you can defunctionalize that, to represent the rest of computation as data type.

-- Application in compiler:
--  CFG and SSA are hard to build for higher order program. But we can transform all
--  higher order programs into first order one  by defuntionalization.
--  lambda terms.
--
--  example:
--  (let ((f (foo 7 g k)
--        (g (aref a7 i ))))
--     (if (< i j (h 30) (f h))))
--  To build a CFG for flow analysis, you need to analyse all possible lambda for f and h.
--  but itself is a flow analysis problem.
--
--  Goal:
--    1. eliminate higher order function.
--    2. make direct toplevel call, which are easy to optemize.
--    3. make control flow into available to rest of optimizer.
--    4. optimize closure justlike other data structures.
--
-- App:
--    1. flow analysis optimizaiton
--    2. common subexpression elimination
--    3. redundant assignment detection
--    4. code hoisting
--    5 .type inference
--    6. verification


module Other.Defunctionalization where


-- 1. convert predicate functon into datatypes.
-- notice defunctionalization is closed under the predicate, we can only use
-- datatypes we defined.
-- This is good for serialization.

data Filter = Tat
            | IsOdd
            | IsEven
            | LessThan Int
            | And Filter Filter

apply :: Filter -> (Int -> Bool)
apply Tat          = const True
apply IsOdd        = odd
apply IsEven       = even
apply (LessThan n) = (< n)
apply (And l r)    = \x -> apply l x && apply r x

filterDefun :: Filter -> [Int] -> [Int]
filterDefun _ [] = []
filterDefun f (x:xs) =
  if apply f x
     then x : filterDefun f xs
     else filterDefun f xs


-- 2. tree

data Tree a = Leaf a | Node (Tree a) (Tree a)

-- original program
-- walk though the tree and collect elements into a list
cons :: a -> [a] -> [a]
cons x xs = x : xs

o :: (b -> c) -> (a -> b) -> a -> c
o f g x = f (g x)

flattern :: Tree t -> [t]
flattern t = walk t []

walk :: Tree t -> [t] -> [t]
walk (Leaf x)     = cons x
walk (Node t1 t2) = walk t1 `o` walk t2

-- defuntionalized:
-- represent cons and o as data, then interpret it with applyCons.

data Lam a = LamCons a
           | LamO (Lam a) (Lam a)

applyCons :: Lam a -> [a] -> [a]
applyCons (LamCons x) xs  = x : xs
applyCons (LamO t1 t2) xs = applyCons t1 (applyCons t2 xs)

consDef :: a -> Lam a
consDef = LamCons

oDef :: Lam a -> Lam a -> Lam a
oDef = LamO

flatternDef :: Tree t -> [t]
flatternDef t = applyCons (walkDef t) []

walkDef :: Tree t -> Lam t
walkDef (Leaf x)     = consDef x
walkDef (Node t1 t2) = oDef (walkDef t1) (walkDef t2)

-- 3. defunctionaliza the continuation
-- related topic: Closure conversion
{-# LANGUAGE GADTs #-}
module Other.EDSL where

-- we have shallow dsl and deep dsl.
-- shallow dsl is just a style of writing library that only
-- exposing combinators and allows the user write logics with
-- provided combinators.
--
-- The benefit is you can not only design a concise set of vocabularies
-- to describe the problem, but extend it with haskell's facilities.

-- Shallow dsl is just an style, not really some deep techniques. It works
-- very well when we need a small langauge to describe and execute some domain
-- specific logics. For example, simulate sequential logics...

-- The problem of shallow dsl is it must execute to something, there is no way to
-- obtain the structure of the dsl since it's just normal haskell program.

-- For instance, it's hard to have a shallow dsl that generate llvm ir, it's just too
-- messy. What we really want for doing this types of work is to convert the langauge in
-- to some structures first. Like an ast.

-- So here deep dsl comes into play. We encode the target operations of the dsl as datatypes,
-- and provide cominator style inteface. But this time, exeuting combinators generate the
-- AST instead of run the logic direcly.
-- Once the AST is built, we can serve it for different purposes. A common use case is to hook
-- up the same AST with different backends.

-- The process of evaluating combinators and generating an AST representation can be though as
-- a "half program". We evaluated the program, but instead of get the result, we stop it in the
-- middle of the process. It's called "partial evaluation"


data Expr where
  Val' :: Integer -> Expr
  Add' :: Expr -> Expr -> Expr
  Sub' :: Expr -> Expr -> Expr
  Mul' :: Expr -> Expr -> Expr
  Abs' :: Expr -> Expr
  deriving (Eq, Show)


instance Num Expr where
  fromInteger n = Val' n
  e1 + e2 = Add' e1 e2
  e1 - e2 = Sub' e1 e2
  e1 * e2 = Mul' e1 e2
  abs e1 = Abs' e1
  signum = error "no signum"

-- this gives you the structure of the program rather
-- than the result of it.
-- We are free to interpret the structure however we want.

-- >>> e1
-- Mul (Add (Lit 1) (Lit 2)) (Lit 3)
e1 = 1 + 2 * 3 :: Expr

-- >>> f e1
-- Add (Add (Lit 1) (Mul (Lit 2) (Lit 3))) (Lit 1)
f :: Expr -> Expr
f x = x + 1



-- Deep embedding for circuit simulator

data Signal a where
  Register :: a -> Signal a -> Signal a
  Mux2 :: Signal Bool -> (Signal a, Signal a) -> Signal a
  Lit :: a -> Signal a
  Add :: Signal a -> Signal a -> Signal a
  Var :: String -> Signal a

instance Num (Signal a) where
   a + b = Add a b

mux2 :: Signal Bool -> (Signal a, Signal a) -> Signal a
mux2 c (a, b) = Mux2 c (a, b)

register :: a -> Signal a -> Signal a
register d s = Register d s

-- a problem with deep embedding is that we might ended up with infinite loops
-- when evalutating the dsl into ast.
--
-- Program written in the dsl sometimes needs some recursion. In shallow dsl that
-- just means run some functions recursively.
-- However, in deep embeded dsl it means the program will generate a subtree of the
-- AST recursively, which is usually not what we want.

-- solutions:
-- 1. indicate loop as an explicit effect with monad.
-- 2. observable sharing.



-- the interaction between the host language and the edsl.
-- 1. the host language can serve as a macro langauge to generate edsl.
-- 2. monadic reification
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE GADTs                     #-}

module Other.Exceptions where

-- exception mechanism in haskell
-- The exception monad transformer nicely simulate exception in a purely functional
-- style. Essentially that's an glorified system built based on Either monad transformer.
-- There are also realy exceptions that are rised by IO, and haskell has mechansim to cope
-- with that.

-- Exceptions naturally form a heirachy, thus subtyping. How do we express that in haskell?
-- We use eistential quantification.


-- exception mechanism in haskell
-- The exception monad transformer nicely simulate exception in a purely functional
-- style. Essentially that's an glorified system built based on Either monad transformer.
-- There are also realy exceptions that are rised by IO, and haskell has mechansim to cope
-- with that.

-- Exceptions naturally form a heirachy, thus subtyping. How do we express that in haskell?
-- We use eistential quantification.
import           Control.Exception (ArithException (..), AsyncException (..))
import           Data.Typeable

-- how are exceptions structured?

-- ways to look at it:
-- 1. sort of super type for all e implements Exception'
-- 2. a type that erase the actual type  it contains.
data SomeException' = forall e. Exception' e => SomeException' e SomeException'

-- use GADT to for existential type
-- no need of explicit forall. It's saying there exists a Exception' a hide behind
-- the SomeExceptionGADT constructor.
--
-- The scope is limited to this constructor only.
-- (POLYMORPHIC PARASITE)
data SomeExceptionGADT where
  SomeExceptionGADT :: Exception' a => a -> SomeExceptionGADT

data BlockedIndefinitelyOnMVar' = BlockedIndefinitelyOnMVar' deriving Show
data BlockedIndefinitelyOnSTM' = BlockedIndefinitelyOnSTM' deriving Show

data ArithException'
  = Overflow'
  | Underflow'
  | LossOfPrecision'
  | DividedByZero'
  | Denormal'
  | RatioZeoDenominator'
  deriving Show

class (Typeable e, Show e) => Exception' e where
  toException' :: e -> SomeException'
  fromException' :: SomeException' -> Maybe e
  displayException' :: e -> String

instance Exception' BlockedIndefinitelyOnSTM' where
  toException' = undefined
  fromException' = undefined
  displayException' = undefined

instance Exception' BlockedIndefinitelyOnMVar' where
  toException' = undefined
  fromException' = undefined
  displayException' = undefined

instance Exception' ArithException' where
  toException' = undefined
  fromException' = undefined
  displayException' = undefined

{-@ Examples @-}

data MyException = forall e. (Show e, Typeable e) => MyException e

instance Show MyException where
  showsPrec p (MyException e) = showsPrec p e

multiError :: Int -> Either MyException Int
multiError n =
  case n of
    0 -> Left (MyException DivideByZero)    -- differet
    1 -> Left (MyException StackOverflow)   -- types
    _ -> Right n

-- TODO
module Other.FAlgebra where

-- https://www.schoolofhaskell.com/user/bartosz/understanding-algebras

-- The minial representation of algebra.

{-@ @-}


-- a functor, a type, and a function => an algebra
-- you can:
-- 1. form an expresion
-- 2. evaluate an expression

type Algebra f a = f a -> a


{-# LANGUAGE ForeignFunctionInterface #-}
module Other.FFI where

import           Foreign
import           Foreign.C.Types
import           Foreign.Ptr
import           System.IO.Unsafe


{-@ Learning to use some ffi
    Marsharling: Converting hasekll types to C types.
@-}

-- use CDouble to represent C types.
-- there is a safety level marker,
-- unsafe is faster then safe, and safe is only required when
-- there are c functions that needto call back haskell function.
--
-- One note: the function signature must be correct!
-- GHC has no idea what type does the underying c fucntion  has.
foreign import ccall unsafe "math.h sin"
  c_sin :: CDouble -> CDouble

hsin :: Double -> Double
hsin = realToFrac . c_sin . realToFrac


-- for impure functions
-- Note for functions with side effects we need to put it into IO.
-- Otherwise haskell will treat it as a pure function and return the
-- same result everytime you call it.
foreign import ccall unsafe "stdlib.h rand"
  c_rand :: IO CUInt

foreign import ccall unsafe "stdlib.h srand"
  c_srand :: CUInt -> IO ()

hsrand :: Int -> IO ()
hsrand =  c_srand . fromIntegral

foreign import ccall unsafe "math.h hypot"
  c_hypot :: CDouble -> CDouble -> CDouble

foreign import ccall unsafe "stdlib.h random"
  c_random :: IO CLong

hrandom :: IO Integer
hrandom = fromIntegral <$> c_random

hhypot :: Double -> Double -> Double
hhypot a b = realToFrac $ c_hypot (realToFrac a) (realToFrac b)

-- these are just simple functions that are really not necessary
-- to be imported. Let's try some more complicated ones.


{-@ Working with C pointers @-}

-- any funciton with side effect needs to be wrapped in IO.
foreign import ccall unsafe "gsl/gsl_math.h gsl_frexp"
  gsl_frexp :: CDouble -> Ptr CInt -> IO CDouble

-- ok now we have this IO stuff, but how do we get value in the pointer
-- out yet still provide a pure interface?
frexp :: Double -> (Double, Int)
frexp x = unsafePerformIO $
  alloca $ \expptr -> do
    f <- gsl_frexp (realToFrac x) expptr
    e <- peek expptr
    return (realToFrac f, fromIntegral e)
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE FlexibleInstances         #-}
{-# LANGUAGE GADTs                     #-}
{-# LANGUAGE KindSignatures            #-}
{-# LANGUAGE OverloadedStrings         #-}
{-# OPTIONS_GHC -Wno-incomplete-patterns #-}

module Other.FinalTagless where
import           Data.Text.Lazy.Builder (Builder)


-- https://legacy.cs.indiana.edu/ftp/techreports/TR65.pdf

{-@ Tagless initial and tagless final.

@-}

-- model language with algebraic data type is called initial encoding.
-- given the ast below, how do we infer return type from constructor?
-- normally you will think of using GADT.
--
-- We can also hide the type info behind a common result type.

-- Problem: Data Type saves too much information, thus works on datatype
--          force us to handle each cases.
data Expr' a
  = I Int
  | B Bool
  | Leq (Expr' Int) (Expr' Int)
  | And (Expr' Bool) (Expr' Bool)
  | Or (Expr' Bool) (Expr' Bool)
  | Not (Expr' Bool)
  deriving (Eq, Show)

-- each Result comes with a constructor, we call this a tag.
data Result = BoolR Bool
            | IntR Int

-- so this should be initial tagged encoding.
eval' :: Expr' a -> Result
eval' (B b) = BoolR b
eval' (I i) = IntR i
eval' (Leq e1 e2) =
  let IntR i1 = eval' e1
      IntR i2 = eval' e2
   in BoolR (i1 <= i2)
eval' (And e1 e2) =
  let BoolR b1 = eval' e1
      BoolR b2 = eval' e2
   in BoolR (b1 && b2)
eval' (Or e1 e2) =
  let BoolR b1 = eval' e1
      BoolR b2 = eval' e2
   in BoolR (b1 || b2)


-- Thus writing with GADt is initial tagless encoding.
-- the type of a is implied by the type constructor.
data Expr_ a where
  I_ :: Int -> Expr_ a
  B_ :: Bool -> Expr_ a
  Leq_ :: Expr_ Int -> Expr_ Int -> Expr_ Bool
  And_ :: Expr_ Bool -> Expr_ Bool -> Expr_ Bool
  Or_ :: Expr_ Bool -> Expr_ Bool -> Expr_ Bool
  Not_ :: Expr_ Bool -> Expr_ Bool


eval_ i@(I_ _)               = i
eval_ b@(B_ _)               = b
eval_ (Not_ (B_ n))          = B_ (not n)
eval_ (Leq_ (I_ i1) (I_ i2)) = B_ (i1 <= i2)
eval_ (And_ (B_ b1) (B_ b2)) = B_ (b1 && b2)
eval_ (Or_ (B_ b1) (B_ b2))  = B_ (b1 || b2)


-- Both examples above uses initial encoding.
-- we also have final encoding, where doesn't uses constructors.

-- data type becomes just `Expr a`
newtype Expr a = Expr { unExpr :: a }

bool :: Bool -> Expr Bool
bool b = Expr b

int :: Int -> Expr Int
int i = Expr i

leq :: Expr Int -> Expr Int -> Expr Bool
leq (Expr e1) (Expr e2) = Expr (e1 <= e2)

and :: Expr Bool -> Expr Bool -> Expr Bool
and (Expr b1) (Expr b2) = Expr (b1 && b2)

or :: Expr Bool -> Expr Bool -> Expr Bool
or (Expr b1) (Expr b2) = Expr (b1 || b2)

not' :: Expr Bool -> Expr Bool
not' = Expr . not . unExpr

-- in final encoding, we switch the role of data type and functions. Now
-- functions are the constructor and all values are tagged by default.

lit' :: Int -> Int
lit' =  id

add' :: Int -> Int -> Int
add' = (+)

a = (add' (lit' 2) (lit' 4))


-- for string
lit'' :: String -> String
lit'' = id

add'' :: String -> String -> String
add'' = (++)

b = (add'' (lit'' "asd") (lit'' "asd"))


-- abstract out to return different types.

class LitExpr a where
  lit :: Int -> a
  add :: a -> a -> a

instance LitExpr Int where
  lit = id
  add = (+)

instance LitExpr String where
  lit = show
  add a b = a ++  " + " ++ b

class Minus a where
  minus :: a -> a -> a

instance Minus Int where
  minus = (-)

instance Minus String where
  minus a b = a ++ " - " ++ b

expr1 :: LitExpr a => Minus a => a
expr1 = add (lit 12) (minus (lit 32) (lit 3))

expr1AsInt :: Int
expr1AsInt = expr1 + 12

expr1AsString :: String
expr1AsString = expr1

{-@ quick recap:
    - tagles initial (GADT) allows data constructor to carry the type information,

    - tagless final data constructor to carry the type information, and it makes types extensible.
      - extensible as you can simply add a new function that return the result type.
      - constructors can carry info becasue it's essentially a function, which has a return type
        you can specify.

    - Tagged initial encoding requires you to use a universal result type to return different
      return type.

    - If the data type doesn't need to be change, tagless initial can be more convinent as you can
      pattern match on constructors.

    - If the data type needs to be extensible and there is only one operation act on it, tagless
      final is probably the simplest way.

    - If the data type needs to be extensible and you have different version of funcions, abstract
      constructors with typeclass, and make instances for different result types.

      The idea is similar to wrap in newtype to work with different monoids.
      Or you can make an instances for a completely different type, the usage is quit flexible.
@-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GADTs             #-}
{-# LANGUAGE KindSignatures    #-}

module Other.FinalTagless1 where



-- expression problem.
-- adt is extensible on adding method but closed on adding datatype
-- subtypig is extensible on adding datatype but closed on adding method?
-- no.
-- what about both.


-- this is the original type
data Expr' a where
  Lit :: Int -> Expr' Int
  Add :: Expr' Int -> Expr' Int -> Expr' Int

-- this is the final tagless version.
{-@ final tagless use function as data constructor
@-}

-- basic
class Expr a where
  lit :: Int -> a
  add :: a -> a -> a

instance Expr Int where
  lit = id
  add = (+)

instance Expr String where
  lit = show
  add a b = a ++  " + " ++ b

-- now just add these two constrains together


{-# LANGUAGE KindSignatures    #-}
{-# LANGUAGE OverloadedStrings #-}

module Other.FinalTagless2 where

-- use typeclass to chose the return type.
-- https://legacy.cs.indiana.edu/ftp/techreports/TR65.pdf

import           Data.Text.Lazy.Builder


data ExprInterp a = Expr { unExpr :: a }


class Expr (m :: * -> *) where
  bool :: Bool -> m Bool
  int :: Int -> m Int
  leq :: m Int -> m Int -> m Bool
  and' :: m Bool -> m Bool -> m Bool
  or' :: m Bool -> m Bool -> m Bool
  not' :: m Bool -> m Bool


instance Expr ExprInterp where
  bool b = Expr b
  int i = Expr i
  leq (Expr x) (Expr y) = bool (x <= y)
  and' (Expr x) (Expr y) = bool (x && y)
  or' (Expr x) (Expr y) = bool (x || y)
  not' = Expr . not . unExpr


expr1 = unExpr $ and' (or' (bool True) (leq (int 2) (int 3))) (bool True)



-- another implementation

data PersistValue
  = PersistInt64 Int
  | PersistBool Bool
  deriving Show

data PersistExpr a = PersistExpr { unPersistExpr :: (Builder, [PersistValue]) }

instance Expr PersistExpr where
  bool b = PersistExpr ("?", [PersistBool b])
  int i = PersistExpr ("?", [PersistInt64 i])
  leq (PersistExpr (x1, v1)) (PersistExpr (x2, v2)) = PersistExpr (x1 <> " <= " <> x2, v1 <> v2)
  or' (PersistExpr (x1, v1)) (PersistExpr (x2, v2)) = PersistExpr (x1 <> " OR " <> x2, v1 <> v2)
  and' (PersistExpr (x1, v1)) (PersistExpr (x2, v2)) = PersistExpr (x1 <> " AND " <> x2, v1 <> v2)
  not' (PersistExpr (x, v)) = PersistExpr ("NOT " <> x, v)

expr2 = unPersistExpr $ and' (or' (bool True) (leq (int 2) (int 3))) (bool True)


-- again make a comparison with  initial tagged encoding.
data Expr' a
  = I Int
  | B Bool
  | Leq (Expr' Int) (Expr' Int)
  | And (Expr' Bool) (Expr' Bool)
  | Or (Expr' Bool) (Expr' Bool)
  | Not (Expr' Bool)
  deriving (Eq, Show)

-- each Result comes with a constructor, we call this a tag.
data Result = BoolR Bool
            | IntR Int

-- so this should be initial tagged encoding.
eval' :: Expr' a -> Result
eval' (B b) = BoolR b
eval' (I i) = IntR i
eval' (Leq e1 e2) =
  let IntR i1 = eval' e1
      IntR i2 = eval' e2
   in BoolR (i1 <= i2)
eval' (And e1 e2) =
  let BoolR b1 = eval' e1
      BoolR b2 = eval' e2
   in BoolR (b1 && b2)
eval' (Or e1 e2) =
  let BoolR b1 = eval' e1
      BoolR b2 = eval' e2
   in BoolR (b1 || b2)


{-@ Conclusion
    1. The name final tagless corresponds ot "initial" "tagged" encoding, we hide different
       return type behind a universal return type

    2. If you use GADT, it becomes initial taggless encoding, the return type info is determined
       based on the data constructor.

    3. The problem with initial encoding is they are not extensible. You can't simply add a
       data constructor without modifying all functions.

  @-}
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE RankNTypes                #-}
module Other.FixPoint where

-- y combinator.

{-@ Note how this definition looks different from ordinary Y combiantor
    which is \f -> (\x -> f $ x x) (\x -> f $ x x)

    It's done with lazy eval.
    x is bind to the result of (f x), which then get evaluate
    so let x = f x
        in f (f x)  -- (f x) is x, the x in (f x) is (f x), oh yeah
        in f (f (f x))
        ...
@-}
-- fix f = f (f (f ...))
fix f =
  let x = f x
   in x

fact = fix f
  where f rec n | n == 0 = 1 | otherwise = n * rec (n -1)

-- infinite
sinFix = fix (\f x -> if x == sin x then x else f (sin x))

-- oh
cosFix = fix (\f x -> if x == cos x then x else f (cos x))

-- with IO action.
printFix  = fix (\f x -> if x >= 0 then do print x; f (x - 1) else pure x) $ 4

many_ones = fix (1:)
onst_still_const = fix (const "hello")

v1 = fact 5

{-@  Curry's pardox: untyped lambda calclus is unsound as a deductive system, as
     the existence of Y combinator (fixed point combinator) makes it possible to
     have undecidable function.

     In a simply type lambda calculus, the existence of Y combinator force all types
     to be lifted. You need to have a bottom value beacuse you can't guarantee function
     terminates.
@-}

-- fix point data type. You can essentially do all recursion with this.
-- (except irregular stuffs like an AST. You might use )
data Fix f = In (f (Fix f))

{-@ Reistricted version of Fix:
    Mu and Nu,
    inductive finite data and coinductive infinite data
@-}

newtype Mu f = Mu (forall a . (f a -> a) -> a)
data Nu f = forall a . Nu a (a -> f a)

-- more of these topic on free algebra.

{-@ Mu for inductive finite data.
    Nu coinductive infinite data (a stream)
@-}

newtype Stream a = Stream (Nu ((,) a))
newtype Void a = Void (Mu ((,) a))
{-# LANGUAGE DeriveFunctor #-}

module Other.FixPoint1 where

import           Control.Arrow

{-@ Fix Point Of Functor
    Sometimes we have recursive types. E.g binary tree

    We can abstract away the recursive part with universal type.
    To make it recursive again we find the fix point of the data type.

    doing so is desiable when you want to separate the primitive representation
    of a data type and it's recursive form.
@-}

data Lit
  = StrLit String
  | IntLit Int
  | Ident String
  deriving (Show, Eq)


-- e.g one way to define Unary might be `Unary String Expr`. We abstract away the
-- Expr part and turns it into a universal type.
data Expr a
  = Index a a
  | Call a [a]
  | Unary String a
  | Binary a String a
  | Paren a
  | Literal Lit
  deriving (Show, Eq, Functor)


-- use a fix point to tight the recursive knot.
-- What does it mean?
--    What is f? it's (Expr a)
--    so we have In (Expr (Fix f))
--    further expand,  we have In (Expr ((In (Expr (Fix f)))))
--    this keep going.

-- Note the original Expr a is not recurisve at all.

-- We are just using the Fix type to create a recursive type externally.
data Fix f = In (f (Fix f))

-- out is a helper function to evaluate the Term f
out :: Fix f -> f (Fix f)
out (In t) = t


n = let term = In (Binary (In (Paren (In (Literal (IntLit 3)))))
                           "+"
                           (In (Binary (In (Binary (In (Literal (IntLit 3)))
                                           "*"
                                           (In (Literal (IntLit 10)))))
                                        "-"
                                        (In (Literal (IntLit 10))))))
      in out term


{-@ Conclusion

    1. fixed point of function f means ∃x. f(f(f(f..(x)))) = x. In another word, a
       fixed point is a value that mapped to itself by some function.
        we say x is the fixed point of f.

    2. but how does fixed point relates to Y combinator?
        fix f = f (fix f)
              = f (f (fix f))
              = f (f (f (fix f)))
              ...

        fix f is the x, f still is the f.  So the fix poinf of f is (fix f).
        Ah I see. (fix f) is the fix point.

        what's the definition of fix?
          fix f = (\x -> f (x x)) (\x -> f (x x))

    3. why is it a big deal?
          Curry paradox.
             you have fix point in lambda calclus.
          -> no guarantee terminate.
          -> lambda calculus is unsound.

    4. the equivalence of fix point operator is on paper, what's the operational
       semantics we we execute it?
          it's just beta reduction. Each time you make a new substitution, a new
          expression with the same form emerge.

    5. but this only build up the infinite expression of fffff, how do you do useful
       things with it?
          well with functions that have only one paramter it will never halt.
          in that case it doesn't matter how function gets applied because you will never
          get an answer.

          You need multiple parameters for functions that do halt with their fix point.
          doing so you can signal the base case on the extra parameter.

          When evaluation hit the base case, it will evaluate the chain of application
          built by fix, which is how things get evaluated.

    6. fix point in type.
          fix point at the type level just creates a recursive type, recurse on the
          type parameter.
          Fix t is the fix point of t.

    7. fix pint of type accommondates arbitrary nested types.
          It's the key idea of using fixed point at the type level. It doesn't matter
          how deep the data type is nested, as long as it's a instance of the fixed point
          of the type it will tye check.

@-}
module Other.IOs where

import           Control.Concurrent
import           Control.Monad
import           Data.Functor.Const
import           Data.Time.Calendar
import           Data.Time.Clock
import           System.Random

import           System.IO.Unsafe

-- IO brings explicit effect to haskell.
-- IO turn off many of the ordinary haskell features:
--   1. sharing via non-strict evalution.
--   2. inlining (or not as aggressive)
--   3. laziness


-- nesting to enforece the order
-- to run the lambda, we must evaluate putStr at the left hand side.
-- By deeply nesting we enforce what to be executed before, what after.
printThings :: IO ()
printThings =
  putStr "1" >>= (\_ ->
    putStr "2" >>= (\_ ->
      putStr "3" >>= (\_ -> return ())))

-- make a comparison with continuation
-- we have explicit nesting here. The call back alwasy called
-- after the caller calls.
contForNesting :: Int -> (Int -> r) -> r
contForNesting n k = go n k
  where
    add1 = \n k -> k (n + 1)
    sub1 = \n k -> k (n - 1)
    go n k =
      add1 n (\n1 ->
        add1 n1 (\n2 ->
          sub1 n2 (\n3 -> k n3)))

-- IO implies mutation, it doesn't make sense to share named values any more.

-- We have the sense of time now
-- isn't it fresh? The real world interaction.
realWorldEffect1 :: IO ()
realWorldEffect1 = do
  t1 <- getCurrentTime
  mapM_ (\_ -> getCurrentTime) [1..10000000]
  t2 <- getCurrentTime
  putStrLn (show t1)
  putStrLn (show t2)


-- this creates as many MVar as you want in IO monaad
myData :: IO (MVar Int)
myData = newEmptyMVar

useMyDataDeadLock :: IO ()
useMyDataDeadLock = do
  mv <- myData
  putMVar mv 0

  mv' <- myData    -- this is a different MVar
  zero <- takeMVar mv'
  print zero

useMyData :: IO ()
useMyData = do
  mv <- myData
  putMVar mv 0
  zero <- takeMVar mv
  print zero

useMyDataEvil :: IO () -- this is really forbidden in a normal workflow.
useMyDataEvil = let m = unsafePerformIO newEmptyMVar :: MVar Int
                 in do
                   putMVar m 0
                   zero <- takeMVar m
                   print zero

-- referential transparency on what?
-- By definition it means given a function, same argument alway give
-- the same result.
-- But is it ture even in IO ?
-- You can still perform arbitrary side effects in IO anyway,

-- IO a represents the process of an effectful computation, but it's not
-- tighted to the result they produce anyhow.

-- Given an IO a, you always genrate the same IO action, it's just that the
-- semantics of the IO performs side-effects.

-- takes the example
-- the semantics of gimmeShelter is that:
--  When input is true, generate a list of random value based on the random value
--  generator
--  when input is false, always genrate [0]
-- when argument is true, IO does always produce different values.

{-@ ! @-}
-- no matter what, the IO action always **produce the list of Int the same**
-- instead of exactly the same list of int.
-- That's one of the reason it's warpped in IO.
-- if want the same list all the time, we will ahve type Bool -> [Int]


gimmeShelter :: Bool -> IO [Int]
gimmeShelter True  = replicateM 10 (randomRIO (0, 10))
gimmeShelter False = pure [0]


-- Functor, Applicative, and Monad of IO

-- notice the effect is in the structure of IO itself, not related to the Int really.
fio = fmap (+1) (randomIO :: IO Int)
aio = (+) <$> (randomIO :: IO Int) <*> (randomIO :: IO Int)

-- pure as the effect free embedding of a value in a recipe creating environment.
embedInIO = return :: a -> IO a

performEffectInNestedOrder = join (join (embedInIO (embedInIO (embedInIO "10"))))


{-@
  Nesting lets us express order dependence
  Peter J Ladin (A correspondence between ALGOL 60 and Church's Lambda notation.)
@-}

-- this is not expressible with applicative, as we need need to chose which branch to
-- return based on the result of performing the previous IO effect.
huehue :: IO (Either (IO Int) (IO ()))
huehue = do
  t <- getCurrentTime
  let (_, _, dayOfMonth) = toGregorian (utctDay t)
  case even dayOfMonth of
    True  -> return $ Left randomIO
    False -> return $ Right (putStrLn "no soup for you")

resultOfhuehue = either (>>= print) id =<< huehue
{-# LANGUAGE ExplicitForAll      #-}
{-# LANGUAGE RankNTypes          #-}
{-# LANGUAGE ScopedTypeVariables #-}
module Other.Lens1 where

import           Data.Functor.Const
import           Data.Functor.Identity

import           Control.Applicative
import           Data.Function         ((&))


{-@ Lens provides access into the middle of a data structure.
    Access:
      1. read
      2. write
      3. modify

    Lens' s a
    Lens' DateTime Min

    lens composes.

    Lens' s1 s2 -> Lens' s2 s3 -> Lens' s1 s3

    typeclass + higher kindness + polymorphic functions

    There are many variation from the basic lens. e.g Traversal for multiple foci,
    Iso for building isomprphism between two data types etc.
@-}

-- solve nested record.
data Person = P { _name   :: String
                , _addr   :: Address
                , _salary :: Int
                }
                deriving Show

data Address = A { _road     :: String
                 , _city     :: String
                 , _postcode :: String
                 }
                 deriving Show

setPostCode' :: String -> Person -> Person
setPostCode' pc p = p { _addr = (_addr p) { _postcode = pc } }

data LenR s a = L { viewR :: s -> a
                  , setR  :: a -> s -> s
                  , modR  :: forall f. Functor f => (a -> f a) -> s -> f s
                  }

fred = P { _name = "fred"
         , _addr = A { _road = "road1"
                     , _city = "city1"
                     , _postcode = "V1V0AA"
                     }
         , _salary = 1000
         }

-- we want to set and get.
-- we have these two represnetation.
-- In fact they are isomorphic.
-- one fact: a is always contained in s.
type Lens' s a = forall f. Functor f => (a -> f a) -> s -> f s

set :: forall s a. Lens' s a -> (a -> s -> s)
set ln x = runIdentity . ln (Identity . const x)

over :: forall s a. Lens' s a -> (a -> a) -> s -> s
over ln f = runIdentity . ln (Identity . f)

view :: forall s a. Lens' s a -> s -> a
view ln = getConst . ln Const


-- now we can produce lenses.
name :: Lens' Person String
name f (P n a s) = fmap (\n' -> P n' a s) (f n)

addr :: Lens' Person Address
addr f (P n a s) = fmap (\a' -> P n a' s) (f a)

salary :: Lens' Person Int
salary f (P n a s) = fmap (\s' -> P n a s') (f s)

road :: Lens' Address String
road f (A r c p) = fmap (\r' -> A r' c p) (f r)

city :: Lens' Address String
city f (A r c p) = fmap (\c' -> A r c' p) (f c)

postcode :: Lens' Address String
postcode f (A r c p) = fmap (\p' -> A r c p') (f p)

{-@ play with lens @-}

-- it's just so magical...
view_fred_name = view (addr . road) fred
set_fred_name = set (addr . road) "dan" fred
modify_fred_name = over (addr . road) ("not_really_" ++) fred

fred_name' = fred
           & over (addr . road) ("not_reallyy_" ++)
           & view (addr . road)


-- lens is already modifyIO, we can just give it a type here.
modifyIO :: Lens' s a -> (a -> IO a) -> s -> IO s
modifyIO = id

modifyMaybe :: Lens' s a -> (a -> Maybe a) -> s -> Maybe s
modifyMaybe = id

{-@ virtual field with lens @-}
data Temp = T { _fahrenheit :: Float } deriving Show

temp_here = T { _fahrenheit = 100 }

fahrenheit :: Lens' Temp Float
fahrenheit fn (T f) = fmap (\f' -> T f') (fn f)

-- this is a virtual field of the original datatype.
-- it might looks like a getter for something non existed.
celsius :: Lens' Temp Float
celsius fn (T f) = fmap (\c' -> T c') (fn (fToC f))

cToF :: Float -> Float
cToF c = (c * 9 / 5) + 32

fToC :: Float -> Float
fToC f = (f - 32) * 5 / 9

{-@ maintaining invariants with lens @-}
data Time = Time { _hours :: Int, _mins :: Int } deriving Show

now = Time {_hours = 3, _mins = 58}

-- not quite, but yes it shows the spirit.
mins :: Lens' Time Int
mins f (Time h m) = fmap wrap (f m)
  where
    wrap :: Int -> Time
    wrap m'
      | m' >= 60 = Time { _hours = h + m' `divInt` 60
                        , _mins = m' `mod` 60
                        }

      | m' < 0  = Time { _hours = h + (abs m') `divInt` 60
                       , _mins = (abs m') `mod` 60
                       }
      | otherwise = Time h m'
    divInt m n = let x = fromIntegral m `div` fromIntegral n
                  in (fromInteger . toInteger) x

{-@ traversal @-}

-- multi foci lens
type Traversal' s a = forall f. Applicative f => (a -> f a) -> s -> f s

addr_strs :: Traversal' Address String
addr_strs fn (A r c p) = (\r' c' -> A r' c' p) <$> (fn r) <*> (fn c)


{-@  Iso
@-}

-- TODO
{-@ Conclusion
@-}
module Other.ListCompQuirks where

import Control.Monad

-- normal version
position :: (Num t, Eq t, Enum a, Num a, Eq a) => t -> a -> [[a]]
position 0 n = [[]]
position k n = [p : ps | p <- [1 .. n], ps <- position (k - 1) n, isSafe p ps]

-- slow in interpreter. call position for each p
positionSlow :: (Num t, Eq t, Enum a, Num a, Eq a) => t -> a -> [[a]]
positionSlow 0 n = [[]]
positionSlow k n = [p : ps | ps <- positionSlow (k - 1) n, p <- [1 .. n], isSafe p ps]

-- monad version
positionM :: (Num t, Eq t, Enum a, Num a, Eq a) => t -> a -> [[a]]
positionM k n = do
  ps <- positionM (k - 1) n
  p <- [1 .. n]
  guard (isSafe p ps) >> return (p : ps)

-- compute position first.
positionSeq :: (Num t, Eq t, Enum a, Num a, Eq a) => t -> a -> [[a]]
positionSeq k n =
  let ls = positionSeq (k - 1) n
   in ls `seq` [p : ps | p <- [1 .. n], ps <- ls, isSafe p ps]

isSafe :: (Eq a, Num a, Enum a) => a -> [a] -> Bool
isSafe p ps = not (p `elem` ps || sameDiag p ps)
  where
    sameDiag p ps = any (\(dist, q) -> abs (p - q) == dist) $ zip [1 ..] ps

queue :: (Num a, Enum a, Eq a) => a -> [[a]]
queue n = position n n
{-# LANGUAGE LambdaCase        #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fwarn-Wno-incomplete-patterns #-}

module Other.ParserCombinator where



import           Control.Applicative
import           Control.Monad.Trans
import           Control.Monad.Identity
import           Data.Char
import           Data.String
import qualified Data.Text              as T
import           Prelude

type Input = T.Text

-- put error types to another type
-- this simplify pattern matching.
data PError
  = ErrorEOF
  | EOF Input
  | UnknownChar Char
  | UnknownString T.Text

data PResult a
  = PError PError
  | Result Input a

instance Show a => Show (PResult a) where
  show (Result i a) = "Result: " ++ show i ++ " " ++ (show a)
  show (PError err) = case err of
    (EOF i)           -> "Expected EOF, but got" ++ (show i)
    (UnknownChar c)   -> "Unknown char" ++ (show c)
    (UnknownString t) -> "UnknownString" ++ (show t)
    ErrorEOF          -> "Parsing aborted because of unexpected EOF"

instance Functor PResult where
  fmap f (Result i a) = Result i $ f a
  fmap _ (PError err) = PError err

newtype ParserT m a = ParserT {parseT :: Input -> m (PResult a)}

type Parser a = ParserT Identity a

instance (Monoid a, Monad m) => Semigroup (ParserT m a) where
  pa <> pb = do
    pa' <- pa
    pb' <- pb
    return $ pa' <> pb'

instance (Monoid a, Monad m) => Monoid (ParserT m a) where
  mempty = ParserT $ \_ -> return $ PError ErrorEOF

instance Monad m => Functor (ParserT m) where
  fmap f p = ParserT $ \s -> do
    a <- parseT p s
    return $ f <$> a

instance Monad m => Applicative (ParserT m) where
  pure a = ParserT $ \s -> return $ Result s a
  ParserT f <*> ParserT x = ParserT $ \s ->
    f s >>= \case
      Result s' g -> (fmap . fmap) g (x s')
      PError err  -> return $ PError err

instance Monad m => Alternative (ParserT m) where
  empty = ParserT $ \_ -> return $ PError ErrorEOF
  (<|>) = option

instance Monad m => Monad (ParserT m) where
  return = pure
  ParserT m >>= f = ParserT $ \s -> do
    m s >>= \case
      Result s' a -> parseT (f a) s'
      PError err  -> return $ PError err

instance MonadTrans ParserT where
  lift m = ParserT $ \s -> do
    c <- m
    return $ Result s c

-- always fail on c
errorChar :: (Monad m) => Char -> ParserT m a
errorChar c = ParserT $ \_ -> return . PError $ UnknownChar c

--0 always return the same result.
constant :: (Monad m) => PResult a -> ParserT m a
constant = ParserT . const . return

-- success as long as input is not empty.
item :: (Monad m) => ParserT m Char
item = ParserT $ \xs ->
  return $
    case T.length xs of
      0 -> PError ErrorEOF
      _ -> (Result (T.tail xs) (T.head xs))

value :: (Monad m) => a -> ParserT m a
value a = ParserT $ \xs -> return $ Result xs a

satisfy :: (Monad m) => (Char -> Bool) -> ParserT m Char
satisfy pred = do
  a <- item
  if (pred a) then return a else errorChar a

char :: (Monad m) => Char -> ParserT m Char
char c = satisfy (== c)

option :: Monad m => ParserT m a -> ParserT m a -> ParserT m a
ParserT x `option` ParserT y = ParserT $ \s ->
  x s >>= \case
    t@(Result _ _) -> return t
    _              -> y s

digit :: (Monad m) => ParserT m Char
digit = satisfy isDigit

space :: (Monad m) => ParserT m Char
space = satisfy isSpace

-- cons two parser's result together
(<:>) :: (Monad m) => ParserT m a -> ParserT m [a] -> ParserT m [a]
pa <:> pxs = do
  a <- pa
  xs <- pxs
  return $ [a] ++ xs

oneOf :: (Monad m) => [Char] -> ParserT m Char
oneOf xs = satisfy (flip elem xs)

spaces1 :: (Monad m) => ParserT m String
spaces1 = some space

spaces :: (Monad m) => ParserT m String
spaces = many space

lower :: (Monad m) => ParserT m Char
lower = do
  a <- (satisfy isLetter)
  return $ toLower a

upper :: (Monad m) => ParserT m Char
upper = do
  a <- (satisfy isLetter)
  return $ toUpper a

alpha :: (Monad m) => ParserT m Char
alpha = satisfy isAlpha

thisMany :: (Monad m) => Int -> ParserT m a -> ParserT m [a]
thisMany n = (fmap $ take n) . many

natural :: (Monad m) => ParserT m Integer
natural = digit >>= \x -> return $ read [x]

string :: (Monad m) => String -> ParserT m String
string []         = return []
string t@(x : xs) = char x *> string xs *> return t

token :: (Monad m) => ParserT m a -> ParserT m a
token p = p >>= \a -> spaces >> return a

reserved :: (Monad m) => String -> ParserT m String
reserved s = token $ string s

numer :: (Monad m) => ParserT m Int
numer = do
  s <- string "-" <|> return []
  cs <- some digit
  return $ read $ s ++ cs

float :: (Monad m) => ParserT m Double
float = do
  s <- string "-" <|> return []
  cs <- some digit
  dot <- string "." <|> return []
  crs <- some digit
  return $ read $ s ++ cs ++ dot ++ crs
{-# LANGUAGE GADTs #-}

module Other.ProbabilityMonad where

import Control.Applicative
import Control.Monad (ap, liftM)
import Data.List
import System.Random hiding (uniform)

type Probability = Double

-- Probability Monad
class Monad m => ProbabilityMonad m where
  choose :: Probability -> m a -> m a -> m a

class ProbabilityMonad m => SupportMonad m where
  support :: m a -> [a]

class ProbabilityMonad m => ExpMonad m where
  expectation :: (a -> Double) -> m a -> Double

class ProbabilityMonad m => SamplingMonad m where
  sample :: RandomGen g => m a -> g -> (a, g)

-- Prob Monad type
newtype PExp a = PExp ((a -> Double) -> Double)

instance Functor PExp where
  fmap = liftM

instance Applicative PExp where
  pure = return
  (<*>) = ap

instance Monad PExp where
  return x = PExp $ \h -> h x
  (PExp d) >>= k =
    PExp $ \h ->
      let apply (PExp f) = f
          g x = apply (k x) h
       in d g

instance ProbabilityMonad PExp where
  choose p (PExp d1) (PExp d2) =
    PExp $ \h -> p * d1 h + (1 - p) * d2 h

instance SupportMonad PExp where
  support (PExp h) = undefined

instance ExpMonad PExp where
  expectation h (PExp d) = d h

instance SamplingMonad PExp where
  sample = undefined

-- generic probability monad
data P a where
  R :: a -> P a
  B :: P a -> (a -> P b) -> P b
  C :: Probability -> P a -> P a -> P a

instance Functor P where
  fmap = liftM

instance Applicative P where
  pure = return
  (<*>) = ap

instance Monad P where
  return = R
  d >>= k = B d k

instance ProbabilityMonad P where
  choose = C

instance SupportMonad P where
  support (R x) = [x]
  support (B d k) = concat [support (k x) | x <- support d]
  support (C p d1 d2) = support d1 ++ support d2

instance ExpMonad P where
  expectation h (R x) = h x
  expectation h (B d k) = expectation g d
    where
      g x = expectation h (k x)
  expectation h (C p d1 d2) =
    (p * expectation h d1)
      + ((1 - p) * expectation h d2)

instance SamplingMonad P where
  sample (R x) g = (x, g)
  sample (B d k) g =
    let (x, g') = sample d g
     in sample (k x) g'
  sample (C p d1 d2) g =
    let (x, g') = random g
     in sample (if x < p then d1 else d2) g'

-- helper functions
prob :: Bool -> Probability
prob b = if b then 1 else 0

uniform :: [a] -> P a
uniform [x] = return x
uniform ls@(x : xs) =
  let p = 1.0 / fromIntegral (length ls)
   in choose p (return x) (uniform xs)
module Other.RecursionScheme1 where

import           Control.Arrow

-- Fix Point Of Functor


-- first, a syntax tree
data Lit
  = StrLit String
  | IntLit Int
  | Ident String
  deriving (Show, Eq)

-- parameterize the occurrence of Expr itself.
-- replace Expr with a.
data Expr a
  = Index a a
  | Call a [a]
  | Unary String a
  | Binary a String a
  | Paren a
  | Literal Lit
  deriving (Show, Eq)


apply :: (a -> b) -> Expr a -> Expr b
apply f (Index e1 e2)   = Index (f e1) (f e2)
apply f (Call x xs)     = Call (f x) (fmap f xs)
apply f (Unary op x)    = Unary op (f x)
apply f (Binary x op y) = Binary (f x) op (f y)
apply f (Paren x)       = Paren (f x)
apply f (Literal l)     = Literal l


-- our syntax tree now actually is a functor.
instance Functor Expr where
  fmap = apply



{-@ Get the fix point of Expr a with Term.
    Why you want this?
    We can isolate the definition of each expression and nested
    expression.
@-}

data Term f = In (f (Term f))

-- out is a helper function to evaluate the Term f
out :: Term f -> f (Term f)
out (In t) = t

-- see in action how our new recursive type accomonate all nested combinations of
-- Expr:

n1 = let term = undefined :: Term Expr
      in out term

n2 = let term = In (Literal (IntLit 2))
      in out term

n3 = let term = In (Paren (In (Literal (IntLit 2))))
      in out term

-- ok this also works...
n4 = let term = In (Index (In (Literal (IntLit 3)))
                          (In (Paren (In (Literal (StrLit "str"))))))
      in out term

-- wow this stil works (of course!)
n5 = let term = In (Binary (In (Paren (In (Literal (IntLit 3)))))
                           "+"
                           (In (Binary (In (Binary (In (Literal (IntLit 3)))
                                           "*"
                                           (In (Literal (IntLit 10)))))
                                        "-"
                                        (In (Literal (IntLit 10))))))
      in out term

{-@ Note for Term f, f is a functor

    So Term is a fix point of the functor f.

    To generialize the traversal of the recursive data type.
    To traverse, we can roughly do these things:
    1. unpack Term to access all it's children (with the out function).
    2  recursively apply f to all children
    3. repack Term
    4. apply f to term.
@-}

bottomUp :: Functor a => (Term a -> Term a) -> Term a -> Term a
bottomUp f = out >>> fmap (bottomUp f) >>> In >>> f

flattern :: Term Expr -> Term Expr
flattern (In (Paren e)) = e
flattern other          = other

n6 = let term = In (Paren (In (Binary (In (Paren (In (Literal (IntLit 3)))))
                               "+"
                               (In (Binary (In (Binary (In (Literal (IntLit 3)))
                                               "*"
                                               (In (Literal (IntLit 10)))))
                                            "-"
                                          (In (Literal (IntLit 10))))))))
      in bottomUp flattern term

-- what about traverse the type top down?

{-@ To traverse it topdown.
    1. apply f to Term
    2. unpack Term to get children
    3. recursively apply f to it's children
    4. pack Term back
@-}

topDown :: Functor a => (Term a -> Term a) -> Term a -> Term a
topDown f = In <<< fmap (topDown f) <<< out <<< f
{-# LANGUAGE FlexibleContexts     #-}
{-# LANGUAGE ScopedTypeVariables  #-}
{-# LANGUAGE UndecidableInstances #-}
module Other.Reflections where

import           Data.Proxy
import           Data.Reflection

-- https://www.tweag.io/blog/2017-12-21-reflection-tutorial/
-- typeclass reflection.
-- use a value as a type class instance.

newtype SortedList a = Sorted [a] deriving (Show, Eq)

forget :: SortedList a -> [a]
forget (Sorted l) = l

nil :: SortedList [a]
nil = Sorted []

singleton :: a -> SortedList a
singleton a = Sorted [a]

-- The point is this version is not particularly satisfying.
-- The reason is we can't enforce the fact that value in Sorted
-- is acutallly sorted.
mergeList :: Ord a => SortedList a -> SortedList a -> SortedList a
mergeList (Sorted left) (Sorted right) = Sorted (merge' left right)
  where
    merge' :: Ord a => [a] -> [a] -> [a]
    merge' [] rs = rs
    merge' ls [] = ls
    merge' ls@(l:ls') rs@(r:rs')
      | l <= r = l : (merge' ls' rs)
      | otherwise = r : (merge' ls rs')

fromList :: Ord a => [a] -> SortedList a
fromList [] = Sorted []
fromList [a] = singleton a
fromList xs = mergeList left right
  where
    left = fromList left'
    right = fromList right'
    (left', right') = splitAt (length xs `div` 2) xs


sort :: Ord a => [a] -> [a]
sort l = forget (fromList l)

-- motivation
-- use a value as a typeclass instance

newtype ReflectedOrd s a = ReflectedOrd { unreflectOrd :: a }

reflectOrd :: Proxy s -> a -> ReflectedOrd s a
reflectOrd _ a = ReflectedOrd a

data ReifiedOrd a = ReifiedOrd
  { reifiedEq      :: a -> a -> Bool
  , reifiedCompare :: a -> a -> Ordering
  }

instance Reifies s (ReifiedOrd a) => Eq (ReflectedOrd s a) where
  (==) (ReflectedOrd x) (ReflectedOrd y) =
    reifiedEq (reflect (Proxy :: Proxy s)) x y

instance Reifies s (ReifiedOrd a) => Ord (ReflectedOrd s a) where
  compare (ReflectedOrd x) (ReflectedOrd y) =
    reifiedCompare (reflect (Proxy :: Proxy s)) x y

sortBy :: (a -> a -> Ordering) -> [a] -> [a]
sortBy ord xs =
  reify (fromCompare ord) $ \p ->
    map unreflectOrd . sort . map (reflectOrd p) $ xs

fromCompare :: (a -> a -> Ordering) -> ReifiedOrd a
fromCompare ord = ReifiedOrd
  { reifiedEq = \x y -> ord x y == EQ
  , reifiedCompare = ord
  }
{-# LANGUAGE DerivingStrategies         #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
module Other.Testing where
import           Data.Char
import           Test.QuickCheck

-- how to test these function?
-- especially we have a getChar which performs
-- side effect
--
-- Here comes another topic, how to write testable code.
-- It's node clear how to properly test this one becuase
-- side effect and pure code a tangled together.
getList' = find 5 where
  find 0 = return []
  find n = do
    ch <- getChar
    if ch `elem` ['a'..'e']
       then do
         tl <- find (n - 1)
         return (ch : tl)
       else find n

newtype Ch = Ch Char deriving newtype (Eq, Show)
-- by separating the big IO function into two smaller one, at least
-- we can test the take 5 one easily.
getList :: IO [Ch]
getList = fmap take5 $ ((fmap . fmap) Ch getContents)

take5 :: [Ch] -> [Ch]
take5 = take 5 . filter (`elem` (fmap Ch ['a'..'e']))

{-@ Testing with quickcheck
    First implement Arbitrary typeclass for data you wnat
    to simulate
@-}

instance Arbitrary Ch where
  arbitrary = Ch <$> choose ('\32', '\128')

instance CoArbitrary Ch where
  coarbitrary (Ch c) = variant (ord c `rem` 4)

-- now try to test some properties
identity = quickCheck ((\s -> s == s) :: [Ch] -> Bool)
doubleReverse = quickCheck ((\s -> (reverse . reverse) s == s) :: [Char] -> Bool)
testTake5 = quickCheck $ (<=5) . length . take5
testRightChar = quickCheck $ \s -> all (`elem` (fmap Ch ['a' .. 'e'])) (take5 s)

testTake5Verbose = verboseCheck $ (<5) . length . take5
{-# LANGUAGE DeriveFunctor              #-} {-# LANGUAGE GeneralizedNewtypeDeriving #-}

module PL.Continuation where


import           Control.Monad
import           Control.Monad.Cont
import           Data.Char
import           Data.IORef
import           Foreign.C.String      (CString, withCString)
import           Foreign.Marshal.Array (withArray0)
import           Foreign.Ptr

-- direct style
id' :: a -> a
id' a = a

{-@ continuation @-}
-- continuation passing style
idCPS :: a -> (a -> r) -> r
idCPS a cont = cont a

-- instead of return a value, pass the vlaue as an argument to the
-- continuation of the execution.

-- consider ($) :: (a -> b) -> a -> b
-- ($ 2) makes it as if we are appling a value to a function.
demo1 = map ($ 2) [(2 *), (3 *), (4 +)]

{-@ suspend computation @-}

-- f :: (a -> r) -> r
-- f is a suspend computation.
-- to complete it, we need to pass a
-- funtion with type (a -> r), which represents the continuation
-- of the current computation.

-- this function converts a value to a suspension.
newtype Suspend r a = Suspend { unSuspend :: (a -> r) -> r }
mkSuspend = Suspend . flip ($)

-- some simple examples

mysqrt :: Floating a => a -> a
mysqrt = sqrt

mysqrtCPS :: Floating a => a -> (a -> r) -> r
mysqrtCPS a k = k (sqrt a)

fact :: Integral a => a -> a
fact 0 = 1
fact n = n * fact (n - 1)

factCPS :: Integral a => a -> (a -> r) -> r
factCPS 0 k = k 1
factCPS n k = k (n * fact (n - 1))

main :: IO ()
main = print $ factCPS 10 (\a -> mysqrtCPS (fromIntegral a) id)

-- intermediate structures
multiCont :: [(r -> a) -> a] -> ([r] -> a) -> a
multiCont xs = runCont (mapM cont xs)
withCStringArray0 :: [String] -> (Ptr CString -> IO a) -> IO a
withCStringArray0 strings act =
  multiCont (map withCString strings) (\rs -> withArray0 nullPtr rs act)

-- write some functions in continuation passing style.
pythagorasCPS :: Int -> Int -> Cont r Int
pythagorasCPS x y = do
  let xsquared = x ^ 2
  let ysqyared = y ^ 2
  s <- add_cont xsquared ysqyared
  fmap floor (sqrt_cont $ fromIntegral s)
  where
    add_cont :: Int -> Int -> Cont r Int
    add_cont x y = return ((+) x y)

    sqrt_cont :: Floating a => a -> Cont r a
    sqrt_cont x = return (sqrt x)

gcdCPS :: Int -> Int -> Cont r Int
gcdCPS x y = if y == 0 then return x else do
  r <- rem_cont x y
  gcdCPS y r
  where
    rem_cont :: Int -> Int -> Cont r Int
    rem_cont x y = return (rem x y)

lcmCPS :: Int -> Int -> Cont r Int
lcmCPS x y  = do
  mul_cont x y >>=
    (abs_cont >=> \a -> do
    gcd <- gcdCPS x y
    div_cont a gcd)
  where
    abs_cont :: Int -> Cont r Int
    abs_cont x = pure ((\x -> if x >= 0 then x else negate x) x)
    div_cont :: Int -> Int -> Cont r Int
    div_cont x y = pure (div x y)
    mul_cont :: Int -> Int -> Cont r Int
    mul_cont x y = pure (x * y)

-- write it without make everthing cps.
lcmCPS' :: Int -> Int -> Cont r Int
lcmCPS' x y = do
  let m = x * y
      a = abs m
  gcd <- gcdCPS x y
  return (a `div` gcd)

{-@ continuation monad @-}
-- let's define our own continuation monad.
newtype Cont' r a = Cont' { runCont' :: (a -> r) -> r } deriving Functor

instance Applicative (Cont' r) where
  pure = return
  (<*>) = ap

instance Monad (Cont' r) where
  return = Cont' . flip ($)
  (Cont' c) >>= f = Cont' $ \k -> c (\a -> runCont' (f a) k)

{-@ callCC @-}
-- continuation monad allows us to write continuation with
-- normal order. But with monadic facilities along, we can't
-- exploit the full power of continuation: arbitrarily control the
-- flow control.
--
-- callCC helps us to do that.

squareCPC :: Int -> Cont r Int -- without callcc
squareCPC n = return (n ^ 2)

squareCC :: Int -> Cont r Int -- with callcc. Expose the current continuation out.
squareCC n = callCC $ \k -> k (n * 2)

-- callcc calls the current continuation as its argument.
class Monad m => MonadCont' m where
  callCC' :: ((a -> m b) -> m a) -> m a

instance MonadCont' (Cont' r) where
  callCC' f = Cont' $ \k -> runCont' (f (\a -> Cont' $ \_ -> k a)) k

-- how is continuation be used?
fun :: Int -> String
fun n = (`runCont` id) $ do
  str <- callCC $ \exit1 -> do            -- define exit1
    when (n < 10) (exit1 (show n))
    let ns = map digitToInt (show (n `div` 2))
    n' <- callCC $ \exit2 -> do           -- define exit2
      when (length ns < 3) (exit2 (length ns))
      when (length ns < 5) (exit2 n)
      when (length ns < 7) $
        do let ns' = map intToDigit (reverse ns)
           exit1 (dropWhile (=='0') ns')   -- escape 2 levels
      return $ sum ns

    return $ "(ns = " ++ show ns ++ ")" ++ show n'
  return $ "Answer: " ++ str

{-@ continuation monad and callCC @-}

-- use callCC allows you to decide when use k
-- early return
foo :: Int -> Cont r String
foo x = callCC $ \k -> do
  let y = x ^ 2 + 3
  when (y > 20) $ k "over twenty"
  return (show $ y - 4)


bar :: Char -> String -> Cont r Int
bar c s = do
  msg <- callCC $ \k -> do
    let s0 = c:s
    when (s0 == "Hello") $ k "They say hello"
    return ("They appear to be saying " ++ s0)
  return $ length msg

quux :: Cont r Int
quux = callCC $ \k -> do
  let n = 5
  k n
  return 25 -- this wil never be called

-- use callCC as a goto.
getCC :: MonadCont m => m (m a)
getCC = callCC (\k -> let x = k x in return x)

-- PS: no matter what, try traverse is always right.
loopyWithcallCC :: IO ()
loopyWithcallCC = do
  c <- liftIO $ newIORef (10 :: Int)
  flip runContT return $ do
    k <- getCC  -- goto
    traverse liftIO [ (putStrLn "Hello1"), modifyIORef c $ (\x -> x-1) ]
    liftIO $ putStrLn "Hello2" >> modifyIORef c (\x -> x-1)
    c' <- liftIO . readIORef $ c
    when (c' > 0) k
    liftIO . putStrLn $ "counter is zero now"
  putStrLn "Done"

{-@ Continuation for exception @-}

-- implemented with two continuations
divExcept :: Int -> Int -> (String -> Cont r Int) -> Cont r Int
divExcept x y handler = callCC $ \ok -> do
  err <- callCC $ \notok -> do
    when (y == 0) $ notok "Denominator 0"
    ok $ x `div` y
  handler err

indexExcept :: [a] -> Int -> (String -> Cont r a) -> Cont r a
indexExcept xs idx handler = callCC $ \ok -> do
  err <- callCC $ \notok -> do
    when (length xs - 1 < idx) $ notok "out of bound"
    ok $ xs !! idx
  handler err

-- more general exception handling
tryCont :: MonadCont m => ((err -> m a) -> m a) -> (err -> m a) -> m a
tryCont c h = callCC $ \ok -> do
  err <- callCC $ \notok -> do
    x <- c notok
    ok x
  h err

data SqrtException = LessThanZero deriving (Show, Eq)

sqrtIO :: (SqrtException -> ContT r IO ()) -> ContT r IO ()
sqrtIO throw = do
  ln <- lift (putStrLn "Enter a number to sqrt: " >> readLn)
  when (ln < 0) (throw LessThanZero)
  lift $ print (sqrt ln)

runSqrtIO :: IO ()
runSqrtIO = runContT (tryCont sqrtIO (liftIO . print)) return
module PL.CoroutinesWithContinuation where


import           Control.Applicative
import           Control.Monad.Cont
import           Control.Monad.State

-- ContT stacked with stateT contains suspended coroutines.
newtype CoroutineT r m a = CoroutineT
  { runCoroutineT :: ContT r (StateT [CoroutineT r m ()] m) a }

getCCs :: Monad m => CoroutineT r m [CoroutineT r m ()]
getCCs = CoroutineT $ lift get

putCCs :: Monad m => [CoroutineT r m ()] -> CoroutineT r m ()
putCCs = CoroutineT . lift . put
{-# LANGUAGE ExistentialQuantification #-}
module PL.DenotationalSem where
-- just some notes
-- denotational semantics maps haskell problem to their mathematically meaning.

-- being a purely function language makes this easier to do than imperative language,
-- as the only corner cases is to define recursive funtions.
-- Typically for imperative langauges, denotational semantics always involve some operational
-- aspects in it.

-- We have a notation for it: [[ ]]
-- e.g
-- code goes in [[]], everything outside is math.
--  [[ 2 * 5 ]] = 10
--
-- denotational semantics are compostitional:
--  [[ a + b ]] = [[a]] + [[b]]

{-@ barber's paradox and impredicative definition @-}
shaves :: Integer -> Integer -> Bool
1 `shaves` 1 = True
2 `shaves` 2 = False
0 `shaves` x = not (x `shaves` x)
_ `shaves` _ = False

-- what is this?
-- Denotational semantics must work with partial function. For shaves, domain is clearly
-- not defined for 0 0, since return type is Bool but we can never get it.
-- it doesn't halt.
_ = 0 `shaves` 0

{-@ bottom type _|_ @-}
-- Although `shaves` should return a Bool, and it is indeed well typed,
-- for input 0 0 it will never halt and we can never get the bool it promise.
-- As long as there is way to create self reference struture, every function that promise to
-- return something has the chance to fail that claim.
--
-- Thus, a type a -> Bool is not really only return two possible values True and False, there is
-- the third possiblilty that it doesn't get the result at all.
--
-- However we are doing denotational semantics for programming language, the goal is to being able
-- to define the semantics in terms of mathematical structure.
-- How do we handle this?
--
-- We add a new value called the bottom for every types in the type system.
-- A bool is not really data Bool = True | False, but rather True | False | _|_
-- The same for integer, denotationally we have |Z| + 1 elements.
--
-- Because undefined inhabited under every types, you can treat it as any type you like.
--
-- to create a instance of bottom in haskell, you use undefined. It works with type inference and
-- the type checker can work out by itself what type the bottom value inhabitate.
--
-- sides: it follows from Curry Howard isomorphism that any value of polymorphic forall a. a must
-- denote _|_
_ = undefined


-- TODO
{-# LANGUAGE GADTs      #-}
{-# LANGUAGE RankNTypes #-}
module PL.HOAS where


{-@ Higher order abstract syntax.
    A technique for implementing the lambda calculus in
    a langauge where the binders of the lambda expression
    map direcly onto lambda binders of the host language
    to give substitution machinery in custom language
    by exploiting the host language's implementation.
@-}


data ExprHOAS a where
  Con :: a -> ExprHOAS a
  Lam :: (ExprHOAS a -> ExprHOAS b) -> ExprHOAS (a -> b)
  App :: ExprHOAS (a -> b) -> ExprHOAS a -> ExprHOAS b

i :: ExprHOAS (a -> a)
i = Lam (\x -> x)

k :: ExprHOAS (a -> b -> a)
k = Lam (\x -> Lam (\_ -> x))

s :: ExprHOAS ((a -> b -> c) -> (a -> b) -> (a -> c))
s = Lam (\x -> Lam (\y -> Lam (\z -> App (App x z) (App y z))))

skk = App (App s k) k

eval :: ExprHOAS a -> a
eval (Con v)     = v
eval (Lam f)     = \x -> eval (f (Con x))
eval (App e1 e2) = (eval e1) (eval e2)


{-@ PHOAS
    A slightly different form of HOAS.
    Using lambda datatype parameterized over the binder types.
    Evaluation requires unpacking into a separate value type
    to wrap the lambda expression.
@-}

data ExprPHOAS a
  = VarP a
  | AppP (ExprPHOAS a) (ExprPHOAS a)
  | LamP (a -> ExprPHOAS a)
  | LitP Integer


data ValuePHOAS
  = Vlit Integer
  | VFun (ValuePHOAS -> ValuePHOAS)
{-# LANGUAGE RankNTypes #-}
module PL.Lam where



-- Some basic lambda calculus.


{-@ Lambda calculus (λx.x)(λy.y)

    definition of lambda expressions
      e := x      (Var) variable
           λx.e   (Lam) abstraction
           e e    (App) application

    convention for multiple parameters
      λxy.z = λx.λy.z

    A variable is bound if it is contained within the parameter of abstraction
    A variable is free if it is not bound.
    An abstraction with only bound variable is called a combinator.
      e₀ = λx.x           -- this is a combinator
      e₁ = λx.x(λy.ay)y   -- this is not a combinator

    Variables that appears multiple times are bounded by the inner most binder.
      λxy.(λxz.x+y)   -- inner x has nothing to do with outer x.
@-}

type Name = String

-- lambda calculus is really simple...
-- this can definitely benefits from gadt.
data Expr
  = Var Name
  | App Expr Expr
  | Lam Name Expr
  | Lit Lit
  deriving (Eq, Show)

-- this is not part of lambda calculus, but it's convenient shorthand.
data Lit = LInt Int
         | LBool Bool
         deriving (Eq, Show)

{-@ SKI combinator

    S = λf.λg.λx.fx(gx)
    K = λx.λy.x
    I = λx.x

    I is actually not necessary because
      SKK = (λf.λg.λx.fx(gx))(λx.λy.x)(λx.λy.x)
          = (λg.λx.((λa.λb.a))x(gx))(λx.λy.x)
          = λx.(λa.λb.a)x((λa.λb.a)x))
          = λx.(λa.λb.a)x((λa.λb.a)x))
          = λx.(λb.x)(λb.x)
          = λx.(λb.x)(x)
          = λx.x
          = I
          ∎

    ω combinator ω = λx.xx
      let Ω = ωω, we find the result is a infinite chain of omega.
      many statically typed typesystem will reject this term fro being well formed.
      It's useful for testing the validity of the typesystem.
@-}

-- define some ski combinator
s f g x = f x (g x)
k x _ = x
i = s k k

-- ω is rejected by the type system.

{-@ Rules of lambda calculus

    * Substitution

      (λx.e)a → [x/a]e

      The notation means application is simply replace
      all occurences of x in expression e with a.

    * Name capturing.
      One of the biggest bummber of lambda calculus is the
    for example:

      [y/x](λy.yx) → λx.xx

      this is not correct. Because you cannot just replace y to x since
      x alreay means a free variable.

    * Solution of name capturing
      use capture-avoiding substitution.
      Ban substitute to the same name as free variable

        (λx.e)a → [x/a]e | x ∉ fv(e)

    * Conversion and Equivalences
        * Alpha equivelance.
                 α
          (λx.e) = (λy.[x/y]e)

          Simply replace variable on the binder and the body of expression
          will not change the meaning ofthe expression.

        * Beta reduction
                  β
          (λx.a)y → [x/y]a
          Perform substitution once.

        * Eta reduction
                  η
          (λx.e)x → e if x ∉ fv(e)
          Get rid of the useless parameter.
@-}


{-@ Scott Encoding: A way to encode algebraic data type in lambda calculus.

    We can encode data in the parameter and use them as a record
    c represents constructor.
    We can also have a function takes different record types to represent sum types.
@-}

-- simulate records.
record1 = \a -> \con -> con a
record2 = \a b -> \con -> con a b
record3 = \a b c -> \con -> con a b c
record4 = \a b c d -> \con -> con a b c d


-- like record type above.
newtype PairS a b = PairS { unPairS :: forall r. (a -> b -> r) -> r }

-- p is the constructor of the pair
pairS :: a -> b -> PairS a b
pairS a b = PairS (\p -> p a b)

fstS :: PairS a b -> a
fstS (PairS p) = p (\a _ -> a)

sndS :: PairS a b -> b
sndS (PairS p) = p (\_ b -> b)

swapS :: PairS a b -> PairS b a
swapS (PairS p) = PairS (p . flip)

-- peano number
-- Maybe the simplest sum type.

newtype NumS = NumS { unNums :: forall r. (NumS -> r) -> r -> r}

zeroS :: NumS
zeroS = NumS (\_ b -> b)

succS :: NumS -> NumS
succS n = NumS (\s _ -> s n)

unnumS :: (NumS -> r) -> r -> NumS -> r
unnumS s z (NumS f) = f s z

isZero :: NumS -> Bool
isZero = unnumS (\_ -> False) True

addS :: NumS -> NumS -> NumS
addS n m = unnumS (\s -> succS (addS s m)) m n


-- list
newtype ListS a = ListS { unconsS :: forall r. (a -> ListS a -> r) -> r -> r }

nilS :: ListS a
nilS = ListS (\_ b -> b)

consS :: a -> ListS a -> ListS a
consS a l = ListS (\f _ -> f a l)

carS :: (a -> ListS a -> r) -> r -> ListS a -> r
carS co ni (ListS f) = f co ni
{-# LANGUAGE LambdaCase          #-}
{-# LANGUAGE Rank2Types          #-}
{-# LANGUAGE RankNTypes          #-}
{-# LANGUAGE ScopedTypeVariables #-}

module PL.ScottEncoding where


-- Scott encoding.
-- You can use functions to encode algebraic data types.
-- So if you have function you don't really need
-- anything else.
-- With scott encoding you can even express algebraic data types
-- in c++.


import           Prelude hiding (concat, curry, foldl, foldr, fst, length, map,
                          null, snd, take, zip, (++))


newtype SMaybe a = SMaybe { runMaybe :: forall b. b -> (a -> b) -> b }
newtype SList a = SList { runList :: forall b. b -> (a -> SList a -> b) -> b }
newtype SEither a b = SEither { runEither :: forall c. (a -> c) -> (b -> c) -> c }
newtype SPair a b = SPair { runPair :: forall c. (a -> b -> c) -> c }

toPair :: SPair a b -> (a,b)
toPair (SPair f) = f (,)

fromPair :: (a,b) -> SPair a b
fromPair (a, b) = SPair (\f -> f a b)

fst :: SPair a b -> a
fst (SPair f) = f const

snd :: SPair a b -> b
snd (SPair f) = f (const id)

swap :: SPair a b -> SPair b a
swap (SPair f) = SPair (f . flip)

curry :: (SPair a b -> c) -> (a -> b -> c)
curry f = \a b -> f (SPair (\f' -> f' a b))

uncurry :: (a -> b -> c) -> (SPair a b -> c)
uncurry f = \(SPair f') -> f' f

toMaybe :: SMaybe a -> Maybe a
toMaybe (SMaybe f) = f Nothing Just

fromMaybe :: Maybe a -> SMaybe a
fromMaybe = \case
  Just a  -> (SMaybe (\_ g -> g a))
  Nothing -> (SMaybe const)

isJust :: SMaybe a -> Bool
isJust (SMaybe f) = f False (const True)

isNothing :: SMaybe a -> Bool
isNothing = not . isJust

catMaybes :: SList (SMaybe a) -> SList a
catMaybes (SList f) = f nil' (\(SMaybe f') l ->
  let rest = (catMaybes l)
   in f' rest (flip cons rest))

toEither :: SEither a b -> Either a b
toEither (SEither f) = f Left Right

fromEither :: Either a b -> SEither a b
fromEither = \case
  Right r -> (SEither (\_ b -> b r))
  Left l  -> (SEither (\a _ -> a l))

isLeft :: SEither a b -> Bool
isLeft (SEither f) = f (const True) (const False)

isRight :: SEither a b -> Bool
isRight = not . isLeft

partition :: SList (SEither a b) -> SPair (SList a) (SList b)
partition (SList f) = f (SPair (\f' -> f' nil' nil'))
  (\(SEither e) l' ->
    let SPair p = partition l'
     in p (\la lb ->
       e (\a -> (SPair (\f' -> f' (cons a la) lb)))
         (\b -> (SPair (\f' -> f' la (cons b lb))))))

toList :: SList a -> [a]
toList (SList f) = f [] (\a l -> a : toList l)

fromList :: [a] -> SList a
fromList = \case
  []     -> nil'
  (x:xs) -> cons x (fromList xs)

nil' :: SList a
nil' = (SList (\b _ -> b))

cons :: a -> SList a -> SList a
cons a b = SList (\_ f -> f a b)

concat :: SList a -> SList a -> SList a
concat (SList f) l = f l (\a l' ->
  cons a (concat l' l))

null :: SList a -> Bool
null (SList f) = f True (const . const False)

length :: SList a -> Int
length (SList f) = f 0 (\_ l -> 1 + (length l))

map :: (a -> b) -> SList a -> SList b
map f (SList la)= la nil' (\a l -> cons (f a) (map f l))

zip :: SList a -> SList b -> SList (SPair a b)
zip (SList la) (SList lb) = la nil' (\a l ->
  lb nil' (\b l' ->
    cons (SPair (\f -> f a b)) (zip l l')))

foldl :: (b -> a -> b) -> b -> SList a -> b
foldl f b l = foldr (\b g a -> g (f a b)) id l b

foldr :: (a -> b -> b) -> b -> SList a -> b
foldr f b  (SList l) = l b (\a l' -> f a (foldr f b l'))

take :: Int -> SList a -> SList a
take n (SList l) = l nil'
  (\a l' ->
    case n of
      0 -> nil'
      _ -> cons a (take (n - 1) l'))
module PL.TypesAndAbstractInterpretation where

-- http://okmij.org/ftp/Haskell/AlgorithmsH.html#teval
-- http://okmij.org/ftp/Computation/FLOLAC/lecture.pdf


{-# LANGUAGE DeriveFunctor              #-}
{-# LANGUAGE DerivingStrategies         #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE TypeFamilies               #-}

module Types.Cardinality where

{-@ 1. the algebra behind type @-}

-- what's the cardinaltity?
data Void'  -- 0

data Unit = Unit () -- 1

-- this function will never be actually called, because there is
-- no data for type Void'
absurd :: Void' -> a
absurd = undefined

-- two types with the same cardialitieswll always be isomorphic to each other.
class Isomorphism s t where
  to :: s -> t
  from :: t -> s


-- from . to = id, to . from = id
data Spin = Up | Down

instance Isomorphism Spin Bool where
  to Up   = True
  to Down = False
  from True  = Up
  from False = Down


-- if cardinality == n, there are n! Isomorphisms!

-- cardinarlity and sumtype, product type
-- |Either a b| = |a| + |b|
-- |(a, b) = |a| * |b|
-- |Maybe a| = |a| + 1

{-@ prove some truth @-}
-- a x 1 = a
prodUnitTo :: a -> (a, ())
prodUnitTo a = (a, ())

prodUnitFrom :: (a, ()) -> a
prodUnitFrom (a, _) = a

-- a + 0 = a
sumUnitTo :: Either a Void' -> a
sumUnitTo (Left a)  = a
sumUnitTo (Right v) = absurd v

sumUnitFrom :: a -> Either a Void'
sumUnitFrom = Left

-- function a -> b has cardinality |b| ^ |a|
-- for Bool -> Bool, we have the cardinality = |2| ^ |2| = 4.
-- You can think a -> b as give a with |a|, for each a' \in a
-- there are a b` \in |b| s.t a' -> b' is a value of the type.
-- here are four possible inhabinants of the type:
id' :: Bool -> Bool
id' True  = True
id' False = False

not' :: Bool -> Bool
not' True  = False
not' False = True

constTrue = const True
constFalse = const False

-- |Either Bool (Bool, Maybe Bool) -> Bool|
-- =  2 + (2*2 + 1)^2 = 27
{-# LANGUAGE DataKinds             #-}
{-# LANGUAGE FlexibleInstances     #-}
{-# LANGUAGE GADTs                 #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE PolyKinds             #-}
{-# LANGUAGE TypeFamilies          #-}
{-# LANGUAGE TypeOperators         #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE KindSignatures #-}
module Types.DataKinds where

-- promote data to type.

import           Data.Proxy
import           GHC.TypeLits

data TypeList l where
  Nil :: TypeList '[]
  (:::) :: a -> TypeList l -> TypeList (a ': l)

infixr :::

-- >>> 1 ::: "Hello" ::: 1.1 :: TypeList '[Int, String, Double]

type family Param f :: [*] where
  Param (a -> f) = a ': Param f
  Param r = '[]

type family Result f :: * where
  Result (a -> f) = Result f
  Result r = r

class (Param f ~ l, Result f ~ r) => ToTypeList f l r where
  translate :: f -> TypeList l -> r

instance (ToTypeList f l r) => ToTypeList (a -> f) (a ': l) r where
  translate f (a ::: l) = translate (f a) l

instance (Param f ~ '[], Result f ~ r, f ~ r) => ToTypeList f '[] r where
  translate r Nil = r

-------------------------------------------------------------------------------

newtype Pointer (align :: Nat) = Pointer Integer deriving Show

zeroPtr :: Pointer n
zeroPtr = Pointer 0

inc :: Pointer align -> Pointer align
inc (Pointer n) = Pointer (n + 1)

-- get the actual pointer value.
ptrValue :: forall align. KnownNat align => Pointer align -> Integer
ptrValue (Pointer p) = p * natVal (Proxy :: Proxy align)

n1 = ptrValue (inc $ zeroPtr :: Pointer 4)
n2 = ptrValue (inc $ zeroPtr :: Pointer 8)
n3 = ptrValue ((inc . inc . inc) $ zeroPtr :: Pointer 16)

-- check if a given integer is a properly aligned pointer
maybePtr :: forall align. KnownNat align => Integer -> Maybe (Pointer align)
maybePtr p
  | remainder == 0 = Just (Pointer quotient)
  | otherwise = Nothing
  where
    (quotient, remainder) = divMod p (natVal (Proxy :: Proxy align))

n4 = maybePtr 24 :: Maybe (Pointer 8)
n5 = maybePtr 100 :: Maybe (Pointer 12)
n6 = maybePtr 120 :: Maybe (Pointer 13)
{-# LANGUAGE TypeOperators #-}

module Types.DataTypeALaCarte where

-- http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf

-- assembling both data types and functions from isolated individual components
-- a way to solve the expression problem.

-- adt has the opposite problem of subtyping --
data Expr' = Val' Int | Add' Expr' Expr'
-- to add a type constructor we need to add a corresponding case for every functions.

eval :: Expr' -> Int
eval (Val' x)   = x
eval (Add' x y) = eval x + eval y

render :: Expr' -> String
render (Val' x)   = show x
render (Add' x y) = show (eval x + eval y)

{-@ data a la carte @-}

-- use coproduct to combine two data constructors.
data (f :+: g) e = Inl (f e) | Inr (g e)

data Expr f = In (f (Expr f))

data Val e = Val Int
data Add e = Add e e

-- add example
addEx :: Expr (Val :+: Add)
addEx = In (Inr (Add
                  (In (Inl (Val 188)))
                  (In (Inl (Val 1219)))))

-- but how do you evaluate this thing??

-- first realize all data types above are functors.
instance Functor Val where
  fmap _ (Val x) = Val x

instance Functor Add where
  fmap f (Add e1 e2) = Add (f e1) (f e2)

instance (Functor f, Functor g) => Functor (f :+: g) where
  fmap f (Inl e1) = Inl (fmap f e1)
  fmap f (Inr e2) = Inr (fmap f e2)

-- because they are all functors, we can fold an Expr as follow:
foldExpr :: Functor f => (f a -> a) -> Expr f -> a
foldExpr f (In t) = f (fmap (foldExpr f) t)
{-# LANGUAGE DeriveGeneric              #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE KindSignatures             #-}
{-# LANGUAGE TypeOperators              #-}
module Types.DataTypeGenericProgramming where


{-@ Map datatypes to equivalent representation
    do some operations on the representation
    map back.

    e.g map a sum type to A :+: B, which can be representated as one single
        type. Then pattern match on each branch.

    advantage: works on anyshape, because the mapping is automatic.
@-}

-- the SYB (scraping your boilerplates) style datatype generic programming
import           Data.Data     as D
import           Data.Typeable as T

-- the new Generic programming library with less overhead.
import           GHC.Generics  as G

-- first we can define some combinators to represent datatypes.
data I r = I r
data K a r = K a
data U r = U    -- unit. constructor with no arguments
data (f :+: g) r = L (f r) | R (g r)
data (f :*: g) r = f r :*: g r
data Fix (f :: * -> *) = In (f (Fix f))

instance Functor (K a) where
  fmap _ (K a) = K a

instance Functor I where
  fmap f (I a) = I (f a)
{-# LANGUAGE DataKinds             #-}
{-# LANGUAGE DerivingStrategies    #-}
{-# LANGUAGE GADTs                 #-}
{-# LANGUAGE KindSignatures        #-}
{-# LANGUAGE PartialTypeSignatures #-}
{-# LANGUAGE TypeFamilies          #-}
{-# LANGUAGE TypeOperators         #-}
{-# LANGUAGE UndecidableInstances  #-}

module Types.DependentType where

{-@ Four capabilities of dependent type systems.
    1. Type camputation
        - program the type checker.
    2. Indexed types
        - type indices constrain values and guide
          computation
    3. Double-duty data
        - using both data in the type indicies and runtime
        - quantify a type parameter with PI, and you can
          get the type in the term level. This is what dependent
          type brings.
        - singleton is used to simulate pi type.
    4. Equivalcne proof
@-}

-- A super short primer.

{-@ Dependent vector with vector length in type.
@-}

-- Do we need this? Nat is already a kind in haskell I think
data Nat = Zero | Succ Nat deriving stock (Eq, Show)


{-@ Now define the vector
    Vector :: Nat -> * -> *. The Nat part is where we encode the length.
    The syntax (n :: Nat) is enabled by KindSignatures.
    Note we are using the promoted data constructor as types now.
@-}


data Vector (n :: Nat) a where
  Nil :: Vector Zero a
  Cons :: a -> Vector n a -> Vector (Succ n) a

instance Show a => Show (Vector n a) where
  show Nil         = "Nil"
  show (Cons x xs) = "Cons " ++ show x ++ "(" ++ show xs ++ ")"

{-@ now some type level operations.
    how do you express m + n in the following vector type?

    We don't know yet. With PartialTypeSignatures, I can put a _hold there
    to indicate it could be anything.
@-}

append' :: Vector n a -> Vector m a -> Vector ((_ :: Nat) :: Nat) a
append' = undefined

type family Add n m where
  Add 'Zero m = m
  Add ('Succ n) m = 'Succ (Add n m)

{-@ Very sadly, if you change the order of m and n, or change the order
    of succ in the above type family, you get type error.
    GHC cann't infer if two types are the same...
    And apparently this is the next step people working towards.
@-}

append :: Vector n a -> Vector m a -> Vector (Add n m) a
append Nil ys         = ys
append (Cons x xs) ys = Cons x (append xs ys)

{-@ Ok that's lame. But let's do something else.
    You can use symbols like normal haskell list syntax at type level with
    TypeOperators
@-}

data HList xs where
  HNil :: HList '[]
  (:::) :: a -> HList as

infix 6 :::
{-# LANGUAGE DeriveAnyClass            #-}
{-# LANGUAGE DeriveGeneric             #-}
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE GADTs                     #-}
{-# LANGUAGE LambdaCase                #-}
{-# LANGUAGE RankNTypes                #-}
{-# LANGUAGE StandaloneDeriving        #-}
module Types.Ex where

import           Control.Monad
import           Control.Monad.ST
import           Data.Foldable
import           Data.IORef
import           Data.STRef
import           GHC.Generics

-- Don't use existential type, just use GADT.
-- we can just hide type behind the type
data WrappedDynValue where
  Wrap :: Show a => a -> WrappedDynValue

deriving instance Show WrappedDynValue

n1 = fmap (\(Wrap x) -> show x) [Wrap "123", Wrap 1]

{-@ extential types
    some level of type erasure.
    You know there is a type, but you don't know what it eactly is.

    T

    first we have universal type ∀.

    ∀x.t means for all type x we have t. Here we don't have any assumption
    of x, so this type should work for every x.

    existential type is the dual of universal type. We say
    ∃x.t, meaning exists a type x such that y.

    existential quantifier type can be encoded with universal quantifier:
    ∃x.t ≡ ∀y.(∀x.t → y) → y

@-}

-- We say there exists a value E such that E -> E.
data E = forall a. E a
ide :: E -> E
ide x = x


-- for all types s that's in Show, there exists SB s.t SB s :: *
data ShowBox = forall s. Show s => SB s

instance Show ShowBox where
  show (SB s) = show s

heterList :: [ShowBox]
heterList = [SB 1, SB True, SB "good"]

printShowboxes :: [ShowBox] -> IO ()
printShowboxes = mapM_ print

-- this is an any type
-- it just takes all types.
-- for all types a, exists All a
data AllBox = forall a. All a

-- forall can be thought of find the commonality of different types.
-- Note bottom is a member of all types!
-- So we are saying for the commonality of all types, we have All a
-- => The only commanlity of all types is they have bottom time as a member.
-- => All types are part of All a
anylist = [All 1, All "asd", All heterList]

-- why we need a box anyway?
-- see this
-- [forall a. a]  a list of forall a, the common types of all a, so... [_|_]
-- [forall a. Show a => a]  list of forall a that is part of Show, the common type of them. So [_|_]
-- [forall a. Num a => a] list of all a that's part of Num a, the common type of them. So [_|_]

-- but This is different:
data T = forall a. MkT a
-- type of MkT :: forall a. a -> T
-- a list allows any types, but we can't do anything to it because types
-- are forall a. a
tlist = [MkT (), MkT "asd", MkT 12]

data G = forall a. (Num a, Show a) => MkG a
-- type of MkG :: a. (Num a, Show a) => MkG a
-- Now we can do something based on the type constraint.
glist = [MkG 1, MkG 1.2]

{-@ The biggest application: RankNType with runST @-}

-- runST :: (forall s. ST s a) -> a
-- the state cannot escape the ST action, so runST constraint the
-- effect within the scope.
localMut :: Int -> Int
localMut n = runST $ do
  ref <- newSTRef n
  modifySTRef' ref (+1)
  readSTRef ref

-- define pair with universal quantification
newtype Pair a b = Pair (forall c. (a -> b -> c) -> c)

makePair :: a -> b -> Pair a b
makePair a b = Pair $ \f -> f a b

-- some other examples --
class Buffer a where
  flush :: a -> a
  read :: Int -> a
  write :: Int -> a

data Object = forall a. Object a
data Ordered = forall a. Ord a => Ordered a

-- note 1. no way to have specific b for Worker
-- note 2. no need to worry about monomorphization restriction.
-- note 3. you can only work with buffer interface, you can't use
--         specific type anymore.
data Worker x y = forall a. Buffer a => Worker { buffer :: a
                                               , input  :: x
                                               , output :: y
                                               }
workerFoo :: Buffer b => b -> Worker Int Int
workerFoo b = Worker b 10 10

-- need existential type because b doesn't presnt on Val branch.
data Expr a = Val a | forall b. Apply (Expr (b -> a)) (Expr b)

-- need exitential type to make sure the io ref is the one used in the closure.
data Action = forall b. Act (IORef b) (b -> IO ())

{-@ miminic dynamic dispatching @-}

class Shape_ a where
  perimeter :: a -> Double
  area :: a -> Double

data Shape = forall a. Shape_ a => Shape a

type Radius = Double
type Side = Double

data Circle = Circle Radius
data Rectangle = Rectangle Side Side
data Square = Square Side

instance Shape_ Circle where
  perimeter (Circle r) = 2 * pi * r
  area (Circle r) = pi * r * r

instance Shape_ Rectangle where
  perimeter (Rectangle x y) = 2 * (x + y)
  area (Rectangle x y) = x * y

instance Shape_ Square where
  perimeter (Square s) = 4 * s
  area (Square s) = s * s

instance Shape_ Shape where
  perimeter (Shape shape) = perimeter shape
  area (Shape shape) = area shape

c1 = Circle 10.1
r1 = Rectangle 10.1 10.1
s1 = Square 12

shapes :: [Shape]
shapes = [Shape c1, Shape r1, Shape s1]

perimeters = perimeter <$> shapes
areas = area <$> shapes

-- alternative method --
type Point = (Float, Float)

-- exmaple use case in raytracer--
class BoundingShape_ a where
  volume :: a -> Double

data BoundingShape = forall a. BoundingShape_ a => BoundingShape a

data BoundingBox = BoundingBox Double Double Double deriving Show
data BoundingSphere = BoundingSphere Double deriving Show

instance BoundingShape_ BoundingBox where
  volume (BoundingBox x y z) = x * y * z

instance BoundingShape_ BoundingSphere where
  volume (BoundingSphere r) = (4 * pi * r^3) / fromIntegral 3

type Fragment = Double

-- use bounding sphere
class Renderable a where
  boundingSphere :: a -> BoundingSphere
  hit :: a -> [Fragment]

-- hide all renderable behind AnyRenderable. Now we can but all renderable into one
-- container and render all of them together.
data AnyRenderable = forall a. Renderable a => AnyRenderable a

instance Renderable AnyRenderable where
  boundingSphere (AnyRenderable a) = boundingSphere a
  hit (AnyRenderable a) = hit a

data Cube3D = Cube3D Double Double Double
data Ball3D = Ball3D Double

-- implementation doesn't really matter here.
instance Renderable Cube3D where
  boundingSphere (Cube3D x y z) = BoundingSphere (maximum [x, y, z])
  hit (Cube3D x y z) = [x, y, z]

instance Renderable Ball3D where
  boundingSphere (Ball3D r) = BoundingSphere r
  hit (Ball3D r) = [r, 1, 2, 3]

objsToRender = [ AnyRenderable (Cube3D 1 2 3)
               , AnyRenderable (Cube3D 2 3 4)
               , AnyRenderable (Ball3D 39)
               , AnyRenderable (Ball3D 23)
               ]

render1 = boundingSphere <$> objsToRender
render2 = hit <$> objsToRender


{-@ Another exercise @-}
class Animal_ a where
  move :: a -> IO ()

data Animal = forall a. Animal_ a => Animal a
instance Animal_ Animal where
  move (Animal a) = move a

class Animal_ a => Cat_ a where
  meow :: a -> IO ()

data Cat = forall a. Cat_ a => Cat a
instance Animal_ Cat where
  move (Cat a) = move a
instance Cat_ Cat where
  meow (Cat a) = meow a

class Animal_ a => Dog_ a where
  bark :: a -> IO ()
data Dog = forall a. Dog_ a => Dog a

instance Animal_ Dog where
  move (Dog a) = move a
instance Dog_ Dog where
  bark (Dog a) = bark a

data Persian = Persian
instance Animal_ Persian where
  move _ = putStrLn "Persian the cat: Moving"
instance Cat_ Persian where
  meow _ = putStrLn "Persian the cat: Meow"

data Corgi = Corgi
instance Animal_ Corgi where
  move _ = putStrLn "Corgi the dog: Moving"
instance Dog_ Corgi where
  bark _ = putStrLn "Corgi the dog: woof woof"

persian = Persian
corgi1 = Corgi
corgi2 = Corgi

moveAnimals = sequence_ $ move <$>  [Animal persian, Animal corgi1, Animal corgi2]
moveDogs = sequence_ $ bark <$> [Dog corgi1, Dog corgi2]

{-@ One can use GADT for existential type @-}

-- exists a
data U where
  U :: a -> (a -> String) -> U
foou :: U -> String
foou (U x f) = f x

-- is the sam as
data V = forall a. V a (a -> String)
foov :: V -> String
foov (V x f) = f x

-- another example
data ExType
  = forall a. Animal_ a => One a
  | forall a. Animal_ a => Two a
  | forall a. Animal_ a => Three a

data ExType' where
  One' :: forall a. Animal_ a => a -> ExType'
  Two' :: forall a. Animal_ a => a -> ExType'
  Three' :: forall a. Animal_ a => a -> ExType'

-- we hide different Animal_ a behind ExType', and put them in to one
-- bucket, perform operation based on the type bound.
-- We don't know what type we are acting one for the entire process.
-- We only know there exists such type, and it's an Animal_ that we can
-- let it move.
--
-- Note this version is expressed in GADT. GADT is generally better syntax.
-- Then existential quantifier.
ex1 :: [ExType'] -> IO ()
ex1 = traverse_ match
  where
    match = \case
      One' x   -> move x
      Two' x   -> move x
      Three' x -> move x
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE StandaloneDeriving        #-}
{-# LANGUAGE TemplateHaskell           #-}
module Types.ExSubTyping where

-- mimic subtyping with typeclass constraint and existential type.
-- need more work to simulate shared state though.
class WidgetC a where
  wHeight :: a -> Double
  wWidth :: a -> Double

class WidgetC a => LabelWidgetC a where
  lblName :: a -> String

-- define some extensial types.
data W = forall a. (WidgetC a) => W a
data LabelW = forall a. LabelWidgetC a => LabelW a

-- implemnet instances
data Widget = Widget { w :: Double, h :: Double }
data LabelWidget = LabelWidget
  { lw        :: Double
  , lh        :: Double
  , labelName :: String
  }

-- for wrapper types -->
instance WidgetC W where
  wHeight (W w) = wHeight w
  wWidth (W w) = wWidth w

instance WidgetC LabelW where
  wHeight (LabelW w) = wHeight w
  wWidth (LabelW w) = wWidth w

instance LabelWidgetC LabelW where
  lblName (LabelW w) = lblName w
-- <---

-- for concrete types --->
instance WidgetC Widget where
  wHeight widget = h widget
  wWidth widget = w widget

instance WidgetC LabelWidget where
  wHeight lbl =  lh lbl
  wWidth lbl = lw lbl

instance LabelWidgetC LabelWidget where
  lblName lbl = labelName lbl
-- <---

getSize ::  W -> (Double, Double)
getSize (W w) = (wWidth w, wHeight w)

a = getSize (W $ Widget 10 10)
b = getSize (W $ LabelWidget 10 30 "label_1")
-- a (10.0, 10.0), b (10.0, 30.0)

-- dynamic dispatch  --
-- Extension started with [x] means it's already adopted in GHC2021, which means
-- it's stable to use and works well with the rest of haskell type system.
-- A lot of extensions are just necessary to write haskell today, the reason they are
-- extension is just because it's the way haskell adding new features.
-- At some point when the number of extensions exploded the committee will do something
-- to offically merge common features into GHC.

-- Promotes term level values into types, and type level values into kinds.
{-# LANGUAGE DataKinds                #-}

-- [x] Allows you to give different names for kinds instead of * only.
{-# LANGUAGE PolyKinds                #-}

-- [x] Allows you to pass polymorphic functions around.
{-# LANGUAGE RankNTypes               #-}

-- [x] Specify type variable based on constructors.
--     also a better syntax for exitential types.
{-# LANGUAGE GADTs                    #-}

-- Allow type variable to be referred under the scope of where it's declared.
{-# LANGUAGE ScopedTypeVariables      #-}

-- Allow you to write the kind signature of a single type.
{-# LANGUAGE KindSignatures           #-}

-- [x] Allow you to write the full kind signature of a type for a type declaration.
{-# LANGUAGE StandaloneKindSignatures #-}

-- [x] Allows you to specify the type of typeclass constriant by passing a type as
--     a extra paramter. The type parameter is written as @Type. --
--     visible type application --
{-# LANGUAGE TypeApplications         #-}

-- Type level function.
{-# LANGUAGE TypeFamilies             #-}

-- [x] Allows type level operators like ':
{-# LANGUAGE TypeOperators            #-}

-- Instance declaration must follows some rules to ensure it terminates. If we remove the
-- restriction to force a declaration should always terminate, we have this extension.
-- might cause non terminated type checking --
--
-- So the problem is in what case a instance is undicidable?
--  1. Paterson condition
--  2. Coverage condition
-- The core is still induction. You want to make sure each reduction step makes the problem
-- smaller by at least on constructor so we can guarantee it terminates.
{-# LANGUAGE UndecidableInstances     #-}

-- [x] Allow the use of complex constraints in class declaration.
--     Context might mean typeclass constraints on type variables of the class or of class
--     functions.
--     With this extension on, the only restriction on class hierarchy is it should be
--     acyclic (acyclic only on the superclass relation).
{-# LANGUAGE FlexibleContexts         #-}

-- [x] Allow definition of type class instances with arbitrary nested types in the instance head.
--     With this extension you can mention concrete type in the instance head.
{-# LANGUAGE FlexibleInstances        #-}

{-# LANGUAGE TypeSynonymInstances     #-}

{-# LANGUAGE AllowAmbiguousTypes      #-}

-- Allow you to define typeclasses based on multiple paramters.
-- it's an example of multi dispatch in haskell.
{-# LANGUAGE MultiParamTypeClasses    #-}

{-# LANGUAGE InstanceSigs #-}
module Types.ExtensionsOnTypes where

import           Data.Kind
import           Data.Proxy
import           GHC.Generics
import           GHC.TypeLits

import           Control.Monad.Trans

-- allowed by FlexibleContexts
class A cls c
class A B c => B c

-- allowed by FlexibleInstances
data A' a
class C' m
instance C' (A' Int)

-- allowed by TypeSynonymInstances + FlexibleInstances
type Point = (Int, Int)
instance C' Point

type Vector3 a = (Int, Int, Int, a)
instance (Monoid (m a), Monad m) => C' (Vector3 (m a))

-- normal higher kinded type paramter.
class C'' (m :: * -> *)
instance C'' A'
{-# LANGUAGE FunctionalDependencies     #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE RankNTypes                 #-}
{-# LANGUAGE TypeFamilies               #-}
{-# LANGUAGE TypeSynonymInstances       #-}

{-# LANGUAGE AllowAmbiguousTypes        #-}
{-# LANGUAGE FlexibleInstances          #-}

{-# LANGUAGE KindSignatures             #-}
{-# LANGUAGE UndecidableInstances       #-}
module Types.FD where

import           Control.Monad.Reader
import           Control.Monad.State
import           Control.Monad.Trans

class Coll c e | c -> e where
  empty :: c
  insert :: c -> e -> c
  member :: c -> e -> Bool


-- [a] determines e should be a.
instance Eq a => Coll [a] a where
  empty = []
  insert xs a = a : xs
  member xs e = e `elem` xs

-- type checker infer to c -> e -> e -> c instead of c -> e1 -> e2 -> c
ins2 xs a b = insert (insert xs a) b

-- without functional dependencies even with same c in the context we can't say
-- what type e will be, so you can only assume different instances of e are different types.
class Coll' c e where
  empty' :: c
  insert' :: c -> e -> c
  member' :: c -> e -> Bool


{-@ Undecidable instance ?

    - It's commonly needed for multiparamter typeclass when recurse on the non functional
    dependend part.

    - Haskell wants all instance to be decidable by default, but in lots' of cases it's just
    not possible.

@-}

-- Bad example:

-- class MonadIO' (m :: * -> *) where
--   liftIO' :: IO a -> m a

-- this is an example of a generic instance for all MonadIO of type (t :: (* -> *) -> * -> *)
-- and m :: * -> *.
-- It works for all instances with (t m) being a monad, t being a monad trans and m being a
-- MonadIO.


-- PROBLEM of this instance --
--    1. overlapping
--        It's too generic and exlucde people implementing instance with the same shape.
--    2. undecidable instance
--        It's undecidable because constraint (Monad (t m)) has the same type parameter
--        as (MonadIO (t m)), no constructor is removed. Haskell requires constraint
--        of instance at least remove one type constructor to make sure it's smaller
--        than the instance head.
instance (Monad m, Monad (t m), MonadIO m, MonadTrans t) => MonadIO (t m) where
  liftIO = lift . liftIO

data SomeEnv = SomeEnv
  { v1 :: Int
  , v2 :: String
  , v3 :: forall a. [(String, a)]
  }

data Rec = Rec
  { intList    :: [(String, Int)]
  , stringList :: [(String, String)]
  }

-- now let's make an arbitray transformer stack.
newtype MTStack m a = MTStack { unMTStack :: ReaderT SomeEnv (StateT Rec m) a }
  deriving (Functor, Applicative, Monad, MonadReader SomeEnv, MonadState Rec)


instance MonadTrans MTStack where     -- still need to make MTStack a monad transformer.
  lift ma = MTStack $ do
    a <- lift . lift  $ ma
    return a

-- This will be an overlapping instance! Because the generic isntance defined above already
-- can be applied to MTStack m a.
-- instance MonadIO (MTStack IO) where
--   liftIO = lift . liftIO

foo :: MTStack IO ()
foo = do
   v <- v1 <$> ask
   liftIO $ putStrLn "asd"
   return ()


{-@ Why UndecidableInstances is usually needed for MPTC and FD?
@-}

-- first try define a mtl style MonadState.
-- It's a MPTC with function dependency, it says given monad m, the state of
-- MonadState is uniquely defined to be s.
class Monad m => MonadState' s m | m -> s where
  get' :: m s
  get' = state' (\s -> (s, s))

  put' :: s -> m ()
  put' s = state' (\_ -> ((), s))

  state' :: (s -> (a, s)) -> m a
  state' f = do
    s <- get'
    let (a, s') = f s
    put' s
    return a

-- Next we make an instance of MonadState for ReaderT

-- According to haskell's standard, this is undecidable instance
-- A decidable instance needs to have a smaller constraint than then instace head.
-- All constraints should at least eliminate one type constructor, so by induction haskell
-- knows the instances for sure terminates.
--
-- Because MonadState is MPTC, our instance only eliminates constructor of (ReaderT e m)
-- but not on s, so it's undecidable.
--
-- But it's really decidable because s is determined by m, so if m is shrinking it doesn't
-- matter what s is since it's a function of m.
--
-- So in these case it's ok to use undecidable instances.
--
instance MonadState' s m => MonadState' s (ReaderT e m)
-- this instance uses default implementation:


{-@ UndecidableInstance is also ok when you're using typeclass as alias of several
    Smaller constraints.
@-}

class Foo a
class Bar a
class (Foo a, Bar a) => FooBar a


{-@ We can replace FD with type family. This way we don't need to show the
    function dependency in the instance context, thus no undecidable instances is
    needed.
@-}

class Monad m => MonadState'' m where
  type MState m :: *
  get'' :: m (MState m)
  get'' = state'' (\s -> (s, s))

  put'' :: (MState m) -> m ()
  put'' s = state'' (\_ -> ((), s))

  state'' :: (MState m -> (a, MState m)) -> m a
  state'' f = do
    s <- get''
    let (a, s') = f s
    put'' s'
    return a

-- don't need functional dependency any more, and s is not in context, so no undecidable
-- instances.
instance MonadState'' m => MonadState'' (ReaderT e m) where
  type MState (ReaderT e m) = e

{-@ Conclusion:
    - You still don't want undecided instances.
    - Cases that undecided instances are ok is because they are inheriently decidable.
      For instance MPTC with functional dependencies is really decidable if you only recurse
      on the non depended parameter.
    - You may say the need of undecided instances for MPTC and FD is a design flaw.

    - side1: When writing generic instance you should be extra careful not to make it to generic
             and pollute other potential instances.

    - side2: Transformer with mtl doesn't make the stack itself transformer, you still need to
             implement the transformer instance. Specifically, how many levels you need to tell
             the instance lift the bottom monad up to perform it's effects.

    - side3: Monad transformer really just implement an interface on top of the stacked newtype,
             the reason we can avoid lift is because all actions are lifted into the same level
             already.

    - side4: For state monad the state function is really the core. All state transformation is just
             take the old state and return new state and retur value.
             The concept is not only for state monad, but anything need functional update.
@-}
{-# LANGUAGE DataKinds             #-}
{-# LANGUAGE FlexibleInstances     #-}
{-# LANGUAGE GADTs                 #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE RankNTypes            #-}

module Types.Gadts where

import           GHC.TypeLits

{-@ what's the point?
 @-}

-- Look at this:
type X a = Either a a
-- This is just a type alias, and it's also a type function.
-- X can only be used at the type level, which takes
-- a type parameter a and give us back a concrete type.

-- in c++ it might look like this:
-- template<tyename T> using X = Either<T, T>;

{-@ Now we want the type function to be more powerful
    We want it to actually act like a function.

    like this:
        type T [a] = Set a
    Or this:
        type F Bool = Char
        type F String = Int
    Or even recursive and using other type functions.
        data TrueType
        data FalseType

        type F [a] = F a
        type F (Map a b) = F b
        type F a | IsSimple a = a

        -- if a type is defined then it's true ...
        -- (figuratively)
        type IsSimple Bool
             IsSimple Int
             IsSimple Double
    Or maybe multi value fucntion? (What's that?)
        type Colelction a = [a]
             Colelction a = (Set a)
             Colelction a = (Map a b)

 @-}

-- Now let's write stuffs above as typeclasses.
-- these are really just predicates at type level.
class IsSimple a
instance IsSimple Bool
instance IsSimple Int
instance IsSimple Double

class Collection a c
instance Collection a [a]

-- A type function that traverses to decide whether it has Int somewhere.
class HasInt a
instance HasInt Int

-- think it as: HasInt [a] = HasInt a
instance (HasInt a) => HasInt [a]
instance (HasInt a) => HasInt (Maybe a)

-- replace a with b and res with t
class Replace t a b res
instance Replace t a a t  -- need flexible instance
instance Replace t a b res => Replace [t] a b [res]
instance Replace t a b res => Replace (Maybe t) a b (Maybe res)
instance Replace t a b t


{-@ Syntax for typeclasses looks more like a constraint rather
    then function.

    To interpret type class as type function the function body seems to be reversed.
      instance (HasInt a) => HasInt [a]
    is
      type HasInt [a] = HasInt a
@-}


{-@ Generalized Abstract data type

    Say you want to do this:
      data T String = D1 Int
           T Bool   = D2
           T [a]    = D3 (a, a)
    you need to use GADT and write this:

      data T a where
        D1 :: Int -> T String     -- match when return T String
        D2 :: T Bool              -- match when return T Bool
        D3 :: (a, a) -> T [a]     -- match when return T [a]

    Pattern mathcing on the data constructor can help you determine what a should be.
@-}

-- to implement an evaluator for sk combinator

data Term' = K' | S' | Term' :@ Term'
infixl 6 :@

-- you don't have any type checking what so ever
eval' (K' :@ x :@ _)      = x
eval' (S' :@ x :@ y :@ z) = x :@ z :@ (y :@ z)
eval' x                   = x
eval' (K' :@ x)           = x


{-@ GADT based small step evaluator
    Comparing with the one above, data constructor's return type
    is specified explicitly.
    It's just a pattern matching. We are saying
    data Term (a -> b -> a) = K
    data Term ((a -> b -> c) -> (a -> b) -> a -> c) = S
    data Term a = a
    data Term b = Term (a -> b) -> Term a
 @-}
-- a full implementation of small step SK evalutor with GADT
data Term x where
  K :: Term (a -> b -> a)
  S :: Term ((a -> b -> c) -> (a -> b) -> a -> c)

  -- simply apply the first arg to the second arg.
  (:$) :: Term (a -> b) -> Term a -> Term b

infixl 6 :$

eval :: Term a -> Term a
eval (K :$ x :$ _)      = x
eval (S :$ x :$ y :$ z) = x :$ z :$ (y :$ z)
eval x                  = x


{-@ An example with list
    Use Gadt to encode if a list is empty or nonemty
@-}

data List' a = Const' a | Nil'

data Empty
data NonEmpty
data List x y where
  Nil :: List a Empty
  Cons :: a -> List a b -> List a NonEmpty

-- again, here we encode some extra information in to the list
{-@ Now this won't type check.
    silly 0 = Nil
    silly 1 = Cons 1 Nil
    You see all the sudden you have this super strong constraint on
    list type. Nil and Const are essentially different types.
@-}

first :: List a NonEmpty -> a
first (Cons x _) = x

-- now you need to differentiate between two types of list.
-- but this fells fall back to a usual list implementation
-- with Maybe and None...
rest :: List a NonEmpty -> Either (List a Empty) (List a NonEmpty)
rest (Cons _ xs) = case xs of
                     c@(Cons _ _) -> Right c
                     _            -> Left Nil

{-@ using GADT to represent stack
@-}
data Z
data S n

data Stack n where
  SEmpty :: Stack Z
  SPush :: Stack n -> Stack (S n)
  SPop :: Stack (S n) -> Stack n

theStack = SPush . SPush . SPush $ SEmpty
theStack' = SPop . SPop $ theStack
{-# LANGUAGE DefaultSignatures  #-}
{-# LANGUAGE DeriveGeneric      #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE FlexibleContexts   #-}
{-# LANGUAGE FlexibleInstances  #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE TypeFamilies       #-}
{-# LANGUAGE TypeOperators      #-}
module Types.Generic1 where

import           Data.Kind
import           GHC.Generics
import           Numeric
import Data.Char

-- basic idea
-- The only thing a generic class does is to create an isomorphism between
-- a and Rep a nothing else.
class MyGeneric a where
  type Rep' a :: Type -> Type
  from' :: a -> (Rep' a) x
  to' :: (Rep' a) x -> a


data Empty deriving Generic

-- Generic representations for type a: Rep a :: Type -> Type
-- from a Rep a x
-- to a

-- This class maps from Generic representations to result.
-- We always need something like this to dispatch the behavior on all
-- representations.
class Encode' f where
  encode' :: f p -> [Bool]

-- dummy case. V1 represents a type without data constructor (Void).
instance Encode' V1 where
  encode' _ = undefined

-- U1 for empty datatype
instance Encode' U1 where
  encode' U1 = []

instance (Encode' f, Encode' g) => Encode' (f :+: g) where
  encode' (L1 x) = False : encode' x
  encode' (R1 x) = True : encode' x

instance (Encode' f, Encode' g) => Encode' (f :*: g) where
  encode' (x :*: y) = encode' x ++ encode' y

instance Encode c => Encode' (K1 i c) where
  encode' (K1 x) = encode x

instance Encode' f => Encode' (M1 i t f) where
  encode' (M1 x) = encode' x

-- the actual class we try to implement
class Encode a where
  encode :: a -> [Bool]
  default encode :: (Generic a, Encode' (Rep a)) => a -> [Bool]
  encode x = encode' (from x)   -- map a to Rep a x and dispatch with encode'

-- defined generic means we have Rep
data Tree a = Leaf
            | Node a (Tree a) (Tree a)

-- Generic works over kind *, Generic1 works on polymorphic kind.
deriving instance Generic (Tree a)
deriving instance Generic1 Tree

deriving instance Show (Tree Int)

t1 = Node (1 :: Int) (Node 2 Leaf Leaf) Leaf
t2 = Node (1 :: Int) (Node 2 Leaf Leaf) (Node 2 (Node 3 Leaf Leaf) (Node 4 Leaf Leaf))

instance Encode Int where
  encode n = fmap f (showIntAtBase 2 intToDigit n "")
    where
      f '0' = False
      f '1' = True

instance Encode a => Encode (Tree a)

-- node how t1 and t2 has completely different shapes, but we can use the same
-- encode function to work on both of them.
-- Trick is we represent adt with datatype, then work on those data types.
-- it's the gist of generic programming. There is nothing more other then that.
n1 = encode t1
n2 = encode t2

-- Generic1
-- bascially the same, but a polymorphic kind version.
-- original Generic ranges over kind *, Generic1 generalized this.
{-# LANGUAGE DataKinds         #-}
{-# LANGUAGE ExplicitForAll    #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GADTs             #-}
{-# LANGUAGE KindSignatures    #-}
{-# LANGUAGE PolyKinds         #-}
{-# LANGUAGE TypeApplications  #-}
{-# LANGUAGE TypeFamilies      #-}
{-# LANGUAGE TypeOperators     #-}
module Types.Inferences where

-- https://www.youtube.com/watch?v=ZiGIBU0haOk

-- type equality is useful for associate types of type families
-- because it's hard to infer whether two associate types should be
-- equal

{-@ injectivity @-}
-- all type constructors are injective
injective :: f a ~ g b => a -> b
injective = id

-- an example of type equality
injMaybe :: forall a b. Maybe a ~ Maybe b => a -> b
injMaybe = id

-- supply type for type application.
injective' = injective @Maybe

{-@ generativity @-}
generativity :: f a ~ g b => f c -> g c
generativity = id

{-@ if two types satisfy injectivity and gnerativity, then
    we say they are matchable.
@-}

{-@ Now assume we have a type family like this:
    by injectivity, we have
    Maybe a ~ Maybe b => a ~ b

    but for associative type family, we don't want this:
    DBValue a ~ DBValue b => a ~ b

    otherwise we will get into the situation that
    DBValue UUID ~ DBValue Password => UUID ~ Password
    which makes little sense.

   So type familiies is no injective. (saturated)
@-}

data UUID = UUID
data Username = Username
data Password = Password

class DB a where
  type DBValue a
  toDB :: a -> DBValue a

instance DB UUID where
  type instance DBValue UUID = Int
  toDB _ = 1

instance DB Username where
  type instance DBValue Username = String
  toDB _ = "UserName"

instance DB Password where
  type instance DBValue Password = String
  toDB _ = "Password"


type User = '[UUID, Username, Password]

data HList :: [*] -> * where
  Nil :: HList '[]
  (:>) :: t -> HList ts -> HList (t ': ts)

infixr :>

jotaro :: HList User
jotaro = UUID :> Username :> Password :> Nil

-- track matchability in kind
-- Maybe :: * -> *  "matchable"
-- DBType :: * ~> *  "unmatchable"
--
-- We can't use DBType for Map because it's saturated.

type family Map (f :: a -> b) (xs :: [a]) :: [b] where
  Map _ '[] = '[]
  Map f (x ': xs) = f x ': Map f xs

dbUser :: HList User -> HList (Map Maybe User)
dbUser = undefined
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE GADTs            #-}
{-# LANGUAGE TypeOperators    #-}

{-# LANGUAGE DataKinds        #-}
{-# LANGUAGE KindSignatures   #-}
{-# LANGUAGE PolyKinds        #-}

{-# LANGUAGE RankNTypes       #-}

module Types.Kindness where

{-@ We have parametric polymorphism for types by
    default. But there is no polymorphic kind.
    To support that we need extension.
@-}

-- by defualt, Bo has kind Bo :: * -> *, implies a :: *
-- if we have polymorphic kind, a can be any kinds.
-- Say a :: * -> *, then we can have Bo :: a -> *
-- thue, Bo :: (* -> *) -> *
data Bo a = Bo a

-- in contrast, this type constraint the kind of a to be
-- * -> *, thus we always know the kind of a.
-- With that information we can now deduce kind of b :: *
data Bobo (a :: * -> *) b = Bobo (a b)


-- with poly kind the kind is polymorphic by default
-- data T (m :: k -> *) (a :: k) = Mkt (m a)
-- this means a has polymorphic kind k.
data T m a = MkT (m a)

-- but if you add a kind signature, you can constrain the kind.
data T' m (a :: *) = MkT' (m a)

-- This means m is a type with kind (k -> *), so it
-- at least be (* -> *), of course also (* -> * -> *)
-- GHC can infer type kind a from the context (m a)
-- It knows
--   (m :: k -> *) (m a :: *)
--   -----------------------
--       (a :: k)
data T'' (m :: k -> *) a = MkT'' (m a)

{-@ A practical example @-}

data Tree z = Leaf | Branch (Tree z) (Tree z)
-- this works with poly kind because now
-- Tree is inferred with kind Tree (k :: * -> *)
-- FunnyTree :: * -> *

-- This can't becomea concrete type now...
type FunnyTree = Tree []

-- This can
type FunnyTreeA a = Tree [a]
type IntTreeA = FunnyTreeA Int
{-# LANGUAGE LinearTypes #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE NoImplicitPrelude #-}
module Types.LinearTypeQSort where

import GHC.Stack

import qualified Data.Array.Mutable.Linear as Array
import Data.Array.Mutable.Linear (Array)
import Data.Unrestricted.Linear
import Prelude.Linear hiding (partition)


quicksort :: Array Int %1-> Array Int
quicksort arr = Array.size arr &
  \(Ur len, arr') -> go 0 (len - 1) arr'

go :: Int -> Int -> Array Int %1-> Array Int
go lo hi arr = case lo >= hi of
                 True -> arr
                 False -> Array.read arr lo &
                   \(Ur pivot, arr0) -> partition arr0 pivot lo hi &
                     \(arr1, Ur ix) -> swap arr1 lo ix &
                       \arr2 -> go lo ix arr2 &
                         \arr3 -> go (ix + 1) hi arr3

partition :: Array Int %1-> Int -> Int -> Int -> (Array Int, Ur Int)
partition arr pivot lx rx
  | (rx < lx) = (arr, Ur (lx - 1))
  | otherwise = Array.read arr rx &
    \(Ur lVal, arr0) -> Array.read arr0 rx &
      \(Ur rVal, arr1) -> case (lVal <= pivot, pivot < rVal) of
                            (True, True) -> partition arr1 pivot (lx + 1) (rx + 1)
                            (True, False) -> partition arr1 pivot (lx + 1) rx
                            (False, True) -> partition arr1 pivot lx (rx + 1)
                            (False, False) -> swap arr1 lx rx &
                              \arr2 -> partition arr2 pivot (lx + 1) (rx - 1)

swap :: HasCallStack => Array Int %1-> Int -> Int -> Array Int
swap arr i j = Array.read arr i &
  \(Ur ival, arr1) -> Array.read arr1 j &
    \(Ur jval, arr2) -> (Array.set i jval . Array.set j ival) arr2

-- test

{-@ Conclusion
    1. Linear types allows it's paramter only be used once. It makes it possible to control
       resources concisely.
@-}
{-# LANGUAGE OverloadedStrings #-}

module Types.LiquidHs where



import           Prelude hiding (head, length, tail)

-- Abstract
--  1. Refinement types: Types + Predicates.
--  2. Specify properties: From refined input/outpt types.
--  3. Verify properties: Va SMT based predicate subtyping.

-- Natrual numbers
{-@ type Nat = {v:Int | 0 <= v} @-}
{-@ type Pos = {v:Int | 0 <= v} @-}

{-@ nats :: [Nat] @-}
nats = [0, 1, 2, 3]

{-@ poss :: [Pos] @-}
poss = [1, 2, 3, 4]


-- A term with many types:
{-@ zero :: Zero @-}
zero = 0
{-@ zero' :: Nat @-}
zero' = zero

-- Predicate subtyping
-- In environment Γ, t₁ is subtype of t2
-- Γ ⊢ t₁ ⪯ t₂
--
-- Where environment is a sequence of binders.
--     ----
-- Γ ≐ xi:Pi
--
-- If VC is valid ∧ᵢPᵢ ⇒ Q ⇒ R
-- then xi:Pi ⊢ {v:b | Q} ⪯  {v:b | R}

{-@ four :: Nat @-}
four = x + 1
  where
    x = 3


-- Contracts: function types
-- no value satisfies false ⇒ no valid inputs for impossible.
-- ⇒ impossible will never be called at runtime.
{-@ impossible :: {v:_ | false } -> a @-}
impossible msg = error msg

-- precondition
-- This is how you write normal safe dev.
safeDivBad :: Int -> Int -> Int
safeDivBad _ 0 = impossible "divide-by-zero"
safeDivBad x n = x `div` n

{-@ type NonZero = {v: Int | v /= 0} @-}  -- 0 is checked now
{-@ safeDiv :: u: Int -> v: NonZero -> Int @-}
safeDiv x n = x `div` n

avg2 x y = safeDiv (x + y) 2
-- with refinement type the precondition is
--    (v = 2) ⇒ (v ≠ 0)
-- ----------------------
--  x:Int, y:Int ⊢ {v|v=2} ⪯ {v|v≠0}
-- Thus safeDiv typecheck.


-- specify post condition
{-@ size :: [a] -> Pos @-}
size [_]    = 1
size (_:xs) = 1 + size xs
size _      = impossible "size"

-- now combine size and safeDiv, the precond and post cond compose.
avg' xs = safeDiv total n
  where
    total = sum xs
    n = size xs


-- Describe properties of structures.
data List a = Emp | (:<:) a (List a)

-- using measure to strengthens type of data constructor
{-@ measure length @-}
length :: List a -> Int
length Emp        = 0
length (_ :<: xs) = 1 + length xs


{-@ head :: List a -> a @-}
head (x :<: _) = x
head _         = impossible "head"


{-@ tail :: List a -> List a @-}
tail (_ :<: xs) = xs
tail _          = impossible "tail"

-- naming nonempty list
{-@ type LisetNE a = {v: List a | 0 < length v} @-}
module Types.NoTypeclass where


{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE GeneralisedNewtypeDeriving #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE StandaloneDeriving         #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE DataKinds #-}
module Types.PhantomType where

import           Data.String
import           Data.Text as Text
import           Data.Text.Conversions

-- encoding arbitray type level invaraints and get statically checked
newtype Id a = Id Text deriving Eq

data User
data Blog
data Post

fetchUser :: Monad m => Id User -> m User
fetchUser = undefined

fetchBlog :: Monad m => Id Blog -> m Blog
fetchBlog = undefined

instance Show (Id User) where
  show (Id txt) = "user #" <> unpack txt

instance Show (Id Blog) where
  show (Id txt) = "blog #" <> unpack txt

instance Show (Id Post) where
  show (Id txt) = "post #" <> unpack txt

-- note n1 == n2 is an error. We can coerce then to the same type then it will
-- work.
npost :: Id Post
npost = Id "as post"

nuser :: Id User
nuser = Id "as user"

nblog :: Id Blog
nblog = Id "as blog"

isValid :: IsString a => a -> Bool
isValid _ = True

instance FromText (Maybe (Id a)) where
  fromText str = if isValid str then Just (Id str) else Nothing

-- we can use stand alone deriving to pick different implmenetation for a
-- specific type.
deriving instance ToText (Id User)
deriving instance ToText (Id Post)

instance ToText (Id Blog) where
  toText (Id x) = Text.concat ["Blog: ", x]

-- text
testToText = [toText nblog, toText npost, toText nuser]

-- data kinds and kind signatures

data RegStatusd = Registered | Anon
newtype UserId (s :: RegStatusd) = UserId Text


{-# LANGUAGE AllowAmbiguousTypes   #-}
{-# LANGUAGE DataKinds             #-}
{-# LANGUAGE ExplicitForAll        #-}
{-# LANGUAGE GADTs                 #-}
{-# LANGUAGE KindSignatures        #-}
{-# LANGUAGE LambdaCase            #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE ScopedTypeVariables   #-}
{-# LANGUAGE TypeApplications      #-}
{-# LANGUAGE TypeFamilies          #-}
{-# LANGUAGE TypeOperators         #-}
{-# LANGUAGE UndecidableInstances  #-}

-- http://okmij.org/ftp/Computation/typeclass.html

module Types.TypeClass where

import           Data.Dynamic
import           Data.Kind
import           Data.List
import           Data.Typeable
import           GHC.TypeLits
import Data.Maybe

-- you don't need typeclass
data UUID

-- we create an newtype wrapper that can have an unique value for each
-- specific type a.
-- Each concrete record is an overload.

-------------------------------------------------------------------------------

type instance Eq' UUID = TypeError (Text "bad" :<>: ShowType UUID)


-- define class where
type family Eq' a :: Constraint
data Eq'Dict a = Eq' a => Eq'Dict { equal :: a -> a -> Bool }
-- end define class

-- define instance where
type instance Eq' Bool = ()
eqBool :: Eq'Dict Bool
eqBool = Eq'Dict { equal = eq }
  where
    eq True True   = True
    eq False False = True
    eq _ _         = False
-- end define instance

-- define instance where
type instance Eq' Int = ()
eqInt :: Eq'Dict Int
eqInt = Eq'Dict { equal = eq }
  where
    eq a b = a - b == 0
-- end define instance

-- we have additional constraints, pass them as implicit paramters.
-- define instance where
type instance Eq' (a, b) = (Eq' a, Eq' b)
eq2Tuple :: (Eq' a, Eq' b) => (Eq'Dict a, Eq'Dict b) -> Eq'Dict (a, b)
eq2Tuple ctxs@(d_a, d_b) = Eq'Dict { equal = eq }
  where
    eq (a1, b1) (a2, b2) = (equal d_a a1 a2) && (equal d_b b1 b2)
-- end define instance

all' :: Eq' a => Eq'Dict a -> [a] -> Bool
all' _ [] = True
all' _ [x] = True
all' d_ (x:y:xs) = f x y && all' d_ xs
  where
    f = equal d_

-------------------------------------------------------------------------------
-- Another example
-- actually we don't need a type family return constraint, because the existance
-- of a dict Num'Dict Int is already a proof that there is an instance for
-- Num' Int.
--
-- define class where
type family Num' a :: Constraint
data Num'Dict a = Num' a => Num'Dict { plus    :: a -> a -> a
                                     , fromInt :: Int -> a
                                     }
-- end define class

-- define instance where
type instance Num' Int = ()
numInt :: Num'Dict Int
numInt = Num'Dict { plus = (+)
                  , fromInt = id
                  }
-- end define instance

-- define instance where
type instance Num' Double = ()
numDouble :: Num'Dict Double
numDouble = Num'Dict { plus = (+)
                     , fromInt = fromIntegral
                     }
-- end define instance

lookup' :: Eq' a => Eq'Dict a -> a -> [(a, b)] -> Maybe b
lookup' _ _ [] = Nothing
lookup' ctx@(Eq'Dict equal) k ((a, b):xs)
  | equal k a = Just b
  | otherwise = lookup' ctx k xs

member' :: Eq' a => Eq'Dict a -> a -> [a] -> Bool
member' ctx k [] = False
member' ctx k (x:xs)
  | (equal ctx) k x = True
  | otherwise = member' ctx k xs

-- zip with
removeDups :: (Num' a, Eq' a) => (Num'Dict a, Eq'Dict a) -> [a] -> [a]
removeDups _ [] = []
removeDups (numdict, eqdict) xs = go xs []
  where
    go [] as = as
    go (x:xs) as = if member' eqdict x as
                      then go xs as
                      else go xs (x:as)

-------------------------------------------------------------------------------
--

-- define class where
-- more constraints are still passed as dictionaries.
type family Mul' a :: Constraint
data Mul'Dict a = (Eq' a, Num' a) => Mul'Dict
  { times :: (Eq'Dict a, Num'Dict a) -> a -> a -> a }
-- end define class

-- define instance where
type instance Mul' Int = ()
intMul = Mul'Dict { times = f }
  where
    f :: (Eq'Dict Int, Num'Dict Int) -> Int -> Int -> Int
    f _ 0 _ = 0
    f _ _ 0 = 0
    f _ 1 x = x
    f _ x 1 = x
    f ctx@(eq_d_, num_d_) a b
      | a > 0 = f ctx (a - 1) ((plus num_d_) b 1)
      | otherwise = negate (f ctx (negate a) b)
-- end define instance

-- NOTE: conclusion 1: For typeclass, it's type predicate property is maintained
--       before the double arrow as the type context, but the actual overload
--       (term level values) are replaced by extra dictionary.
--       So it's appropriate to think the type conext has nothing to do with
--       term level values, but typeclass give us a convinent bridge between the
--       two.


-------------------------------------------------------------------------------
-- There are other ways to compile typeclasses.

-------------------------------------------------------------------------------
-- 1. Type calss as macros (monomorphization)
--
-- This is essentially haskell's C++ templates. It simply rewrite typeclass
-- into equivalent simple code and insert into the source during compilation.
--
-- If we do this after type checking, we don't really need type constraints
-- at all. Since the code is already type checkd, all we need is to pass the
-- right instance to the right function.
-- Let's see how monomorphization transform code.
bool_to_string = show @Bool
int_to_string = show @Int

class Show'Mono a where
  show'mono :: a -> String

instance Show'Mono Int where
  show'mono = int_to_string

instance Show'Mono Bool where
  show'mono = bool_to_string

test_show'mono :: String
test_show'mono = show'mono True

print'mono :: forall a. Show'Mono a => a -> IO ()
print'mono = putStrLn . show'mono

print_ints :: IO ()
print_ints = do
  traverse print'mono [1 :: Int, 2, 3]
  return ()

-----------------------
-- this compiles to the following code with monomophization:
-- No typeclass, no instance, no overloaded functions. No bounded polymorphism.
-- In monomorphization, overloaded functions are not really functions, but
-- macros that generate the corresponding function.

test_show'monoCompiled :: String
test_show'monoCompiled = bool_to_string True

-- this becomes a template, and it will be instantiated at call site.
-- print'mono'Compiled :: a -> IO ()

-- note that the polymorphic function is inlined all together.
-- this is a complete time process.
print_intsCompiled :: IO ()
print_intsCompiled = do
  traverse (putStrLn . int_to_string) [1 :: Int, 2, 3]
  return ()

-- NOTE: monomorphization is a partial evaluation of the result of
-- dictionary-passing translation.

-- NOTE: monomorphization lacks of support for separate compilation becasue
-- instantiation needs to be recompiled for all call site if the original
-- function is changed.

-- NOTE: monomorphization doesn't support runtime polymorphism, so it's still
-- necessary to have dictionary passing

-- NOTE: GHC use both, first it does full program dictionary passing, then it
-- will do partial evaluation to monomorphize possible cases.
-- Thus the compiled program is a mixture of dictionary passing and
-- monomorphization.

-- NOTE: monomorphization makes IO and State monad efficient.


-------------------------------------------------------------------------------
-- 2. Intentional type analysis
-- it's essentially doing the runtime type checking trick.

class Show'Intensional a where
  show'intensional :: a -> String

instance Show'Intensional Int where
  show'intensional = int_to_string

instance Show'Intensional Bool where
  show'intensional = bool_to_string

-- this compiles to

-- This is a little circular since we're still using typeclass. Typeclass here
-- can be thought as compiler builtin rtti predicates.
show'intensionalCompiled :: Typeable a => a -> String
show'intensionalCompiled x =
  case cast x :: Maybe Bool of
    Just v -> bool_to_string v
    Nothing ->
      case cast x :: Maybe Int of
        Just v -> int_to_string v
        Nothing -> error "no type resolution"

-- call site is essentially the same, as the show function already can
-- dispatch base on all situations, we only need one function.
test_show'intensional :: String
test_show'intensional = show'intensionalCompiled True

-- Typeable again can be build into compiler.
print'intensional :: Typeable a => a -> IO ()
print'intensional = putStrLn . show'intensionalCompiled

-- again no problem.
print_ints'intensional :: IO ()
print_ints'intensional = do
  traverse print'intensional [1 :: Int, 2, 3]
  return ()

-- We no longer have parametricity since the intensional version show doesn't
-- support all types, some runtime input will an exception.
--
-- print :: a -> String looks like it's paramtric polymorphic, but it is not.
-- It doesn't work for types other then int and bool beacuse we only have
-- typeclasses for them.
--
-- NOTE: it's not always possible to do runtime type checking. Sometimes you
-- need to add type information for all values for them to be able to be type
-- checked.

{-# LANGUAGE ExplicitForAll           #-}
{-# LANGUAGE FlexibleInstances        #-}
{-# LANGUAGE GADTs                    #-}
{-# LANGUAGE KindSignatures           #-}
{-# LANGUAGE TypeApplications         #-}
{-# LANGUAGE TypeFamilies             #-}
{-# LANGUAGE ConstraintKinds #-}

{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE DataKinds                #-}
{-# LANGUAGE StandaloneKindSignatures #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE AllowAmbiguousTypes #-}
module Types.TypeFam where

import           Control.Monad.Except
import           Data.Char            (ord)
import qualified Data.IntMap          as M
import           Data.Maybe

import           Data.Kind
import           Data.Proxy
import           GHC.Generics
import           GHC.TypeLits

import           Control.Monad.Trans



-- how you normall define a list with gadt??
data GList a where
  GCons :: !Char -> (GList Char) -> GList Char
  GListUnit :: !Int -> GList ()

{-@ Type families (indexed type families)
    Haskell's ad-hoc overloading of data types.
    family to overload data is class to overlod function.
@-}

{-@ toplevel data family  @-}

-- here we defined a data family XList.
data family XList a :: *

-- and here we created two overloads.
-- XList CHar and XList () are really two different types if you look
-- at their underlying value. But at the type level they are both
-- XList.
data instance XList Char = XCons !Char !(XList Char) | XNil

data instance XList () = XListUnit !Int

{-@ More example with the SK evaluator defined previously. @-}
data TermGADT a where
  K' :: TermGADT (a -> b -> a)
  S' :: TermGADT ((a -> b -> c) -> (a -> b) -> a -> c)
  (:@) :: TermGADT (a -> b) -> TermGADT a -> TermGADT b

infixl 6 :@

evalgadt :: TermGADT a -> TermGADT a
evalgadt (K' :@ x :@ _)      = x
evalgadt (S' :@ x :@ y :@ z) = x :@ z :@ (y :@ z)
evalgadt x                   = x

-- you can't realy simulate this gadt though, because data family implies
-- that data instances has the same arity.
data family Fam a :: *

data instance Fam () = FamA Int Int
data instance Fam Int = FamB Char
data instance Fam (a -> b) = FamC (a -> b)

-----------------------------------------------------------------------

{-@ Associated (data familiy).
    we can give the assiciated data type a kind signature.
    each instance can have it's own data type.
@-}
-- let's make a generialzed trie
class GMapKey k where
  data GMap k :: * -> *
  empty :: GMap k v
  lookup :: k -> GMap k v -> Maybe v
  insert :: k -> v -> GMap k v -> GMap k v

instance GMapKey Int where
  data GMap Int v = GMapInt (M.IntMap v) deriving (Show)
  empty = GMapInt M.empty
  lookup k (GMapInt m) = M.lookup k m
  insert k v (GMapInt m) = GMapInt $ M.insert k v m

instance GMapKey Char where
  data GMap Char v = GMapChar (M.IntMap v) deriving (Show)
  empty = GMapChar M.empty
  lookup k (GMapChar m) = M.lookup (ord k) m
  insert k v (GMapChar m) = GMapChar $ M.insert (ord k) v m

m :: GMap Char Int
m = insert 'a' 10 empty

n :: GMap Int Int
n = insert (10 :: Int) 10 empty

{-@ type family  is similar @-}

-- another example with data family
-- here we uses the type family instead of data family
class Collects c where
  type Elem c :: *
  cempty :: c
  cinsert :: Elem c -> c -> c

instance Collects [a] where
  type Elem [a] = a
  cempty = []
  cinsert a as = a : as

-- use top level type family
type family Thing c

class Container c where
  conempty :: c
  coninsert :: Thing c -> c -> c

type instance Thing [c] = c

instance Container [a] where
  conempty = []
  coninsert a as = a : as

{-@ Do some type level operations
    It's here again, but let's do some peano number
 @-}
data Zero
data Succ n
type family Pred' n
type instance Pred' (Succ n) = n
type instance Pred' Zero = Zero

-- you can write type family in one place.
-- this starts to feels like Gadt
type family Pred n where
  Pred (Succ n) = n
  Pred n = n

-- ambigious type
data KebabState = Kebab | NoKebab | NoMoreKebab deriving (Show, Eq)

class HasKebab a where
  type KGame a :: *
  hasKebab :: KGame a -> a

{-@ hasKebab :: KGame a -> KebabState @-}
-- this will cause a can't deduce Kebab a warning.
-- Imagine writing typeclass without type family, of course you need to
-- have the type parameter a some where to indicate which oveload to use.

class HasKebab' a where
  hasKebab' :: a -> a

-- some convenient language extensions
{-@ type applications
    Allows you to explicitly declare what types should be instantiated
    for argument of a function application.
    There are cases that you need to specify the type of a simple parameter,
    but to annotate it you needs to provides the full type signatures.
    Type application helps you to annotate only one type to make it type check.
@-}

type family FTypeApp a

-- only have two overloads here.
type instance FTypeApp Char = Bool
type instance FTypeApp Bool = Bool

functionApp = l $ ord h
  where
    g :: FTypeApp a -> a
    g _ = undefined

    -- this can be inferred.
    f :: Char
    f = g True

    -- give the tyupe info here.
    -- h' = g False   -- this causes an error.
    h = g @Char False

    x :: Enum b => b -> b
    x = undefined
    l = x @Int -- here specify l with use the Int overload.



{-@ 1. closed type families @-}
-- some type level programing.
-- standalone kind signature / kind signature + type familiy + polykind to
-- write type level function as if it's normal function.
-- data kinds promote all term level values into type, so we can do all term level
-- computations at the type level.

-- this form is called a closed type family.
type Append :: forall a. [a] -> [a] -> [a]
type family Append xs ys where
  Append '[] ys = ys
  Append (x ': xs) ys = x ': Append xs ys

-- '[1, 2, 3, 4, 5, 6]
type ListType1 = Append '[1, 2, 3] '[4, 5, 6]

type Cons :: forall a. a -> [a] -> [a]
type family Cons a xs where
  Cons a '[] = '[a]
  Cons a xs = a ': xs

-- --
type Consed1 = Cons 1 '[1, 2, 3]
type ConsedList = Append (Cons 1 (Append '[1, 2, 3] '[3, 4, 5])) ListType1
-- --

type Take :: forall a. Nat -> [a] -> [a]
type family Take n xs where
  Take 0 xs = '[]
  Take n (x ': xs) = x ': Take (n - 1) xs

type Length :: forall a. [a] -> Nat
type family Length xs where
  Length '[] = 0
  Length (x ': xs) = 1 + (Length xs)

-- --
type Take3OnList = Take 3 ConsedList
type LengthOfList = Length ConsedList
type Take30OnList = Take 30 ConsedList
-- --


{-@ 2. open type families @-}
type Label :: Type -> Symbol   -- type level string
type family Label t where
  Label Double = "number"
  Label String = "string"

-- how do we get the label into term level?
label :: forall t. KnownSymbol (Label t) => String
label = symbolVal (Proxy @(Label t))

v1 = label @Double
v2 = label @String


{-@ 3. Type level pattern matching @-}
data Currency
  = USD
  | CND
  | JPY
  | RMB
  | EUR
  deriving (Show, Eq)


type family IsAmericanDollar (a :: Currency) where
  IsAmericanDollar 'USD = ()
  IsAmericanDollar a = TypeError ('Text "It's not American dollar")

type R1 = IsAmericanDollar 'USD
type R2 = IsAmericanDollar 'RMB


{-@ Conclusion

    1. Type family is the type level function.

    2. Haskell has some quirks on type level operator and type applications,
       these are not important to the type system, they are just notational
       convinences.

    3. Type family pattern match on type paramter thus breaks the parametricity.

    4. Parametricity means a function works on all types. If we pattern matches on
       a type paramter a and have different behaviors based on what a is, apparently
       a doesn't represent all types any more.

    5. If a type family returns the kind 'Constraint', it's just a type class constraint
       without corresponding term level functions.

    6. There are lots of type level facilities, like type level natural numbers, type level
       String (Symbol) etc.

       Facilities are from GHC.TypeLits.

    7. Proxy are dummy values, or a safer undefined.

    8. It's possible to project some type level values to term level. One possible senario
       is from Symbol to string.

    9. Type equality can be expressed with '~'.
       Another use of ~ is to bind a super long constraint with a name and refer to the name
       later.

    10.
 @-}
{-# LANGUAGE ConstraintKinds          #-}
{-# LANGUAGE ExplicitForAll           #-}
{-# LANGUAGE FlexibleInstances        #-}
{-# LANGUAGE GADTs                    #-}
{-# LANGUAGE KindSignatures           #-}
{-# LANGUAGE TypeApplications         #-}
{-# LANGUAGE TypeFamilies             #-}

{-# LANGUAGE AllowAmbiguousTypes      #-}
{-# LANGUAGE DataKinds                #-}
{-# LANGUAGE FlexibleContexts         #-}
{-# LANGUAGE PolyKinds                #-}
{-# LANGUAGE ScopedTypeVariables      #-}
{-# LANGUAGE StandaloneKindSignatures #-}
{-# LANGUAGE TypeOperators            #-}
{-# LANGUAGE UndecidableInstances     #-}


module Types.TypeFam1 where

import           Data.Kind
import           Data.Word
import           GHC.TypeLits

import Control.Monad.Reader
import Control.Monad.Except
import Control.Monad.State
import Data.Proxy

-- type family is heavily used in vector library.

------------------------------------------------------ ------------------------
{-@ typeclass are type level predicates @-}
data Defined e = Yes | No e

type family And (a :: Defined Symbol) (b :: Defined Symbol) :: Defined Symbol where
  And 'Yes 'Yes = 'Yes
  And 'Yes e = e
  And e 'Yes = e
  And e1 e2 = e1

type family IsEq (a :: *) :: Defined Symbol
type instance IsEq Int = Yes
type instance IsEq [a] = IsEq a
type instance IsEq (a, b) = And (IsEq a) (IsEq b)

type Eq' a = IsEq a ~ Yes

all' :: Eq' a => [a] -> Bool
all' = undefined

none' :: forall a . IsEq a ~ Yes  => [a] -> Bool
none' = undefined

a1 = all' [1 :: Int, 2]
-- this doesn't type check
-- b = all' ['a', 'b']

-- works the same
a2 = none' [1 :: Int, 2]

------------------------------------------------------ ------------------------
{-@ disjoints @-}
data IntegralOrFactional = INTEGRAL | FRACTIONAL | NONE

type family IsIntegralOrFractional t :: IntegralOrFactional

type instance IsIntegralOrFractional Int = INTEGRAL
type instance IsIntegralOrFractional Integer = INTEGRAL
type instance IsIntegralOrFractional Double = FRACTIONAL

type family IsIntegral' (c :: IntegralOrFactional) :: Defined Symbol where
  IsIntegral' INTEGRAL = Yes
  IsIntegral' FRACTIONAL = No "Not integral"
  IsIntegral' c = No ""


type IsIntegral t = IsIntegral' (IsIntegralOrFractional t)

type Tt1 = IsIntegral Int ~ Yes

foo1 :: IsIntegral t ~ Yes => t -> t
foo1 = id

a3 = foo1 (1 :: Int)

------------------------------------------------------ ------------------------
-- use constraint
-- note this is very different from a simple type level funtion.
-- It's used as a type level predicate that requires a constructive proof.
-- Here we define (Ord' Int) = (), means the return value of Ord' Int is an
-- elemnet in Constraint. It doesn't matter what it is becasue the only thing
-- that is important is it exists.
--
-- Constraints can only be used in the context, we can also use type classes
-- as type families that return a Constraint.

type family Ord' (a :: *) :: Constraint
type instance Ord' Int = ()
type instance Ord' Char = ()
type instance Ord' (a, b) = (Ord' a, Ord' b)

gt :: Ord' a => a -> a -> a
gt = undefined


------------------------------------------------------ ------------------------
-- use type error

type family IsInt (a :: Type) :: Type where
  IsInt Int = ()
  IsInt a = TypeError (Text "type " :<>: ShowType a :<>: Text " is not Int" )

type family ByteSize x where
  ByteSize Word16 = 2
  ByteSize Word8 = 1
  ByteSize a = TypeError (Text "the type " :<>: ShowType a :<>: Text " is not exportable")

-- wow. Type level values get into term.
bytesOfWord16 = natVal (Proxy :: Proxy (ByteSize Word16))


------------------------------------------------------ ------------------------
-- Constraint synonym
-- Now this constraint can be use everywhere else.
type StackM (r :: *) (m :: * -> *) = (MonadReader r m, MonadIO m, MonadError String m)

runStack :: StackM r m => m ()
runStack = do
  liftIO $ putStrLn "good"
  throwError "Error"
  x <- ask
  return ()
{-# LANGUAGE DataKinds          #-}
{-# LANGUAGE FlexibleInstances  #-}
{-# LANGUAGE GADTs              #-}
{-# LANGUAGE RankNTypes         #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE TypeApplications   #-}
{-# LANGUAGE TypeFamilies       #-}
{-# LANGUAGE TypeOperators      #-}

module Types.TypeFamZipper where

import           Control.Exception
import           Control.Monad.Except
import           Data.Maybe

data TypeList l where
  Nil :: TypeList '[]
  (:::) :: a -> TypeList l -> TypeList (a ': l)

infixr :::

type family Head ls where Head (TypeList (x ': _)) = x
type family Tail ls where Tail (TypeList (_ ': xs)) = xs

type family Foldr (f :: * -> * -> *) b ls where


-- type synonyms families

class Zippers c where
  type Focus c :: *
  type Context c :: *
  moveLeft :: c -> c
  moveRight :: c -> c
  modify :: (Focus c -> Focus c) -> c -> c
  focus :: c -> Maybe (Focus c)

data ListZipper a = ListZipper [a] a [a]
                  | EmptyListZipper

deriving instance Show a => Show (ListZipper a)

instance Zippers (ListZipper a) where
  type Focus (ListZipper a) = a
  type Context (ListZipper a) = ([a], [a])

  moveLeft (ListZipper (l : ls) x rs) = ListZipper ls l (x : rs)
  moveLeft EmptyListZipper            = EmptyListZipper

  moveRight (ListZipper ls x (r : rs)) = ListZipper (x : ls) r rs
  moveRight EmptyListZipper            = EmptyListZipper

  modify f (ListZipper ls x rs) = ListZipper ls (f x) rs
  modify _ EmptyListZipper      = EmptyListZipper

  focus (ListZipper _ c _) = Just c
  focus EmptyListZipper    = Nothing


data Tree a = Branch a (Tree a) (Tree a) | Leaf
data TreeDir a = TreeLeft a (Tree a) | TreeRight a (Tree a)
type TreeDirs a = [TreeDir a]
data TreeZipper a = TreeZipper (Tree a) (TreeDirs a)
                  | EmptyTreeZipper

deriving instance Show a => Show (Tree a)
deriving instance Show a => Show (TreeDir a)
deriving instance Show a => Show (TreeZipper a)

instance Zippers (TreeZipper a) where
  type Focus (TreeZipper a) = a
  type Context (TreeZipper a) = TreeDirs a
  moveLeft (TreeZipper (Branch a lt rt) bs) = TreeZipper lt (TreeLeft a rt : bs)
  moveLeft EmptyTreeZipper                  = EmptyTreeZipper

  moveRight (TreeZipper (Branch a lt rt) bs) = TreeZipper rt (TreeRight a lt : bs)
  moveRight EmptyTreeZipper = EmptyTreeZipper

  modify f (TreeZipper (Branch a lt rt) bs) = TreeZipper (Branch (f a) lt rt) bs
  modify _ EmptyTreeZipper                  = EmptyTreeZipper

  focus (TreeZipper (Branch a _ _) _) = Just a
  focus (TreeZipper _ _)              = Nothing

-- equality constraint.
-- given two zipper c1, c2, we want they have the same Focus
move2ZippersLeft :: ( Zippers c1
                    , Zippers c2
                    , Focus c1 ~ Focus c2
                    , f1 ~ Focus c1
                    , f2 ~ Focus c2
                    ) => c1 -> c2 -> (f1, f2)
move2ZippersLeft c1 c2 = (fromJust $ focus (moveLeft c1), fromJust $ focus (moveLeft c2))


listz = ListZipper [1..10] 11 [12..20]
treez = TreeZipper (Branch 10
                     (Branch 20
                       (Branch 40 Leaf Leaf)
                       Leaf)
                     (Branch 30 Leaf Leaf))
                     []

newfocus = move2ZippersLeft listz treez

moveLeftN :: forall a. Zippers a => a -> Int -> a
moveLeftN z 0 = z
moveLeftN z n = moveLeftN (moveLeft z) (n - 1)

moveRightN :: forall a. Zippers a => a -> Int -> a
moveRightN z 0 = z
moveRightN z n = moveRightN (moveRight z) (n - 1)
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE UndecidableInstances #-}
module TypeFibs where

-- some basics about proofing math with haskell.

-- peano natrual numbers.
data Nat = Z | S Nat
type family Add (a :: Nat) (b :: Nat) :: Nat
type instance Add Z b = b
type instance Add (S a) b = S (Add a b)

type family Fibonacci (n :: Nat) :: Nat
type instance Fibonacci Z = Z
type instance Fibonacci (S Z) = (S Z)
type instance Fibonacci (S (S n)) = Add (Fibonacci n) (Fibonacci (S n))
{-# LANGUAGE ConstrainedClassMethods   #-}
{-# LANGUAGE DataKinds                 #-}
{-# LANGUAGE DeriveDataTypeable        #-}
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE GADTs                     #-}
{-# LANGUAGE KindSignatures            #-}
{-# LANGUAGE PolyKinds                 #-}
{-# LANGUAGE RankNTypes                #-}
{-# LANGUAGE StandaloneDeriving        #-}
{-# LANGUAGE TypeFamilies              #-}
{-# LANGUAGE TypeOperators             #-}

module Types.TypeableAndDatKinds where


-- Data and Typeable
-- encode type information that can be quried at runtime.

import           Data.Data
import           Data.Dynamic
import           Data.Maybe
import           Data.Proxy
import           Data.Typeable (Typeable, cast, typeOf)

strLen :: String -> Int
strLen = length

-- cast try to convert m to the designated type.
-- we convert a polymorphic type into a concrete type.

fn :: Typeable a => a -> Int  -- given any type a, if it's String, use it.
fn m =
  case (cast m :: Maybe String) of
    Just mi -> strLen mi
    Nothing -> error "Not a string"

runStrLen :: IO ()
runStrLen = putStrLn $ show $ fn "Is this a string?"


{-@ show case some DataKinds Techniques
    data kinds allows you to define a data type, and promote it to the data level.
    namely you have the type becomes kind and values becomes type.
@-}
-- promote type level enum. Now we defined 4 different types and a new kinds.
data Currency = 'INR | 'USD | 'AUD | 'YEN deriving (Show, Data, Typeable)

-- the kind of c is Curreny, so Money can only have four possible variations.
-- note Currency is a phanthom type, under the hood there is only one representation.
data Money :: Currency -> * where
  Money :: Typeable c => Int -> Money c

deriving instance Show (Money c)

usdMoney n = Money n :: Money 'USD
yenMoney n = Money n :: Money 'YEN
audMoney n = Money n :: Money 'AUD
inrMoney n = Money n :: Money 'INR

-- just make a baby step each time.
fromUSD :: forall (a :: Currency). Typeable a => Money a -> Maybe Int
fromUSD m = do
  Money n <- cast m :: Maybe (Money 'USD)
  return n

fromYEN :: forall (a :: Currency). Typeable a => Money a -> Maybe Int
fromYEN m = do
  Money n <- cast m :: Maybe (Money 'YEN)
  return n

fromAUD :: forall (a :: Currency). Typeable a => Money a -> Maybe Int
fromAUD m = do
  Money n <- cast m :: Maybe (Money 'AUD)
  return n

fromINR :: forall (a :: Currency). Typeable a => Money a -> Maybe Int
fromINR m = do
  Money n <- cast m :: Maybe (Money 'INR)
  return n

-- hide different money behind exitential type and pick the right type with typeable.
data M = forall (a :: Currency). Typeable a => M (Money a)

pickYen :: [M] -> [Money 'YEN]
pickYen [] = []
pickYen ((M x):xs) = maybe (pickYen xs) (\n -> n:pickYen xs) (cast x :: Maybe (Money 'YEN))

moneys = [ M $ usdMoney 12
         , M $ yenMoney 39
         , M $ audMoney 23
         , M $ yenMoney 102
         , M $ usdMoney 39
         , M $ inrMoney 34
         ]

-- Type operators.
type family CurrencyOf a :: Currency where
  CurrencyOf (Money 'USD) = 'USD
  CurrencyOf (Money 'YEN) = 'YEN
  CurrencyOf (Money 'INR) = 'INR
  CurrencyOf (Money 'AUD) = 'AUD

-- instance Show (Money currency) where
--   show (Money a) = (show a) ++ (show $ typeOf (Proxy :: Proxy currency))

{-@ bring back types hidden behind exitential types.
@-}

data MoneyEx' = forall x. MoneyEx' (Money x)


-- when adding two moneys, we want them to be of the same currency, thus c to be the same
-- type.
moneyAdd :: Money c -> Money c -> Money c
moneyAdd (Money a) (Money b) = (Money (a + b))

-- this doesn't work because we erased the type. After we bring the value back all we know
-- about the type is it's money. We don't know, for example, whether two types are the same.
-- moneyAddEx' :: MoneyEx' -> MoneyEx' -> MoneyEx'
-- moneyAddEx' (MoneyEx' a) (MoneyEx' b) = MoneyEx' $ moneyAdd a b

-- we can solve this with typeable.

data MoneyEx = forall x. (Typeable x) => MoneyEx (Money x) deriving Typeable

deriving instance Show MoneyEx

-- this will throw an error when a and b are not of the same type.
moneyAddEx :: MoneyEx -> MoneyEx -> MoneyEx
moneyAddEx (MoneyEx a) (MoneyEx b) = case cast a of
                                       Just a1 -> MoneyEx $ moneyAdd a1 b
                                       Nothing -> error "not the same type"

-- this works.
addusd1 = moneyAddEx (MoneyEx (Money 12 :: Money 'USD)) (MoneyEx (Money 10 :: Money 'USD))

-- this throws a runtime error.
addusd2 = moneyAddEx (MoneyEx (Money 12 :: Money 'USD)) (MoneyEx (Money 10 :: Money 'AUD))


{-@ Use dynamics to replce exitential types
    Dynamic types provide operations to convert dynamic values to a monomorphic type.
    Still use Typeable under the hood.
@-}
-- using exitential type means we have to erase the type info, and later if we want to restore
-- them we somehow need to test the type at runtime. (Typeable.)
-- Another approach is to use Data.Dynamic

data IntWrapper = IntWrapper Int deriving (Typeable, Show, Eq)

addIntWrappter (IntWrapper a) (IntWrapper b) = IntWrapper $ a + b

-- wrap into dynamic varaible
d0 = toDyn (IntWrapper 1)
d1 = toDyn (MoneyEx (Money 12 :: Money 'USD))

d0' = fromDyn d0 (MoneyEx (Money 0 :: Money 'USD))
d1' = fromDyn d1 (MoneyEx (Money 0 :: Money 'USD))

d0'' :: Maybe MoneyEx
d0'' = fromDynamic d0

-- apply dynamic function to dynamic values.
dapplied :: Maybe IntWrapper
dapplied = do
  f1 <- dynApply (toDyn addIntWrappter) (toDyn (IntWrapper 1))
  r <- dynApply f1 (toDyn (IntWrapper 2))
  fromDynamic r

{-@ Conclusion
    1. Typeable is what gives you runtime type information check.

    2. Using the function cast, you can check whether a type is the one you want.

    3. case on type is doing pattern matching on type varaible, this violate parametricity.

    4. Having different behaviors based on different type based on the result of cast is really
       another type of adhoc polymorphism.

    5. Datakinds promotes types and values to kinds and types.

    6. At type level kinds indicates a set of types that's acceptable.

    7. Type family is the bread and butter of the type level computation. It's the function from
       type level to term level. (Type predicate + dictionary)

    8. Type family also pattern matches on type variable. As typeable, it also break the
       parametricity

    9. Typeable can be used to restore types hiden behind exitential type constructors.

    10. Or better, we can use Data.Dynamic to smuggle some types without GHC notices.

    11. Data.Dynamic provides full type erase + rtti. It gets much more freedom, thus much less
        typesafty.

        However in a lot of cases it's the best choice. Especially when you need to work on a list
        of existential types and do something base on their specific types.
@-}
{-# LANGUAGE AllowAmbiguousTypes   #-}
{-# LANGUAGE DataKinds             #-}
{-# LANGUAGE FlexibleContexts      #-}
{-# LANGUAGE FlexibleInstances     #-}
{-# LANGUAGE GADTs                 #-}
{-# LANGUAGE KindSignatures        #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE PolyKinds             #-}
{-# LANGUAGE ScopedTypeVariables   #-}
{-# LANGUAGE StandaloneDeriving    #-}
{-# LANGUAGE TypeApplications      #-}
{-# LANGUAGE TypeFamilies          #-}
{-# LANGUAGE TypeOperators         #-}
{-# LANGUAGE UndecidableInstances  #-}


module Types.TypeclassMetaprogramming where
import qualified Data.Map               as Map
import qualified Data.Vector            as Vector
import           Data.Void
import           Numeric.Natural

import           Control.Exception.Base (assert)
import           Data.Kind
import           System.IO

import           Data.Type.Equality

-- https://lexi-lambda.github.io/blog/2021/03/25/an-introduction-to-typeclass-metaprogramming/

-------------------------------------------------------------------------------
-- typeclass as function from type to term
-- use compile time information to generate runtime behavior.

class TypeOf a where
  typeOf :: String

instance TypeOf Bool where
  typeOf = "Bool"

instance TypeOf Char where
  typeOf = "Char"

instance (TypeOf a, TypeOf b) => TypeOf (a, b) where
  typeOf = "(" ++ typeOf @a ++ ", " ++ typeOf @b ++ ")"

-- type application allows us to define TypeOf for void.
instance TypeOf Void where
  typeOf = "Void"

instance TypeOf a => TypeOf [a] where
  typeOf = "[" ++ typeOf @a ++"]"

-------------------------------------------------------------------------------
-- type level interpreter
data Nat = Z | S Nat

class ReifyNat (a :: Nat) where
  reifyNat :: Natural

instance ReifyNat 'Z where
  reifyNat = 0

instance ReifyNat a => ReifyNat ('S a) where
  reifyNat = 1 + (reifyNat @a)

-------------------------------------------------------------------------------
-- overlapping instances.
-- this works somehow like template specialization in c++.
-- when there is overlapping instances, it choose the more specific instance

class IsUnit a where
  isUnit :: Bool

instance {-# OVERLAPPING #-} IsUnit () where
  isUnit = True

instance IsUnit a where
  isUnit = False

guardUnit :: forall a . IsUnit a => a -> Either String a
guardUnit x = case isUnit @a of
                True  -> Left "No unit"
                False -> Right x

-- Note this doesnt work because the instance needs to be picked at the compile
-- time, but we don't know which one to pick because type of a is instantiated
-- at runtime.
-- guardUnit :: forall a . a -> Either String a
-- guardUnit x = case isUnit @a of
--                 True -> Left "no unit"
--                 False -> Right x


-------------------------------------------------------------------------------
-- type families, function from type to type.

type family Sum a b where
  Sum Z b = b
  Sum (S a) b = S (Sum a b)

n1 = reifyNat @(Sum (S (S Z)) (S (S (S Z))))

-------------------------------------------------------------------------------
-- e.g flattern
-- concat with arbitrary depth.

type family ElementOf a where
  ElementOf [[a]] = ElementOf [a]
  ElementOf [a] = a

class Flatten a where
  flatten :: a -> [ElementOf a]

-- base case
instance (ElementOf [a] ~ a) => Flatten [a] where
  flatten = id

instance {-# OVERLAPPING #-} Flatten [a] => Flatten [[a]] where
  flatten = flatten . concat

n2 = flatten [[[1 :: Integer, 2], [3, 4]], [[5, 6], [7, 8]]]

-------------------------------------------------------------------------------
-- type class as compile type code generation.
-- in this case it works like templates.

-- flatten @[[Int]] ->  id . concat . concat
n3 = flatten @[[Int]] $ [[1, 2], [3, 4]]

-------------------------------------------------------------------------------
-- open type family written within type class.

class HasKey a where
  type Key a
  hasKey :: Key a -> a -> Bool

instance HasKey (Vector.Vector a) where
  type Key (Vector.Vector a) = Int
  hasKey i vs = i >= 9 && i < Vector.length vs

instance Ord k => HasKey (Map.Map k v) where
  type Key (Map.Map k v) = k
  hasKey = Map.member

-------------------------------------------------------------------------------
-- datatype generic programming

type Username = String
type Password = String
type PublicKey = String

-- Sum type version
data Authentication = AuthBaisc Username Password
                    | AuthSSH PublicKey

class GNumFields a where
  gnumFields :: a -> Natural

instance {-# OVERLAPPING #-} GNumFields () where
  gnumFields _ = 0

instance GNumFields a where
  gnumFields _ = 1

instance {-# OVERLAPPING #-} (GNumFields a, GNumFields b) => GNumFields (a, b) where
  gnumFields (a, b) = gnumFields a + gnumFields b

instance {-# OVERLAPPING #-} (GNumFields a, GNumFields b) => GNumFields (Either a b) where
  gnumFields (Left a)  = gnumFields a
  gnumFields (Right b) = gnumFields b

authGenerialize :: Authentication -> Either (Username, Password) PublicKey
authGenerialize (AuthBaisc u p) = Left (u, p)
authGenerialize (AuthSSH p)     = Right p

numFieldsAuth :: Authentication -> Natural
numFieldsAuth = gnumFields . authGenerialize

n4 = numFieldsAuth (AuthSSH "asd")
n5 = numFieldsAuth (AuthBaisc "asd" "asd")

-------------------------------------------------------------------------------
-- Define a generic  NumFields that works on any types.
-- The idea is to convert a type to a isomorphic representation that we can
-- work with.
-- If we have typeclass that works on the transformed representation, we can
-- do various things with the new representation and map it back when we
-- are finished

class Generik1 a where
  type Rep1 a
  genericize1 :: a -> Rep1 a

-- Rep maps the type to it's representation type.
-- in our case we want to map it to either or tuple so we can count with GNumFields.
instance Generik1 Authentication where
  type Rep1 Authentication = Either (Username, Password) PublicKey
  genericize1 (AuthBaisc user pass) = Left (user, pass)
  genericize1 (AuthSSH key)         = Right key

-- we want (Rep a) available for GNumFields
numFields :: (Generik1 a, GNumFields (Rep1 a)) => a -> Natural
numFields = gnumFields . genericize1

n6 = numFields (AuthBaisc "asd" "asd")
n7 = numFields (AuthSSH "asd")

-------------------------------------------------------------------------------
-- improve generic
-- 1. this type will give wrong numfields because Rep a will be two nested
--    either, one is only a representation for the sum type.
--    To solve this, we can wrap each leaf with a new type Leaf.
data Foo = A (Either Int String) | B (Char, Bool)
data Boool = FF | TT
newtype Leaf a = Leaf { getLeaf :: a }

class Generik2 a where
  type Rep2 a
  genericize2 :: a -> Rep2 a

instance Generik2 Authentication where
  type Rep2 Authentication = Either (Leaf Username, Leaf Password) (Leaf PublicKey)
  genericize2 (AuthBaisc user pass) = Left (Leaf user, Leaf pass)
  genericize2 (AuthSSH key)         = Right (Leaf key)

instance Generik2 Foo where
  type Rep2 Foo = Either (Leaf (Either Int String)) (Leaf (Char, Bool))
  genericize2 (A x) = Left (Leaf x)
  genericize2 (B x) = Right (Leaf x)

instance Generik2 Boool where
  type Rep2 Boool = Either () ()
  genericize2 FF = Left ()
  genericize2 TT = Right ()

numFields2 :: Generik2 a => GNumFields (Rep2 a) => a -> Natural
numFields2 = gnumFields . genericize2

n8 = numFields2 (A (Left 1))
n9 = numFields2 (B ('a', True))
n10 = numFields2 (AuthBaisc "asd" "asd")
n11 = numFields2 TT

------------------------------------------------------------------------------
-- dependent types

-- Note: a has kind *, so it will accpet whatever types. If the pattern
-- matching fails, it will get stuck.
-- For example, BadNot Char will return BadNot Char instead of evaluate further
--
-- DataKind promotes types to new kinds and constructors to types, which give
-- us more elements to work with at the type level.
type family BadNot a where
  BadNot 'True = 'False
  BadNot 'False = 'True

type family Not (a :: Bool) :: Bool where
  Not 'True = 'False
  Not 'False = 'True

------------------------------------------------------------------------------
-- runtime information -> compile time type
-- GADT and proof terms

data WhatIsIt a where
  ABool :: WhatIsIt Bool
  AInt :: WhatIsIt Int

-- the type of x is determined by tye constructor.
-- which constructor is passed is a runtime behavior. But we can infer the type
-- of the type parameter with GDAT
--
-- Think GADT as a proof of type equalities.
-- ABool => a ~ Bool
-- AInt => a ~ Int
doSometing :: WhatIsIt a -> a -> a
doSometing ABool x = not x
doSometing AInt x  = x + 1

-- GADT with type level list.
infixr 5 `HCons`

-- hetergenous list
-- we defined two propositions, a term level value is a proof of the proposition
data HList as where
  HNil :: HList '[]
  HCons :: a -> HList as -> HList (a ': as)

-- note because we specifically say the input is of type HList (a ': as), GHC
-- knows the list will not be empty.
headHList :: HList (a ': as) -> a
headHList (x `HCons` _) = x

type family Head as where
  Head (HList '[]) = 'Nothing
  Head (HList (a ': as)) = 'Just a

type family FromJust (a :: Maybe b) where
  FromJust (Just x) = x

-- note HList only takes kinds with *, it doesn't accept types promoted from
-- data constructors, because they have different kinds.
type T1 = Head (HList '[Bool, Char])

-- but for this case we need to handle the empty case
-- headHList' :: Head as => HList as -> Maybe a
-- headHList' (x `HCons` _) = Just x
-- headHList' HNil = Nothing

n12 = True `HCons` "hellow" `HCons` 42 `HCons` HNil

------------------------------------------------------------------------------
-- proofs that works together.
data OneToThree a b c as where
  One :: OneToThree a b c '[a]
  Two :: OneToThree a b c '[a, b]
  Three :: OneToThree a b c '[a, b, c]

sumUpToThree :: OneToThree Int Int Int as -> HList as -> Int
sumUpToThree One (x `HCons` HNil)                       = x
sumUpToThree Two (x `HCons` y `HCons` HNil)             = x + y
sumUpToThree Three (x `HCons` y `HCons` z `HCons` HNil) = x + y + z

------------------------------------------------------------------------------
-- we say: Give me a Even as, I can give you a Even (a ': b ': as) which has
-- at least two elements. the argument goes over inductively until hit the
-- base case. So this term proofs that the list is always even.

data Even as where
  EvenNil :: Even '[]
  EvenCons :: Even xs -> Even (a ': b ': xs)

-- grab two elements and pair them up.
type family PairUp as where
  PairUp '[] = '[]
  PairUp (a ': b ': xs) = (a, b) ': PairUp xs

-- pairup elements in a HList
-- Even as proofs that as must be even
-- note how it's passed as the first paramter
pairUp' :: Even as -> HList as -> HList (PairUp as)
pairUp' EvenNil HNil                             = HNil
pairUp' (EvenCons even) (x `HCons` y `HCons` xs) = (x, y) `HCons` pairUp' even xs

n14 = pairUp' (EvenCons EvenNil) (() `HCons` "foo" `HCons` HNil)
n15 = pairUp' (EvenCons $ EvenCons EvenNil)
             (True `HCons` 'a' `HCons` () `HCons` "foo" `HCons` HNil)
n16 = pairUp' (EvenCons $ EvenCons $ EvenCons EvenNil)
             (False `HCons` 1 `HCons` True `HCons` 'a' `HCons` () `HCons` "foo" `HCons` HNil)

------------------------------------------------------------------------------
-- What if we don't want to pass Even proof term all the time?
-- remeber typeclass is type predicate + type to term funcction
-- this is a simple application of the tmp technique.

class IsEven as where
  evenProof :: Even as

instance IsEven '[] where
  evenProof = EvenNil

instance IsEven as => IsEven (a ': b ': as) where
  evenProof = EvenCons evenProof


-- as = '[Bool, Bool, Bool, Bool],
-- evenProof
-- = EvenCons (evenProof :: '[Bool, Book])
-- = EvenCons (EvenCons (evenProof :: '[])))
-- = EvenCons (EvenCons EvenNil)
-- Even is used to construct proof recursively.
-- The purpose of evenProof is to be a proof term that can recursively generate
-- new EvenCons base on the type as.
pairUp :: IsEven as => HList as -> HList (PairUp as)
pairUp = go evenProof
  where
    go :: Even as -> HList as -> HList (PairUp as)
    go EvenNil HNil                             = HNil
    go (EvenCons even) (x `HCons` y `HCons` xs) = (x, y) `HCons` go even xs

-- now the proof is implicit
n17 = pairUp (() `HCons` "foo" `HCons` HNil)

------------------------------------------------------------------------------
-- GADT vs type family

-- EvenPairsCons EvenPairsNil :: '[a, b] [(a, b)]
-- EvenPairsCons (EvenPairsCons EvenPairsNil) :: '[a, b, c, d] [(a, b), (c, d)]
data EvenPairs as bs where
  EvenPairsNil :: EvenPairs '[] '[]
  EvenPairsCons :: EvenPairs xs ys -> EvenPairs (a ': b ': xs) ((a, b) ': ys)

-- what is a function? A function is a mapping, in a set theory pov it's an
-- ordered pair relates input and output.
-- If we can construct a proof that relates it's input and output, we don't
-- really need type family anyway.
-- Here, EvenPairs takes an input type as, and the output tupe is bs. The
-- relation between as and bs is defined in the GADT. We can just us bs as if
-- we have a type famliy PairUp.
pairUp1 :: EvenPairs as bs -> HList as -> HList bs
pairUp1 EvenPairsNil HNil = HNil
pairUp1 (EvenPairsCons even) (x `HCons` y `HCons` xs) = (x, y) `HCons` pairUp1 even xs

------------------------------------------------------------------------------
-- Type family to achieve the smae
-- I find type family is much easier to write...

-- a type level predicate that constraint a list to be even elements.
type family IsEvenTF as :: Constraint where
  IsEvenTF '[] = ()
  IsEvenTF (_ ': _ ': xs) = IsEvenTF xs

type family FirstTwo as where
  FirstTwo '[] = '[]
  FirstTwo (a ': b ': _) = a ': b ': '[]

firstTwo :: IsEvenTF as => HList as -> HList (FirstTwo as)
firstTwo HNil                    = HNil
firstTwo (x `HCons` y `HCons` _) = x `HCons` y `HCons` HNil

pairUp2 :: IsEvenTF as => HList as -> HList (PairUp as)
pairUp2 HNil                     = HNil
pairUp2 (x `HCons` y `HCons` xs) = (x, y) `HCons` pairUp2 xs

n18 = firstTwo (1 `HCons` "a" `HCons` 3 `HCons` 'a' `HCons` HNil)
n19 = pairUp2 (1 `HCons` "a" `HCons` 3 `HCons` 'a' `HCons` HNil)

-- GADT vs type family:
-- GADT + proofterm can achieve similar effect as type family, but GADT more
-- precise constraints.

------------------------------------------------------------------------------
-- Guided type inference

class UnitList as where
  unitList :: HList as

instance UnitList '[] where
  unitList = HNil

-- How does GHC resolve which instance to use?
-- First it match instance head, if it matches it will try to solve the
-- constraint imposed from the instance context.
-- For example
-- instance head UnitList (() ': as) will only pick elements with first element
-- to be a unit.
-- while UnitList (a ': as) will be picked for all lists.
-- this constriant the list can only be a list of units
--
-- If we want a finer control for type inference, we can move information in
-- the instance head to instance context and hand write constraints.
instance (a ~ (), UnitList as) => UnitList (a ': as) where
  unitList = () `HCons` unitList

-- create a HList with 3 units without defining it explicitly.
-- TMP generate the term for us.
n20 = unitList :: HList '[(), (), ()]

unsingleton :: HList '[a] -> a
unsingleton (x `HCons` HNil) = x

n21 = unsingleton (unitList :: HList '[()])
n22 = unsingleton unitList

------------------------------------------------------------------------------
-- Subtyping constraints.
-- In haskell we don't have subtyping, beacuse it doesn't support type inferece.
-- instead most ppl use polymorphism to get around with it.
-- Subtyping is not a equivalence relation, so we can't simpmly run unification
-- algorithm on different types.

-- Something can be a input, or an output.  both is a subtype of both.
data GQLKind
  = Both
  | Input
  | Output

-- how it may be used
data GQLType k where
  TScalar :: GQLType 'Both
  TInputObject :: Int -> GQLType 'Input
  TIObject :: Int -> GQLType 'Output

-- proof subkinding relationship
-- To proof the relationship we give an instance of value in the propositrion
data SubKind (k1 :: GQLKind) (k2 :: GQLKind) where
  KRefl :: SubKind k k    -- two k must be the same
  KBoth :: SubKind 'Both k -- whatever k will do.

-- Use typeclass to help us to generate proof.
class IsSubKind k1 k2 where
  subKindProof :: SubKind k1 k2

-- ignore k
instance IsSubKind 'Both k where
  subKindProof = KBoth

-- only accept Input
instance (k ~ 'Input) => IsSubKind 'Input k where
  subKindProof = KRefl

instance (k ~ 'Output) => IsSubKind 'Output k where
  subKindProof = KRefl

data GQLParser (k :: GQLKind) a where
  GQLParser :: a -> GQLParser k a

nullable :: IsSubKind k 'Input => GQLParser k a -> GQLParser k (Maybe a)
nullable = undefined

n23 = nullable (GQLParser @Int @'Input 1)
n24 = nullable (GQLParser @Int @'Both 1)

-- same thing.
n25 = (nullable psin, nullable psout)
  where
    psin :: GQLParser 'Input Int
    psin = undefined

    psout :: GQLParser 'Both Int
    psout = undefined

data PValue = InputValue | SelectionSet

type family ParserInput k where
  ParserInput 'Both = InputValue
  ParserInput 'Input = InputValue
  ParserInput 'Output = SelectionSet

-- Refl gives a proof of a equals to b. w
-- :~: itself is a type. ~ is an operator for imposing type equality constraint
-- Use Refl to write a resuable proof.
inputParserInput :: forall k. IsSubKind k 'Input => ParserInput k :~: InputValue
inputParserInput = case subKindProof @k @'Input of
                    KRefl -> Refl
                    KBoth -> Refl

-- use the reusable proof term to redefine nullable
nullable1 :: forall k a. IsSubKind k 'Input => GQLParser k a -> GQLParser k (Maybe a)
nullable1 parser = case inputParserInput @k of
                     Refl -> undefined

------------------------------------------------------------------------------
run :: IO ()
run = do
  assert (n1 == 5) (return ())
  assert (n2 == [1..8]) (return ())
  assert (n3 == [1..4]) (return ())
  assert (n4 == 1) (return ())
  assert (n5 == 2) (return ())
  assert (n6 == 2) (return ())
  assert (n7 == 1) (return ())
  assert (n8 == 1) (return ())
  assert (n9 == 1) (return ())
  assert (n10 == 2) (return ())
  assert (n11 == 0) (return ())
module Test where

{-@ Test editor config @-}

main :: IO ()
main = undefined
main :: IO ()
main = putStrLn "Test suite not yet implemented"
section
variables (P Q : Prop)

theorem my_theorem : P ∧ Q → Q ∧ P :=
assume h : P ∧ Q,
have P, from and.left h,
have Q, from and.right h,
show Q ∧ P, from and.intro ‹Q› ‹P›

end
#include <fcntl.h>
#include <linux/fs.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/uio.h>

#if defined(Debug)
const size_t BLOCK_SZ = sizeof(void *);
#else
const size_t BLOCK_SZ = 4096;
#endif

off_t get_file_size(int fd) {
  struct stat st;

  // use fstat and fd to get status info of the file.
  if (fstat(fd, &st) < 0) {
    perror("fstat");
    return -1;
  }

  // test file type
  if (S_ISBLK(st.st_mode)) {
    off_t bytes;

    // ioctl generic way to send request to a device driver.
    if (ioctl(fd, BLKGETSIZE64, &bytes) != 0) {
      perror("ioctl");
      return -1;
    }
    return bytes;

  } else if (S_ISREG(st.st_mode)) {
    return st.st_size;
  }

  return -1;
}

void output_to_console(const char *buf, size_t len) {
  fwrite(buf, 1, len, stdout);
}

int read_and_print_file(char *filename) {
  // simple buffer with length
  struct iovec *iovecs;
  int file_fd = open(filename, O_RDONLY);

  if (file_fd < 0) {
    perror("open");
    return 1;
  }

  off_t file_sz = get_file_size(file_fd);
  off_t bytes_remaining = file_sz;

  int blocks = (int)file_sz / BLOCK_SZ;
  if (file_sz % BLOCK_SZ)
    blocks++;
  iovecs = (struct iovec *)malloc(sizeof(struct iovec) * blocks);

  int current_block = 0;

  while (bytes_remaining) {
    off_t bytes_to_read = bytes_remaining;
    if (bytes_to_read > BLOCK_SZ) {
      bytes_to_read = BLOCK_SZ;
    }

    // allocate buffer for iovecs.
    void *buf;
    if (posix_memalign(&buf, BLOCK_SZ, BLOCK_SZ)) {
      perror("posix_memalign");
      return 1;
    }

    iovecs[current_block].iov_base = buf;
    iovecs[current_block].iov_len = bytes_to_read;
    current_block++;
    bytes_remaining -= bytes_to_read;
  }

  // read files into iovecs blocks.
  // (base: [...], len), (base: [...], len ...)
  // readv will block until all buffers are filled.
  int ret = readv(file_fd, iovecs, blocks);
  if (ret < 0) {
    perror("readv");
    return 1;
  }

  for (int i = 0; i < blocks; i++) {
    output_to_console((const char *)iovecs[i].iov_base, iovecs[i].iov_len);
  }

  free(iovecs);
  return 0;
}

int main(int argc, char *argv[]) {
  if (argc < 2) {
    fprintf(stderr, "Usage: %s <filename> [<filename1>...]\n", argv[0]);
  }

  for (int i = 1; i < argc; i++) {
    if (read_and_print_file(argv[i])) {
      fprintf(stderr, "Error reading file\n");
      return 1;
    }
  }

  return 0;
}
#include <linux/fs.h>
#include <linux/io_uring.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/uio.h>

#define QUEUE_DEPTH 1
#define BLOCK_SZ 1024

// To avoid memory reordering.
// Note: memory reordering are ways the compiler uses to utilize some
// cpu technqiues like pipelining.
// But it might not be what we want. For example, int
#define read_barrier() __asm__ __volatile__("" :::"memory")
#define write_barrier() __asm__ __volatile__("" :::"memory")
#include <assert.h>
#include <fcntl.h>
#include <liburing.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

// TODO

struct read_descriptor {
  int fd;
  char *buf;
  size_t pos;
  size_t size;
  int result;
};

void free_read_descriptor(struct read_descriptor *desc) {
  free(desc->buf);
  free(desc);
}

int dispatch_reads(struct io_uring *ring, struct read_descriptor *descv,
                   size_t nrdesc) {
  int i;

  for (i = 0; i < nrdesc; i++) {
    struct io_uring_sqe *sqe;
    struct read_descriptor *desc = &descv[i];

    sqe = io_uring_get_sqe(ring);
    io_uring_prep_read(sqe, desc->fd, desc->buf, desc->size, desc->pos);
    io_uring_sqe_set_data(sqe, desc);
  }

  return io_uring_submit(ring);
}

int consume_reads(struct io_uring *ring) {
  int completed;
  int head;
  struct io_uring_cqe *cqe;

  io_uring_for_each_cqe(ring, head, cqe) {
    completed++;
    struct read_descriptor *desc = (struct read_descriptor *)cqe->user_data;
    desc->result = cqe->res;
  }

  io_uring_cq_advance(ring, completed);
}

int init_files(struct io_uring *ring, const char *prefix, int *fds,
               const size_t n_fds) {

  if (strlen(prefix) > 128) {
    fprintf(stderr, "the length of file prefix cannot exceed 128\n");
  }

  if (n_fds > 128) {
    fprintf(stderr, "cannot create more than 128 files at once\n");
  }

  const char *buf = "some text to write";
  int fd;
  char filename[256];

  for (int i = 0; i < n_fds; i++) {
    sprintf(filename, "%s-%d", prefix, i);
    fd = open(filename, O_CREAT | O_RDWR, S_IRUSR | S_IRGRP | S_IROTH);
    fds[i] = fd;

    struct io_uring_sqe *sqe;
    sqe = io_uring_get_sqe(ring);
    io_uring_prep_write(sqe, fd, buf, strlen(buf), 0);
  }
  return io_uring_submit(ring);
}

int complete_write_files(struct io_uring *ring, const size_t n_fds) {}

struct read_descriptor *make_descriptors(struct io_uring *ring,
                                         const size_t n) {
  int fds[n];
  init_files(ring, "sample", fds, n);

  struct read_descriptor *descv =
      (struct read_descriptor *)malloc(sizeof(struct read_descriptor) * n);

  for (int i = 0; i < n; i++) {
    descv[i].fd = fds[i];
  }

  return NULL;
}

int main(void) {
  for (;;) {
  }
  return 0;
}
#include <stdio.h>
#include <stdlib.h>

#include <sys/types.h>
#include <sys/uio.h>
#include <unistd.h>

int main(void) {
  const char *buf1 = "Hello, ";
  const char *buf2 = "Haskell ";
  const char *buf3 = "Curry\n";

#ifdef DEBUG
  fprintf(stderr, "sizeof buf1: %d\n", sizeof(buf1));
#endif

  // sizeof(...) - 1 because we don't want to write \0.
  struct iovec bufs[] = {
      {.iov_base = (void *)buf1, .iov_len = sizeof(buf1) - 1},
      {.iov_base = (void *)buf2, .iov_len = sizeof(buf2) - 1},
      {.iov_base = (void *)buf3, .iov_len = sizeof(buf3) - 1},
  };

  // write data of iovec.
  if (writev(STDOUT_FILENO, bufs, sizeof(bufs) / sizeof(*bufs)) == -1) {
    perror("writev()");
    exit(EXIT_FAILURE);
  }

  return EXIT_SUCCESS;
}
#include <fcntl.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <unistd.h>

// map or unmap files or devices into memory
//
// mmap creats a new mapping in the virtual address space of the calling
// process.
// params:
//  addr: starting address for the new mapping
//  length: length of the mapping
//  prot: memory protectoin level
//  flags: general configs (shared? etc)
//  fd:
//  offset:
//
// What can you do with it?
//   map something to your virtual memory address.
//   the "something" can be very board. It can be actual physical memory, disk,
//   or socket.

//////////////////////////////////////////////////
// basic usage of mmap
int basic() {
  // get the size of a system page
  size_t pagesize = getpagesize();

  printf("System page size: %zu\n", pagesize);

  char *region = (char *)mmap((void *)(1 << 20), pagesize,
                              PROT_READ | PROT_WRITE | PROT_EXEC,
                              MAP_ANON | MAP_PRIVATE, 0, 0);
  strcpy(region, "Hello mmap\n");
  printf("Content of the region: %s", region);

  if (munmap(region, 1 << 10)) {
    perror("Cannot unmap\n");
    return 1;
  }

  return 0;
}

//////////////////////////////////////////////////
// allocate heap anonymous memory
// note leak on memory acquired by mmap will not be detected by valgrind.
void allocate_anonymous_memory_helper(void **p) {
  size_t pagesize = getpagesize();
  *p = mmap(0, pagesize * 10, PROT_READ | PROT_WRITE,
            MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
}

int allocate_anonymous_memory() {
  char *p = NULL;
  allocate_anonymous_memory_helper((void **)&p);

  strcpy(p, "hi I'm newly allocated memory");
  printf("%s\n", p);

  if (munmap(p, getpagesize() * 10)) {
    perror("Cannot unmap\n");
    return 1;
  }
  return 0;
}

//////////////////////////////////////////////////
// render a piece of memory unreadable

void unreadable() {
  size_t pagesize = getpagesize();
  void *p = malloc(128);
  size_t pg = pagesize > 128 ? pagesize : ceil(pagesize / 128);
  void *q = mmap(p, pg, PROT_NONE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
  strcpy((char *)p, "try this\n");

  // this will segfault now.
  // printf("\s\n", q);

  if (munmap(q, pg)) {
    perror("Cannot unmap\n");
  }
}

//////////////////////////////////////////////////
// map virtual address space to a disk file directly
// This will not actually load the entire content in to the memory. Instead
// data is loaded when used.
// There is no guarantee that when modificaition will be flushed. Linux
// ensure change on the file will be flushed on the disk, but it can happen
// anytime after the write operation is done.
// msync can be used to force flush.

int map_disk_file() {
  const char str1[] = "string 1";

  void *p, *q;
  int fd = -1;
  if ((fd = open("./sample1", O_RDWR, 0)) == -1) {
    perror("open error\n");
    return -1;
  }

  p = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, -1, 0);

  // the OS maintains page cache like how db does. When accessing a mmaped
  // file, kernel loads the portion into the cache. The cache resides in the
  // kernel space.
  // After operation is done, the modified content will remain in the page
  // cache. The OS will flush the change when possible.
  q = mmap(NULL, 3096, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);

  printf("q from file: %s\n", (char *)q);
  strcpy((char *)p, (char *)q);

  // handle mmaped memory as an ordinary memory
  char *cur = NULL;
  for (cur = (char *)p; *cur != '\0'; ++cur)
    ;

  strcpy(cur, str1);

  printf("p copied from q append with string1: %s\n", (char *)p);

  if (munmap(p, 4096)) {
    perror("unmap erroron p");
    return 1;
  }

  if (munmap(q, 4096)) {
    perror("unmap erroron p");
    return 1;
  }

  return 0;
}

int main(void) {
  // allocate_anonymous_memory();

  // unreadable();
  map_disk_file();
  return 0;
}
// how do we avoid blocking?
// 1. set all descriptor in nonblocking mode, and busy polling on all of them.
// (100% cpu usage.)
// 2. enable all descriptors of interest to send singal when IO can be done
// (fcntl, SIGIO)
// 3. System provide a method for asking which descriptor are capable of
// performing IO (epoll)
// 4. Having the process register with OS all events on descriptor that is
// intereted in tracking.

#include <stdio.h>
int main(int argc, char *argv[]) {
  return 0;
}
#include <errno.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <sys/wait.h>
#include <unistd.h>

// signal handling.
// signal:      specify the signal for the current process.
// sigfillset:  add all semaphore into one signal set.
// execve:      execute
// sigprocmsk:  mask process signal.

// - after fork, the child process will inherits it's parent's setting on signal
// masks and signal handling configs
// - execve will reset the text section, heap, and stack of the current process.
// - every process has their own signal mask set. if a signal in the mask is
// fired, it will be pushed into a queue and defer the handling. We say the
// signal is in a pending state.
// - after child process exit, it will send the parent process a SIGCHLD. It
// indicates that the parent process need to call wait_pid to handle the child
// process. If the parent didn't handle the child process, the child process
// will become a zombie process.
//
// - after a signal is triggered, it will jump to the corresponding signal
// handling function.

void deletejob(pid_t pid) { printf("delete task %d\n", pid); }
void addjob(pid_t pid) { printf("add task %d\n", pid); }

void handler(int sig) {
  int olderrno = errno;
  sigset_t mask_all, prev_all;
  pid_t pid;

  // add all semaphore to the signal set.
  sigfillset(&mask_all);
  while ((pid = waitpid(-1, NULL, 0)) > 0) {
    // block signal to make sure the job will not be interrupted.
    sigprocmask(SIG_BLOCK, &mask_all, &prev_all);
    deletejob(pid);
    // unblock
    sigprocmask(SIG_SETMASK, &prev_all, NULL);
  }

  if (errno != ECHILD) {
    printf("waitpid error");
  }
}

int main(int argc, char *argv[]) {

  int pid;
  sigset_t mask_all, prev_all;
  sigfillset(&mask_all);

  // if receiveSIGCHLD, call handler
  signal(SIGCHLD, handler);
  while (1) {
    if ((pid = fork()) == 0) {
      // fork and execute a new process.
      // this will call date program, and then exit.
      // when a child process exits, it will send it's parent a SIGCHLD singal.
      // The parent process should call wait_pid to handle it.
      execve("/bin/date", argv, NULL);
    }

    // if it's the parent proces, report the new process just created. This is
    // protected by sigprocmask, so if there is a SIG_BLOCK sent in addjob will
    // still be called.
    sigprocmask(SIG_BLOCK, &mask_all, &prev_all);
    addjob(pid);
    sigprocmask(SIG_SETMASK, &prev_all, NULL);
  }
  return 0;
}
#include <ao/ao.h>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <math.h>
#include <thread>
#include <time.h>
#include <unistd.h>
#include <xcb/xcb.h>
#include <xcb/xcb_event.h>
#include <atomic>

// X c bindings, low level api for x window server.
// xcb is an alternative of xlib,

// Client and server model of X window system.
// Two parts:
// 1. Client decide what to do
// 2. X server actually draw on the screen and read user inputs.
// Note it's a bit different from a normal client server.
// Server handles drawing, so if you want to render a window
// on a remote machine, the remote machine need to run a server.

// X11 use x message protocol. It's orignally a TCP/IP net based protocol,
// but you also optimization for local client. Like using shared
// memory and unix domain socket.

// GUI programming and asynchronous nature.
// GUI program usually use asynchronous model. (event driven programming.)
// The program mostly sit aside, waiting for events event by the X server,
// and acts on these events.
//
// For an asynchronous model, a very important part to be aware is not to make
// your callback too big. If it takes up too much time, it will block the
// event queue and cause your UI hangs.

// Some basic notion of xcb
// 1. X connection
//    represents connection with given x server. It hides queue of
//    messages coming from the server, and queue of pending requests that
//    the client intends to send to the server.
// 2. Request and reply are not locked, the cost of round trip time is
// suppressed.
// 4. Graphics context
// 5. Events

ao_device *device;
ao_sample_format format;
int default_driver;
char *buffer;
int buf_size;
int sample;
int i;

void beep(float freq = 440.0) {
  /* -- Play some stuff -- */
  buf_size = format.bits / 8 * format.channels * format.rate;
  buffer = static_cast<char *>(calloc(buf_size, sizeof(char)));

  for (i = 0; i < format.rate; i++) {
    sample =
        (int)(0.75 * 32768.0 * sin(2 * M_PI * freq * ((float)i / format.rate)));

    /* Put the same stuff in left and right channel */
    buffer[4 * i] = buffer[4 * i + 2] = sample & 0xff;
    buffer[4 * i + 1] = buffer[4 * i + 3] = (sample >> 8) & 0xff;
  }
  ao_play(device, buffer, buf_size);
}

void report_screen(xcb_screen_t *screen) {
  std::cout << "==========GUI START============" << std::endl;
  std::cout << "screen: " << screen->root << std::endl;
  std::cout << "width: " << screen->width_in_pixels << std::endl;
  std::cout << "height: " << screen->height_in_pixels << std::endl;
  std::cout << "black pix: " << screen->black_pixel << std::endl;
  std::cout << "white pix: " << screen->white_pixel << std::endl;
  std::cout << "===============================" << std::endl;
}

int main(void) {

  /* -- Initialize -- */
  ao_initialize();

  /* -- Setup for default driver -- */
  default_driver = ao_default_driver_id();

  memset(&format, 0, sizeof(format));
  format.bits = 16;
  format.channels = 2;
  format.rate = 44100;
  format.byte_format = AO_FMT_LITTLE;

  /* -- Open driver -- */
  device = ao_open_live(default_driver, &format, NULL);
  if (device == NULL) {
    fprintf(stderr, "Error opening device.\n");
    exit(-1);
  }

  // end init libao

  int screen_num;

  // to do anythign you need a x server connection
  xcb_connection_t *conn = xcb_connect(NULL, &screen_num);

  if (xcb_connection_has_error(conn)) {
    std::cout << "error on connection" << std::endl;
    exit(1);
  }

  // get setup of this connection
  const xcb_setup_t *setup = xcb_get_setup(conn);

  // iterator of all screens.
  xcb_screen_iterator_t iter = xcb_setup_roots_iterator(setup);

  xcb_screen_t *screen = iter.data;
  report_screen(screen);

  // create window
  // config the window to take events.
  unsigned int value_mask = XCB_CW_BACK_PIXEL | XCB_CW_EVENT_MASK;
  unsigned int value_list[]{screen->white_pixel, XCB_EVENT_MASK_BUTTON_PRESS |
                                                     XCB_EVENT_MASK_KEY_PRESS |
                                                     XCB_EVENT_MASK_EXPOSURE};

  uint32_t window_id = xcb_generate_id(conn);

  xcb_create_window(conn, screen->root_depth, window_id, screen->root, 0, 0,
                    100, 100, 1, XCB_WINDOW_CLASS_INPUT_OUTPUT,
                    screen->root_visual, value_mask, &value_list);
  xcb_map_window(conn, window_id);

  xcb_flush(conn);

  // generic event takes all type of event.
  xcb_generic_event_t *evt;
  std::thread note;
  std::atomic<int> new_notehit;

  while ((evt = xcb_wait_for_event(conn))) {
    switch (evt->response_type) {
    case XCB_KEY_PRESS: {
      std::cout << "key is pressed"
                << (int)((xcb_key_press_event_t *)(evt))->detail << std::endl;

      switch ((int)((xcb_key_press_event_t *)(evt))->detail) {
      case 38: // F

        note = std::thread([]() { beep(349.23); });
        note.detach();
        break;
      case 39: // G
        std::thread([]() { beep(392); }).detach();
        break;
      case 40: // A
        std::thread([]() { beep(440); }).detach();
        break;
      case 41: // B
        std::thread([]() { beep(493.88); }).detach();
        break;
      case 42: // C
        std::thread([]() { beep(523.25); }).detach();
        break;
      case 43: // D
        std::thread([]() { beep(587.33); }).detach();
        break;
      case 44: // E
        std::thread([]() { beep(659.25); }).detach();
        break;
      case 45: // F
        std::thread([]() { beep(698.46); }).detach();
        break;

      default:
        std::thread([]() { beep(); }).detach();
      }

    } break;
    case XCB_BUTTON_PRESS:
      std::cout << "button pressed"
                << (int)((xcb_button_press_event_t *)(evt))->detail
                << std::endl;
      break;
    default:
      break;
    }
    free(evt);
  }

  xcb_disconnect(conn);

  /* -- Close and shutdown -- */
  ao_close(device);

  ao_shutdown();

  return 0;
}
;; binary tree implementation
(deftype uint () '(unsigned-byte 62))   ; define a integer alias.

(defconstant min-depth 4 "Minial depth of the binary tree.")
(defconstant num-workers 4 "Number of concurrent workers.")

(defun build-tree (depth)
  "Build binary tree with the given depth. Leaves are nil, branchs
   are cons cells"
  (declare (ftype (function (uint) list) build-tree)    ; declare a function type
           (uint depth)
           (optimize (speed 3) (safety 0)))
  (if (zerop depth)
      (cons nil nil)    ; why is this a tree?
      (cons (build-tree (1- depth))
            (build-tree (1- depth)))))

(defun check-node (node)
  (declare (ftype (function (list) uint) check-node)
           (optimize (speed 3) (safety 0)))
  (if (null (car node))
      1
      (the uint (+ 1 (check-node (car node)) (check-node (cdr node))))))

(defun check-trees-of-depth (depth max-depth)
  (declare (uint depth max-depth)
           (optimize (speed 3) (safety 0))))
(declaim (optimize (speed 3) (safety 0) (space 0) (debug 0)))

(defconstant +days-per-year+ 365.24d0)
(defconstant +solar-mass+ (* 4d0 pi pi))

;; Both defstruct and deftype will introduce new type into the system
;; type and classes are different, not like in python the definitions are
;; very blury.
(defstruct (body (:type (vector double-float))
                 (:conc-name nil)
                 (:constructor make-body (x y z vx vy vz mass)))
  x y z
  vx vy vz
  mass)
(deftype body () '(vector double-float 7))

(defparameter *jupiter*
  (make-body 4.84143144246472090d0
             -1.16032004402742839d0
             -1.03622044471123109d-1
             (* 1.66007664274403694d-3 +days-per-year+)
             (* 7.69901118419740425d-3 +days-per-year+)
             (* -6.90460016972063023d-5  +days-per-year+)
             (* 9.54791938424326609d-4 +solar-mass+)))

(defparameter *saturn*
  (make-body 8.34336671824457987d0
             4.12479856412430479d0
             -4.03523417114321381d-1
             (* -2.76742510726862411d-3 +days-per-year+)
             (* 4.99852801234917238d-3 +days-per-year+)
             (* 2.30417297573763929d-5 +days-per-year+)
             (* 2.85885980666130812d-4 +solar-mass+)))

(defparameter *uranus*
  (make-body 1.28943695621391310d1
             -1.51111514016986312d1
             -2.23307578892655734d-1
             (* 2.96460137564761618d-03 +days-per-year+)
             (* 2.37847173959480950d-03 +days-per-year+)
             (* -2.96589568540237556d-05 +days-per-year+)
             (* 4.36624404335156298d-05 +solar-mass+)))

(defparameter *neptune*
  (make-body 1.53796971148509165d+01
             -2.59193146099879641d+01
             1.79258772950371181d-01
             (* 2.68067772490389322d-03 +days-per-year+)
             (* 1.62824170038242295d-03 +days-per-year+)
             (* -9.51592254519715870d-05 +days-per-year+)
             (* 5.15138902046611451d-05 +solar-mass+)))

(defparameter *sun*
  (make-body 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 0.0d0 +solar-mass+))

(declaim (inline applyforces))
(defun applyforces (a b dt)
  (declare (type body a b) (type double-float dt))
  (let* ((dx (- (x a) (x b)))
         (dy (- (y a) (y b)))
         (dz (- (z a) (z b)))
         (distance (sqrt (+ (* dx dx) (* dy dy) (* dz dz))))
         (mag (/ dt (* distance distance distance)))
         (dxmag (* dx mag))
         (dymag (* dy mag))
         (dzmag (* dz mag)))
        (decf (vx a) (* dxmag (mass b)))
        (decf (vy a) (* dymag (mass b)))
        (decf (vz a) (* dzmag (mass b)))
        (incf (vx b) (* dxmag (mass a)))
        (incf (vy b) (* dymag (mass a)))
        (incf (vz b) (* dzmag (mass a))))
  nil)

(defun advance (system dt)
  (declare (double-float dt))
  (loop for (a . rest) on system do
        (dolist (b rest)
                (applyforces a b dt)))
  (dolist (b system)
          (incf (x b) (* dt (vx b)))
          (incf (y b) (* dt (vy b)))
          (incf (z b) (* dt (vz b))))
  nil)

(defun energy (system)
  (let ((e 0.0d0))
       (declare (double-float e))
       (loop for (a . rest) on system do
             (incf e (* 0.5d0
                        (mass a)
                        (+ (* (vx a) (vx a))
                           (* (vy a) (vy a))
                           (* (vz a) (vz a)))))
             (dolist (b rest)
                     (let* ((dx (- (x a) (x b)))
                            (dy (- (y a) (y b)))
                            (dz (- (z a) (z b)))
                            (dist (sqrt (+ (* dx dx) (* dy dy) (* dz dz)))))
                           (decf e (/ (* (mass a) (mass b)) dist)))))
       e))

(defun offset-momentum (system)
  (let ((px 0.0d0)
        (py 0.0d0)
        (pz 0.0d0))
       (dolist (p system)
               (incf px (* (vx p) (mass p)))
               (incf py (* (vy p) (mass p)))
               (incf pz (* (vz p) (mass p))))
       (setf (vx (car system)) (/ (- px) +solar-mass+)
             (vy (car system)) (/ (- py) +solar-mass+)
             (vz (car system)) (/ (- pz) +solar-mass+))
       nil))

(defun nbody (n)
  (declare (fixnum n))
  (let ((system (list *sun* *jupiter* *saturn* *uranus* *neptune*)))
       (offset-momentum system)
       (format t "~,9F~%" (energy system))
       (dotimes (i n)
                (advance system 0.01d0))
       (format t "~,9F~%" (energy system))))

(defun main ()
  (let ((n (parse-integer (or (car (last #+sbcl sb-ext:*posix-argv*
                                         #+cmu  extensions:*command-line-strings*
                                         #+gcl  si::*command-args*)) "1"))))
       (nbody n)))
;;;; alist and plist
;; plist is simply key value alterantivly stored in the list.
;; alist is a list of key value pairs.

;;;; Some examples with plist.
(setf plist '(:foo 10 :bar 20 :goo 30))
;; get
(getf plist :foo)
;; set
(setf (getf plist :foo) 11)
;; notice each symbol also has it's own plist
(get 'plist :k)
(setf (get 'plist :k) 100)

;; this plist is different from the plist we created above.
;; plist is a symbol that it's value is a property list
;; a symbol can have mutiple cells, refer to values in different name spaces.
;; the most famous example is value and function. ;
;; while (symbol-plist) is the plist in the symbol's property list cell.
;; plist historically was like slot in python that holds entries like value or
;; functions, but now it's just an annoying historical legacy.
(symbol-plist 'plist)   ;;  don't use it.

;; that's it...

;;;; Some examples with alist.
(setf alist '((:foo . 10) (:bar . 20) (:coo . 30)))

;; get from alist
(assoc :foo alist)

;; find
(rassoc 20 alist)
(rassoc-if (lambda (x) (> x 24)) alist)

;; push
(acons :doo 100 alist)

;; add buch of duplicates
(push  '(:poo . 99) alist)
(push  '(:poo . 99) alist)
(push  '(:poo . 99) alist)
(push  '(:poo . 99) alist)

(remove-duplicates alist :test #'equal)
#|
    learn some common lisp today.
|#

; single line comment

(defun meaning (life)
  (let ((meh "abc"))
    (loop :for x :across meh  ; store values into x then return it.
          :collect x)))

(meaning '())

; creates a symbol from a string
(intern "AAAA")

(let ((me "dance with you")) me)

;; Structs
(defstruct dog name breed age)
(defparameter *rover*
  (make-dog :name "rover"
          :breed "collie"
          :age 5))

(character-to-morse #\a)

*rover*
(dog-p *rover*)
(dog-name *rover*)

;; pairs
(cons 'subject 'verb)
(car (cons 'subject 'verb))
(cdr (cons 'subject 'verb))

;; list
(cons 1 (cons 2 (cons 3 nil)))
(list 1 2 3)

(concatenate 'list '(1 2) '(3 4))

#(1 2 3)

(make-array (list 2 2))

; create a hashtable
(defparameter *m* (make-hash-table))

(setf (gethash 'a *m*) 1)

(gethash 'a *m*)

; functions
(lambda () "hello world")

(defun helloworld () "hello world")
(defun hello (name) (format nil "Hello, ~A" name))
(hello "good")

; optional arguments
(defun hello- (name &optional from)
  (if from
      (format t "Hello, ~A from ~A" name from)
      (format t "Hello, ~A" name)))
(hello- "good")
(hello- "good" "me")


(defun fact1 (n)
  (if (< n 2)
      1
      (* fact1 (- n 1))))

(fact1 5)

(defun (lamdba (x)
               (fact0)))

;; log rules
(defun log-rule1 (m n)
  (= (log (* m n))
     (+ (log m) (log n))))

(defun log-rule2 (m n)
  (= (log (/ m n))
     (- (log m) (log n))))

(defun log-rule3 (m k)
  (= (log (expt m k))
     (* k (log m))))

(defun log-rule5 () (= (log 1) 0))

(defun log-rule6 (n) (= (log n n) 1))

(defun log-rule7 (b k) (= (expt b (log k b)) k))

;; multiple value reutrn

(defun polar (x y)
  (values (sqrt (+ (* x x) (* y y))) (atan y x)))

(multiple-value-bind (r theta) (polar 3 4)
  (vector r theta))


;; get rid of the multi value return
(defun floor-1 (x y) (floor x y) x)

;; a traditional common lisp association list.
(defparameter *assoclist* (list
                            (cons 'a 10)
                            (cons 'b 20)
                            (cons 'c 30)))

;; get value from an assoc list
(assoc 'a *assoclist*)

(setf (cdr (assoc 'a *assoclist*)) 100)

(acons 'd 100 *assoclist*)


;;;; show some list data structures

(defmacro deftest (name params &rest body) `(defun ,name ,params ,@body))

;;; List

;; circular lists
(defun circular! (items)
  ;; tell the printer to recognize circular list but not print them
  ;; this gives you infinite list
  (setf *print-circle* t)
  (check-type items list)
  (setf (cdr (last items)) items))

(deftest
  circular-test ()
  (let ((xs '(1 2 3)))
    (circular! xs)
    (format t "~%circular-test~%")
    (format t ":xs ~a~%" xs)
    (format t ":5th xs ~a~%" (fifth xs))))


;; dotted list ()
(defun dotted-list ()
  (let ((t1 (cons 1 2))
        (t2 (cons  1(cons 2 nil))))
    nil))

;; basic car cdr frsit/rest, nth
(deftest
  basic-list ()
  (format t "~%basic-list~%")
  (let ((xs '(1 2 3 4 5)))
    (format t ": ~a~%" (car xs))    ;; => 1
    (format t ": ~a~%" (cdr xs))    ;; => (2 3 4 5)

    (format t ": ~a~%" (fifth xs))  ;; => 5
    (format t ": ~a~%" (second xs)) ;; => 2

    (format t ": ~a~%" (nthcdr 3 xs)) ;; => (4 5)

    (format t ": ~a~%" (last xs))       ;; => (5) return the last con cell
    (format t ": ~a~%" (butlast xs))    ;; => (1 2 3 4)
    (format t ": ~a~%" (nbutlast xs 2)) ;; => (1 2 3)


    (format t ": ~a~%" (nbutlast xs 2)) ;; => (1 2 3)

    (format t ": ~a~%" (reverse xs)) ;;=> (5 4 3 2 1)

    (format t ": ~a~%" (append xs xs)) ;;=> (1 2 3 4 5 1 2 3 4 5)

    nil))

(deftest
  destructive-list ()
  ;; nreverse will flip the direction of
  ;; cdr of the con cell and return the last element
  ;; the original concell will become the head of a
  ;; list with only one element.
  (let* ((xs '(1 2 3 4 5))
         (sx (nreverse xs)))
    (format t "~%nreverse~%")
    (format t "sx: ~a~%" sx)   ; => (5 4 3 2 1)
    (format t "xs: ~a~%" xs)   ; => (1)
    nil)

  (let* ((xs '(1 2)))
    (format t "~%push~%")
    (push 1 xs)
    (push 1 (elt xs 1))
    (push 1 (elt xs 2))
    (format t "xs: ~a~%" xs)
    (pop xs)
    (format t "xs: ~a~%" xs))

  (destructuring-bind (x y z) (list 1 2 3)
    (format t "~%dest:ructuring-bind~%")
    (format t "x: ~a~%" x)))

(deftest
  list-predicates ()
  (let ((xs '(1 2 3)))
    (format t "~%predicates~%")
    (format t ": ~a~%" (null xs))
    (format t ": ~a~%" (listp xs))
    (format t ": ~a~%" (atom xs))))

(deftest
  list-membership ()
  (let ((xs '(1 2 3))
        (ys '("a" "b" "c")))
    (format t ": ~a~%" (member 2 xs))
    (format t ": ~a~%" (member "b" ys :test #'equal))
    (format t ": ~a~%" (elt xs 2))))

(deftest
  list-creation ()
  (format t ": ~a~%" (make-list 10 :initial-element "p")))

(deftest
  list-sub ()
  (format t ": ~a~%" (subst 'one 1 '(1 2 3)) :test #'equal)

  (format t ": ~a~%" (sublis '((x . 10) (y. 20)) '(xyx)))


  (format t ": ~a~%" (sublis '((x . 10) (y . 20)) '(λ x \. λ y \. x + y)
                             :test #'equal))

  (format t ": ~a~%" (sublis '((x . 10) (y . 20)) '(* x (+ x y) (* y y))))

  (format t ": ~a~%" (sublis '((t . "foo")) '("one" 2 ("three" (5 2)))
                             :key #'stringp)))
;;;; form macro

;; takes a form with name substituted

(defmacro with-name ((s name) &body body)
  `(progn
     (format t "~a" ,s)
     (format t "~a" ,name)
     (let ((x ,(car (car (cdr body))))
           (y ,(cdr (car (cdr body)))))
       (format t "~a" x)
       (format t "~a" y)
       (values x y))))


(defmacro listit ((a b c) (d e))
  `(list ,a ,b ,c ,d ,e))
;;;; kmean
;; a little practice of kmean algorithm
(defun classify (means data dist-fun)
  (let ((sets (loop for m in means collect '())))
    (loop for d in data do
          (let ((min 0)
                (dist (funcall dist-func d (car means))))
            (loop for m in (cdr means) for n from i do
                  (when (< (funcall dist-func d m) dist)
                    (setf min n
                          dist (funcall dist-func d m))))
            (push d (nth min stes))))
    sets))
; learn some vim slime
(defpackage :morse
  (:use :common-lisp))

(in-package :morse)

; editing

(declaim (optimize (speed 0) (safety 3) (debug 3)))

; ,W -> wrap ()
; ,< -> move ( or ) to the left
; ,> -> move ( or ) to the right
; ,S -> remove the wrapping ()

; loading
; ,F -> compile the fiel
; ,L -> reload

; info
; ,s -> describe symbol
; ,A -> prorpos

; repl
; ,c -> connect to swan server
; ,y -> interrupt lisp process
; ,- -> clear
; ,Q -> quit repl
; ,g -> set package

; cross reference
; ,xc -> who calls

; evaluation
; ,d -> deval defun (topve level form)
; ,e -> eval current expression
; ,r -> eval visual selected region
; ,b -> eval the buffer
; ,v -> interactive eval
; ,u -> undefine function

; profiling
; ,p toggle profile
; ,o profile report
; ,x profile reset

(defparameter *morse-mapping*
  '((#\A ".-")
    (#\B "-...")
    (#\C "-.-.")
    (#\D "-..")
    (#\E ".")
    (#\F "..-.")
    (#\G "--.")
    (#\H "....")
    (#\I "..")
    (#\J ".---")
    (#\K "-.-")
    (#\L ".-..")
    (#\M "--")
    (#\N "-.")
    (#\O "---")
    (#\P ".--.")
    (#\Q "--.-")
    (#\R ".-.")
    (#\S "...")
    (#\T "-")
    (#\U "..-")
    (#\V "...-")
    (#\W ".--")
    (#\X "-..-")
    (#\Y "-.--")
    (#\Z "--..")
    ))


(defun character-to-morse (character)
  (second (assoc character *morse-mapping* :test #'char-equal)))

(defun morse-to-character (morse-string)
  (first
    (find morse-string *morse-mapping* :test #'string= :key #'second)))

(defun string-to-morse (string)
  (with-output-to-string (morse)
    (write-string (character-to-morse (aref string 0)) morse)
    (loop
      for char across (subseq string 1)
      do (write-char #\Space morse)
      do (write-string) (character-to-morse char) morse)))

(defun morse-to-string (string)
  (with-output-to-string (character-stream)
    (loop
      for morse-char
        in (split-sequence:split-sequence #\Space string)
      do (write-char (morse-to-character morse-char) character-stream))))


(character-to-morse #\A)
(character-to-morse #\A)
(morse-to-character "-")
(morse-to-character ".--")
(morse-to-character ".--")
(morse-to-character "..")

(string-to-morse "WHYLISPUSESOMANYUPPERCASES")
(string-to-morse "AVOIDUSINGCONTROLC")
(string-to-morse "HAHA")
;;;; CLOS


;;; common lisp object orientation system

(defvar *account-number* 0)

(defclass bank-account ()
  ((customer-name
     :initarg :customer-name)
   (balance
     :initarg :balance
     :initform 0)
   (account-number
     :initform (incf *account-number*))
   ; gold, silver, or bronze
   account-type))

(defclass checking-account (bank-account) ())

; define the :after method for initialize-instance.
; initialize instance is what's going to be called once you call
; make-instance.
; &key is required because that's how initialize-instance defined

(defmethod initialize-instance :after ((account bank-account)
    (setf (slot-value account 'account-type)
          (cond
            ((>= balance 10000) :gold)
            ((>= balance 1000) :silver)
            (t :bronze)))
    (when opening-bonus-percentage
      (incf balance (* balance (/ opening-bonus-percentage 100))))))

; mannually init
(defparameter *account* (make-instance 'bank-account))
(setf (slot-value *account* 'customer-name) "John Doe")
(setf (slot-value *account* 'balance) 1001)

; init with initalizer
(defparameter *president-account*
  (make-instance 'bank-account
                 :customer-name "Mr. President"
                 :balance 1000000
                 :opening-bonus-percentage 10))     ;; add some bonus

;; The core of CLOS: generic functions!
(defgeneric withdraw (account amount)
  (:documentation "Withdraw amount from the account"))

;; methods must have the same signatures as the generic function.
;; so &key, &rest also must be specified.
(defmethod withdraw ((account bank-account) amount)
  (let ((balance (slot-value account 'balance)))
    (when (< balance amount)
      (error "Account overdrawn."))
    (decf balance amount)))
;;;; common collections

;;; Lisp was designed to be list processing langauge, but as
;;; time goes, many more efficient data sturcture creeps into
;;; the language.
;;; It doesn't matter what paradigm you are using, there will
;;; always be a need for a efficient data structure. Even in
;;; haskell sometimes you want a mutable array to play with.


;;; Other than list, common lisp has some other builtin types
;;; that comes very handy. Not like in haskell which even a map
;;; needs to come as a library, common lisp has the most handy
;;; contains available all the time. I really think haskell should
;;; do the same.

;;; Most commonly used:
;;; 1. array
;;; 2. vector
;;; 3. hashtable
;;; 4. struct

;;; These variation is more than enough for daily uses. Other things
;;; are just optmization on specific use cases.


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; struct
;;; one problem of struct is one they are created they cannot
;;; be redefined.
;;; if you are using an repl to develop struct, you should be careful
;;; compiling struct because if you want to modify anything after it's
;;; loaded, the only senible way is to restart the repl.

;;; each defstruct also define some helper functions including:
;;; 1. field accessors
;;; 2. type specifier
;;; 3. type predicate

(defstruct (human (:constructor create-person (id name age)))
  id name age)

;;; structs can have single inheritance, works as you expected.
(defstruct (female
             (:include human)
             (:print-function
               (lambda (struct stream depth)
                 (declare (ignore depth))
                 (print "customized printer: ")
                 (print (female-name struct)))))
  (gender "female" :type string))

(let ((me (create-person 1 "me" 10))
      (notme (make-female :id 10 :name "notme" :age 20)))
  (format t "This human is ~a~%" (human-name me))
  (format t "This female is ~a~%" (female-name notme))
  (format t "This human is also ~a~%" (human-name notme))
  (format t "am I female? ~a" (female-p me))
  (format t "female is a human: ~a" (subtypep 'female 'human))
  ;; structs fields are settable
  (setf (human-age me) 23))


;;; define show struct is stored in memeory
(defstruct (bar (:type vector)) a b c)
;;;; concurrency in common lisp

;;;; condition system

;; Three components of a condition system
;; 1. signaling a condition
;; 2. handling a condition
;; 3. recover from a condition

;;; condition system is a more powerful try catch mechanism.
;;; try catch allows you to attempt execute a block of code,
;;; if some situation happen, the block can voluntarily throw
;;; an exception. The exception will propagage upward to it's
;;; caller until a catch block is found.
;;; Then, the control flow is hand over to that catch block,
;;; code in the block get executed, and the original stack frame
;;; get unwind.
;;; Getting unwind means the stack get destroyed. But all resources
;;; will be released before destroy everything in the stack.

;;; Common lisp is different from ordinary languages in the sense that
;;; it heavily use the repl feature to develop interactively. It has
;;; the mechanism called restart, whenever something exceptions happen,
;;; the repl will bring you to the restrat menu, which gives you a list
;;; of possible way to handle this situation. Options in the list are either
;;; predefined or defined by the user.
;;; You decide how to handle the condition, and the repl will restart the
;;; function again.

;;; To have a error catching mechansim that supports this concept of
;;; restarting, common lisp's condition system made several differemt
;;; design choces.

;;; First, like most other languages, conditions (exceptions) are object.
;;; more specficially it's a CLOS object with arbitrary slots. We can carry
;;; various information with condition, change a condition at runtime, and
;;; do everything else we can do with an object.

;;; The most basic way to throwing a condition is to call (error 'condt ..)
;;; this will throw a condtion and propagate upwards like in a conventional
;;; expcetion system.
;;; If the expression is controled by a (handler-case e c .. ) somewhere
;;; in it's backtrace, and the condtion is capture by the handler-case
;;; expression, the corresponding handler code will be executed. After
;;; that's done, the orgina lstack is unwinded. This works like normal
;;; try catch.
;;; Note in this case the handler code is defined in the handler-case
;;; expression, in another word, the caller defines what to do.

;;; Not like convential exception handling, in condition system we can
;;; define the counter action in the callee as well. To do so
;;; we define possible "restarts" in a (restart-case) expression
;;; in the callee. A restart-case can define several restarts, each with
;;; a unique name. Note restart-case doesn't bind restart to a particular
;;; condition, it just define the possible reaction.
;;; To use these restarts defined in the callee, we use handler-bind and
;;; invoke-restart from the caller.
;;; The mechanism is similar to handler-case, we match on the case for
;;; handling the condition, and call (invoke-restart 'restart) to choose
;;; the restart provided by the callee.

;;; What's the benefit of this more complex system comparing with a simple
;;; try catch system?
;;; Try-catch separate the exception signaling and exception handling into
;;; two parts. While condition system breaks it into three parts:
;;;   1. signaling a condition
;;;        this happens at the callee level. When situations emerge
;;;        we call (error), a new condition get created and propagated
;;;   2. handling a condition
;;;        for handler-case:
;;;           execute the handling code, unwind stack
;;;
;;;        for handler-bind:
;;;           execute the handling code, doesn't unwind the stack
;;;   3. recover from a condition
;;;        for handler-case:
;;;           keep going, doesn't recover from the exception
;;;        for handler-bind:
;;;           use invoke-restart to choose a restart to run.


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ignore an error
(ignore-errors (/ 3 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; catching a condition (handler-case)

;;; (handler-case (code that errors out)
;;;   (condition-type (the-condition) (code)
;;;   (condition-type (the-condition) (code)
;;;   ...
;;;   )
;;; It's like typecase but work for conditions.

(handler-case (/ 3 0)
  (error (c)  ; error is the general condion, c is the conditon itself
         (format t "We caught a condition. ~&")
         (values 0 c)))   ; return value

;;; some examples of catching the most generic errors
(defun division-1 (a b)
  (handler-case (/ a b) ; note if no exception happens it just return
    (division-by-zero
      (c)
      (format t "Division by zero! ~%")
      (values 0 c))
    (error
      (c)
      (format t "Some generic errors ~%")
      (values 0 c))))
(division-1 2 1) ;; 2
(division-1 2 0) ;; error caught

(defun index (xs n)
  (check-type xs sequence)
  (handler-case (elt xs n)
    (error
      (c)
      (format t "error when trying  to index the sequence")
      (values n c))))
(index '(1 2 3) 2)  ;; 3
(index '(1 2 3) 10) ;; error caught

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; handler-bind (actually use the restart mechansim)
;;; handler bind does not unwind the stack!

(define-condition my-div-by-zero (error)
  (:documentation "my division by zero condition")
  ((dividend :initarg :dividend   ;; a condtion can have any slots
             :initform nil
             :reader dividend)))  ;; :reader create a getter

;; a condition generally behaves like an object
(let ((con (make-condition 'my-div-by-zero :dividend 3)))
  (equal (dividend con) 3))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; signaling (throwing) (error, warn, signal)

;;; error
;;; error is a `overloaded` functions (optional param)
;;;   1. (error "asd) singal a 'simple-error
;;;   2. (error 'error-type :message "Error message") throw a constom error

(defun my-div (a b)
  (if (= b 0)
    (error 'my-div-by-zero :dividend a)
    (/ a b)))

(handler-case (my-div 3 0)
  (my-div-by-zero
    (c)
    (format t "on I caught my own error")
    (values 0 c)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; restart

;;; assert
(defun not-1 (x)
  (assert (not (= x 1)))  ; this throw a condition that bring to restart
  x)

(defun not-2 (x &optional (y 0))
  (assert (not (= x 2))
          (y)             ;; optional arg in restart menu
          "You cannot be 2")
  x)

;;; restart-case

(defun div-restart (x y)
  (restart-case (/ x y)   ;; we define cases in restart-case
    (return-zero () ;; create a new restart called "return-zero"
                 :report "Return 0"
                 0)
    (divide-by-one ()
                   :report "Divide by 1"
                   (/ x 1))
    (set-new-divisor (value)
                     :report "Enter a new divisor"
                     :interactive (lambda ()
                                    (prompt-new-value "Please enter: "))
                     (div-restart x value))))

(defun prompt-new-value (prompt)
  (format *query-io* prompt)  ;; special stream to make user query
  (force-output *query-io*)
  (list (read *query-io*)))

(div-restart 3 0)


;;; restart prorammatically (handler-bind, invoke-restart)
;;; process:
;;;   1. invoke div-restart
;;;   2. restart cases get defined in div-restart
;;;   3. div-restart throw a condtion 'division-by-zero
;;;   4. it's propagated to div-and-handle-error, bind to
;;;      the corresponding case, invoke the 'divide-by-one
;;;      restart.
(defun div-and-handle-error (x y)
  (handler-bind     ;; capture restart conditons and choose what to do.
    ((division-by-zero
       (lambda (c)
         (format t "Got error ~a~%" c)
         (format t "will divide by 1 ~%")
         (invoke-restart 'divide-by-one))))
    (div-restart x y)))
(div-and-handle-error 3 0)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; some examples
;; (in-package :error-handling)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; define two errors
;;; Note that a new condition is a new type that can be checked
;;; by typep at the runtime.

(define-condition file-io-error (error)
  ((message :initarg :message :reader message)))

(define-condition another-file-io-error (error)
  ((message :initarg :message :reader message)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; handler-bind

;; simulate an io operation that might fail.
;; it throws like a normal language with try/catch, there is
;; no condition handler defined with the code, all error recovering
;; code are from the caller.
(defun fake-io (&key (fail nil fail-p) (message "Error!"))
  (cond
    ((not fail-p)
     (if (evenp (random 100))
         (error 'file-io-error :message "message")
         "success"))
    (fail (error 'another-file-io-error :message "message"))
    (t "success")))


;;; flush the io buffer:
;; finish-output, force-output, and clear-output

;;; lisp has muli value output
;; to obtain multiple values as a list you can wrap the function in
;; multiple-value-list. Similary to destruct multiple values reutrned
;; you can use multiple-value-bind to bind values with a name.

;; define a restart function
(defun read-new-value ()
  (format t "Enter a new value: ")
  (force-output)
  (multiple-value-list (eval (read))))

;; use restart when error happens.
;; these cases will be added into the debugger options so you can invoke.
;; (restart-case (form) (restart1) (restart2) ...)
(let ((fail t))
     (restart-case
       (fake-io :fail fail)  ;; expression to run
       ;; first handler we define
       (retry-without-errors (new-fail)
                             :report "Pass in a fail value"
                             :interactive read-new-value (setf fail new-fail)
                             (fake-io :fail fail))
       ;; second handler simply do nothing
       (do-nothing ()
                   :report "don't handle the error"
                   "done with it!")))
(fake-io)
(fake-io :fail t)
(fake-io :fail nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; we want to define handler to automatically handle
;;;; handler-case behaves like try-catch in other languages.
;; catching any conditions
(handler-case (/ 3 0)
  (error (c) (format t "We caught a condition ~&")
         (values 0 c)))

;; another way to catch all conditions with t
(handler-case
  (progn
    (format t "This won't work~&")
    (/ 3 0))
  (t (c)
     (format t "Got a condition ~a~%" c)
     (values 0 c) ) )

;; catching specific conditions
(handler-case (/ 3 0)
  (division-by-zero (c)
                    (format t "caught a division by zero condition  ~a~%" c)
                    (values 0 c)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; we define a new condition here
(define-condition on-zero-denominator (error)
  ((message :initarg :message :reader message)))

;; reciprocal will decide what conditon to throw, also it defines
;; some handler for that condition.
(defun reciprocal (n)
  (restart-case
    (if (/= n 0)
        (/ 1 n)
        (error 'on-zero-denominator :message "can't divide by zero"))
    (return-zero () :report "Just return 0" 0)
    (return-value (r) :report "Return another value" r)
    (recalc-using (v) :report "recalculate" (reciprocal v))
    (return-nil () nil)))

;; in this function we choose to ignore condition
;; but we also provide another possible way to handle any possible
;; condition, namely `just continue`
(defun list-of-reciprocals (array)
  (restart-case
    (mapcar #'reciprocal array)
    (just-continue () nil)))''

;; here we 'bind on-zero-denominator with a lambda handler.
;; in the handler it calls the lower level handler provided by reciprocol.
;; in this case, we choose to just return 0.
(defun print-reciprocals (array)
  (handler-bind
    ((on-zero-denominator
       #'(lambda (c)
           (format t "error signaled: ~a~%" (message c))
           (invoke-restart 'return-value 0))))
    (let (r)
      (setf r (list-of-reciprocal array))
      (dolist (x r)
        (format t "Reciprocal: ~a~%" x)))))
;;;; hygenic macro

;;; in common lisp there is no hygenic macro, to avoid
;;; capture we need to use gensym

(defun primep (number)
  (when (> number 1)
    (loop for fac from 2 to (isqrt number)
          never (zerop (mod number fac)))))

(defun next-prime (number)
  (loop for n from number when (primep n) return n))

(defmacro once-only ((&rest names) &body body)
  (let ((gensyms (loop for n in names collect (gensym))))
    `(let (,@(loop for g in gensyms collect `(,g (gensym))))
       `(let (,,@(loop for g in gensyms
                       for n in names collect ``(,,g ,,n)))
          ,(let (,@(loop for n in names
                         for g in gensyms collect `(,n ,g)))
             ,@body)))))

(defmacro do-primes ((var start end) &body body)
  (once-only (start end)
    `(do ((,var (next-prime ,start) (next-prime (1+ ,var))))
     ((> ,var ,end))
     ,@body)))

;;;; how to write a hyneic macro writing macro?
(defmacro repeat-times-writing-robot (count-form forms)
  (let ((counter-sym-sym (gensym)))  ; macro's symbol
    `(let ((,counter-sym-sym (gensym)))
       ;; unquote twice for the outer most symbol
       `(loop for ,,counter-sym-sym below ,,count-form
              do ,@,forms))))

(defmacro repeat-times (count-form &body forms)
  (repeat-times-writing-robot count-form forms))
;;;; imperative programming in common lisp

;;; common lisp has so many features for explicit mutation
;;; that it really shoundn't be regarded as a functional programming
;;; language.


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; set place

;;; setq:
;;;   simply set the value binds to the symbol
(let ((x 1))
  (setq x 10))

;;; setf:
;;;   generic set macro. It will call setq when the place is a symbol,
;;;   otherwise it will invoke specific implementation for different
;;;   place forms.
(let ((x 1)
      (xs (list 1 2 3)))
  (setf (elt xs 2) 10
        x 10)
  `(,x ,(caddr xs)))

;;; setf is generic, we can expand places it accepts

(defun set-last (xs new-val)
  "set the last element of a list to new-val and
   return the modified list."
  (labels ((set-last-* (xs new-val head)
             (if (eql (cdr xs) nil)
               (progn
                 (setf (car xs) new-val)
                 head)
               (set-last-* (cdr xs) new-val head))))
    (set-last-* xs new-val xs)))

(let ((xs '(1 2 3)))
  (set-last xs 5))

;; register the set-last function to setf with setter last-th
(defsetf last-th set-last)
(let ((xs  '(1 2 3 4)))
  (setf (last-th xs) 10))

;;; side: set
;;;   Note this is totally different thing.
;;;   For setq, there are two objects
;;;   involed: sym -> object
;;;   But beause symbols themselves are objects too, all objects have
;;;   value cells, so technically one can store value in the
;;;   symbol's value cell. set is for that purpose.
;;;   set is deprecated.

(let ((x 'sym))
  (set x 10)
  `(,x ,(symbol-value x)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; block structure

;;; One of the most prominent feature of imperative programming
;;; is to use blocks to separate different chunks of computations.
;;; In structure programming, we have the operator `;` that chains
;;; statements together, and perform one after another in order.

;;; Because common lisp is an expression based language, it simulate
;;; blocks with expressions too.


;;; progn
;;;   simply sequencing expression one after another. The whole
;;;   expression return what the last expression evalutes to.

(progn
  (setq a nil)
  (setq b nil)
  'here)


;;;

;;; block
;;;   a block can also sequence expressions. In addition one can
;;;   perform earily return by jumping out of a block with return-from

(block alpha
       (setq a nil)
       (setq b nil)
       (return-from alpha)
       'here)   ;; this will never be executed


(block nil
       (return 1)   ;; simplified return
       (return 2))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; transfering control flows
;;; This can be done in any languages, implemented with
;;; cps or go as the basis.
;;; In a imperative style, abitrary transferring of control flow
;;; is not uncommon and can be a very useful tool.

;;; Structure programming doesn't support goto, because goto
;;; transfer control flow to arbitrarily so the program behavior
;;; can no longer be anaysed by hoare logic.

;;; Primitive goto transfer the current instruction to any other
;;; instruction without caring about the concequence.

;;; Jumping from one location to another without and restruction is very
;;; problematic. A piece of code can have set up some context, required
;;; some resources, and when some computation is done those context
;;; and resources are suppose to be teared down. If we can jump away
;;; in the middle of this process, there is no longer guarantee that we
;;; wil release those resources, causing leaky program.

;;; So in most practical languages an long jump of control flow usually
;;; come with stack unwinding. In most exception handling system, if an
;;; exception is happend in the middle of somewhere, the stack is unwund
;;; before it transfer the control to the handler. Meaning, content in
;;; the current stack and all resources allocated will be released.

;;; In C++, even stack unwinding is not enough to make sure the memory
;;; safety. If we new a memory and free it at the end of a block, but an
;;; exception is thrown before we can call the destructor, the pointer to
;;; the memory will be destroyed because it's in the stack, but the
;;; allocated memory will just be there.
;;; The real problem is the arbitrary tranferring of control violates
;;; RAII, which is what the languged is designed for.

;;; In a GCed language, stack unwinding is easier to do because if we
;;; transferred away from a block, handlers on the stack will be destroyed,
;;; so unreachble heap memory will be detected at the next gc cycle and get
;;; swept away. But this doesn't save us from close external resources like
;;; files.

;;; A solution for this is to create an expression such that even when
;;; the control flow transferred away in the middle of the expression,
;;; some functions still get called. (unwind-protect) helps us with this.

;;; This method can be abstracted away into a context manager, where the
;;; acquisition and the release of the resource are managed together within
;;; the block, and the release is protected.

;;; In common lisp, any transfer of control will go through these steps:
;;; 1. extend (lifetime) of the exit point are abandoned
;;;    (can't go back again)
;;; 2. clean up clause of (unwind-protect) are evaluated
;;; 3. related dynamic bindings of special veriables, tags, handlers ...
;;;    are undone (clean up general stuffs)
;;; 4. lifetime of exit point end, control get passed.

;;; code in unwind-project will be executed no matter
;;; when it's jumped out.
(block alpha
       (setq a nil)
       (block beta
              (setq b nil)
              (setq c nil)
              (format t "In beta~%")
              (unwind-protect
                (return-from alpha)
                u(print "still executed")))  ;; this is still executed
       (setq d nil)
       (format t "End of alpha"))   ;; this will never be executed

;;; side note: unwind-protect
;;;   protects against all attempts to exit from the protected from,
;;;   including go, handler-case, ignore-errors, return-from, etc..
;;; side note: return-from
;;;   immediately return from the from to desginated block, unwind
;;;   the stack.

(block alpha
       (with-open-file (in "file.txt" :direction :input)  ;; unwind-protect
         (loop for n = (read-char in)
               with i = 0
               when (< i 100) do
               (progn
                 (incf i)
                 (if (= i 10) (return-from alpha))
                 (format t "read a char: ~a ~%" n)))))

;;; catch and throw is another mechanism we can use
;;; it's a simple version of condition system.
(defun fn-a ()
  (catch 'fn-a
         (print 'before-fn-b-call)
         (fn-b)
         (print 'after-fn-b-call)))

(defun fn-b ()
  (print 'before-fn-c-call) (fn-c) (print 'after-fn-c-call))

(defun fn-c ()
  (print 'before-throw) (throw 'fn-a 'done) (print 'after-throw))

(fn-a)


;;; tag and go
;;; this is really bad... don't use it
(let ((val 1))
  (tagbody
    (setq val 1)
    (go a)
    (incf val 16)
    a
    (incf val 4)
    (go b)
    (incf val 32)
    b
    (incf val 8))
  val)


;;; fortran style declare + labels + bunch of statements
(prog ((x 2) (y 1) z)
      a
      (setq x 10)
      (if (not (eql x y))
        (progn
          (format t ": not equal at first~%")
          (go b))
        (format t ": equal now~%"))
      (return (if (eql x y) '= '\=))
      b   ;; set y to x
      (setf y x)
      (go a))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; loops!

;;; Everybody's favorite structure programming strcuture

(dotimes (n 10 n))
(dotimes (i 10) (format t "~a " i))     ; result is nil
(dotimes (i 10 i) (format t "~a " i))   ; result is i
(dotimes (i 10 t) (format t "~a " i))   ; result is t

;;; char is a setf place ...
(defun palindromep (string &optional (start 0) (end (length string)))
  (dotimes (k (floor (- end start) 2) t)
    (unless (eql (char string (+ start k))
                 (char string (- end k 1)))
      (return nil))))

;;; dolist also supports different return results
(dolist (n '(1 2 3) t) (format t "~a" n))


;;; do. really uncessary structure

(do
  ((tmp1 1 (1+ tmp1))
   (tmp2 0 (1- tmp2)))
  ((> (- tmp1 tmp2) 5)    ;; end test form
   tmp1   ;; end result
   ))

(defun list-reverse (list)
  (do
    ((x list (cdr x))     ;; init form [step form]
    (y '() (cons (car x) y)))
    ((endp x) y)))        ;; end test form

;;; (var init-value next-value)
;;; note other vars referred in next-value position is the value in the
;;; last loop.
(defun fib (n)
  (do
    ((cnt 0 (1+ cnt))
     (i 0 j)
     (j 1 (+ i j))
     (acc '() (cons j acc)))
    ((= cnt n) acc)))


;;; loop

(loop
  (print "Here I am.")
  (return 17)
  (print "Not here"))

;;; there is no need for do
(let ((n 0))
  (loop
    (when (> n 10) (return))
    (print n)
    (prin1 (* n n))
    (incf n)))
;;;; macros

;;; three main mechanisms to write good macro
;;; 1. backquote
;;; 2. comma
;;; 3. gensym

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro my-when (condition &rest body)
  `(if ,condition (progn ,@body)))

(defmacro my-unless (condition &rest body)
  `(if (not ,condition) (progn ,@body)))

;; backquote is nice, you can write the code without
;; quote everything.
(defmacro do-primes-1 ((var start end) &body body)
  `(do ((,var (next-prime ,start)
              (next-prime (1+ ,var))))
       ((> ,var ,end))
       ,@body))

;;; use gensym to avoid leaky abstraction
;; 1. use gensym to generate unique symbol.
;; 2. make sure only evaluate each subform once.
;; 3. make evaluation order the same as the parameter order.

(defmacro do-primes-2 ((var start end) &body body)
  (let ((end-value (gensym)))
    `(do ((,var (next-prime ,start)
                (next-prime (1+ ,var)))
          (,end-value ,end))
         ((> ,var ,end-value)) ,@body)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; macro writing macro
(defmacro with-gensyms ((&rest names) &body body)
  `(let ,(loop for n in names collect `(,n (gensym))) ,@body))

(defmacro do-primes-with-gensyms ((var start end) &body body)
  (with-gensyms (end-value)
    `(do ((,var (next-prime ,start)
                (next-prime (1+ ,var)))
          (,end-value ,end))
         ((> ,var ,end-value))
         ,@body)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; common macro helps you to evaluate a symbol only once.
;; multiple layers because once-only is a macro itself so
;; it needs to be hygenic for itself too.
(defmacro once-only ((&rest names) &body body)
  ;; generate unique symbols for each name
  (let ((gensyms (loop for n in names collect (gensym))))
    ;;
    `(let (,@(loop for g in gensyms collect `(,g (gensym))))
       `(let (,,@(loop for g in gensyms
                       for n in names collect ``(,,g ,,n)))
          ,(let (,@(loop for n in names
                         for g in gensyms collect `(,n ,g)))
             ,@body)))))

;; with once only things get much simler.
(defmacro do-primes ((var start end) &body body)
  (once-only (start end)
    `(do ((,var (next-prime ,start) (next-prime (1+ ,var))))
     ((> ,var ,end))
     ,@body)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; oneliner macro
;;; there are a lot of restructions for mutation in common lisp.
;;; like if you want to make a form setable you need to have the
;;; corresponding place define with (DEFSETF).
;;; and because it's macro, a value (elt x x) returned from a function
;;; won't work.
;;; But sometimes you need to refer to one value again and again.
;;; like if I'm working with (elt x 1), I will need to address it multiple
;;; time in a body.

(defun foo ()
  (let ((xs '(1 2 3 4 5 6)))
    (macrolet ((3rd () `(elt xs 3)))
      (setf (3rd) 10)
      xs)))

(foo)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; topevel def macros
;; use macros to generate functions

(defmacro gen-foo (v)
  (let ((fname (concatenate 'string
                            "foo-"
                            (symbol-name v)))
        (format t "~a" fname)
        `(defun ,fname () ,v))))
;;;; meta object protocol

;;; common lisp meta object protocol



;;;; packages and symbols

;;; common lisp has it's own package system.

;;;

()
;;;; pattern matching with trivia
;;; it's weird common lisp doesn't support pattern matching
;;; by default. But at least the package is easy to get.

(use-package :trivia)

(match `(1 2 3)
       ((cons x y)
        (print x)
        (print y)))

(match `(something 2 3)
       ((list a b _)
        (values a b)))

(match `(something 2 3)
       ((list* a b)
        (values a b)))

(match #(1 2 3)
       ((vector _ x _)
        (print x)))

;; xx* pattern is flexible in length
(match #(1 2 3 4)
       ((vector* _ x _)
        (print x)))

;; there are three style to match a struct
(defstruct foo bar baz)
(match (make-foo :bar 0 :baz 1)
       ((foo :bar a :baz b)
        (values a b))
       ((foo (bar a) (baz b))
        (values a b))
       ((foo bar baz)
        (values bar baz)))

(match (list 2 5)
       ((guard (list x y)
               (= 10 ( * x y)))
        :ok))
;;;; read macro

;;; lisp macros works at two stage: read time and compile time.
;;; read macro is more like macro in a c preprocesser sense as it
;;; works on plain text.
;;; macro, instead, works on parsed ast.

;;; reader macro involves using the read function
;;; read : optional input steram
;;;     -> optional eof error predicate  : bool
;;;     -> optional eof value : a
;;;     -> optional recursive predicate :  bool

;;; when implementing reader macros, recursive-p should always be true

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; stream primer
;;; first try to understand where does things come from
(defun stream-primer ()
  (let ((ss (make-string-input-stream "1 one ")))
    (check-type ss stream)
    (when (input-stream-p ss)
      (list (read ss nil nil)   ;; read 1, skip space
            (read ss nil nil)   ;; read one, skip space
            (read ss nil nil)   ;; points to the nil, only nil to read
            (read ss nil nil)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; quote
;;; simplest macro that translate form '<a> to (quote a)
;;; we use ^ instead of '
(defun single-quote-reader (stream char)
  (declare (ignore char))
  ;; construct (quote ...)
  (list (quote quote) (read stream t nil t)))

;;; set-marco-character makes the lisp reader assoicate the char
;;; with the reader. Anything after ^ will be processed at read time.
(set-macro-character #\^ #'single-quote-reader)

;;; the process of running a customized reader macro:
;;; > ^asd
;;; 1. reader read "^asd",
;;; 2. reader find ^, it's defined, so calls the corresponding function
;;; 3. single-quote-reader is called, which in turn calls read again.


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; json

(defconstant +left-bracket+ #\[)
(defconstant +right-bracket+ #\])
(defconstant +left-brace+ #\{)
(defconstant +right-brace+ #\})
(defconstant +comma+ #\,)
(defconstant +colon+ #\:)

(defun read-next-object (separator
                         deliminator
                         &optional (input-stream *standard-output*))
  (check-type separator char)
  (check-type deliminator char)
  ;; define two short hands
  ;; : peek-char peek a char from the input stream
  ;; : read-char consume a char from the input stream
  (flet ((peek-next-char () (peek-char t input-stream t nil t))
         (discard-next-char () (read-char input-stream t nil t)))
    (if (and deliminator (char= (peek-next-char) deliminator))
      (progn
        (discard-next-char)
        nil)
      (let* ((object (read input-stream t nil t))
             (next-char (peek-next-char)))
        (cond
          ((char= next-char separator) (discard-next-char))
          ((and deliminator (char= next-char deliminator)) nil)
          (t (error "Unexpected nextchar: ~S" next-char)))
        object))))

(defun read-left-bracket (stream char)
  (declare (ignore char))
  ;; readtable: map between character and their reader macro (can be nil)
  ;; copy-readtable simply copy the current readtable
  ;; this is a example of using dynamic variable.
  ;; it copy the global config, and do some modification on it.
  (let ((*readtable* (copy-readtable)))
    (set-macro-character +comma+ 'read-separator)
    ;; see how pros use loop
    (loop
      for object = (read-next-object +comma+ +right-bracket+ stream)
      while object
      collect object into objects
      finally (return `(vector ,@objects)))))

(set-macro-character +left-bracket+ 'read-left-bracket)
;;;; setf
;;; is a macro that sets a value to a place.

;; object: any lisp datum.
;; form: an object meant to be evaluated / a symbol
;; cell: a conceptual slot of an object. in lisp 2
;;       an object can have two cells: variable cell and
;;       function cell
;; slot: a component of an object that can store a value
;; symbol: used for objet identity
;; place: a form which is suitable for uses as a generalized reference
;;        / the conceptual location referred by a place
;; generalized reference: a reference to a location storing an object

(defmacro my-setf (place values-form &environment env)
  (multiple-value-bind (vars vals stores setter)
    (get-setf-expansion place env)
    `(let* ,(mapcar #'list vars vals)
       (multiple-value-bind ,stores ,values-form ,setter))))

(let ((list (list 1 2 3 4)))
  (my-setf (elt list 2) 100))

;; setq is a low level primitive for setting the value to a
;; symbol if a value is binded to that symbol.
(let ((a 10))
  (setq a 11)
  a)


;;; this doesn't work for setq
;;; (let ((a '(1 2 3)))
;;;   (setq (elt a 1) 20)
;;;   a)

;;; setf is a macro
;;; setf is designed for more generic set. it works for all setq
;;; cases, as they just get expanded to (setq a x)
;
;;; but you can define you own place with defsetf, meaning you can
;;; customize a place to be settable.

(defun eleventh (ls)
  (elt ls 10))

(defun set-eleventh (ls new-val)
  (setf (elt ls 10) new-val))

(defsetf eleventh set-eleventh)

(let ((l (loop for i from 0 to 15 collect i)))
  (setf (eleventh l) :foo)
  l)


;;; some experiments
(let ((a 10))
  (setf a 10)   ;; (setq a 10)
  (incf a)      ;; (setq a (+ 1 a))
  a)

(let ((a '(1 2 3)))
  (setf (elt a 2) 10) ;; (sb-kernel:%setelt a 2 10)
  a)

(let* ((l '(1 2 3))
       (a (elt l 1)))
  (setf a 10)
  (values a l))
;;;; stream
;;; stream is a very important abstraction in common lisp
;;; it's used for almost all sort of IO operations.

;;; Stream:
;;;   a stream is an object that can be used with an input or
;;;   output function to identify anapproriate source or sink of
;;;   characters or bytes for that operations.

;;; Stream designator:
;;;   A designator for a stream that is an object that denotes a
;;;   stream.
;;;   deginator can be one of:
;;;     t: denoting  *terminal-io*
;;;     nil: denoting *standard-input*
;;;     *standard-output*: standard output

;;; A stream can be either a character stream or a binary stream.
;;; base on its direction it can be a input stream or an output stream.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; check if an obejct is a stream
(streamp *standard-input*)
;; is the same as
(typep *standard-input* 'stream)

;; usually we have two streams from on type: input and output
;; we can use following predicates to test if it's an
;; input or output stream
(open-stream-p *standard-input*)
(input-stream-p *standard-input*)
(output-stream-p *standard-output*)

(stream-element-type *standard-input*)

;; a generic context manager
(with-open-stream (s (make-string-input-stream "1 2 3 4"))
  (+ (read s) (read s) (read s) (read s)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Input stream specific operations
;;; problems a input stream system needs to solve:
;;; 0. where are things come from?
;;; 1. what type is read.
;;; 2. how many value is read at once?
;;; 3. should I consume the input or just look at the input?
;;; 4. input streams are designed for reading lisp and s-expression,
;;;    in that case all white spaces are noise.
;;;    but what if we actually want to read plain string?
;;; 5. probe the status of the stream. (has values? empty?)

;;; the most important one is read
(defun slash-reader (stream char)
  (declare (ignore char))
  `(path . ,(loop for dir = (read-preserving-whitespace stream t nil t)
                  then (progn (read-char stream t nil t)
                              (read-preserving-whitespace stream t nil t))
                  collect dir
                  while (eql (peek-char nil stream nil nil t) #\/))))
(set-macro-character #\/ #'slash-reader)

;;; clears any available inputs
(defun read-sleepily (&optional (clear-p nil) (zzz 0))
  (list (progn (print '>) (read))
        (progn (print '>)
               (if zzz (sleep zzz))
               (if clear-p (clear-input))
               (read))))

;;; listen:
;;;   return true if a char is immediately available.
;;;   otherwise return false
(progn (unread-char (read-char))
       ;; this kinda parallel the operation (not really)
       ;; it's because to construct the list lisp needs to wait
       ;; for both side effects been performed.
       (list (listen) (read-char)))

;;; variations of read
(read-line (make-string-input-stream "line1
                                     line 2")
           nil  ; eof-error-p
           nil  ; eof-value
           nil) ; recursive-p

;;; read a char from the stream
(with-input-from-string (is "123")
  (do ((c (read-char is) (read-char is nil 'the-end)))
      ((not (characterp c)))
      (format t "~S" c)))

(with-input-from-string (is "  1 2 3 4 5")
  (format t "~S ~S ~S"
          (peek-char t is)      ; skip white spaces
          (peek-char #\4 is)    ; skip til 4 is found
          (peek-char nil is)))  ; no skip.

(with-input-from-string (is "0123")
  (dotimes (i 6)
    (let ((c (read-char is)))
      (if (evenp i)
        (format t "~&~S ~S~%" i c)
        (unread-char c is)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Output stream specific operations

;;; Problem needs to be solved by output stream system
;;; 0. Where are we writing to?
;;; 1. what type are we writing?
;;; 2. what's the format of the output?
;;; 3. how to set pretty printer for output?
;;; 4. how many stuffs to write at once?

;;; write the printed representation to the output stream
;;; write is the core function to use, tehre are other short hands
;;; specialize for specific situations.
(princ "asd" *standard-output*)
(princ "asd" t)
(pprint "asd" t)
(prin1 "asd" t)

;;; finish output
(progn (princ "am I seen?") (clear-output))

;;; write char
(with-output-to-string (s)
  (write-char #\a s)
  (write-char #\Space s)
  (write-char #\b s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; There are different types of streams
;;; string-stream is stream that holds string data types.
;;; file-stream handles io of files,
;;; also we have broad-case stream, concatenated-stream, echo stream ..

;;; string stream
(let ((ss (make-string-input-stream "1 one ")))
  (check-type ss stream)
  (list (read ss nil nil)
        (read ss nil nil)
        (read ss nil nil)
        (read ss nil nil))
  (close ss)) ;; we can close the stream at the end

;; raii for stream. close the stream automatically
(let ((ind 0))
  (with-input-from-string (s "XXX1 2 3 4"
                             :index ind
                             :start 3
                             :end 10)
    (+ (read s) (read s) (read s)))
  (format t "~a" ind))


;;; broadcast stream:
;;;   an output stream which has associated with it a set of zero or
;;;   more output stream.
;;;   it combines multiple output streams and output to all of them.

(let* ((as (make-string-output-stream))
       (bs (make-string-output-stream))
       (broadcast (make-broadcast-stream as bs *standard-output*)))
  (format broadcast "this goes to both output streams")
  (format t "the boardcast stream output to: ~%~a ~%"
          (broadcast-stream-streams broadcast))
  (concatenate 'string
               (get-output-stream-string as)
               (get-output-stream-string bs)))

;;; conctenated stream
;;;   input stream which is a composite stream of zero or more
;;;   input streams.
;;;   it's the inverse of broadcast stream

(read (make-concatenated-stream
        (make-string-input-stream "1")
        (make-string-input-stream "2")))

;;; echo stream:
;;;   a bindirectional stream that gets its input from an
;;;   associated input and sends it to an associated output
;;;   all input taken from the input stream is echoed to the
;;;   output stream

(let ((out (make-string-output-stream)))
  (with-open-stream
    (s (make-echo-stream
         (make-string-input-stream "this-is-read-and-echoed")
         out))
    (read s)
    (format s " * this-is-direct-output")
    ;; : output-stream -> string
    ;; return all the characters in string-out-stream
    (get-output-stream-string out)))
;;;; Type Systems
;; PS: 1. trick with slimv: ,i to inspect a package
;;     2. trace a function with ,t
;;     3. in the restart mannual, move cursor to a local var
;;        and press ,i to inspect local variable.
;;     4. inspect on frame with global vars like *stanard-output*
;;        to check the value of the varin that frame.
;;     5. ,xl under a name to check where the function is called
;;        ,xe check what functions are called

(declaim (optimize (speed 0) (safety 3) (debug 3)))

;;; type:
;;;   a set of objects. Types are never explicitly represented as
;;;   objects in cl, instead they are referred to by type
;;;   specifiers.
;;;   So we can talk about types, but really there are not explicit
;;;   entity that is a type.
;;;
;;;   Although being dynamically typed language, common lisp has a
;;;   complete and expressive type system. It's a strongly typed language
;;;   so no random coersion happen under the scene.
;;;
;;;   by using facilities like deftype, we can make types with various
;;;   constraints.
;;;
;;;   One thing to note is that in a dynamcially typed language,
;;;   everything are essentially an object, and everything technically
;;;   can be passed around safely unless at some call sites a type
;;;   mismatch actually cause a trouble.
;;;
;;;   In a statically typed language, we have a full set of compile time
;;;   static sytem to denote and check type's validity. If you really
;;;   boil down to the meaning of types, a type checker is a light weight
;;;   specification langauge that describes the behavior of the program.
;;;   a language get interpreted. With this simple langauge we can
;;;   interpret it at compile time, or even editing time, to check if
;;;   there is any inconsistency of the logic. The fact that all objects
;;;   come with a type with it ensure a program that pass a type checker
;;;   doesn't make type errors.
;;;
;;;   In a dynamically typed language, the story is a little bit different.
;;;   Although in common lisp we still can do statical type checking, but
;;;   common lisp as a langauge itself doesn't provide a static type
;;;   system for a type checker to work with. What usually happen is that
;;;   the compiler will collect hints from the context, and try to give
;;;   variables a type. If by deduction a variable is 100% of type a, then
;;;   it will be treated as a value with type a. Any usage that treat it
;;;   as other types will be rejected.
;;;
;;;   But this is just some compiler tricks. At it's core, type errors
;;;   are considered as runtime error. Thus the idiomatic way to ensure
;;;   the correct usage of a function usually depends on some runtime
;;;   type check facilities. In common lisp it's common to call
;;;   (check-type) to make a type assertion.
;;;
;;;   It's useful to think about how to describe an algebraic data type
;;;   in a dynamically typed langue. An algebraic data type that consists
;;;   sum types and product types. product type is just a tuple of values,
;;;   which can be represented by any sequnce like objects and fix it's
;;;   size. But to represent a value is either of form A or form B, in
;;;   a dynamically typed langauge this is actually default. Since all
;;;   value can be passed as argument of any fucntions, all stand alone
;;;   types combined make a giant sum type that coporate all possible
;;;   input. There is no need for algebraic data type.
;;;
;;;   But it's good to have a way to specify some value is either type a
;;;   or type b just for runtime checking. This can be done with some
;;;   simply custom type specifier.
;;;
;;;   Given a type A, it's possible that type B is a proper subset of
;;;   A, thus B is a subtype of A. This subtype relation can be achieved
;;;   in common lisp with struct single inheritance, or using CLOS
;;;   system.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; checking a type
(defmacro my-typep (a type)
  (subtypep (type-of a) type))

(my-typep 1 bit)
(my-typep 1 integer)
(my-typep "good" (simple-array character (4))) ;; => t
(my-typep "good" (simple-array character (5))) ;; => nil

(typep 12 '(satisfies evenp))

;; for some reason the example online uses satisfies with lambda
;; expression, but according to the document satisifies only take
;; symbols as it's argument.
;; (typep 12 '(satisfies (lambda (x) (oddp x))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Define types
;;; type can be defined with deftype, defstruct, defclass and defcondition

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; deftype: define a derived type specifier

;;; We can define a new type that it's value satisfies some
;;; specific predicates we defined somewhere else.
;;; From here you can see how runtime type check predicates comes
;;; hand in hand with the type itself.

;;; satisify can be used to indicate type predicate.
;;; new type defined by deftype can be used with typep
;;; satisfy : a -> bool

;;; example1: square matrix
(defun equidimensional (a)
  "equal dimensional array"
  (or (< array-rank 2)
      (apply #'= (array-dimensions a))))
(deftype square-matrix (type size)
  `(and (array ,type (,size ,size))
        (satisfies equidimensional)))

;;; type p always works
(typep (make-array '(2 2) :initial-element 0) `(square-matrix integer 2))

(defun det-2x2 (matrix)
  ;; check the type of the input paramter before we go through
  (check-type matrix (square-matrix integer 2))
  (let ((a (aref matrix 0 0))
        (b (aref matrix 0 1))
        (c (aref matrix 1 0))
        (d (aref matrix 1 1)))
    (- (* a d) (* b c))))

(let ((m (make-array '(2 2) :initial-element 0)))
  (setf (aref m 0 0) 1
        (aref m 1 1) 1)
  (format t "~A~%" m)
  (det-2x2 m))

;;; example2 prime type
(defun primep (x)
  "primality test"
  (let ((r (floor (sqrt x)))
        (isprime t))
    (if (< x 2)
      nil
      (loop for i from 2 to r do
            (when (= 0 (mod x i))
              (setf isprime nil))))
    isprime))
(deftype prime () '(and integer (satisfies primep)))
(typep 11 'prime)
(typep 12 'prime)
(typep 13 'prime)

;;; TODO this two doesn't work because satisfies doesn't
;;; accept anything other than symbol
;;; example 3 pair type
(deftype pair (a b &optional typ)
  `(satisfies (lambda (x)
                (and (consp x)
                     (typep (car x) (quote ,a))
                     (typep (cdr x) (quote ,b))))))
(typep '(1 . 2) '(pair integer integer))

;;; example 4 list type
(defun list-of-p (typ xs)
  (and (listp xs) (every (lambda (x) (typep x typ))  xs)))
(list-of-p 'integer '(1 2 3))


(deftype list-of (typ)
  `(satisfies (lambda (xs) (list-of-p (quote ,typ) xs))))

(typep '(1 2) '(list-of integer))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; defstruct
;;; type defined by defstruct can also been used as a type
;;; specifier and get involved in runtime type checking.

(defstruct person
  (name "James" :type string)
  (age 0 :type integer))

(defstruct (astronaut :include person)   ;; inheritance
  (:conc-name astro-)
  (helmet-size 0.0 :type float))

(defstruct dawg
  (name "Dawg" :type string)
  (leg-num 0 :type integer))

(deftype person-or-dawg ()
  `(or person dawg))
(typep (make-dawg) 'person-or-dawg) ;; => true

(let ((p1 (make-person :name "Peter J Ladin" :age 100))
      (dawg1 (make-dawg :name "potsu" :leg-num 2)))
  (and (typep p1 'person)
       (person-p p1)
       (typecase p1     ;; this essentially allows you to pattern match.
         (person "Person!")
         (dawg "Dawg!"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; &key parameters can have a type!

(declaim (ftype (function (string &key (:n integer))) foo))
(defun foo (bar &key n) n)
;; compile time check :n to be integer
(let ((a (bar "asd" :n 1))) a)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; how to fit in type theory?
;;; https://alhassy.github.io/TypedLisp

;; t top type
(typep 'x 't)
(typep 1 t)

;; bottom type
(typep nil 'nil)

;; unit
(typep nil 'null)
(typep () 'null)

;; singleton type
(typep 3 '(eql 3))
(typep 10 '(eql 10))

;; union type
(typep 3 '(or integer char))

;; intersection type
(typep #(1) '(and array vector))

;; predicate
(typep 2 '(satisfies evenp))

;; note, many lisp types that looks polymorphic are not
;; polymorphic.
;; e.g cons is just a type that contains two parts
;; called car and cdr.

;; unlike variables in statically typed languages where
;; their types are fixed at compile time,
;; variables don't have type in lisp, only values have.

;; Because in lisp all variables have essentially the same type,
;; everything is polymorphic, which means nothing is polymorphic...

;; If everything is the same from each other, what's the point of
;; having parametric polymorphism in the first place?




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; checking types

;;; in lisp, types are inferred. By inferring it means you check the
;;; type info when it matters.
;;; e.g when you are passing a string as a function parameter, which
;;; eventually will be used as an integer, it will fail somewhere in the
;;; strack trace.

;;;
;;; For a compiler, type needs to be inferred by it's context. As
;;; mentioned above, (check-type) can give compilers a good hint about
;;; what type it supposes to have.

;; tbh this type of thing is hard to do in Haskell. You need typeable
;; coerce to Maybe Integer or something, lot of hassles to come by.
(let ((ellew 321))
  (list
    (type-of ellew)
    (progn
      (setf ellew "mm")
      (type-of ellew))))

(defmacro my-checktype (v type)
  (unless (typep v type) (error "type mismatch")))

(my-checktype 1 integer)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; quote to prevent evaluation
;;; x is the same as (eval x) unless specified.

(eval 1)
(eval (quote 1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; coersion
;;     e : a
;; -----------------
;;  (coerce e b) : b
;; (coerce '(76 105 115 112) 'string)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; type annotation
(+ (the integer 1)
   (the integer 2))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Some type specifiers
;;; (vector double-float 100)
;;; (vector double-float *)     ;; leave the name unspecified
;;; (vector * 100)              ;; leave the name unspecified

;;; predicating type specifiers
;;; (satisfies numberp) is the same type as number.
;;; it's like a way to promote term level predicate function to
;;; the type level.
(typep 10 '(satisfies numberp))
(typep 10 '(satisfies integerp))
(typep 10 '(satisfies characterp))
(typep "asd" '(satisfies stringp))
(typep "asd" 'string)
(deftype string-char () '(or character (satisfies numberp)))
(deftype string-char* () '(or character (satisfies numberp)))
(typep #\a 'string-char)
(typep 2 'string-char)


;;; subtyping

(typep #(#\a #\b) '(simple-vector 2))
(typep #(#\a #\b) '(array character))
(typep #(#\a #\b) '(array character (2)))
(typep #(#\a #\b) '(array character 2))
(subtypep '(simple-vector 2) '(array character 2))
(subtypep '(simple-vector 2) '(array t))


;; you can use deftype as type alias.
(deftype array3d () '(array integer (* * *)))

(deftype mod-type (n) `(integer 0 (,n)))
(deftype list-type () '(or null cons))
(deftype square-matrix (&optional type size)
  "square-matrix includes all square 2-d arrays"
  `(array ,type (,size ,size)))

;; defstruct will introduce a new type automatically.

(declaim (ftype (function ((or integer string hash-table))) fn1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; typecase
(defun fn1 (x)
  (typecase x
    (integer (format t "~%I got an integer"))
    (string (format t "~%I got an string"))
    (hash-table (format t "~%I got an hash-table"))
    (t (format t "~%What is this"))))

(defun fn2 ()
  (fn1 (case (random 4)
         (0 5)
         (1 "a string")
         (2 (make-hash-table))
         (3 #('none 'of 'above)))))

(defun fn3 (x)
  (typecase x
    (integer (format t "~%I got an integer"))
    (string (format t "~%I got an string"))
    (hash-table (format t "~%I got an hash-table"))
    (t (format t "~%What is this"))))
;;;; path
(probe-file "foo")

;; better portability
(uiop:probe-file* "/etc/passwd")

;;;; expand a file name with ~
;; expand to user home directory
(uiop:native-namestring "~/.vim/")

(directory ".")
(directory "./*")
(directory "*.*")
(directory "*/*.*")
(directory "**/*/*.*")

;; get absolute path
(truename "../cpp/tp/sfinae.cc")

;; concat path name
(merge-pathnames (elt (directory ".") 0) #P"file.txt")

;; the order is truely obnoxious.
(merge-pathnames #P"ugly" #P"good/bad/")

;;;; create directory
;; create a folder if not exists. / is necessary
(ensure-directories-exist (uiop:native-namestring "~/temp-from-lisp/"))

(with-output-to-string (out)
  (format out "good ~a" '(1 2 3))
  out)

(defun try-it ()
  (unwind-protect
    (return-from try-it)
    (print 'imhere)))

;;;; open and close streams, input and output.
;; out as a stream
(with-output-to-string (out)
  (with-open-file (in "./demo.lisp")
    (loop with buffer = (make-array 256 :element-type 'character)
          for n-characters = (read-sequence buffer in)
          while (< 0 n-characters)
          do (progn
               (format t "buffer filled, content:  ~%")
               (format t "~a~%" buffer)
               (write-sequence buffer out :start 0 :end n-characters)))))

;; with open file take both input and output.
(with-open-file (in "./demo.lisp" :direction :input)
  (loop for line = (read-line in nil)
        while line
        do (format t "~a" line)))

(unwind-protect ()
  (with-open-file (out "./file.txt" :direction :output
                       :if-exists :append
                       :if-does-not-exist :create)
    (with-open-file (in "./demo.lisp" :direction :input)
      (loop for line = (read-line in nil)
            while line do (format out "~a~%" line)))))

;; treat string a input
;; peek char just peek doesn't consume
(with-input-from-string (stream "this is a string")
  (print (read-char stream))
  (print (peek-char nil stream))

  (print (read-char stream))
  (print (read-char stream))

  (print (peek-char nil stream))
  (print (peek-char nil stream))
  (print (read-char stream))
  (values))

;; get file extension
(pathname-type "~/file.lisp")
;; some onlisp utils

(defun mkstr (&rest args)
  (with-output-to-string (s)
    (dolist (a args) (prin1 a s))))

;; creating symbols
(defun symb (&rest args)
  (values (intern (apply #'mkstr args))))

;; grouping list by n
(defun group (source n)
  (if (zerop n) (error "zero length")
      (labels ((rec (source acc)
                 (let ((rest (nthcdr n source)))
                   (if (consp rest)
                       (rec rest (cons
                                   (subseq source 0 n)
                                   acc))
                       (nreverse (cons source acc))))))
        (if source (rec source nil) nil))))

(group (loop for n from 1 to 10 collect n) 3)

;; flat nested list.
(defun flattern (xs)
  (labels ((rec (xs acc)
             (cond ((null xs) acc)
                   ((atom xs) (cons xs acc))
                   (t (rec (car xs) (rec (cdr xs) acc))))))
    (rec xs nil)))
;;;; This chapter talkes bout lexical scoping and closure

;;;; environment and extent ;;;;
;; an environment with temporary extent will last temporarily.
;; environment with indefinite extent will always being able to be referred to.

(defun parse-float (input)
  (with-input-from-string (s input)
    (car (loop for num = (read s nil nil)
               while num collect num))))

;; scanf in lisp
;; only takes %d, %s, %f
;; (fn &rest params)
(defun scanf (s fn)
  (labels ((read-word
             ()
             (with-output-to-string (s)   ;; how to get a string from a stream.
               (format s "~{~A~}"
                       (loop for c = (read-char)
                             while (not (member c '(#\Space #\Linefeed)))
                             collect c))
               s)))
    (let* ((anchors nil)
           (args nil)
           (next nil))
      (loop for c across s do
            (if (eq c #\%)
              (setf next t)
              (if next
                (progn
                  (push c anchors)
                  (setf next nil)))))
      (loop for i from (- (length anchors) 1) downto 0
            for n = (elt anchors i) do
            (cond ((eq n #\d) (push (parse-integer (read-word)) args))
                  ((eq n #\f) (push (parse-float (read-word)) args))
                  ((eq n #\s) (push (read-word) args))
                  (t (error "illegal anchor for scanf"))))
      (apply fn (nreverse args)))))


;; works pretty well
;; this chapter uses this as an example. The poiont is you don't pass
;; pointer of variable you want to change, instead you pass a closure that
;; capture those variables.
;; this way you get a mutable reference to variable you want to modify, but
;; only within the lambda you pass in.
(let ((a nil)
      (b nil)
      (c nil)
      (d nil))
  (scanf "%d %f %f %s"
         (lambda (x1 x2 x3 x4)
           (setf a x1)
           (setf b x2)
           (setf c x3)
           (setf d x4)))
  (format t "~% a is now ~a~%" a)
  (format t "~% b is now ~a~%" b)
  (format t "~% c is now ~a~%" c)
  (format t "~% d is now ~a~%" d))

;; I think closure was still a quite new idea while the book as written, but now
;; anybody should be able to get this easily.

;; It's just what's the actual benefit you get?
;; comparing with passing a point to get assigned, passing a closure is more
;; flexible as you can add additional logic to it.
;; It's not necesary that only pass the value to modify, as the closure can
;; capture any other variables it requres to work with.
;; it takes some practice.
;; you can't necessarily remember all usage without usig them...

;; idea of clos:
;; 1. class are just data with some accessors
;; 2. polymorphism is achieved by dispatch generic functions
;; 3. generic functions has specific implemnetations called mathods.
;; 4. once a generic function called, it will stich multiple method implementations
;;    to form a effective method.
;; 5. clos support multi dispath, meaning the decision of which method to call can be
;;    determined by more than one arguments. (in C++ dynamic dispatching only dispatch on
;;    one method, so it's single dispath)


;;;;
;; -- define a class
;; attributes of classes are called slots.
(defclass person ()
  ((name
     :initarg :name   ;; define init arg
     :accessor name)  ;; define the accessor name used
   (lisper
     :initarg :lisper
     :initform nil
     :accessor lisper)
   (species
     :initform 'homo-sapiens
     :accessor species
     :allocation :class)))
     ;; allocation control if the field is local or shared
     ;; between classes. By default is local (member)
     ;; set to :class to make it `static`.

;; -- create an object with make-instance
(defparameter *p1* (make-instance 'person :name "me" :lisper nil))

(defparameter *p2* (make-instance 'person :name "you" :lisper '(1 2 3)))

;; -- access slot with slot-value
;; slot is a function that always work...
(slot-value *p1* 'name)
(slot-value *p1* 'lisper)
(slot-value *p1* 'name)
(slot-value *p2* 'lisper)

(setf (slot-value *p1* 'lisper) '(-1))
(setf (slot-value *p1* 'lisper) '(9 8 7))

;; -- access slot predefined accessor
(name *p1*)
(name *p2*)
(funcall #'name *p1*)   ;; name is a funtion generated.

(class-of *p1*)
(type-of *p1*)
;; (inspect *p1*)

;; short hand for accessing necessary slots.
(with-slots ((n name)
             (l lisper))
  *p1*
  (format t "~a, ~A~%" n l))

;; -- set the shared field will change all instances.

;;;; inheritance

(defclass child (person)
  (can-walk-p
    :accessor can-walk-p
    :initform t))

(defmethod greet (obj)
  (format t "You are a ~a~&" (type-of obj)))
(defclass kombucha ()
  ((flavor
     :initarg :flavor
     :accessor flavor
     :initform nil)))

(defclass monkey ()
  ((name
     :initarg :name
     :accessor monkey
     :initform nil)))


(defclass person ()
  ((name
     :initarg :name
     :accessor name
     :initform nil)))

(defclass child (person) ())

(defclass dog ()
  ((name
     :initarg :name
     :accessor name
     :initform nil)))

(defclass zaku ()
  ((id
     :initarg :id
     :accessor id
     :initform nil)))

(setf p1 (make-instance 'person :name "me"))
(setf p2 (make-instance 'child :name "alice"))
(setf k (make-instance 'kombucha :flavor "ginger"))
(setf m (make-instance 'monkey :name "mm"))
(setf d (make-instance 'dog :name "bob"))
(setf z1 (make-instance 'zaku :id "0x001"))

;; define a method
;; if a method has no generic function, cl will automatically add
;; a definition for the generic function.

(defmethod greet (obj)
  (format t "Hi I am a ~a" (type-of obj)))

(defmethod greet ((obj dog))
  (format t "Wof I am a dog, my name is ~a" (name obj)))

(defmethod greet :before ((obj person))
  (format t "++++++ before person +++++~%"))

(defmethod greet ((obj person))
  (format t "I am a person and my name is ~a" (name obj)))

(defmethod greet :after ((obj child))
  (format t "~%++++++ after child +++++~%")
  (format t "... ~a is clawing away" (name obj)) )

(defmethod greet ((obj zaku))
  (format t "Zig Zeon! I am zaku number ~a" (id obj)))

(defmethod greet ((obj kombucha))
  (with-accessors ((flavor flavor))
    obj
    (format t "Hi I am a can of kombucha, my flavor is ~a" flavor)))
(defclass kombucha ()
  ((flavor
     :initarg :flavor
     :accessor flavor
     :initform nil)))

(defclass monkey ()
  ((name
     :initarg :name
     :accessor monkey
     :initform nil)))

(defclass person ()
  ((name
     :initarg :name
     :accessor name
     :initform nil)))

(defclass child (person) ())

(defclass dog ()
  ((name
     :initarg :name
     :accessor name
     :initform nil)))

(defclass zaku ()
  ((id
     :initarg :id
     :accessor id
     :initform nil)))

(setf p1 (make-instance 'person :name "me"))
(setf p2 (make-instance 'child :name "alice"))
(setf k (make-instance 'kombucha :flavor "ginger"))
(setf m (make-instance 'monkey :name "mm"))
(setf d (make-instance 'dog :name "bob"))
(setf z1 (make-instance 'zaku :id "0x001"))


;; using generic functions

(defgeneric greet (obj)
  (:documentation "say hello")
  (:method (obj)
   (format t "Hi I am ~a" (type-of obj)))
  (:method :before ((obj person))
   (format t "Before person +++ ~%"))
  (:method ((obj person))
   (format t "Hi I am person, my name is ~a" (name obj))))



;; specializers
(defgeneric feed (obj meal-type)
  (:method (obj meal-type)
   (declare (ignorable meal-type))
   (format t "eating ~&")))

;; eql specializer
(defmethod feed (obj (meal-type (eql :dessert)))
  (declare (ignorable meal-type))
  (format t "mmh, dessert! ~&"))

;; a varaible and a eql specializer
(defmethod feed ((obj child) (meal-type (eql :soup)))
  (declare (ignorable meal-type))
  (format t "yammy Mom I like soup"))


;; try some mutiple dispatch mechanisms

(defclass asteroid () ())
(defclass spaceship () ())

(defgeneric collide-with (x y)
  (:documentation "collides behavior"))

(defmethod collide-with ((x asteroid) (y asteroid))
  (format t "asteroid x asteroid"))

(defmethod collide-with ((x asteroid) (y spaceship))
  (format t "asteroid x spaceship"))

(defmethod collide-with ((x spaceship) (y asteroid))
  (format t "spaceship x asteroid"))

(defmethod collide-with ((x spaceship) (y spaceship))
  (format t "spaceship x spaceship"))
;; just some stuffs you already seen

;;;; lisp 2, function and variables have different namespaces.

(defun foo (x) (+ x 1))
(setf foo 10)

;; select value of a symbol from different namespace.
(symbol-value 'foo)
(symbol-function 'foo)

;; this is essentially defun under the hood.
(setf (symbol-function 'bar)
      (lambda (x) (* x x)))
(bar 2)

;; apply takes argument list, funcall call function directly.
(apply #'+ '(1 2))
(apply (symbol-function '+) '(1 2))
(funcall #'+ 1 2)

(mapcar (lambda (x) (+ x 10)) '(1 2 3))

(remove-if-not #'evenp '(1 2 3 4 5))

;; functions as properties
(defun behave (animal)
  (funcall (get animal 'behavior)))

;; All symbol can have global property list.
;; here we set the plist of 'dog direcly
(progn
  (setf (get 'dog 'behavior) #'(lambda () (format t "wig tails")))
  (behave 'dog)
  (symbol-plist 'dog))

;;;; plist, function, and value are i different name spaces!

(symbol-plist 'cat)   ;; at beginning it's default empty
(get 'cat 'mew)       ;; get from symbol plist.
                      ;; can give default value, this is different from getf.
(setf (get 'cat 'mew) "mew")    ;; set the global plist.

(setf cat 1)
(symbol-value 'cat)     ;; the value namespace

(defun cat () (format t "~a~%" (get 'cat 'mew)))
(funcall #'cat)         ;; the function namespace

;;;; under the hood get looks like this.
(defun get-* (x y) (getf (symbol-plist x) y))

(setf al '((a . 1) (b . 2)))

;; a explicit property list.
(defun behave1 (animal)
  (funcall (getf animal :behavior)))
(progn
  (let ((dog '()))
    (setf (getf dog :behavior) #'(lambda () (format t "wig tails")))
    (behave1 dog)))

(defun our-length (lst)
  (labels ((rec (lst acc)
             (if (null lst)
                 acc
                 (rec (cdr lst) (1+ acc))) ))
    (rec lst 0)))

;;;; function can be compile together or individuely.
;; you can even call a function to compile them.

(defun foo (x) (1+ x))
(compile 'foo)  ;; compile the function cell of the symbol 'foo



;;;; Conclusion
;; lisp is based on s expression
;;
;; you have either an atom or a list
;;
;; an atom can be a literal value, or a symbol.
;;
;; literal value is like string, integer, lambda  etc.
;;
;; symbol is it's own datatype, like a string but not, in the sense
;; that it's the symbol used in ast directly.
;;
;; a symbol can bind to a value. once bind you can access the value from
;; the symbol
;;
;; each symbol has two cells, one for function one for variable.
;;
;; a list is either a list or a function call
;;
;; special forms like if else are cases that treated differently.
;;
;; macro are functions execute at compile time.
;;
;; if macro return a list, the list itself as the ast of the code can be
;; substituted into wherever it's called. and that's how you are able to
;; write dsl with macros.
;;

;;;; further
;; common lisp is heavily imperative, there are lots of functions are mutation
;; based.
;;
;; You have wierd condition system that separate error handling into three parts:
;; handler, signaling error, and choose handler to handle errors.
;; handler are called restart. you can define different restarts.
;;
;; There is a widely used object system called CLOS. It has different inheritence
;; mechanism as normal oo. Namely it's based on generic function and is
;; able to do multi-disptaching.
;;
;; In clos class are only for data. generic funtion is like a interface for all
;; methods that has the same signature. Each implemnetation of a method specialize
;; for one type. You have some operators to interact with other methods implement
;; the generic function. like `call-next-method` etc.
;;

;;;; usage
;; plist and alist are very fundamental light data structures used in lisp. Both of
;; them had quite some history.
;;
;; function can have multiple return values. By default the first one is returned, but
;; you can disctruct multiple values with multiple-value-bind
;;
;; struct is a very light weight data structure, you can use it without worrying anything
;;
;; vector and hashmap ae properly supported too.
;;

;;;; typing
;; common lisp is strongly typed dynamic language. But it's also compiled, you
;; are able to annotate some types to assist compiler better.
;;
;; some functions around types like typep, typecase are convinent. Thye also
;; implies runtime type information.
;;
;; if you annotate type, compile will give you better warning. If you call a
;; annotated funtion with the runtime, it will be a runtime type error.

;;;; dsl
;; lisp is famous for it's dsl ability. The ability is mainly comes from the
;; homoiconcity of data and code. To exploit the homoiconicity, you write macro
;; to generate code.
;;
;; code generate code also called mata function
;;
;; There can be multiple stages for a macro. You can nest quotes and unquotes.
;; again, basic stuffs.

; (defun destructive-rev (lst)
;   (let* ((len (length lst))
;          (ilimit (truncate (/ len 2))))
;     (do ((i 0 (1+ i))
;          (j (1- len) (1- j)))
;         (rotatef (nth i lst) (nth j lst)))))

;; reverse can be either destructive or non destructive.
(defun destructive-rev (lst)
  (let* ((len (length lst))
         (limit (truncate (/ len 2))))
    (do ((i 0 (1+ i))
         (j (- len 1) (1- j)))
        ((>= i limit))
        (rotatef (elt lst i) (elt lst j))))
  lst)

(defun immut-rev (lst)
  (labels ((rec (xs acc)
             (if (null xs)
                 acc
                 (rec (cdr xs) (cons (car xs) acc)))))
    (rec lst nil)))

;; ok that's all...
;; this chapter really doesn't have much
;;;; some common lisp practices.

(defun mkstr (&rest args)
  (with-output-to-string (s)
    (dolist (a args) (prin1 a s))))

(defun flattern (xs)
  (labels ((rec (xs acc)
             (cond ((null xs) acc)
                   ((atom xs) (cons xs acc))
                   (t (rec (car xs) (rec (cdr xs) acc))))))
    (rec xs nil)))

(flatten '((12 (8 83 (2 (2))) 4 (2 34 1) (2 3 (2 3 4)))))
module MapCar
  ( mapcar
  , maplist
  , mapcar
  ) where

import           Control.Monad
import           Data.IORef
import           System.IO.Unsafe

transpose []       = repeat []
transpose (xs:xss) = zipWith (:) xs (transpose xss)

-- | mapcar, can be map or zip
-- >>> 10
mapcar :: ([a] -> b) -> [[a]] -> [b]
mapcar f = fmap f . transpose

-- | maplist scans on sublist
maplist :: ([[a]] -> b) -> [[a]] -> [b]
maplist f = fmap f . transpose . (stairs <$>)
  where
    stairs []       = []
    stairs [x]      = [[x]]
    stairs t@(_:xs) = t : stairs xs

-- | cons and update
nconc :: [IORef [a]] -> IO [a]
nconc = join . fmap readIORef . foldl nconc' (newIORef []) . fmap pure

nconc' :: IO (IORef [a]) -> IO (IORef [a]) -> IO (IORef [a])
nconc' xio yio = do
  xref <- xio
  ys <-join $ readIORef <$> yio
  modifyIORef xref (<> ys)
  return xref

unsafeNonc :: [IORef [a]] -> [a]
unsafeNonc = unsafePerformIO . nconc

unsafeNconc' :: IORef [a] -> IORef [a] -> IORef [a]
unsafeNconc' xref yref = unsafePerformIO $ do
  ys <- readIORef yref
  modifyIORef xref (<> ys)
  return xref

-- update on first argument
mapcan :: ([a] -> b) -> [[IORef a]] -> IO [b]
mapcan = undefined

(defvar *account-number* 0)

(defclass bank-account ()
  ((customer-name
     :initarg :customer-name)
   (balance
     :initarg :balance
     :initform 0)
   (account-number
     :initform (incf *account-number*))
   ; gold, silver, or bronze
   account-type))

(defclass checking-account (bank-account) ())

; define the :after method for initialize-instance.
; initialize instance is what's going to be called once you call
; make-instance.
; &key is required because that's how initialize-instance defined
(defmethod initialize-instance :after ((account bank-account)
    (setf (slot-value account 'account-type)
          (cond
            ((>= balance 10000) :gold)
            ((>= balance 1000) :silver)
            (t :bronze)))
    (when opening-bonus-percentage
      (incf balance (* balance (/ opening-bonus-percentage 100))))))

; mannually init
(defparameter *account* (make-instance 'bank-account))
(setf (slot-value *account* 'customer-name) "John Doe")
(setf (slot-value *account* 'balance) 1001)

; init with initalizer
(defparameter *president-account*
  (make-instance 'bank-account
                 :customer-name "Mr. President"
                 :balance 1000000
                 :opening-bonus-percentage 10))     ;; add some bonus

;; The core of CLOS: generic functions!
(defgeneric withdraw (account amount)
  (:documentation "Withdraw amount from the account"))

;; methods must have the same signatures as the generic function.
;; so &key, &rest also must be specified.
(defmethod withdraw ((account bank-account) amount)
  (let ((balance (slot-value account 'balance)))
    (when (< balance amount)
      (error "Account overdrawn."))
    (decf balance amount)))
;; 10 numbers - 11 collections - 12 list - 13 trees

;; lisp is surprisingly rich with it's data structures support.
;; lots of things are in the standard library direclty,
;; not like in haskell, to use vector you need extra dependency.


;; vectors

(defun play-with-vector ()
  (let ((vec1 (vector 1 2 3))
        (vec2 #(13 2))
        (vec3 (make-array 5 :initial-element nil))
        ;; resizable vector. :adjustable is not required.
        (vec4 (make-array 5 :fill-pointer 3
                          :adjustable t)))
    (format t "vec4 before push: ~a~%" vec4)

    (vector-push 'a vec4)
    (format t "vec4 after push ~a~%" vec4)

    (vector-pop vec4)
    (format t "vec4 after pop ~a~%" vec4)

    (loop for n in '(1 2 3 4) do (vector-push-extend n vec4))
    (format t "vec4 after grown ~a~%" vec4)))

(defun specialized-vector ()
  (let ((char-vec (make-array 5 :fill-pointer 4
                              :adjustable t
                              :initial-element #\Z
                              :element-type 'character))
        (bit-vec (make-array 5 :fill-pointer 0
                             :adjustable t
                             :element-type 'bit)))
    ;; length and elt are defined for all sequences.
    (format t "~a ~%"(length char-vec))
    (setf (elt char-vec 2) #\X)

    (vector-push #\A char-vec)
    (format t "before set elt : ~a~%" char-vec)

    (setf (elt char-vec 0) #\B)
    (format t "after set elt : ~a~%" char-vec)
    ))

(defmacro show (clause)
  (let ((name (gensym)))
    `(let ((,name ',clause))
       (format t "[code]: ~a [result]: ~a~%" ,name ,clause))))

(defun verbose-first (x)
  (format t "Looking at ~s~%" x) (first x))

(defun sequence-iterating ()
  (let ((seq1 (make-array 5 :fill-pointer 5
                           :adjustable t
                           :element-type 'number
                           :initial-element 1
                           )))
    (show (count 1 #(1 2 3 1 1)))
    (show (remove 1 #(1 2 3 1 1)))
    (show (remove 1 '(1 2 3 1 1)))
    (show (remove #\A "abcAbcA")) (show (substitute 9 1 #(1 2 3 1 1)))
    (show (find 'a #((a 10) (b 20) (c 30)) :key #'first))
    (show (remove #\a "foobarbazbarbar" :count 2))
    (show (count 'a #((a 10) (b 20) (c 30)) :key #'verbose-first))
    (show (remove #\a "foobarbar" :count 1 :from-end t))
    (show (find 3 #(1 2 3 1 1)))))


(defun sequence-function-variants ()
  (show (remove-if-not #'evenp (loop for n below 10 collect n)))
  (show (count-if #'oddp (loop for n below 10 by 2 collect n))))


(defun some-operations ()
    (concatenate 'vector #(1 2 3) '(4 5 6))
    (concatenate 'list '(1 2 3) #(3 4 5))
    (concatenate 'string "abc" '(#\a #\b))
    (sort #("asd" "qd" "bvkds") #'string>)
    (let ((my-seq #(9 3 4 2 7 1)))
      (setf my-seq (sort my-seq #'<))   ; sort is destructive update
      (elt my-seq 0))
    (merge 'vector #(1 3 5) #(2 4 6) #'<)
    (subseq "foobarbaz" 3)
    (subseq "foobarbaz" 3 6)
    (let ((my-seq #(9 8 3 4)))      ; subseq is setable.
      (setf (subseq my-seq 2 4) #(1 2))
      (write my-seq))
    (every #'evenp #(1 2 3 4 5))
    (some #'evenp #(1 2 3 4 5))
    (map 'vector #'* #(1 2 3 4) #(1 2 3 4))
    (map 'vector (lambda (x) (* x 10)) #(1 2 3 4))
    (reduce #'+ (loop for n below 11 collect n) :initial-value 0)
    (reduce #'- (loop for n below 11 collect n) :initial-value 0)
    (reduce #'- (loop for n below 11 collect n)
            :initial-value 0 :from-end t))

(defmacro test-hash (fn)
  (let ((hash-table-sym (gensym)))
    `(let ((,hash-table-sym (make-hash-table)))
       (,fn ,hash-table-sym))))

; play with multiple return values.
(defun show-value (key hash-table)
  (multiple-value-bind (value present) (gethash key hash-table)
    (if present
        (format t "Value ~a by ~a actually present.~%" value key)
        (format t "Value ~a by ~a doesn't present.~%" value key))))

(defun play-hash ()
  (test-hash (lambda (table) (gethash 'foo table)))
  (test-hash (lambda (table)
               (setf (gethash 'foo table) 1)
               (gethash 'foo table)))

  (test-hash (lambda (table)
               (setf (gethash 'foo table) nil)
               (show-value 'foo table)
               (show-value 'bar table)
               (remhash 'foo table)     ; remove element
               (show-value 'foo table)
               ))

  (test-hash (lambda (table)
               (setf (gethash 'foo table) 1)
               (setf (gethash 'bar table) 2)
               (setf (gethash 'bz table) 2)
               (maphash (lambda (k v)
                          (format t "key ~a, value: ~a~%" k v))
                        table)
               (loop for k being the hash-keys
                     in table using (hash-value v)
                     do (format t "~a => ~a~%" k v))
               )))

; cons cell: (car, cdr), which forms a pair.

(defun car-cdr-cons ()
  (cons 1 2) ; => (1 . 2) dotted pair
  (cons 1 (cons 2 nil))
  (cons 1 (cons 2 (cons 3 nil))) ; (1.)->(2.)->(3.nil)
  (list "foo" (list 1 2) 10)

  (append (list 1 2 3) (list 3 4 5))
  (reverse (list 1 2 3))

  ; for side effects / recycling
  (let ((list1 (list 1 2 3)))   ; destructive

    ; use side effects, be careful to mix it with
    ; functional style code.
    (setf (first list1) 3)
    (format t "~a~%" list1)

    (setf (elt list1 2) 99)
    (format t "~a~%" list1)

    (setf (aref list1 3)))
  ; recycling, use side effect to optmize functional
  ; code
  ; recycling functions can only be used safely
  ; if the list isn't gonna be used afterwards.

  (let ((list1 (list 1 2 3)))

    (reverse list1)
    (format t "~a~%" list1)

    (setf list1 (reverse list1))
    (format t "~a~%" list1)

    (nreverse list1))

  (first (list 1 2 3))
  (rest (list 1 2 3))
  (last (list 1 2 3))
  (mapcar (lambda (x) (+ x 1)) (list 1 2 3))
  (mapcar (lambda (x y) (+ x y)) (list 1 2 3) (list 2 3 4))

  (let ((x '(1 2 3))
        (y '(2 3 4)))
    (mapcan (lambda (a b) (+ a b)) x y)
    (cons x y))

  (map 'vector #'evenp (loop for i from 0 to 100 collecting i))

  (maplist (lambda (x) (cons 'foo x)) '(a b c d))

  ;; map list is like scan, it lambda receive the rest of the list.
  (maplist (lambda (xs) (mapcar #'1+ xs)) '(1 2 3 4))

  (maplist (lambda (xs ys) (concatenate 'list xs ys)) '(1 2 3 4) '(3 4 5 6))

  ;; mapcan is like mapcar but reuslt is connected with nconc
  ;; mapcan is destructive, apply nconc to intermediate result.
  ;; this is really confusing.
  (let ((x (list 1 2 3)))
    (mapcan (lambda (a) (+ a 1)) x)
    x)

  (let ((x '((1 2 3) (4) (5 6) (2 3))))
    (mapcan #'cdr x)
    ;x destructive
    x)

  (mapc (lambda (x) (+ x 1)) '(1 2 3))
  (mapcar (lambda (x) (+ x 1)) '(1 2 3))

  ;; mapcon is like maplist but connected with nconc
  (let ((x '(1 2 3 4))
        (y '(2 3 4 5)))
    (mapcon
      (lambda (xs ys) (mapcar (lambda (x y) (+ x y)) xs ys)) x y)
    (cons x y))

  (mapcon (lambda (x) (mapcar #'1+ x)) '(1 2 3 4))

  (nth 3 (list 1 2 3 4))
  (quote ((1 2) (3 4) (5 6)))

  (let* ((list1 '(1 2 3))
         (list2 (copy-list list1))
         (list3 '((1 2) (3 4)))
         (list4 (copy-list list3)))
    (setf (elt list2 2) 99)

    (format t "list1: ~a~%" list1) ; (1 2 3)
    (format t "list2: ~a~%" list2) ; (1 2 99)

    (setf (elt list3 1) 99)

    (format t "list3: ~a~%" list3)
    (format t "list4: ~a~%" list4)
    (tree-equal list1 list2 :test #'equal))

  ; tree with con cells
  (let ((tree1 '(1 2 (3 2 1) (1 1) (2 2))))
    (subst 10 1 tree1)
    (subst-if 10 #'listp tree1)) ; TODO works

  ; set with con cells
  (let ((s '()))
    (pushnew 1 s)   ; destructive
    (adjoin 2 s)))

(defun assoc-list ()
  ; lookup table
  ; association list (alist) and property list (plist)

  ; assoc list is just list with dotted pairs as it's elements.
  '((a . 1) (b . 2) (c . 3))

  ; use assoc to look up
  (assoc 'a '((a . 1) (b . 2) (c . 3)))
  (cdr (assoc 'a '((a . 1) (b . 2) (c . 3))))
  (cdr (assoc "a" '(("a" . 1) ("b" . 2) ("c" . 3)) :test #'string=))

  ; add an key-value pair to the list.
  (cons (cons 'd 3) '((a . 1) (b . 2) (c . 3)))
  ; short hand
  (acons 'd 3 '((a . 1) (b . 2) (c . 3)))

  ;;; for small table and the performance of alist can
  ;;; out perform hashtable, since hashtable itself has
  ;;; some extra overhead like hashing and collision resolving.
  ;;; There are a lot of situations that you only need a small
  ;;; table. For example, for the entire problem you only have
  ;;; 20 or 30 special configs to keep track of. alist can be
  ;;; a very good candidate for that.

 (let* ((alist (acons 1 "one" (acons 2 "two" '())))
        (list-copy (copy-list alist))
        (alist-copy (copy-alist alist))
        (show (lambda ()
                (format t "alist      ~a ~%" alist)
                (format t "list-copy  ~a ~%" list-copy)
                (format t "alist-copy ~a ~%" alist-copy)
                (format t "~%")
                )))
   ; conclusion list-copy share the same underlying atoms.
   ; alist copy copy the entire table
   (funcall show)

   (setf (cdr (assoc 2 alist)) "deux")
   (funcall show)

   (setf (cdr (assoc 1 list-copy)) "uno")
   (funcall show)

   (setf (cdr (assoc 1 alist-copy)) "yi")
   (funcall show))

 ; plist is similar but use symbols directly

 (let ((plist '(:a 1 :b 2 :c 3)))
   (getf plist :a)
   (setf (getf plist :a) 10)
   (remf plist :a)
   (write plist))


 ; destructruring binding
 (destructuring-bind (x y z) (list 1 2 3)
   (list :x x :y y :z z))

 (destructuring-bind (x y z) (list 1 (list 1 2) 3)
   (list :x x :y y :z z))

 (destructuring-bind (&whole whole &key x y z)
   (list :z 1 :x 1 :y 1)
   (write whole)))
;; condition system
;; combinations of exceptions and warnings
;;
;; In a java/python like exception system, each time a code throws
;; an exception, the stack will unwind, and the call site will be destoried.
;; So even if the caller get signaled that some exception happened, it can't
;; do much to fix it because the callee no longer exists.
;;
;; But with common lisp conditon system, we can have keep the callee intact,
;; while choose what handler to call to fix the exception. As if you can
;; freeze the time and choose what to do.
;;
;; Three components of a condition system
;; 1. signaling a condition
;; 2. handling a condition
;; 3. recover from a condition
;; You can handle exceptions at lower level functions, not like in languages like
;; python, error handlers are all defined in higher level functions.


;; (in-package :error-handling)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; define two errors
(define-condition file-io-error (error)
  ((message :initarg :message :reader message)))

(define-condition another-file-io-error (error)
  ((message :initarg :message :reader message)))

;; simulate an io operation that might fail.
;; it throws like a normal language with try/catch, there is
;; no condition handler defined with the code, all error recovering
;; code are from the caller.
(defun fake-io (&key (fail nil fail-p) (message "Error!"))
  (cond
    ((not fail-p)
     (if (evenp (random 100))
         (error 'file-io-error :message "message")
         "success"))
    (fail (error 'another-file-io-error :message "message"))
    (t "success")))

;;;; flush the io buffer:
;; finish-output, force-output, and clear-output

;;;; lisp has muli value output
;; to obtain multiple values as a list you can wrap the function in
;; multiple-value-list. Similary to destruct multiple values reutrned
;; you can use multiple-value-bind to bind values with a name.

;; define a restart function
(defun read-new-value ()
  (format t "Enter a new value: ")
  (force-output)
  (multiple-value-list (eval (read))))

;; use restart when error happens.
;; these cases will be added into the debugger options so you can invoke.
;; (restart-case (form) (restart1) (restart2) ...)
(let ((fail t))
     (restart-case (fake-io :fail fail)  ;; expression to run
                   ;; first handler we define
                   (retry-without-errors (new-fail)
                                         :report "Pass in a fail value"
                                         :interactive read-new-value (setf fail new-fail)
                                         (fake-io :fail fail))
                   ;; second handler simply do nothing
                   (do-nothing ()
                               :report "don't handle the error"
                               "done with it!")))
(fake-io)
(fake-io :fail t)
(fake-io :fail nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; we want to define handler to automatically handle
;;;; handler-case behaves like try-catch in other languages.
;; catching any conditions
(handler-case (/ 3 0)
  (error (c) (format t "We caught a condition ~&")
         (values 0 c)))

;; another way to catch all conditions with t
(handler-case
  (progn
    (format t "This won't work~&")
    (/ 3 0))
  (t (c)
     (format t "Got a condition ~a~%" c)
     (values 0 c) ) )

;; catching specific conditions
(handler-case (/ 3 0)
  (division-by-zero (c)
                    (format t "caught a division by zero condition  ~a~%" c)
                    (values 0 c)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; we define a new condition here
(define-condition on-zero-denominator (error)
  ((message :initarg :message :reader message)))

;; reciprocal will decide what conditon to throw, also it defines
;; some handler for that condition.
(defun reciprocal (n)
  (restart-case
    (if (/= n 0)
        (/ 1 n)
        (error 'on-zero-denominator :message "can't divide by zero"))
    (return-zero () :report "Just return 0" 0)
    (return-value (r) :report "Return another value" r)
    (recalc-using (v) :report "recalculate" (reciprocal v))
    (return-nil () nil)))

;; in this function we choose to ignore condition
;; but we also provide another possible way to handle any possible
;; condition, namely `just continue`
(defun list-of-reciprocals (array)
  (restart-case
    (mapcar #'reciprocal array)
    (just-continue () nil)))''

;; here we 'bind on-zero-denominator with a lambda handler.
;; in the handler it calls the lower level handler provided by reciprocol.
;; in this case, we choose to just return 0.
(defun print-reciprocals (array)
  (handler-bind
    ((on-zero-denominator
       #'(lambda (c)
           (format t "error signaled: ~a~%" (message c))
           (invoke-restart 'return-value 0))))
    (let (r)
      (setf r (list-of-reciprocal array))
      (dolist (x r)
        (format t "Reciprocal: ~a~%" x)))))
; read
;; common lisp has a very complicated stream system.
;; (not really, but the api is hard to follow up)
;; I'm sure if you are already very familiar with the
;; mechanism it will be very nice to use, but there are
;; simply too many details exposed.

(let ((in (open "db1" :if-does-not-exist nil)))
  (when in
    (format t "~a~%" (read-line in))
    (close in)))

(let ((in (open "./file.txt" :if-does-not-exist nil)))
  (when in
    (loop for line = (read-line in nil)
          while line
          do (format t "~a~%" line))
    (close in)))

(let ((in (open "./file.txt")))
  (dotimes (n 3) (read-line in))
  (format t "~a~%" (read in))   ; read read s-expr directly
  (format t "~a~%" (read in))   ; and return the list object
  (format t "~a~%" (read in)))

; read and print helps you to serialize and deserialze
; easily.
(read (print '(1 2 3)))

(with-output-to-string (out)
  (format out "output this string to out")
  out)


; context manager for files
; nil is almost necessary for read-line...
(with-open-file (in "./file.txt")
  (loop for line = (read-line in nil)
        while line
        do (format t "~a~%" line)))

(with-open-file (stream "db2" :direction :output)
  (format stream "Some text."))

; how does the context manager work
(defun try-it ()
   (unwind-protect
     (return-from try-it) ; doesn't really return here
     (print 'iamhere)))

(defun try-it-unprotected ()
  (return-from try-it-unprotected)
  (print 'iamhere))  ; this will not be printed

; an example implementation of getenv

(defun my-getenv (name &optional default)
  "Obtains the current value of the POSIX environment variable NAME."
  (declare (type (or string symbol) name))
  (let ((name (string name)))
       (or #+abcl (ext:getenv name)
           #+ccl (ccl:getenv name)
           #+clisp (ext:getenv name)
           #+cmu (unix:unix-getenv name) ; since CMUCL 20b
           #+ecl (si:getenv name)
           #+gcl (si:getenv name)
           #+mkcl (mkcl:getenv name)
           #+sbcl (sb-ext:posix-getenv name)
           default)))
;; Format is no longer a format function. It's more like a versatile type
;; converter in common lisp...
;; format has three main functionalities
;; 1. printing tables of data.
;; 2. pretty printing s expressions.
;; 3. print values in human readable form.

;; the first argument of format is a output stream. It can be
;; nil, t, *standard-output*, or a string with filled pointer.
;; with a string with a filled pointer, you can get the result of
;; format as a variable, much like sprintf in c.
(format t "~{~a^, ~}" '(1 2 3 4 5 6 7 8 9 10))

(format t "~a" pi)

(format t "~$" pi)  ;; floating point with 2 digitis
(format t "~5$" pi)

;; prefix parameter allows you to alter some behaviors
(format t "~v$" 3 pi) ;; v consume one format paramter, use it to set prefix.
(format t "~3$" pi)   ;; this is the same as the line above.

(format t "~#$" pi)  ;; # will evaluated as # of remaing format arguments
(format t "~#$" pi 1 2 3)


;; an example of outputing formatted string to fillpointer string.
(let ((s1 (make-array 0 :element-type 'character
                      :adjustable t
                      :fill-pointer 0))  ;; fill at the beginning
      (s2 (make-array 10 :element-type 'character
                      :adjustable t
                      :fill-pointer 4)))
     (format s1 "Hello, ~a" 'Jimmy)
     (format s2 "Hello, ~a" 'Jimmy)
     (print s1)
     (print s2)
     nil)
(defun primep (number)
  (when (> number 1)
    (loop for fac from 2 to (isqrt number)
          never (zerop (mod number fac)))))

(defun next-prime (number)
  (loop for n from number when (primep n) return n))

(defmacro once-only ((&rest names) &body body)
  (let ((gensyms (loop for n in names collect (gensym))))
    `(let (,@(loop for g in gensyms collect `(,g (gensym))))
       `(let (,,@(loop for g in gensyms
                       for n in names collect ``(,,g ,,n)))
          ,(let (,@(loop for n in names
                         for g in gensyms collect `(,n ,g)))
             ,@body)))))

(defmacro do-primes ((var start end) &body body)
  (once-only (start end)
    `(do ((,var (next-prime ,start) (next-prime (1+ ,var))))
     ((> ,var ,end))
     ,@body)))

;;;; how to write a hyneic macro writing macro?
(defmacro repeat-times-writing-robot (count-form forms)
  (let ((counter-sym-sym (gensym)))  ; macro's symbol
    `(let ((,counter-sym-sym (gensym)))
       ;; unquote twice for the outer most symbol
       `(loop for ,,counter-sym-sym below ,,count-form
              do ,@,forms))))

(defmacro repeat-times (count-form &body forms)
  (repeat-times-writing-robot count-form forms))
;;;; Chapter 5 - 13, some language features

;;;; Rule of thunbs
;;; 1. lisp always evaluate all expressions
;;; 2. atoms are self-evaluating
;;; 3. symbols stores 2 types of values:
;;;    regular value and functional definition. (2-lisp)
;;; 4. given S-expression, if quoted, return unevaluated
;;;    otherwise get it's car and evaluate.

(defun plot (fn min max step)
  ; use funcall to avoid evaluating the symbol for function name.
  (loop for i from min to max by step do
        (loop repeat (funcall fn i) do (format t "*"))
        (format t "~%")))

(defun funcall-and-apply ()
  ; this work, lambda is self-evaluating
  (write (funcall (lambda (x) (+ x 1)) 1))
  (write (funcall #'evenp 2))

  ; apply is the same as funcall, but takes arguments as a list
  (write (apply (lambda (x) (+ x 1)) '(1)))
  (write (apply #'evenp '(2))))
  ; (funcall evenp 2) this doesn't work because evenp get evaluated.


(defun hello-world ()
  (format t "Hello world"))

(defun verbose-sum (x y)
  "Sum two numbers, and let everybody knows it"
  (format t "Yo, adding ~d and ~d now ~%" x y)
  (+ x y))

(defun optional-foo (a b &optional c d (e 10) (f '(good bad) f-p))
  (list a b c d e f f-p))

;;; &rest and &key are safe to combine together.
;;; &optional is the most problematic when combine with others.
(defun mixed-foo (a b &rest res &key x y z)
  (list a b x y z (length res)))

(defun foo (&key a (b 20) (c 30 c-p)) (list a b c c-p))
(defmacro varadic (&rest rs) (write rs))

(defun grow- (a b) (if (= b 0) a (grow- b (mod a b))))

(defun foo-return (n)
  (dotimes (i 10)
    (dotimes (j 11) ; return-from a block
      (when (> (* i j) n) (return-from foo-return (list i j))))))

;;; macro gym
(defmacro backward (expr) (reverse expr)) ; macro
(defun hello-macro ()
  (backward ("hello, world" t format)))

;;; ('a) use tip to avoid evaluate
;;; `(a ,b) back tip to not evaluate by default, use , to evaluate
(defun backtip () `(and ,(list 1 2 3)))     ; normal
(defun backtip* () `(and ,@(list 1 2 3)))    ; splice
(defun backtip** () `(and ,@(list 1 2 3) 4 5))    ; splice
(backtip**)

;;; chapter 3 row database
;ll property list with keyword symbol
(defparameter *propertylist* (list :a 1 :b 2 :c 3))
(getf *propertylist* :a)

;; chapter 6 variables

(defvar *var* 1)

;; introduce variable bindings
(defun foo (x y) (let ((z 10))
    (+ x y z)))


;; closure
(defparameter *fn*
  (let ((count 0))
    (lambda () (setf count (1+ count)))))

(defun funcscall (fns)
  (car (last (mapcar (lambda (fn) (funcall fn)) fns))))

(defparameter *fn1*
  (funcscall
    (let ((count 0))
      (list
        (lambda () (incf count))
        (lambda () (incf count))
        (lambda () (decf count))
        (lambda () count)))))

;; dynamic variables (special variables)
(defvar *a-counter* 0
  "Count of wdgets made so far")

(defvar *unbound*) ; this one is unbound

; (defparameter *unbound1*)
; defparameter always assign the inital value to the name
; so you can't have unbound variable.

(defparameter *gap-tolerance* 0.001
  "Tolerance to be allowed in widget gaps.")

; reload will keep the previous *a-counter* value
(defun increment-widget-count () (incf *a-counter*))

; each reload rebind the variable.
(defun increment-widget-gap-tolerance ()
  (setf *gap-tolerance* (1+ *gap-tolerance*)))


(defvar *x* 8)
(defun dynamicfoo ()
  (format t "outside of let binding, *x* is now ~a~%" *x*)
  (let ((*x* 20))
    (setf *x* 99)
    (format t "*x* is ~a~%" *x*))
  (format t "outside of let binding, *x* is now ~a~%" *x*))

; just lexical binding, nothing much to say.
(defun lexical-shadowing (x)
  (format t "the real parameter ~a~%" x)
  (let ((x 10))
    (format t "one layer down x: ~a~%" x)
    (let ((x 99))
      (format t "inner most x: ~a~%" x))))

; note all global variables are dynamically binded.
; see this example:
(defparameter *par* 5) ; define some global variables
(defvar *var* 10)
; the closure should always be the global if it's lexical
; scoped
(defun dynamic-scope-test () (+ *par* *var*))
(defun call-dynamic-scope-test ()
  (dynamic-scope-test) ; use the global binding like normal
  (let ((*par* 10)     ; we can sneaky in some other values.
        (*var* 20))
    ; however here it uses the local here.
    (dynamic-scope-test)))


; of course you have constant
(defconstant +constant+ 1)

; explanation:
; the value y is binded to 20
; then f is called,
; the value of y binds to, 20, now bind to value 10.
; it's a copy so to speak.
(defun set-lexical-binding ()
  (let ((f (lambda (x)
             (setf x 10) ; set the local binding.
             (prin1 x)
             ))
        (y 20))
    (funcall f y)
    (print y)))          ; binding y doesn't change

(defun set-by-closure () ; if you want to change value, use closure.
  (let* ((y 10)
         (f (lambda ()
              (setf y 20)
              (print y))))
    (funcall f)
    (print y)))


; setf with side effect.
(defparameter *array* (make-array 10))
(defparameter *vector* #(1 2 3 4))

(defun inc-random-array-cell ()
  (incf (aref *array* (random (length *array*)))))

; ref to the same cell twice
(defun inc-random-array-cell-with-setf-1 ()
  (let* ((idx (random (length *array*))))
    (setf (aref *array* idx) (+ (aref *array* idx) 1))))

; use getf to get the reference.
(defun inc-random-array-cell-with-setf ()
  (let* ((idx (random (length *array*)))
         (cell (aref *array* idx)))
    (setf (getf cell) (+ (getf cell) 1))))

; swap
(defun try-rotate (x y)
  (print `(,x ,y))
  (rotatef x y)
  `(,x ,y))

(defun my-rotate (a b)
  (let ((tmp a))
    (setf a b b tmp)
    nil))

; shift value one to the right.
;; a = 10, b = a
(defun try-shift (a b)
  (shiftf a b 10)
  (list a b))

;; lisp 2
;; common lisp is lisp 2, so it's variable name and function names
;; are in different namespaces.
;; when common lisp sees form (f a b c d), name a will be looked
;; up in function space and a b c d will be from variable space.
;; this is why you have let and flet.
;; use flet to introduce a local binding.

;; use let* and labels for the usual cases,
;; let and labels are used only for cases that you explicitly
;; don't want closure or don't want recursive binds.

(defun lisp2-let ()
  (let* ((a 10)
         (b 20))
    (labels ((f (x) (+ x 1))
             (g (x) (* x 2)))
      (print (f (g a)))
      (print (g (f b))))))
;;;; I have no idea how a loop dsl can be so complicated...
;; but it's a way to investigate what doesn it mean to be a loop so...
;; guess it's worthy.

;; this is really a zip
(loop
  for item in '(a b c d e)
  for i from 1 to 10
  do (format t "(~a, ~a)" item i))

;; this is the cartesian product.
(loop for item in '(a b c d e) do
      (loop for i from 1 to 10 do
            (format t "(~a, ~a)" item i)))

;;;; counting loop (the most primitive loops
;; Three main preprositional phrases:
;;   fromwhere:  from, downfrom, upfrom
;;   towhere:    to, upto, below, downto, above
;;   byhowmuch:  by ...
;; you must specify at least on of these three prepositions.

;; default starts at 0.
(loop for i upto 10 collect i)
(loop for i to 10 collect i)

;; downto requires a starting value.
(loop for i from 10 downto 1 collect i)
(loop for i from 10 downto -10 collect i)

;; can start from any value
(loop for i from 20 to 30 collect i)
(loop for i from 20 to 30 by 2 collect i)

;; need a form after by, must return a positive number
(loop for i from 20 to 30 by (floor 24 11) collect i)

;; loop is a macro, so it must know the direciton of the loop
;; to know how to step it's variable.
(loop for i from 20 to 10 collect i)  ;; this won't run since inc is default.
(loop for i from 20 downto 10 collect i)

;; simply repeat
(loop repeat 3 do (format t "good"))

;;;; looping over collection and packages (for each)
;; Only two prepositional phrases:
;;  :in
;;  :on

;; :in iter over a list
(loop for i in (loop for i from 0 to 10 collect i) by #'cddr collect i)
(loop for i in (loop for i from 0 to 30 collect i) by #'cdddr collect i)
(loop for i in (loop for i from 0 to 100 collect i)
      by (lambda (x) (cdddr (cdddr x)))
      collect i)

;; :on step over con cell. it's like scandl (:) []
(loop for x on '(10 20 30 40 50) collect x)
(loop for x on '(10 20 30 40 50) by #'cddr collect x)

;; looping over vector uses different keywords somehow
(loop for x across "abcd" collect x)
(loop  for x across #(1 2 3 4 5) collect x)

;; looping over hashtable
(let ((table (make-hash-table)))
  (setf (gethash 'a table) 1)
  (setf (gethash 'b table) 2)
  (setf (gethash 'c table) 3)
  (loop for k being the hash-keys in table using (hash-value v) do
        (format t "~a ~a / " k v)))

;;;; Equal then iteration
;; : init-form
;; : then-step

;; be careful about the order.

;; here y uses the value of x from the last iteration.
;; x y
;; 0 1
;; 1 2
;; 2 4
(loop repeat 5
      for x = 0 then y
      for y = 1 then (+ x y)
      collect y)

(loop repeat 5
      for y = 1 then (+ x y)
      for x = 0 then y
      collect y)

;; here y uses the value of x at current iteration
(loop repeat 5
      for x = 0 then y
      and y = 1 then (+ x y)
      collect y)

;;;; local variables

(loop for x upto 3
      with foo = :foo
      and bar = :bar
      collect (list x foo bar))

(loop for x upto 3
      with foo = :foo
      with bar = :bar
      collect (list x foo bar))

;;; destructring variables

;; accetps destructuring binding
(loop for (a b) in '((1 2) (3 4) (5 6)) collect (+ a b))

;; accepts dotted list.
(loop for (item . rest) on '(1 2 3 4 5 6) do
      (format t "~a ~A ~%" item rest))

(loop for cons on '(1 2 3 4 5 6) do
      (format t "~a" (car cons)) when (cdr cons) do
      (format t ", "))
;; above is the same as this
(loop for (item . rest) on '(1 2 3 4 5 6)
      do (format t "~a" item)
      when rest do (format t ", "))     ;; don't add , after nil.

;;;; value accumulation clause

(let ((randomlist (loop repeat 100 collect (random 10000))))
  (loop for i in randomlist
        counting (evenp i) into evens
        counting (oddp i) into odds
        summing i into total
        maximizing i into max
        minimizing i into min
        finally (return (list min max total evens odds))))

(defun primep (x)
  (let ((r (floor (sqrt x)))
        (isprime t))
       (if (< x 2)
           nil
           (loop for i from 2 to r do
                 (when (= 0 (mod x i))
                       (setf isprime nil))))
       isprime))

(defun primep (x)
  (let ((r (floor (sqrt x)))
        (isprime t))
       (if (< x 2)
           nil
           (loop for i from 2 to r do
                 (when (= 0 (mod x i))
                       (setf isprime nil))))
       isprime))

(let ((randomlist (loop repeat 100 collect (random 10000))))
  (loop for i in randomlist
        count (evenp i) into evens
        count (oddp i) into odds
        count (primep i) into primes
        sum i into total
        maximize i into max
        minimize i into min
        finally (return (list :evens evens
                              :odds odds
                              :primes primes
                              :total total
                              :max max
                              :min min))))

; side: return ==  (return-from nil)
(block nil (return) 1)
(block nil (return 1) 2)
(block alpha (block nil (return 1)) 2) ; return from nil and execute alpha

;;;; unconditional execution
;; return clauses (different from return and return-from
; break out of a loop with return
(block outer
       (loop for i from 0 return 100)
       (print "print this")
       200) ; => 100

(block outer
       (loop for i from 0 do (return-from outer 100))   ;; return from outer block
       (print "print this")
       200) ; => 200

(block outer
       (loop for i from 0 to 100 do
             (when (>= i 20)
                 (return-from outer i)))
       (print "print this")
       200) ; => 20

;;;; conditional executin

;; this can be written as
(loop for i from 1 to 10 do (when (evenp i) (print i)))
;; this
(loop for i from 1 to 10 when (evenp i) sum i)

;; the return when i > 20 loop can also be written like this
(block outer
       (return-from outer (loop for i from 0 to 200 when (>= i 20) return i))
       (print "print this"))

;;;; use it to refer to selected value
(let ((table (make-hash-table)))
  (setf (gethash 'a table) 1)
  (setf (gethash 'b table) 2)
  (setf (gethash 'e table) 3)
  (loop for key in '(a b c d e) when (gethash key table) collect it))

;;;; loop blac belt. It's really a dsl if you look at it now...
;; it has value binding
;; it has loop (the whole thing is a loop
;; it has conditional (complicated control flow, even goto)
;; it can combine multiple expression together
;; it's just another language live in common lisp standard, as template to c++.
(loop for i from 1 to 100
      if (evenp i)
      minimize i into min-even and
      maximize i into max-even and
      unless (zerop (mod i 4))
      sum i into even-not-fours-total
      end
      and sum i into even-total
      else
      minimize i into min-odd and
      maximize i into max-odd and
      when (zerop (mod i 5))
      sum i into fives-total
      end
      and sum i into odd-total
      do (return (list min-even
                        max-even
                        min-odd
                        max-odd
                        even-total
                        odd-total
                        fives-total
                        even-not-fours-total)))

;; loop setting up and tear down.
;; use initially and finally set up and tear down states for the loop.


;; termination test
;; :termination clauses while, until always never thereis
;; these clauses  decide when to exit a loop

(if (loop for n in '(2 2 2 4 5 6) always (evenp n) do ;; will only loop 4 times
          (prin1 "looping"))
    (print "all even"))

(if (loop for n in (loop for i from 0 to 10 by 2 collect i) never (oddp n))
    (print "all even")u)

;; check if there exists
(loop for char across "abcdef" thereis (digit-char-p char))
(loop for char across "abc1ef" thereis (digit-char-p char))


;;;; Conclusion
;; loop clauses structure
;; 1. name clause with
;; 2. general control clauses (initally, with, for repeat)
;; 3. body clauses (conditional/unconditional clauses, accumulation, termination test)
;; 4. end with finally
;; chapter 7, some constructs
;; show the side effect.
(defmacro show (val)
  `(progn
     (format t "before: ~a~%" x)
     ,val
     (format t "after: ~a~%~%" x) nil))

;; our own progn
;; evaluate first n-1 forms, and return the last one.
(defun my-progn (&rest forms)
  (subseq forms (1- (length forms)))
  (car (last forms)))

(defun use-progn (bool)
  (let* ((x 10)
         (y 20))
    (if bool
        (progn
          (show (setf x (1+ x)))
          (show (incf x))
          (show (rotatef x y))
          (show (shiftf y x 100))))))

(defmacro my-when (condition &rest body)
  `(if ,condition (progn ,@body)))

(defmacro my-unless (condition &rest body)
  `(if (not ,condition) (progn ,@body)))

;; traverse_ on a list
(defun play-dolist ()
  (dotimes (x 10) (format t "from do time: ~a~%" x))
  (dolist (x '(1 3 5 7 8 9 11 13))
    (format t "from do list: ~a~%" x)
    (if (evenp x) (return)))) ; return break out of the loop

(defun make-id-square-matrix (n)
  (dotimes (x n)
    (dotimes (y n)
      (let ((val (if (= x y) 1 0)))
        (format t "~a " val)))
    (format t "~%")))

(defun make-caley-table (as op)
  (dolist (x as)
    (dolist (y as)
      (format t "~a " (funcall op x y)))
    (format t "~%")))

(defun mod-add-n (x y n) (mod (+ x y) n))

(defun range (n) (loop for i from 0 below n by 1 collect i))

(defun make-zn-caley-table (n)
  (make-caley-table (range n) (lambda (x y) (mod-add-n x y n))))

;; (do (variable definition) (end-test-form result form) statements)
;; n: 0 cur: 0 next: 1
;; n: 1 cur: 1 next: 1
;; n: 2 cur: 1 next: 2
;; n: 3 cur: 2 next: 3
;; n: 4 cur: 3 next: 5
;; n: 5 cur: 5 next: 8
;; n: 6 cur: 8 next: 13
;; n: 7 cur: 13 next: 21
;; n: 8 cur: 21 next: 34
;; n: 9 cur: 34 next: 55
;; 55
(defun play-do-1-fib ()
  (do ((n 0 (1+ n)) ; (var init-form step-form)
       (cur 0 next)
       (next 1 (+ cur next)))
      ((= 10 n) cur)
      (format t "n: ~a cur: ~a next: ~a ~%" n cur next)))

;; be careful that all binding in the step form will
;; use the value from the last step.
(defun fib (n)
  (do ((i 0 (1+ i))             ; couter
       (cur 0 next)             ; cur is previous of next
       (next 1 (+ cur next)))   ; new next is cur + next
      ((= n i) cur)))

(defun play-do-2 ()
  (do ((i 0 (1+ i)))    ; step fun
      ((>= i 4))        ; end test form
      (print i)))


;: mighty loop
;: simple loop, it's just an infinite loop
(defun loopy ()
  (let ((ti (+ 3 (get-universal-time))))
    (loop
      (when (> (get-universal-time) ti)
        (return))
      (format t "Waiting ~%")
      (sleep 1))))

;; loop on list and perform arbitrary statements.
(defun loop-and-do ()
  (loop for i from 1 to 10
        do (print i)))

;; extended loop

;; these two do the same thing
;; so lisp do is basically a mutation based loop
;; structure.
(defun do-and-loop ()
  (do ((nums nil)   ; mutation right there ew.
       (i 1 (1+ i)))
      ((> i 10) (reverse nums))
      (push i nums))
  (loop for i from 1 to 10 collecting i))

;; you have different semantics for loop...
(defun loop-de-loop () (loop for i from 1 to 10 collecting i))

(defun loop-de-loop-1 ()
  (loop for x from 1 to 10 summing (expt x 2)))

;; how many vows are there?
(defun loop-de-loop-2 ()
  (loop for x across "the quick brown fox jumps over the lazy dog"
        counting (find x "aeiou")))

;; it's the same as fib
(defun loop-de-loop-3-fib (n)
  (loop for i below n
        and a = 0 then b
        and b = 1 then (+ b a)
        finally (return a)))

;; chapter 8
(defun primep (number)
  (when (> number 1)
    (loop for fac from 2 to (isqrt number)
          never (zerop (mod number fac)))))

(defun next-prime (number)
  (loop for n from number when (primep n) return n))

;; backquote is nice, you can write the code without
;; quote everything.
(defmacro do-primes-1 ((var start end) &body body)
  `(do ((,var (next-prime ,start)
              (next-prime (1+ ,var))))
       ((> ,var ,end))
       ,@body))

;; an comparison between quotes and backquotes.

(defun quotes-and-backquotes ()
  (let ((a (lambda (x y) (+ x y)))
        (c 10))
    (list
      `(a (+ 1 2) c)
      (list 'a '(+ 1 2) 'c))
    (list
      `(a ,(+ 1 2) c)
      (list 'a (+ 1 2) c))
    (list
      `(a (list 1 2) c)
      (list 'a '(list 1 2) 'c))))

;; don't write leaky abstraction!
;; 1. use gensym to generate unique symbol.
;; 2. make sure only evaluate each subform once.
;; 3. make evaluation order the same as the parameter order.

(defmacro do-primes-2 ((var start end) &body body)
  (let ((end-value (gensym)))
    `(do ((,var (next-prime ,start)
                (next-prime (1+ ,var)))
          (,end-value ,end))
         ((> ,var ,end-value)) ,@body)))

;; macro writing macro
(defmacro with-gensyms ((&rest names) &body body)
  `(let ,(loop for n in names collect `(,n (gensym))) ,@body))

(defmacro do-primes-with-gensyms ((var start end) &body body)
  (with-gensyms (end-value)
    `(do ((,var (next-prime ,start)
                (next-prime (1+ ,var)))
          (,end-value ,end))
         ((> ,var ,end-value))
         ,@body)))

;; common macro helps you to evaluate a symbol only once.
;; multiple layers because once-only is a macro itself so
;; it needs to be hygenic for itself too.
(defmacro once-only ((&rest names) &body body)
  ;; generate unique symbols for each name
  (let ((gensyms (loop for n in names collect (gensym))))
    ;;
    `(let (,@(loop for g in gensyms collect `(,g (gensym))))
       `(let (,,@(loop for g in gensyms
                       for n in names collect ``(,,g ,,n)))
          ,(let (,@(loop for n in names
                         for g in gensyms collect `(,n ,g)))
             ,@body)))))

;; with once only things get much simler.
(defmacro do-primes ((var start end) &body body)
  (once-only (start end)
    `(do ((,var (next-prime ,start) (next-prime (1+ ,var))))
     ((> ,var ,end))
     ,@body)))
;; chapter 7, some constructs

;; show the side effect.
(defmacro show (val)
  `(progn
     (format t "before: ~a~%" x)
     ,val
     (format t "after: ~a~%~%" x) nil))

;; our own progn
;; evaluate first n-1 forms, and return the last one.
(defun my-progn (&rest forms)
  (subseq forms (1- (length forms)))
  (car (last forms)))

(defun use-progn (bool)
  (let* ((x 10)
         (y 20))
    (if bool
        (progn
          (show (setf x (1+ x)))
          (show (incf x))
          (show (rotatef x y))
          (show (shiftf y x 100))))))


(defmacro my-when (condition &rest body)
  `(if ,condition (progn ,@body)))

(defmacro my-unless (condition &rest body)
  `(if (not ,condition) (progn ,@body)))


;; note backquotes ` are just short hand for creating list.
;; everything you write under defmacro will be executed at the
;; compile time, and the returned list will be inserted into the AST.
(defmacro set-them-* (a b) (list 'setf a 10 b 20))
(defmacro set-them (a b) `(setf a 10 b 20))

;; traverse_ on a list
(defun play-dolist ()
  (dotimes (x 10) (format t "from do time: ~a~%" x))
  (dolist (x '(1 3 5 7 8 9 11 13))
    (format t "from do list: ~a~%" x)
    (if (evenp x) (return)))) ; return break out of the loop

(defun make-id-square-matrix (n)
  (dotimes (x n)
    (dotimes (y n)
      (let ((val (if (= x y) 1 0)))
        (format t "~a " val)))
    (format t "~%")))

(defun make-caley-table (as op)
  (dolist (x as)
    (dolist (y as)
      (format t "~a " (funcall op x y)))
    (format t "~%")))

(defun mod-add-n (x y n) (mod (+ x y) n))

(defun range (n) (loop for i from 0 below n by 1 collect i))

(defun make-zn-caley-table (n)
  (make-caley-table (range n) (lambda (x y) (mod-add-n x y n))))

;; (do (variable definition) (end-test-form result form) statements)
;; n: 0 cur: 0 next: 1
;; n: 1 cur: 1 next: 1
;; n: 2 cur: 1 next: 2
;; n: 3 cur: 2 next: 3
;; n: 4 cur: 3 next: 5
;; n: 5 cur: 5 next: 8
;; n: 6 cur: 8 next: 13
;; n: 7 cur: 13 next: 21
;; n: 8 cur: 21 next: 34
;; n: 9 cur: 34 next: 55
;; 55
(defun play-do-1-fib ()
  (do ((n 0 (1+ n)) ; (var init-form step-form)
       (cur 0 next)
       (next 1 (+ cur next)))
      ((= 10 n) cur)
      (format t "n: ~a cur: ~a next: ~a ~%" n cur next)))

;; be careful that all binding in the step form will
;; use the value from the last step.
(defun fib (n)
  (do ((i 0 (1+ i))             ; couter
       (cur 0 next)             ; cur is previous of next
       (next 1 (+ cur next)))   ; new next is cur + next
      ((= n i) cur)))

(defun play-do-2 ()
  (do ((i 0 (1+ i)))    ; step fun
      ((>= i 4))        ; end test form
      (print i)))


;: mighty loop
;: simple loop, it's just an infinite loop
(defun loopy ()
  (let ((ti (+ 3 (get-universal-time))))
    (loop
      (when (> (get-universal-time) ti)
        (return))
      (format t "Waiting ~%")
      (sleep 1))))

;; loop on list and perform arbitrary statements.
(defun loop-and-do ()
  (loop for i from 1 to 10
        do (print i)))

;; extended loop

;; these two do the same thing
;; lisp do is basically a mutation based loop
;; structure.
(defun do-and-loop ()
  (do ((nums nil)   ; mutation right there ew.
       (i 1 (1+ i)))
      ((> i 10) (reverse nums))
      (push i nums))
  (loop for i from 1 to 10 collecting i))

;; you have different semantics for loop...
(defun loop-de-loop () (loop for i from 1 to 10 collecting i))

(defun loop-de-loop-1 ()
  (loop for x from 1 to 10 summing (expt x 2)))

;; how many vows are there?
(defun loop-de-loop-2 ()
  (loop for x across "the quick brown fox jumps over the lazy dog"
        counting (find x "aeiou")))

;; it's the same as fib
(defun loop-de-loop-3-fib (n)
  (loop for i below n
        and a = 0 then b
        and b = 1 then (+ b a)
        finally (return a)))

;; chapter 8
(defun primep (number)
  (when (> number 1)
    (loop for fac from 2 to (isqrt number)
          never (zerop (mod number fac)))))

(defun next-prime (number)
  (loop for n from number when (primep n) return n))

;; backquote is nice, you can write the code without
;; quote everything.
(defmacro do-primes-1 ((var start end) &body body)
  `(do ((,var (next-prime ,start)
              (next-prime (1+ ,var))))
       ((> ,var ,end))
       ,@body))

;; an comparison between quotes and backquotes.

(defun quotes-and-backquotes ()
  (let ((a (lambda (x y) (+ x y)))
        (c 10))
    (list
      `(a (+ 1 2) c)
      (list 'a '(+ 1 2) 'c))
    (list
      `(a ,(+ 1 2) c)
      (list 'a (+ 1 2) c))
    (list
      `(a (list 1 2) c)
      (list 'a '(list 1 2) 'c))))

;; don't write leaky abstraction!
;; 1. use gensym to generate unique symbol.
;; 2. make sure only evaluate each subform once.
;; 3. make evaluation order the same as the parameter order.

(defmacro do-primes-2 ((var start end) &body body)
  (let ((end-value (gensym)))
    `(do ((,var (next-prime ,start)
                (next-prime (1+ ,var)))
          (,end-value ,end))
         ((> ,var ,end-value)) ,@body)))

;; macro writing macro
(defmacro with-gensyms ((&rest names) &body body)
  `(let ,(loop for n in names collect `(,n (gensym))) ,@body))

(defmacro do-primes-with-gensyms ((var start end) &body body)
  (with-gensyms (end-value)
    `(do ((,var (next-prime ,start)
                (next-prime (1+ ,var)))
          (,end-value ,end))
         ((> ,var ,end-value))
         ,@body)))

;; common macro helps you to evaluate a symbol only once.
;; multiple layers because once-only is a macro itself so
;; it needs to be hygenic for itself too.
(defmacro once-only ((&rest names) &body body)
  ;; generate unique symbols for each name
  (let ((gensyms (loop for n in names collect (gensym))))
    ;;
    `(let (,@(loop for g in gensyms collect `(,g (gensym))))
       `(let (,,@(loop for g in gensyms
                       for n in names collect ``(,,g ,,n)))
          ,(let (,@(loop for n in names
                         for g in gensyms collect `(,n ,g)))
             ,@body)))))

;; with once only things get much simler.
(defmacro do-primes ((var start end) &body body)
  (once-only (start end)
    `(do ((,var (next-prime ,start) (next-prime (1+ ,var))))
     ((> ,var ,end))
     ,@body)))
;; common lisp package system is based on symbols
;; a name with : in the middle is interpreted as a qualified name,
;; and the common lisp reader will separate the name and use the first
;; part as the pacakge name, the second part as the function name.

;; symbols are real data structures, and it's also the text used by the
;; s-expression. You can use symbols to construct a piece of textual form
;; of common lisp code and evaluate it as it's a real code.

;; A lisp form is a piece of s-expression to be evaluated.
;; when you evaluate a symbol as lisp form it means you are trying to
;; evaluate whatever form associated with that symbol.

;; to assoicate a symbol with other lisp forms, say a macro, you need to
;; first generate a string as the name of the symbol, then genrate the symbol
;; from the string.

;; to intern a symbol
;; intern will take the string and check if the name already exists in the
;; current pacakge. If it does, it will create and add a new symbol into the package.
(intern "bar")

(eql ':foo :foo) ;; => t
(symbol-name :foo)  ;; => "FOO"

;; You can also have unintended symbol. which each time you read the symbol
;; it will be a new symbol (like gensym)
(eql '#:foo '#:foo) ;; => nil
(gensym)

(defpackage "SAMPLE-PACKAGE"
  (:use "COMMON-LISP")
  (:export :hello-world
           :good-day))

;; bring you to sample-package namespace
(in-package :sample-package)

(intern "hello-world")
(defun hello-world ()
  (format t "hello world ~%"))

(defun good-day ()
  (format t "good day mate ~%"))

; read time conditionalizatio

(defun foo ()
  #+allegro (print "allegro")
  #+sbcl (print "sbcl")
  #+clisp (print "clisp")
  #+cmu (print "cmu")
  #- (or allegro sbcl clisp cmu) (error "not implemented"))

(defun component-present-p (value)
  (and value (not (eql value :unspecific))))

(defun directory-path-p (p)
  (and
    (not (component-present-p (pathname-name p)))
    (not (component-present-p (pathname-name p)))
    p))

(defun pathname-as-directory (name)
  (let ((pathname (pathname name)))
    (when (wile-pathname-p pathname)
      (error "Can't reliably convert wild pathnames"))
    (if (not (directory-path-p name))
        (make-pathname
          :directory (append (or (pathname-directory pathname)
                                 (list :relative))
                             (list (file-namestring pathname)))
          :name nil
          :type nil
          :defaults pathname)
        pathname)))
(in-package :cl-user) ;; use cl namespace

(defpackage :pathnames
  (:use :common-lisp)   ;; only uses common lisp standard lib
  (:export
    :list-directory
    :file-exists-p
    :directory-pathname-p
    :file-pathname-p
    :pathname-as-directory
    :pathname-as-file
    :walk-directory
    :directory-p
    :file-p
    :parent-directory))

(in-package :pathnames)

(defun list-directory (dirname)
  "Return a list of the contents of the directory named by dirname.
Names of subdirectories will be returned in `directory normal
form'. Unlike CL:DIRECTORY, LIST-DIRECTORY does not accept
wildcard pathnames; `dirname' should simply be a pathname that
names a directory. It can be in either file or directory form."
  (when (wild-pathname-p dirname)
    (error "Can only list concrete directory names."))

  (let ((wildcard (directory-wildcard dirname)))

    #+(or sbcl cmu lispworks)
    ;; SBCL, CMUCL, and Lispworks return subdirectories in directory
    ;; form just the way we want.
    (directory wildcard)

    #+openmcl
    ;; OpenMCl by default doesn't return subdirectories at all. But
    ;; when prodded to do so with the special argument :directories,
    ;; it returns them in directory form.
    (directory wildcard :directories t)

    #+allegro
    ;; Allegro normally return directories in file form but we can
    ;; change that with the :directories-are-files argument.
    (directory wildcard :directories-are-files nil)

    #+clisp
    ;; CLISP has a particularly idiosyncratic view of things. But we
    ;; can bludgeon even it into doing what we want.
    (nconc
     ;; CLISP won't list files without an extension when :type is
     ;; wild so we make a special wildcard for it.
     (directory wildcard)
     ;; And CLISP doesn't consider subdirectories to match unless
     ;; there is a :wild in the directory component.
     (directory (clisp-subdirectories-wildcard wildcard)))

    #-(or sbcl cmu lispworks openmcl allegro clisp)
    (error "list-directory not implemented")))



(defun file-exists-p (pathname)
  "Similar to CL:PROBE-FILE except it always returns directory names
in `directory normal form'. Returns truename which will be in
`directory form' if file named is, in fact, a directory."

  #+(or sbcl lispworks openmcl)
  ;; These implementations do "The Right Thing" as far as we are
  ;; concerned. They return a truename of the file or directory if it
  ;; exists and the truename of a directory is in directory normal
  ;; form.
  (probe-file pathname)

  #+(or allegro cmu)
  ;; These implementations accept the name of a directory in either
  ;; form and return the name in the form given. However the name of a
  ;; file must be given in file form. So we try first with a directory
  ;; name which will return NIL if either the file doesn't exist at
  ;; all or exists and is not a directory. Then we try with a file
  ;; form name.
  (or (probe-file (pathname-as-directory pathname))
      (probe-file pathname))

  #+clisp
  ;; Once again CLISP takes a particularly unforgiving approach,
  ;; signalling ERRORs at the slightest provocation.

  ;; pathname in file form and actually a file      -- (probe-file file)      ==> truename
  ;; pathname in file form and doesn't exist        -- (probe-file file)      ==> NIL
  ;; pathname in dir form and actually a directory  -- (probe-directory file) ==> truename
  ;; pathname in dir form and doesn't exist         -- (probe-directory file) ==> NIL

  ;; pathname in file form and actually a directory -- (probe-file file)      ==> ERROR
  ;; pathname in dir form and actually a file       -- (probe-directory file) ==> ERROR
  (or (ignore-errors
        ;; PROBE-FILE will return the truename if file exists and is a
        ;; file or NIL if it doesn't exist at all. If it exists but is
        ;; a directory PROBE-FILE will signal an error which we
        ;; ignore.
        (probe-file (pathname-as-file pathname)))
      (ignore-errors
        ;; PROBE-DIRECTORY returns T if the file exists and is a
        ;; directory or NIL if it doesn't exist at all. If it exists
        ;; but is a file, PROBE-DIRECTORY will signal an error.
        (let ((directory-form (pathname-as-directory pathname)))
          (when (ext:probe-directory directory-form)
            directory-form))))


    #-(or sbcl cmu lispworks openmcl allegro clisp)
    (error "file-exists-p not implemented"))

(defun directory-wildcard (dirname)
  (make-pathname
   :name :wild
   :type #-clisp :wild #+clisp nil
   :defaults (pathname-as-directory dirname)))

#+clisp
(defun clisp-subdirectories-wildcard (wildcard)
  (make-pathname
   :directory (append (pathname-directory wildcard) (list :wild))
   :name nil
   :type nil
   :defaults wildcard))


(defun directory-pathname-p (p)
  "Is the given pathname the name of a directory? This function can
usefully be used to test whether a name returned by LIST-DIRECTORIES
or passed to the function in WALK-DIRECTORY is the name of a directory
in the file system since they always return names in `directory normal
form'."
  (flet ((component-present-p (value)
           (and value (not (eql value :unspecific)))))
    (and
     (not (component-present-p (pathname-name p)))
     (not (component-present-p (pathname-type p)))
     p)))


(defun file-pathname-p (p)
  (unless (directory-pathname-p p) p))

(defun pathname-as-directory (name)
  "Return a pathname reperesenting the given pathname in
`directory normal form', i.e. with all the name elements in the
directory component and NIL in the name and type components. Can
not be used on wild pathnames because there's not portable way to
convert wildcards in the name and type into a single directory
component. Returns its argument if name and type are both nil or
:unspecific."
  (let ((pathname (pathname name)))
    (when (wild-pathname-p pathname)
      (error "Can't reliably convert wild pathnames."))
    (if (not (directory-pathname-p name))
      (make-pathname
       :directory (append (or (pathname-directory pathname) (list :relative))
                          (list (file-namestring pathname)))
       :name      nil
       :type      nil
       :defaults pathname)
      pathname)))

(defun pathname-as-file (name)
  "Return a pathname reperesenting the given pathname in `file form',
i.e. with the name elements in the name and type component. Can't
convert wild pathnames because of problems mapping wild directory
component into name and type components. Returns its argument if
it is already in file form."
  (let ((pathname (pathname name)))
    (when (wild-pathname-p pathname)
      (error "Can't reliably convert wild pathnames."))
    (if (directory-pathname-p name)
      (let* ((directory (pathname-directory pathname))
             (name-and-type (pathname (first (last directory)))))
        (make-pathname
         :directory (butlast directory)
         :name (pathname-name name-and-type)
         :type (pathname-type name-and-type)
         :defaults pathname))
      pathname)))

(defun walk-directory (dirname fn &key directories (test (constantly t)))
  "Walk a directory invoking `fn' on each pathname found. If `test' is
supplied fn is invoked only on pathnames for which `test' returns
true. If `directories' is t invokes `test' and `fn' on directory
pathnames as well."
  (labels
      ((walk (name)
         (cond
           ((directory-pathname-p name)
            (when (and directories (funcall test name))
              (funcall fn name))
            (dolist (x (list-directory name)) (walk x)))
           ((funcall test name) (funcall fn name)))))
    (walk (pathname-as-directory dirname))))

(defun directory-p (name)
  "Is `name' the name of an existing directory."
  (let ((truename (file-exists-p name)))
    (and truename (directory-pathname-p name))))

(defun file-p (name)
  "Is `name' the name of an existing file, i.e. not a directory."
  (let ((truename (file-exists-p name)))
    (and truename (file-pathname-p name))))

(defun parent-directory (pathname)
  "Return the pathname of the directory containing pathname."
  (make-pathname :name nil :type nil :defaults (pathname-as-file pathname)))
;; bayesian spam filter.
(in-package :cl-user)

(defpackage :spam-filter
  (:nickname :spam-filter)
  (:use :common-lisp
        :com.ailrk.pathnames
        :com.ailr.utilities)
  (:export
   :make-feature-database
   :clear-database
   :intern-feature
   :train
   :untrain
   :classify
   :all-features
   :freature-spamminess
   :id
   :hams
   :spams))
;;; early chapters

(defun make-row (title artist rating ripped)
  (list :title title :artist artist :rating rating :ripped ripped))

;;; *xx* is the name convention for global variables
(defvar *db* nil)
(setf *db* nil)

(defun add-record (row) (push row *db*))

;;; format: ~a  :  aesthetic directive
;;;         ~10t:  10 space
;;;         ~%  :  emit 1 new line
;;;         ~{ }~ : process format string multiple times
(defun dump-record ()
  (dolist (row *db*)
    (format t "~5tCD Records~%~{~a:~10t~a~%~}~%" row)))

(defun prompt-read (prompt)
  (format *query-io* "~a: " prompt)
  (force-output *query-io*) ;
  (read-line *query-io*))

(defun prompt-for-row ()
  (make-row
    (prompt-read "Title")
    (prompt-read "Artist")
    (or (parse-integer (prompt-read "Rating") :junk-allowed t) 0)
    (y-or-n-p "Ripped")))

(add-record (make-row "sunny" "potsu" 100 t))
(add-record (make-row "banana with nuts" "potsu" 100 nil))
(add-record (make-row "bossa uh" "potsu" 100 t))
(add-record (make-row "misty" "ella fizgerald" 100 nil))
(add-record (make-row "ain't misbehavin" "joe pass" 100 nil))

(defun add-rows ()
  (loop (add-record (prompt-for-row))
        (if (not (y-or-n-p "Another? [y/n]: ")) (return))))

(defun save-db (filename)
  (with-open-file (out filename
                       :direction :output
                       :if-exists :supersede)
    (with-standard-io-syntax (print *db* out))))

(defun load-db (filename)
  (with-open-file (in filename
                      :direction :input)     ; default is reading
    (with-standard-io-syntax
      (setf *db* (read in)))))

;;; keyword parameter and supplied-p
(defun select (selector-fn)
  (remove-if-not selector-fn *db*))

;;; to build a list pass symbols, this stop lisp from evaluating.
(defun make-comparison-expr-old (field value)
  (list 'equal (list 'getf 'row field) value))

;;; with quasi quotes
(defun make-row-expr (op row field value)
  `(,op (getf ,row ,field) ,value))

(defun make-comparison-expr (field value)
  (make-row-expr 'equal 'row field value))

(defun make-comparison-list (records)
  (loop while records
        collecting (make-comparison-expr (pop records) (pop records))))

;;; &rest makes the function varadic
(defmacro where (&rest clauses)
  `(lambda (row) (and ,@(make-comparison-list clauses))))

(defun make-update-expr (field value)
  (make-row-expr 'setf 'row field value))

(defun make-update-expr-list (records)
  (loop while records
        collecting (make-update-expr (pop records) (pop records))))

;;; (update (where :title "misty") :title "Misty" :rating 101)
(defmacro update (selector-fn &rest clauses)
  `(setf *db* (mapcar
                (lambda (row)
                  (when (funcall ,selector-fn row)
                    ,@(make-update-expr-list clauses)) row)
                *db*)))

(defun delete-rows (selector-fn)
  (setf *db* (remove-if selector-fn *db*)))
;; use labels to define local recursive function
(defun collect-leaves (tree)
  (let ((leavse ()))
    (labels ((walk (tree)
               (cond
                 ((null tree))
                 ((atom tree) (push tree leaves))
                 (t (walk (car tree))
                  (walk (cdr tree))))))
      (walk tree))
    (nreverse leaves)))

;; tagbody and goto
(let ((x 10))
     (tagbody
      top
      (decf x)
      (print "hello")
      (if (> x 0) (go top))))

;; return from with a named function
(defun fooi (x)
  (print "good")
  (return-from foo t)
  nil)

;; return to named block
(block b
       (print "here")
       (return-from b)
       (print "after"))

;; return to nil block
(block nil
  (print "here")
  (return)
  (prin1 "after"))

;; jump around
(tagbody
  a (print 'a) (if (zerop (random 2)) (go c))
  b (print 'b) (if (zerop (random 2)) (go a))
  c (print 'c) (if (zerop (random 2)) (go b)))

;; knuth's algorithm-s
(defun algorithm-s* (n max)
  (let (seen
        selected
        u
        (records ()))
       (tagbody
        s1
        (setf seen 0)
        (setf elected 0)
        s2
        (setf u (random 1.0))
        s3
        (when (>= (* (- max seen) u) (- n selected)) (go s5))
        s4
        (push seen records)
        (incf selected)
        (incf seen)
        (if (< selected n)
            (go s2)
            (return-from algorithm-s* (nreverse records)))
        s5
        (incf seen)
        (go s2))))

(defun algorithm-s (n max)
  (loop for seen from 0
        when (< (* (- max seen) (random 1.0)) n)
        collect seen and do (decf n)
        until (zerop n)))

;; unwinding the stack
(defun baz (fn)
  (format t " Entering baz~%")
  (funcall fn)
  (format t " Leaving baz~%"))

(defun bar (fn)
  (format t " Entering bar~%")
  (baz fn)
  (format t " Leaving bar~%"))

(defun foo ()
  (format t " Entering foo~%")
  (block a
         (format t " Entering Block~%")
         (bar (lambda () (return-from a)))
         (format t " Leaving Block ~%"))
  (format t " Leaving foo~%"))

;; result:
;  Entering Block
;  Entering bar
;  Entering baz
;  Leaving foo
;; The stack is unwind once you call return-from, and
;; everything after that block get discarded.

;; unwind-protect makes sure certain code always run even
;; if there is a stack unwinding.
;; (unwind-protect protected-form cleanup-form)

;; + just discard multivalue
(funcall #'+ (values 2 3) (values 4 5))

;; will treat everything as a list
(multiple-value-call #'+ (values 1 2) (values 3 4))

(multiple-value-bind (x y) (floor 30 20)
  (+ x y))

;; value-list is the inverse of the value list.

;;;; Eval when
;; control when a

;; load and compile-file
;; load: laod all top levle forms. The order of side effects will affect
;; subsequent loading.
;; compile-file: compile file into fasl, usually doesn't load, only load case
;; of keeping consistentcy

(defparameter *s* "a")
;; this will be load at compile time
(eval-when (:compile-toplevel :load-toplevel :execute)
  (setf *s*  "PP"))
;; chapter 9 test framework

(defvar *test-name* nil)

(defmacro deftest-unit (name parameters &body body)
  `(deftest ,name ,parameters
     (check ,@body)))

(defmacro deftest-suit (name parameters &body body)
  `(deftest ,name ,parameters
     (combine-results ,@body)))

(defmacro deftest (name parameters &body body)
  "define a test function"
  `(defun ,name ,parameters
     (let ((*test-name* (append *test-name* (list ',name))))
       ,@body)))

(defmacro check (&body test-cases)
  "run each test cases"
  `(combine-results
     ,@(loop for f in test-cases collect `(report-result ,f ',f))))

(defmacro combine-results (&body forms)
  "combine the results of evaluating forms in order"
  (with-gensyms (result)
    `(let ((,result t))
       ,@(loop for f in forms collect
               `(unless ,f (setf ,result nil)))
       ,result)))

(defun report-result (result form)
  "report the result of a single test case called by check"
  (format t "~:[FAIL~;pass~] ... ~a: ~a~%"
          result *test-name* form) result)

(defmacro with-gensyms ((&rest names) &body body)
  `(let ,(loop for n in names collect `(,n (gensym))) ,@body))


(deftest-suit test-arithmetics ()
              (test-arithmetics--/)
              (test-arithmetics-+*))


(deftest-suit test-arithmetics--/ ()
  (test--)
  (test-/))

(deftest-suit test-arithmetics-+* ()
  (test-*)
  (test-+))

(deftest-unit test-* ()
  (= (* 2 10) 20)
  (= (* 200 300) 60000))

(deftest-unit test-+ ()
  (= (+ 1 2) 3)
  (= (+ 1 2 3) 6)
  (= (+ 19 20) 38))

(deftest test-- ()
  (check
    (= (- 1 2) -1)
    (= (- 30 2 2) 27)
    (= (- 30 2 2) 26)))

(deftest test-/ ()
  (check
    (= (/ 10 2) 5)
    (= (/ 20 4) 5)))
;; this is actually quite simple.
;; why ppl likes to make it seems so fancy...

;; this is the most primitive form of evaluator.
;; no error checking, no arity checking, nothing.

;; buts this is the core of any list. You can add more
;; features into the evaluators as you want.

;; it's also easy to create programming tools by injecting
;; related code into the evaluator.

(define (evaluate e env)
  (if (atom? e)
      ;;;; environment ;;;;
      ;; programs and there representations are separated.
      ;; like symbols are tangible textual object, but varaible is
      ;; just an imaginary object in our program.
      ;; to look up the value of a variable, we use the equivelent
      ;; symbols as key to search in the environment.
      (cond ((symbol? e) (lookup e env))
            ;;;; autoquotes ;;;;
            ;; It can be hard to determine what does it mean for some
            ;; objects be evaluated. For instance, what does a function
            ;; evaluates to?
            ;; So we only have these clearly defined autoquotes.
            ((or (number? e)
                 (string? e)
                 (char? e)
                 (boolean? e)
                 (vector? e)) e)
            (else (error "Can't evaluate e")))
      (case (car e)
        ;;;; quote (discriminator between data and program) ;;;;
        ;; because we can represent our lisp program in terms of it's value
        ;; (symbols and list), it's necessary to have a tag to tell you
        ;; whether an object is part of the code or it's just value.
        ((quote) (cadr e))                  ;; special forms
        ;;;; meta circular ;;;;
        ;; one thing to note is we are implemeting scheme with scheme,
        ;; so there are a lot of facility can be shared between these two
        ;; implementations.
        ;; For example, we can reuse boolean values from mit-scheme.
        ((if) (if (not (eq? (evaluate (cadr e) env) #f))
                  (evaluate (caddr e) env)
                  (evaluate (cadddr e) env)))
        ((begin) (eprogn (cdr e) env))
        ((set!) (update! (cadr e) (cddr e) env))
        ((lambda) (make-function (cadr e) (cddr e) env))  ;; abstraction
        (else (invoke (evaluate (car e) env) ;; function applicatoin
                      (evlis (cdr e) env))))))

;;;; sequence: putting series of evaluations in order ;;;;
;; in an algol like language it's like your begin ... end block.
;; what you expect is a group of forms be evaluated sequentially,
;; and there side effects are performed sequentially too.
;; or in anoter word, evaluate a list of expressions in order.
(define (eprogn e env)
  (if (pair? e)
      (if (pair? (cdr e))
          (begin (evaluate (car e) env)
                 (eprogn (cdr e) env))
          (evaluate (car e) env))   ;; last return will be this
      '()))

;; this just map evaluate to all elements in e
;; use let here to enforce left to right evaluation.
;; this is not necessary always a good thing, as it impose
;; more restrictoin for a compiler to do some optimizatoin.
(define (evlis e env)
  (if (pair? e)
      (let ((argument1 (evaluate (car e) env)))
       (cons argument1 (evlis (cdr e) env)))
      '()))

;;;; environment will be implemented in association list
(define (loopup id env)
  (if (pair? env)
      (if (eq? (caar env) id)
          (cdar env)
          (lookup id (cdr env)))
      (error "No such binding")))

;; see how we manually mapping stuffs...
(define (update! id env value)
  (if (pair? env)
      (if (eq? (caar env) id)
          (begin (set-cdr! (car env) value) value)
          (update! id (cdr env) value))
      (error "No such binding")))

;; represent function with function. It feels like HOAS.
(define (invoke fn args)
  (if (procedure? fn)
      (fn args)                   ;; think, how to warn the user this error
      (error "Not a function")))  ;; as early as possible?
#lang racket/base
;; <Little_schemer_practice>.

; The First Commandment
; ask null? as the first condition.

; atom? atom checker
(define atom?
  (lambda (x)
    (and
      (not (null? x))
      (not (pair? x)))))

; lat? list atom checker
(define lat?
  (lambda (l)
    (cond
      ((null? l) #t)
      ((atom? (car l)) (lat? (cdr l)))
      (else #f))))

; member? check if atom is a member of a list
(define member?
  (lambda (a lat)
    (cond
      ((null? lat) #f)
      (else (or (equal/s (car lat) a)
                (member? a (cdr lat)))))))

; The second Commandment
; use cons to build lists

; remove a member
(define rember
  (lambda (a lat)
    (cond
      ((null? lat) '())
      ((eq? a (car lat)) (cdr lat))
      (else
        (cons (car lat)
              (rember a (cdr lat)))))))

; get first s-expr of a list with () or non empty lists
; ((a b) (c d) (e f)) -> (a c e)
(define firsts
  (lambda (l)
    (cond
      ((null? l) '())
      (else (cons (car (car l))
                  (firsts (cdr l)))))))

; insert new value to the right of old value.
(define insertR
  (lambda (new old lat)
    (cond
      ((null? lat) '())
      (else (cond
              ((eq? (car lat) old)
               (cons old
                     (cons new (cdr lat))))
              (else (cons (car lat)
                          (insertR new old (cdr lat)))))))))

(define insertL
  (lambda (new old lat)
    (cond
      ((null? lat) '())
      (else (cond
              ((eq? (car lat) old) (cons new lat))
              (else (cons (car lat)
                          (insertL new old (cdr lat)))))))))

; The Third  Commandment
; when building a list, describe the first typical element,
; then cons it into the natural recursion.

; substitute the first occurance.
(define subst
  (lambda (new old lat)
    (cond
      ((null? lat) '())
      (else (cond
              ((eq? (car lat) old) (cons new (cdr lat)))
              (else (cons (car lat)
                          (subst new old (cdr lat)))))))))

; sub one of the give old value.
(define subst2
  (lambda (new o1 o2 lat)
    (cond
      ((null? lat) '())
      (else (cond
              ((or (eq? o1 (car lat))
                   (eq? o2 (car lat)))
                   (cons new (cdr lat)))
              (else (cons (car lat)
                          (subst2 new o1 o2 (cdr lat)))))))))

; remove all occurance of a in lat
(define multirember
  (lambda (a lat)
    (cond
      ((null? lat) '())
      (else (cond
              ((equal/s (car lat) a) (multirember a (cdr lat)))
              (else (cons (car lat)
                          (multirember a
                                       (cdr lat)))))))))

(define multiinsertR
  (lambda (new old lat)
    (cond
      ((null? lat) '())
      ((eq? old (car lat))
       (cons old
             (cons new
                   (multiinsertR new old (cdr lat)))))
      (else
        (cons (car lat) (multiinsertR new old (cdr lat)))))))

; The fourth Commandment
; always change at least one argument while recuring.

(define multiinsertL
  (lambda (new old lat)
    (cond
      ((null? lat) '())
      ((eq? old (car lat))
       (cons new
             (cons old (multiinsertL new old (cdr lat)))))
      (else
        (cons (car lat) (multiinsertL new old (cdr lat)))))))

(define multisubst
  (lambda (new old lat)
    (cond
      ((null? lat) '())
      ((eq? old (car lat))
       (cons new (multisubst new old (cdr lat))))
      (else
        (cons (car lat) (multisubst new old (cdr lat)))))))

(define add1 (lambda (n) (+ n 1)))
(define sub1 (lambda (n) (- n 1)))

(define plus
  (lambda (n m)
    (cond
      ((zero? m) n)
      (else
        (add1 (plus n (sub1 m)))))))

(define minus
  (lambda (n m)
    (cond
      ((zero? m) n)
      (else
        (sub1 (minus n (sub1 m)))))))

; define tuple: list of number (1 2 3 4)
(define addup
  (lambda (tup)
    (cond
      ((null? tup) 0)
      (else
        (plus (car tup)
              (addup (cdr tup)))))))

(define mul
  (lambda (n m)
    (cond
      ((zero? m) 0)
      (else (plus n (mul n (sub1 m)))))))

(define tup+
  (lambda (t1 t2)
    (cond
      ((null? t1) t2)
      ((null? t2) t1)
      (else
        (cons
          (plus (car t1) (car t2))
          (tup+ (cdr t1) (cdr t2)))))))

(define gt
  (lambda (n m)
    (cond
      ((zero? m) #t)
      ((zero? n) #f)
      ((zero? (minus m n)) #f)
      (else (gt (sub1 n) (sub1 m))))))

; equal for number comparison
(define eq_ (lambda (n m) (not (or (gt n m) (lt n m)))))

(define lt
  (lambda (n m)
    (cond
      ((zero? (minus n m)) #f)
      (else (not (gt n m))))))

(define exp_
  (lambda (n m)
    (cond
      ((zero? m) 1)
      (else
        (mul n (exp_ n (sub1 m)))))))


(define quotient_
  (lambda (n m)
    (cond
      ((< n m) 0)
      (else (add1 (quotient_ (minus n m) m))))))

(define length_
  (lambda (lat)
    (cond
      ((null? lat) 0)
      (else
        (add1 (length_ (cdr lat)))))))

(define pick_
  (lambda (n lat)
    (cond
      ((zero? n) (car lat))
      (else
        (pick_ (sub1 n) (cdr lat))))))

(define rempick
  (lambda (n lat)
    (cond
      ((zero? n) (cdr lat))
      (else
        (cons (car lat)
              (rempick (sub1 n) (cdr lat)))))))

; remove all numbers in a list
(define no-nums
  (lambda (lat)
    (cond
      ((null? lat) '())
      ((number? (car lat)) (no-nums (cdr lat)))
      (else
        (cons (car lat)
              (no-nums (cdr lat)))))))

; extract all the number from a tup
(define all-nums
  (lambda (lat)
    (cond
      ((null? lat) '())
      ((not (number? (car lat))) (all-nums (cdr lat)))
      (else
        (cons (car lat)
              (all-nums (cdr lat)))))))

; check if two arguments are the same atoms.
(define eqan?
  (lambda (a1 a2)
    (cond
      ((and (number? a1) (number? a2)) (eq_ a1 a2))
      ((or (number? a1) (number? a2)) #f)
      (else (eq? a1 a2)))))

(define occur
  (lambda (a lat)
    (cond
      ((null? lat) 0)
      ((eq? a (car lat)) (add1 (occur a (cdr lat))))
      (else
        (occur a (cdr lat))))))

(define one?
  (lambda (n)
    (cond
      ((zero? n) #f)
      (else (zero? (sub1 n))))))

(define rember*
  (lambda (a l)
    (cond
      ((null? l) '())
      ((atom? (car l))
       (cond
         ((eq? (car l) a)
          (rember* a (cdr l)))
         (else (cons (car l)
                     (rember* a (cdr l))))))
       (else (cons (rember* a (car l))
                   (rember* a (cdr l)))))))

(define insertR*
  (lambda (new old l)
    (cond
      ((null? l) '())
      ((atom? (car l))
       (cond
         ((eq? old (car l))
          (cons old
                (cons new
                      (insertR* new old (cdr l)))))
         (else
           (cons (car l)
                 (insertR* new old (cdr l))))))
      (else
        (cons (insertR* new old (car l))
              (insertR* new old (cdr l)))))))

(define occur*
  (lambda (a l)
    (cond
      ((null? l) 0)
      ((atom? (car l))
       (cond
         ((eq? a (car l))
          (add1 (occur* a (cdr l))))
         (else
           (occur* a (cdr l)))))
      (else
        (plus (occur* a (car l))
              (occur* a (cdr l)))))))

(define subst*
  (lambda (new old l)
    (cond
      ((null? l) '())
      ((atom? (car l))
       (cond
         ((eq? old (car l))
         (cons new (subst* new old (cdr l))))
        (else
          (cons (car l) (subst* new old (cdr l))))))
      (else
        (cons (subst* new old (car l))
              (subst* new old (cdr l)))))))

(define insertL*
  (lambda (new old l)
    (cond
      ((null? l) '())
      ((atom? (car l))
       (cond
         ((eq? (car l) old)
          (cons new (subst* new old (cdr l))))
         (else
           (cons (car l) (subst* new old (cdr l))))))
      (else (cons
              (insertL* new old (car l))
              (insertL* new old (cdr l)))))))

(define member*
  (lambda (a l)
    (cond
      ((null? l) #f)
      ((atom? (car l))
       (or (eq? a (car l))
           (member* a (cdr l))))
      (else
        (or (member* a (car l))
            (member* a (cdr l)))))))

; it only go in one branch of the tree, so not a *-func.
(define leftmost
  (lambda (l)
    (cond
      ((atom? (car l)) (car l))
      (else (leftmost (car l))))))

; ; ; ; ; refinement ; ; ; ;
; check if two lists are identical.
(define eqlist?
  (lambda (l1 l2)
    (cond
      ((and (null? l1) (null? l2)) #t)
      ((or (null? l1) (null? l2)) #f)
      (else
        (and (equal/s (car l1) (car l2))
             (eqlist? (cdr l1) (cdr l2)))))))

; check if two S-expressions are equal
(define equal/s
  (lambda (s1 s2)
    (cond
      ((and (atom? s1) (atom? s2)) (eqan? s1 s2))
      ((or (atom? s1) (atom? s2)) #f)
      (else (eqlist? s1 s2)))))


; The Sixth Commandment
; Simplify only after the funcition is correct

(define rember/s*
  (lambda (s l)
    (cond
      ((null? l) '())
      ((atom? (car l))
       (cond
        ((equal/s s (car l)) (rember/s* s (cdr l)))
        (else
          (cons (car l)
                (rember/s* s (cdr l))))))
       (else
         (cons (rember/s* s (car l))
               (rember/s* s (cdr l)))))))


;; Shadows

; n + 3: a arithmetic expression
; (n + 3): a representation of the arithmetic expression.
;   it is a S-expr and can be feeded as argument.
(define or-list
  (lambda (l)
    (cond ((null? l) #f)
          (else (or (car l)
                  (or-list (cdr l)))))))

(define numbered?
  (lambda (aexp)
    (cond
      ((atom? aexp) (number? aexp))
      ((or-list (map (lambda (o) (eq? (car (cdr aexp)) o))
                '(plus minus mul)))
       (and (numbered? (car aexp))
            (numbered? (car (cdr (cdr aexp))))))
      (else #f))))


;; The Seventh Commandment
;; Recur on the subpart that are of the same nature.

;; The Eighth Commandement
;; Use help functions to abstract from representations.


; (define value
;   (lambda (nexp)
;     (define 1st-sub-expr (lambda (aexp) (car (cdr aexp))))
;     (define 2ed-sub-expr (lambda (aexp) (car (cdr (cdr aexp)))))
;     (define operator (lambda (aexp) (car aexp)))
;     (cond
;       ((atom? nexp) nexp)
;       ((eq? (operator nexp) 'plus)
;        (plus (value (1st-sub-expr nexp))
;              (value (2ed-sub-expr nexp))))
;       ((eq? (operator nexp) 'minus)
;        (minus (value (1st-sub-expr nexp))
;               (value (2ed-sub-expr nexp))))
;       ((eq? (operator nexp) 'mul)
;        (mul (value (1st-sub-expr nexp))
;               (value (2ed-sub-expr nexp))))
;       ((eq? (operator nexp) 'quotient_)
;        (quotient_ (value (1st-sub-expr nexp))
;               (value (2ed-sub-expr nexp))))
;       (else
;         (exp_ (value (1st-sub-expr nexp))
;               (value (2ed-sub-expr nexp)))))))

;; new number representation: () -> 0 (()) -> 1 ...
(define sero?  (lambda (n) (null? n)))
(define edd1 (lambda (n) (cons '() n)))
(define zub1 (lambda (n) (cdr n)))
(define qlus
  (lambda (m n)
    (cond
      ((sero? m) n)
      (else
        (edd1 (qlus n (zub1 m)))))))


;; Relations

(define set?
  (lambda (lat)
    (cond
      ((null? lat) #t)
      ((member? (car lat) (cdr lat)) #f)
      (else
        (set? (cdr lat))))))

(define makeset
  (lambda (lat)
    (cond
      ((null? lat) '())
      ((member? (car lat) (cdr lat))
       (makeset (cdr lat)))
      (else
        (cons (car lat) (makeset
                          (multirember (car lat)
                                       (cdr lat))))))))

(define subset?
  (lambda (set1 set2)
    (cond
      ((null? set1) #t)
      (else
        (and (member? (car set1) set2)
             (subset? (cdr set1) set2))))))


(define eqset?
  (lambda (set1 set2) (and (subset? set1 set2) (subset? set2 set1))))

(define intersect?
  (lambda (set1 set2)
    (cond
      ((null? set1) #f)
      (else
        (or (member? (car set1) set2)
            (intersect? (cdr set1) set2))))))

(define intersect
  (lambda (s1 s2)
    ((lambda (set1 set2)
       (cond
         ((null? set1) '())
         ((member? (car set1) set2)
          (cons (car set1) (intersect (cdr set1) set2)))
         (else
           (intersect (cdr set1) set2))))
    (makeset s1)
    (makeset s2))))

(define union
  (lambda (s1 s2)
    ((lambda (set1 set2)
      (cond
        ((null? set1) set2)
        ((member? (car set1) set2)
         (union (cdr set1) set2))
        (else
          (cons (car set1)
                (union (cdr set1) set2)))))
     (makeset s1)
     (makeset s2))))

(define difference
  (lambda (s1 s2)
    (define one-side-difference
      (lambda (set1 set2)
       (cond
         ((null? set1) '())
         ((member? (car set1) set2)
          (one-side-difference (cdr set1) set2))
         (else
           (cons (car set1)
                 (one-side-difference (cdr set1) set2))))))
    ((lambda (l1 l2)
      (union (one-side-difference l1 l2)
             (one-side-difference l2 l1)))
     (makeset s1)
     (makeset s2))))

(define intersectall
  (lambda (l-set)
    (cond
      ((null? (cdr l-set)) (car l-set))
      (else (intersect (car l-set) (intersectall (cdr l-set)))))))


; make representation
(define first (lambda (p) (car p)))
(define second (lambda (p) (car (cdr p))))
(define third (lambda (p) (car (cdr (cdr p)))))
(define build (lambda (s1 s2) (cons s1 (cons s2 '()))))
(define revpair
  (lambda (pair)
    (build (second pair) (first pair))))

; define a pair (S-expr S-expr)
(define a-pair?
  (lambda (x)
    (cond
      ((atom? x) #f)
      ((null? x) #f)
      ((null? (cdr x)) #f)
      ((null? (cdr (cdr x))) #t)
      (else #f))))

; define: fun stand for function
; check if is finite func. f(2) == f(3) is not defined here.
(define fun? (lambda (rel) (set? (firsts rel))))

; reverse the domain and range.
(define reverl
  (lambda (rel)
    (cond
      ((null? rel) '())
      (else
        (cons (revpair (car rel))
              (reverl (cdr rel)))))))

(define one-to-one?
  (lambda (l)
    (and (fun? l)
         (fun? (reverl l)))))


(define rember-f
  (lambda (test? a l)
    (cond
      ((null? l) '())
      ((test? (car l) a) (cdr l))
      (else (cons (car l)
                  (rember-f test? a
                            (cdr l)))))))

; lambda...

; currying
(define eq?-c
  (lambda (a)
    (lambda (x)
      (eq? x a))))
; (define eq?-salad (eq?-c 'salad))

(define seqL (lambda (new old l) (cons new (cons old l))))
(define seqR (lambda (new old l) (cons old (cons new l))))

(define insert-g
  (lambda (seq)
    (lambda (new old l)
      (cond
        ((null? l) '())
        ((eq? (car l) old)
         (seq new old (cdr l)))
        (else (cons (car l)
                    ((insert-g seq) new old (cdr l))))))))

;; The Ninth Commandment
;; Abstract common patterns with a new function.

;; a substitution with insert.
(define seqS (lambda (new old l) (cons new l)))
(define subst_ (insert-g seqS))


; a prototype of eval.
(define atom-to-function
  (lambda (x)
    (cond
      ((eq? x 'plus) plus)
      ((eq? x 'minus) minus)
      ((eq? x 'mul) mul)
      ((eq? x 'quotient_) quotient_)
      ((eq? x 'minus) minus)
      (else exp_))))

(define value_
  (lambda (nexp)
    (define 1st-sub-expr (lambda (aexp) (car (cdr aexp))))
    (define 2ed-sub-expr (lambda (aexp) (car (cdr (cdr aexp)))))
    (define operator (lambda (aexp) (car aexp)))
    (cond
      ((atom? nexp) nexp)
      (else
        ((atom-to-function (operator nexp))
         (value_ (1st-sub-expr nexp))
         (value_ (2ed-sub-expr nexp)))))))

(define eq-tuna (eq?-c 'tuna))

;; pass a partial func
(define multiremberT
  (lambda (test? lat)
    (cond
      ((null? lat) '())
      ((test? (car lat))
       (multiremberT test? (cdr lat)))
      (else
        (cons (car lat)
              (multiremberT test? (cdr lat)))))))


;; The Tenth Commandment
;; Build funtioncs to collect more than one value at a time.


;; collector/continuation.
; first call (multirember&co 'a '(b c a))
; in last layer, (multirember&co 'a '())
;
; replaced with value:
; (multirember&co 'a '(b c a) col)
; (multirember&co 'a '(c a) (lambda col))
; (multirember&co 'a '(a) (lambda (lambda col)))
; (multirember&co 'a '() (lambda (lambda (lambda (col)))))
;   ((lambda (n s)                        ;last recur layer
;     ((lambda (n s)
;        ((lambda (n s)                   ;first recur layer
;           (col (cons (car lat) n) s))  ;;lat='(b c a) ;n: (c d), s: (a)
;         (cons (car lat) n) s))         ;;lat='(c a)   ;n: (c),   s: (a)
;      n (cons (car lat) s))) '() '())   ;;lat='(a)     ;n: (),    s: (a)

(define multirember&co
  (lambda (a lat col)
    (cond
      ((null? lat) (col '() '()))
      ((eq? (car lat) a)
       (multirember&co a
         (cdr lat)
         (lambda (newlat seen)
           (col newlat (cons (car lat) seen)))))
      (else
        (multirember&co a
          (cdr lat)
          (lambda (newlat seen)
            (col (cons (car lat) newlat) seen)))))))

;; examples of collector.
(define rm (lambda (x y) x))
(define contain? (lambda (x y) (null? y)))
(define count? (lambda (x y) (length y)))
; (multirember&co 'a '(b c) contain?)
; (multirember&co 'a '(b c a d e a) count?)
; (multirember&co 'a '(b c a d e a) rm)

(define multiinsertLR&co
  (lambda (new oldL oldR lat col)
    (cond
      ((null? lat) (col '() 0 0))
      ((eq? (car lat) oldL)
       (multiinsertLR&co new oldL oldR (cdr lat)
                         (lambda (newlat L R)
                           (col (cons new
                                      (cons oldL newlat))
                                (add1 L) R))))
      ((eq? (car lat) oldR)
       (multiinsertLR&co new oldL oldR (cdr lat)
                         (lambda (newlat L R)
                           (col (cons oldR
                                      (cons new newlat))
                                L (add1 R)))))
      (else
        (multiinsertLR&co new oldL oldR (cdr lat)
                          (lambda (newlat L R)
                            (col (cons (car lat) newlat)
                                 L R)))))))

(define evens-only*
  (lambda (l)
    (cond
      ((null? l) '())
      ((atom? (car l))
       (cond
         ((even? (car l))
          (cons (car l) (evens-only* (cdr l))))
         (else (evens-only* (cdr l)))))
      (else (cons (evens-only* (car l))
                  (evens-only* (cdr l)))))))

; 1. pass a list and a colletor func
; 2. base case of collector is ('() 1 0).
; 3. stands for list of all even number, product of evens, sum of pluses.
; 4. if (car l) is atom and is even, recur with new lambda
;    the lambda will cons (car l) into '(), and time (car l) with 1.(in base case)
; 5. if (car l) is atom but not even, just plus (car l) with 0 (in base case)
; 6. if (car l) is a list
;    it call itself with (car l) // a list as l, and create a huge collector.
;    the collector use evens-only*&co as col to vist (cdr l)
;    and there is another collector in this collector, we call it subcollector.
;    the subcollector will cons the result of (car l) with (cdr l).

(define evens-only*&co
  (lambda (l col)
    (cond
      ((null? l) (col '() 1 0))
      ((atom? (car l))
       (cond
         ((even? (car l))
          (evens-only*&co (cdr l)
                          (lambda (newl p s)
                            (col (cons (car l) newl)
                                 (* (car l) p) s))))
         (else
           (evens-only*&co (cdr l)
                           (lambda (newl p s)
                             (col newl
                                  p (+ (car l) s)))))))
      (else
        (evens-only*&co (car l)
                        (lambda (al ap as)
                          (evens-only*&co (cdr l)
                                          (lambda (dl dp ds)
                                            (col (cons al dl)
                                                 (* ap dp)
                                                 (+ as ds))))))))))
(define get-result
  (lambda (newl product sum)
    (cons
      (cons
        product
        (cons
          sum '())) newl)))
; (evens-only*&co '((10 9 1 2) 3 10 (9 9) 7 98) get-result)

;
; unnatrual recursion
;
(define looking
  (lambda (a lat)
    (keep-looking a (pick_ 1 lat) lat)))

(define keep-looking
  (lambda (a sorn lat)
    (cond
      ((number? sorn)
       (keep-looking a (pick_ sorn lat) lat))
      (else (eq? sorn a)))))

; partial recusrive function and total recursive function
(define eternity
  (lambda (x)
    (eternity x)))

; take a pair with first component is a pair, it shift the (car (cdr ) first pair)
; into the second component.
(define shift
  (lambda (pair)
    (build (first (first pair))
           (build (second (first pair))
                  (second pair)))))

; each recursion change its parameters, and it cannot garantee it apporach the goal.
; it is a total recursive func, every para has a value.
(define align
  (lambda (pora)
    (cond
      ((atom? pora) pora)
      ((a-pair? (first pora))
       (align (shift pora)))
      (else (build (first pora)
                   (align (second pora)))))))


; wrong. first argument gets simpiler but second get more complicated.
(define pora-length*
  (lambda (pora)
    (cond
      ((atom? pora) 1)
      (else
        (+ (pora-length* (first pora))
           (pora-length* (second pora)))))))

; pay 'twice' attention to first component, arguments get simpler.
(define pora-weight*
  (lambda (pora)
    (cond
      ((atom? pora) 1)
      (else
        (+ (* (pora-weight* (first pora) 2))
           (pora-weight* (second pora)))))))

; it is not a total recursive func.
(define shuffle
  (lambda (pora)
    (cond
      ((atom? pora) pora)
      ((a-pair? (first pora))
       (shuffle (revpair pora)))
      (else (build (first pora)
                   (shuffle (second pora)))))))

; not a total function.
; Lothar Collatz.
; It is only known that it is undefined when n=0
(define C
  (lambda (n)
    (cond
      ((one? n) 1)
      (else
        (cond
          ((even? n) (C (/ n 2)))
          (else (C (add1 (* 3 n)))))))))


; Ackermann  // unnatrual recursion, total function.
(define A
  (lambda (n m)
    (cond
      ((zero? n) (add1 m))
      ((zero? m) (A (sub1 n) 1))
      (else (A (sub1 n)
               (A n (sub1 m)))))))

; (A 4 3) take forever.

; HOW TO MAKE A Y COMBINATOR

;; Version 1 ;;
; (lambda (l)
;   (cond
;     ((null? l) 0)
;     (else
;       (add1
;         ((lambda (l)
;            (cond
;              ((null? l) 0)
;              (else (add1
;                      (eternity (cdr l))))))
;          (cdr l))))))

;; Version 2 ;;
; ((lambda (f)
;    (lambda (l)
;      (cond
;        ((null? l) 0)
;        (else (add1 (f (cdr l)))))))
;  ((lambda (g)
;     (lambda (l)
;       (cond
;         ((null? l) 0)
;         (else (add1 (g cdr l))))))
;   eternity))

;; Version 3 ;;
; ((lambda (mk-length)
;    (mk-length
;      (mk-length eternity)))
;  (lambda (len)
;    (lambda (l)
;      (cond
;        ((null? l) 0)
;        (else (add1 (len (cdr l))))))))
; Using arguments to abstract, same as define.

; RECURSIVE DEFINITION.

; create a func, pass a lambda as argument to it
;
;Version 4
; ((lambda (mk-length)
;    (mk-length mk-length))   ;engine 1
;  (lambda (mk-length)        ;recur
;    (lambda (l)              ;primitive
;      (cond
;        ((null? l) 0)
;        (else (add1
;                ((mk-length mk-length)  ;engine 2
;                 (cdr l))))))))

; Version 6 *
((lambda (mk-length)
   (mk-length mk-length))
 (lambda (mk-length)
   ((lambda (len)                       ; (lambda (x) f x)
      (lambda (l)                       ; also return a
        (cond                           ; function with one
          ((null? l) 0)                 ; argument.
          (else                         ;
            (add1 (len (cdr l)))))))    ;
    (lambda (x)
      ((mk-length mk-length) x)))))

; version 7 move the comment part in version 6 out since
; doesn't depends on mk-length at all.
((lambda (le)
   ((lambda (mk-length)
      (mk-length mk-length))
    (lambda (mk-length)
      (le (lambda (x)
            ((mk-length mk-length) x))))))
 (lambda (len)
   (lambda (l)
     (cond
       ((null? l) 0)
       (else (add1 (len cdr l)))))))

; applicative-order Y combinator:
(define Y
  (lambda (g)
    ((lambda (f) (f f))
     (lambda (f) (g (lambda (x) ((f f) x)))))))

;
; Y combinator recursive nature prove.
;
; Y := λf.(λx.(f (x x)) λx.(f (x x)))
; Y g = λf.(λx.(f (x x)) λx.(f (x x)))g
;     = λx.(g (x x)) λx.(g (x x))
;     = λy.(g (y y)) λx.(g (x x))
;     = g (λx.(g (x x)) λx.(g (x x)))
;
; Meanwhile,
; g(Y g) = g (λf.(λx.(f (x x)) λx.(f (x x)))g)
;        = g (λx.(g (x x)) λx.(g (x x)))
;        = (Y g)
; Thus, (Y g) = (g (Y g)) = ... = (g(g ... (g (Y g) ...)))
; any of them works the same as Y.

;
; applicative Y combinator, the versoin we write.
;
; Y := λg.(λf.(f f) λf.g(λx.((f f) x)))
; Y h = λg.(λf.(f f) λf.g(λx.((f f) x)))h
;     = λf.h(λx.((f f) x)) λf.h(λx.((f f) x))
;     = h( λx.((λf.h(λx.((f f) x))  λf.h(λx.((f f) x))) x) )
;     let F = λx.((λf.h(λx.((f f) x))
; then
;     = h((F F) x)
;     = h(h ((F F) x)) = ...

; omega combinator: apply a func to itself.
; (lambda (o) (o o))

; apply to Y to achieve generic recursion.
; ((Y (lambda (len)
;      (lambda (l)
;        (cond
;          ((null? l) 0)
;          (else
;            (add1 (len (cdr l))))))))
;  '(1 2 3 9 9 9 9 9 9 9 9 9 9 9 9 9 9))

;
; EVAL
;

; entry: a pair of set and list with same length
(define entry?
  (lambda (e)
    (and (set? (first e))
         (eq? (length (first e)) (length (second e))))))

(define new-entry
  (lambda (set lst)
    (cond
      ((or (and (null? set) (null? lst))
           (not (and (set? set) (eq? (length set) (length lst)))))
       '(() ()))
      (else
        (cons set (cons lst '()))))))


(define lookup-in-entry
  (lambda (name entry entry-f)
    (define lookup-in-entry-help
      (lambda (name names vals entry-f)
        (cond
          ((null? names) (entry-f name))
          ((eq? name (car names))
           (car vals))
          (else
            (lookup-in-entry-help name
                                  (cdr names)
                                  (cdr vals)
                                  entry-f)))))
    (lookup-in-entry-help name
                          (first entry)
                          (second entry)
                          entry-f)))

; (lookup-in-entry 'a
;                  (new-entry '(b e a i f) '(1 2 3 4 5))
;                  (lambda (n) 'no-val-for-key))


; define table/environment: a list of entries.

(define extend-table
  (lambda (new-e old-table)
    (cond
      ((not (entry? new-e)) old-table)
      (else
        (cons new-e old-table)))))

; (extend-table (new-entry '(b c d) '(1 2 3))
;               (cons (new-entry '(A B C) '(0 9 8))
;                     (cons (new-entry '(@ * $) '(5 6 7))
;                           '())))

; used continuation.
(define lookup-in-table
  (lambda (name table table-f)
    (cond
      ((null? table) (table-f name))
      (else
        (lookup-in-entry name
                         (car table)
                         (lambda (name)
                           (lookup-in-table name
                                            (cdr table)
                                            table-f)))))))
; lisp types:
;     *const
;     *quote
;     *identifier
;     *lambda
;     *cond
;     *application

; value: find out the type of the expression and invoke
; associated function(also called action here).


(define expression-to-action
  (lambda (e)
    (cond
      ((atom? e) (expression-to-action e))
      (else (list-to-action e)))))

(define atom-to-action
  (lambda (e)
    (cond
      ((number? e) *const)
      ((eq? e #t) *const)
      ((eq? e #f) *const)
      ((eq? e 'cons) *const)
      ((eq? e 'car) *const)
      ((eq? e 'cdr) *const)
      ((eq? e 'null?) *const)
      ((eq? e 'eq?) *const)
      ((eq? e 'atom?) *const)
      ((eq? e 'zero?) *const)
      ((eq? e 'add1) *const)
      ((eq? e 'sub1) *const)
      ((eq? e 'number?) *const)
      (else *identifier))))

(define list-to-action
  (lambda (e)
    (cond
      ((atom? (car e))
       (cond
         ((eq? (car e) 'quote)
          *quote)
         ((eq? (car e) 'lambda)
          *lambda)
         ((eq? (car e) 'cond)
          *application)))
      (else *application))))

; interpreter...
(define value
  (lambda (e)
    (meaning e (quote ()))))
(define meaning
  (lambda (e table)
    ((expression-to-action e) e table)))

; actions
(define *const
  (lambda (e table)
    (cond
      ((number? e) e)
      ((eq? e #t) #t)
      ((eq? e #f) #f)
      (else (build (quote primitive) e)))))

(define text-of cdr)
(define *quote
  (lambda (e table)
    (text-of e)))
; (*quote '(quote a b c) '())

(define *identifier
  (lambda (e table)
    (lookup-in-table e table (lambda (name)
                               (car (quote ()))))))

(define *lambda
  (lambda (e table)
    (build (quote non-primitive)
           (cons table (cdr e)))))

(define table-of
  (lambda (lambda-expr)
    (first (second lambda-expr))))

(define formals-of
  (lambda (lambda-expr)
    (second (second lambda-expr))))

(define body-of
  (lambda (lambda-expr)
    (third (second lambda-expr))))


(table-of (*lambda '(lambda (x) x) '((a b c) (1 2 3))))
(formals-of (*lambda '(lambda (x) x) '((a b c) (1 2 3))))
(body-of (*lambda '(lambda (x) x) '((a b c) (1 2 3))))


(define evcon
  (lambda (lines table)
    (define else?
      (lambda (x)
        (cond
          ((atom? x) (eq? x 'else))
          (else #f))))
    (define question-of first)
    (define answer-of second)
    (cond
      ((else? (question-of (car lines)))
       (meaning (answer-of (car lines)) table))
      ((meaning (question-of (car lines)) table)
       (meaning (answer-of (car lines)) table))
      (else (evcon (cdr lines) table)))))

(define *cond
  (lambda (e table)
    (define cond-lines-of cdr)
    (evcon (cond-lines-of e) table)))

(define evlis  ; eval list
  (lambda (args table)
    (cond
      ((null? args) '())
      (else
        (cons (meaning (car args) table)
              (evlis (cdr args) table))))))
(define :atom?
  (lambda (x)
    (cond
      ((atom? x) #t)
      ((null? x) #f)
      ((eq? (car x) 'primitive) #t)
      ((eq? (car x) 'non-primitive) #t)
      (else #f))))

(define *application
  (lambda (e table)
    (define function-of car)
    (define arguments-of cdr)
    (define primitive?
      (lambda (l)
        (eq? (first l) 'primitive)))
    (define non-primitive?
      (lambda (l)
        (eq? (first l) 'non-primitive)))
    (define apply_
      (lambda (fun vals)
        (cond
          ((primitive? fun)
           (apply-primitive
             (second fun) vals))
          ((non-primitive? fun)
           (apply-closure
             (second fun) vals)))))
    (define apply-primitive
      (lambda (name vals)
        (cond
          ((eq? name 'cons)
           (cons (first vals) (second vals)))
          ((eq? name 'car)
           (car (first vals)))
          ((eq? name 'cdr)
           (cdr (first vals)))
          ((eq? name 'null?)
           (null? (first vals)))
          ((eq? name 'eq?)
           (eq? (first vals)))
          ((eq? name 'atom?)
           (:atom? (first vals))) ; use atom? directly?
          ((eq? name 'zero?)
           (zero? (first vals)))
          ((eq? name 'add1)
           (add1 (first vals)))
          ((eq? name 'sub1)
           (sub1 (first vals)))
          ((eq? name 'number?)
           (number? (first vals))))))
    (define apply-closure
      (lambda (closure vals)         ; closure: lambda expr
        (meaning (body-of closure)
                 (extend-table
                   (new-entry        ; args
                     (formals-of closure)
                     vals)
                   (table-of closure)))))
    (apply_
      (meaning (function-of e) table)
      (evlis (arguments-of e) table))))


; example of closure
; (((u v w) (1 2 3)) ((x y z) (4 5 6)) (x y) (cons z x))
; example of vals
; ((a b c)(d e f))

#lang racket
; https://stackoverflow.com/questions/22888722/could-someone-explain-call-cc-in-simple-words

; say you want to compute (+ (* 2 3) (/ 10 2))
; you can't evaluate everything at the same time,
; so the actually implementation will be evaluing simple
; components by parts until the evaluation finished.

(+ (* 2 3) (/ 10 2))

(define (*& x y cont) (cont (* x y)))
(define (+& x y cont) (cont (+ x y)))
(define (-& x y cont) (cont (- x y)))
(define (/& x y cont) (cont (/ x y)))
(define (zero?& x y cont) (cont (zero? x y)))

(define (*& x y cont) (cont (* x y)))

; new write it in continuation style.
; you keep passing the rest continuation
(define expression
  (lambda (k)
    (*& 2 3
        (lambda (r1)
          (/& 10 2
              (lambda (r2)
                (+& r1 r2 k)))))))
(expression identity)

; but what if the division is invalid? in case you are
; dividing a value by 0, you want to exit the evaluation
; all together. what should you do in that case?

; to handle zero case with cps only, we need to write this:
(define expression1
  (lambda (k)
    (*& 2 3
        (lambda (r1)
          (zero?& a
                  (lambda (azero?)
                    (if (azero?)
                      (k +inf.0)
                      (/& 10 a
                          (lambda (r2)
                            (+& r1 r2 k))))))))))

; call/cc helps you to simplify the code above
(call/cc
  (lambda (k)
           (+ (* 2 3)
              (/ 10 (if (zero? a) (k +inf.0) a)))))

; this will print hello 11 times
(let* ((c 10)
       (r (call/cc (lambda (exit) exit))))
  (display "Hello\n")
  (cond ((zero? c) 'done)
        (else (set! c (- c 1))
              (r r))))

(define (lstadd1 lst)
  (call/cc (lambda (exit)
             (let loop ((lst lst))
               (cond ((pair? lst) (cons (add1 (car lst)) (loop (cdr lst))))
                     ((null? lst) '())
                     (else (exit #f)))))))
#lang typed/racket
(require (for-syntax racket/match))
(require (for-syntax racket/syntax))

;----------------------------------------
; Report on A quick overview of racket
; This report is not based on one particular paper, but rather a conclusion of
; multiple sources.

; https://stackoverflow.com/questions/49669142/what-is-difference-between-datum-syntax-and-syntax-in-define-syntax-body#:~:text=However%2C%20datum%2D%3Esyntax%20is,the%20input%20to%20the%20macro.
; http://www.greghendershott.com/fear-of-macros/Robust_macros__syntax-parse.html
;----------------------------------------

;----------------------------------------
; Basics
;----------------------------------------
; Boolean & conditions
; Use square bracket is more friendly to color blind people than
; rainbow bracketes :3
(: condition : Integer -> (U Symbol Void)) ; U is Sum type
(define (condition n)
  (if (< n 50)
    (if (= n 20) 'eq20
      (cond [(= n 30) 'eq30]  ; idiomatic scheme use [] to differentiate
            [(= n 40) 'eq40]  ; bracket.
            [(or (= n 44) (= n 45)) 'eq44or45]
            [else (case n
                    [(1) 'eq1]
                    [(2) 'eq2]
                    [(3) 'eq3]
                    [else (match n  ; you also have pattern matching
                            [4 'eq4]
                            [5 'eq5]
                            [_ (when (= n 9) 'eq9)])])]))
    'gt50)) ; Symbol


;----------------------------------------
; list
;----------------------------------------
(: list-fun (Listof (U Symbol Number (Listof Any))))
(define list-fun
  ((lambda ()
     (let* ([x 45]   ; binding in racket
           [y 55]
           [list1 (list 'a x y)] ; with list constructor
           [list2 '(x y)]  ; make datum with quote
           [listss '((1 2 3) (a b c))]) ; naming convention. s for nested level
       (append listss list2 list1)))))

;----------------------------------------
; quasiquote
;----------------------------------------
; You have list and quote. between this two is quasiquote
; you can make a quasiquote with (`) and unquote a value with (,) prefix
; In this case you inject x=10 into the quasiquote
(: quasi (->* (#:size Integer) (Listof Number)))
(define (quasi #:size n)
  (: stack (-> Integer (Listof Integer)))
  (define (stack n)
    (case n
      [(<= n 0) '()]
      [else (cons n (stack (- n 1)))]))
  (let ([x 10]
        [xs (list 9 9 9)]
        [ys (stack n)])
    `(1 2 ,x ,@xs ,@ys 3)))  ; @ spread list into the quote (unquote splicing)

;----------------------------------------
; Module, contract and mutation
;----------------------------------------
; You can define multiple modules in the same file.
; it's like restricted namespace, you don't define same module in
; different files.
; Modules are all lazily evaluated.
(module bank-account racket ; we are not using typed racket so can use contract
  (provide (contract-out    ; contract impose constraint. like assert.
           [deposit (-> positive? any)]
           [balance (-> positive?)]))
  (define amount 0)
  (define (deposit a) (set! amount (+ amount a)))   ; mutation with set!
  (define (balance) amount))
; the need of contract can be eliminated with proper types
; this module shows how to require untyped module in typed racket.
(module use-bank-account typed/racket
  (provide get-money)
  (require/typed 'bank-account
                 [deposit (-> Positive-Integer Void)])
  (: get-money (-> Void))
  (define (get-money)
    (deposit 5)))

;----------------------------------------
; Macros
;----------------------------------------
; Make dsl easy!
; Because lisp syntax is so easy, the code your macro expand to is
; just lisp code itself! (instaed of string like in c)
; Some examples of macros

; ** hygenic macro **
; Basic idea is that your macros will not have name conlision with macros
; defined by someone else even when they have the same identifier.
; To achieve this, when expanding the macro racket macro expender will
; "color" the syntax object with the scope they live in.

; Basics ;
; A ** syntax transformer ** is a function takes syntax and return syntax.
; This is an example that ignore the input syntax and transform a string.
; the synax is the constructor of syntax object, and you can write the
; short hand version #'
(define-syntax foo
  (lambda (stx) (syntax "I am foo")))

; Another way Just to show it's the same as function
(define-syntax (say-hi stx)
  (print stx)   ; print the syntax object (the code.)
  #'(displayln "\nhi"))

; you can define your own syntax
(: stx-1 (Syntaxof Any))
(define stx-1 #'(if x (list "true") #f))

; Some eliminator of syntax type.
(: syntax-stat (-> (Syntaxof Any) Void))
(define (syntax-stat stx)
  (display "Source: ") (displayln (syntax-source stx))
  (display "Line: ") (displayln (syntax-line stx))
  (display "Column: ") (display (syntax-column stx)))

; You can convert syntax to other stuffs
(: syntax-convert (-> (Syntaxof Any) (Values Any Any)))
(define (syntax-convert stx)
  (values (syntax->datum stx) (syntax-e stx)))

; ** datum ** is the type to represent s-expression.
; cdr is to get rid of 'reverse-me in the syntax
; ps: with datum->syntax you can even make syntax object on the fly (
; make syntax object that doesn't exist in the argument stx).
; The reason why we need datum->syntax is to color the synatx object so
; so macro system is hygenic.
(define-syntax (reverse-me stx)
  (datum->syntax stx (reverse (cdr (syntax->datum stx)))))
(: reverse-me-driver (Listof Symbol))
; this will transform the syntax into (list 'v 'a "1")
(define reverse-me-driver (reverse-me 'x 'a 'v list))

; if macro example ;
; Classic (if) example. This in haskell can be achieve by function
; because of the lazy evaluation, but because racket evaluate eagerly,
; you need macro to avoid evaluate all parameters together.
(define-syntax (new-if stx)
  (define xs (syntax->list stx))
  (datum->syntax stx `(cond [,(cadr xs) ,(caddr xs)]
                            [else ,(cadddr xs)])))

; new-if version 2 with match. macro code run at compile time, and
; there is only racket/base available. To use other functionalities
; you need to require with ** for-syntax **. For instance, here we imported
; pattern matching.
(define-syntax (new-if2 stx)
  (match (syntax->list stx)
    [(list _ condition true-expr false-expr)
     (datum->syntax stx `(cond [,condition ,true-expr]
                               [else ,false-expr]))]))

; new-if version 3 with syntax case
; syntax-case simplified using pattern matching.
; Some differences:
; 1. you don't need to manually pattern match
; 2. you don't need to feed data into quasi quote any more.
(define-syntax (new-if3 stx)
  (syntax-case stx ()
    [(_ condition true-expr false-expr)
     #'(cond [condition true-expr] [else false-expr])]))


; define-syntax-rule is a short hand for pattern in new-if3
; You can just write code in the body, and they will transform into
; syntax automatically.
(define-syntax-rule (new-if4 condition true-expr false-expr)
  (cond [condition true-expr] [else false-expr]))

; hyphen macro Examples ;
; (hyphen-define a b (args) body) -> (define (a-b args) body)

; ** define-for-syntax ** allows you to define helper functions in
; macro. It's accessible at compile time.
(: stitch-name (-> (Syntaxof Any) (Syntaxof Any) Symbol))
(define-for-syntax (stitch-name s1 s2)
    (string->symbol
      (format "~a-~a"
              (syntax->datum s1)
              (syntax->datum s2))))

; use nested syntax-case.
;   First, syntax part in `syntax-case` is called template. In our case
; the template in the last line is the syntax get outputed.
;   Note parameters of `stitch-name` are syntax #'a #'b rather than pattern
; matched a and b: we made a b template.
;   You can't use a matched pattern outside of a template. But you can make
; an ad hoc template by forcibly using syntax of the symbol of the varible.
; (use #'a for a, etc)
(define-syntax (hyphen-define/1 stx)
  (syntax-case stx ()
    [(_ a b (args ...) body0 body ...)
     (syntax-case (datum->syntax
                    #'a   ;
                    (stitch-name #'a #'b))
       ()
       [name #'(define (name args ...)  body0 body ...)])])) ; template.

; ** with-syntax ** is like syntax-case but chagne the order of parameters.
(define-syntax (hyphen-define/2 stx)
  (syntax-case stx ()
    [(_ a b (args ...) body0 body ...)
     (with-syntax ([name (datum->syntax #'a (stitch-name #'a #'b))])
       #'(define (name args ...) body0 body ...))]))

; ** with-syntax* ** is the self referential version.
(define-syntax (foo stx)
  (syntax-case stx ()
    [(_ a)
     (with-syntax* ([b #'a]   ; force to use pattern a in template
                    [c #'b])
                   #'c)]))

; short-circuiting or
; evaluate a first, stop the evaluation if it's true.
; If you want to implement or with function you must evaluate both a and b,
; which is not really what you're intended.
(define-syntax-rule (or-short-circuit a b) (if a a b))

; a while loop macro ;
(define-syntax-rule (while condition body ...)
  (let loop ()
    (when condition
      body ...
      (loop))))

; 3. a macro for swap two variables. ;
; ! is convention for mutation
(define-syntax-rule (swap! x y) ; macro are hygienic so no name colisions.
  (let ([tmp x])
    (set! x y)
    (set! y tmp)))
; actual macro

;----------------------------------------
; Types
;----------------------------------------
; Typed tree
(define-type Tree (U leaf node))
(struct leaf ([val : Number]))
(struct node ([left : Tree] [right : Tree]))

(: tree-height (-> Tree Integer))
(define (tree-height t)
  (cond [(leaf? t) 1]
        [else (max (+ 1 (tree-height (node-left t)))
                   (+ 1 (tree-height (node-right t))))]))

(: tree-sum (-> Tree Number))
(define (tree-sum t)
  (cond [(leaf? t) (leaf-val t)]
        [else (+ (tree-sum (node-left t))
                 (tree-sum (node-right t)))]))

; Typed maybe
(struct None ())
(struct (a) Some ([v : a]))
(define-type (Opt a) (U None (Some a)))

(: find (-> Number (Listof Number) (Opt Number)))
(define (find v l)
  (cond [(null? l) (None)]
        [(= v (car l)) (Some v)]
        [else (find v (cdr l))]))

; polymorphic functions
; All is the quantifier.
(: list-len (All (a) (-> (Listof a) Integer)))
(define (list-len l)
  (if (null? l)
    0
    (add1 (list-len (cdr l)))))

; varadic
(: sumNumbers (-> Number * Number))
(define (sumNumbers . xs)
  (if (null? xs) 0 (+ (car xs) (apply sumNumbers (cdr xs)))))

;----------------------------------------
; Exceptions
;----------------------------------------
; racket also has exception system.
; try catch style. Haskell has similar idiom to
; handle context.
(with-handler ([exn:fail? (lambda (exn) 999)])
              (+ 1 "2"))

; handle case when you break while the program is sleeping.
(with-handler ([exn:break? (lambda (exn) "No time")])
              (sleep 3)
              "phew")

; it will catch numeric value get raised, and return it's
; identity
(with-handler ([number? identity])
              (+ 1 (raise 2)))

;----------------------------------------
; Some common data structures
;----------------------------------------

; define structs
; struct is a macro, it will automatically generate methods like
; dog? and dog-* (dog-name, dog-breed) for struct dog.
; it's really like haskell record type, even the accessor part.
(struct dog ([name : String] [breed : String] [age : Positive-Integer]))
; hypotheical way of using struct

; ** string-append ** is ad hoc concat for a list of string
; ** ~a ** is
(: mk-dog-string (-> dog String))
(define (mk-dog-string d)
  (let* ([name (dog-name d)]
         [name-tag (~a (char-upcase (string-ref name 0)) name)])
    (string-append "Dog name: " name-tag " | "
                   "Dog breed: " (dog-breed d) " | "
                   "Dog age: " (~a (dog-age d) " Years old"))))

; To make a mutable struct you need to specify it in the constructor.
(struct rgba ([r : Integer]
              [g : Integer]
              [b : Integer]
              [a : Integer]) #:mutable #:transparent)

; there are some boilerplates that we can potentially eliminate with macro.
(: color-complement! (-> rgba Void))
(define (color-complement! color)
  (: flip (-> Integer Integer))
  (define (flip n)
    (cond [(> n 255) 0]
          [else (- 255 n)]))
    (set-rgba-r! color (flip (rgba-r color)))
    (set-rgba-g! color (flip (rgba-g color)))
    (set-rgba-b! color (flip (rgba-b color)))
    (set-rgba-a! color (flip (rgba-a color))))

; you also have tings like vector.
; typed racket trips here. I can't use any type other than
; Vectorof Integer (even Vectorof Any) ...
(: vector-playground (Vectorof Integer))
(define vector-playground
  (let* ([xs (take '(1 2 3 4 2) 3)]
         [vs-1 (list->vector xs)]
         [vs-2 #(8 8 9 9)]
         [vs-3 (vector-append vs-1 vs-2)])
    vs-3))

; and set $ hash as normal
(: power-set (All (a) (-> (Setof a) (Setof (Setof a)))))
(define (power-set xs)
  (if (= 0 (set-count xs))
    (let ([set1 (inst set a)]
          [set2 (inst set (Setof a))])
      (set2 (set1)))
    (let ([xs- (power-set (set-rest xs))])
      (set-union
        (for/set ([e xs-]) (set-add e (set-first xs)))
        xs-))))

; Also I found this very convinent digraph for data structures.
; DATA STRUCTURE   ACCESS       NUMBER     INDICES
; List:            sequential   Variable   not used
; Struct:          random       Fixed      names
; Vector:          random       Fixed      integer
; Growable vector: random       Variable   integer
; Hash:            random       Variable   hashable
; Splay:           random       Variable   non-integer, total order


-- lua curring has some problem comes from ambiguious syntax
fs = (function() return function() return 1 end end)()()

triple = ((function(a)
    return function(b) return function(c) return {a, b, c} end end
end)(1)(2)(3))

make_pair = function(a) return function(b) return {a, b} end end

function s(x) return function(y) return function(z) return (x(z))(y(z)) end end end

s(make_pair)(function(x) return x + 10 end)(10)

x = (s(make_pair)(function(x) return x + 10 end)(10))

y = (s(make_pair)(function(x) return x + 10 end)(10))

function print_all(...)
    local arg = table.pack(...)
    print('in print_all' .. #arg)
    for i, v in ipairs(arg) do
        print(i)
        print(v)
    end
end

print_all(1, 2, 3)
-- Part I
start = {
    main = function()
        io.open('a')
        local a = "one string"
        local b = string.gsub(a, "one", "another")
        print(#a)
        print(a .. b)
        print(a .. 2)
        local page = [[
            <html>
                <head>
                    <title></title>
                </head>
                <body>
                    <a href="http://www.lua.org">Lua</a>
                </body>
            </html>
        ]]
        local mml = [=[
            <![CDATA[
                hello world
            ]]>
        ]=]
    end
}

Ch2EightQueen = {
    main = function()
        local N = 8
        local function isplaceok(a, n, c)
            for i = 1, n - 1 do
                if (a[i] == c) or (a[i] - 1 == c - n) or (a[i] + 1 == c + n) then
                    return false
                end
            end
            return true
        end

        local function printsolution(a)
            for i = 1, N do
                for j = 1, N do
                    io.write(a[i] == j and "X" or ".", " ")
                end
                io.write("\n")
            end
            io.write("\n")
        end

        local function addqueen(a, n)
            if n > N then
                printsolution(a)
                do return end
            else
                for c = 1, N do
                    if isplaceok(a, n, c) then
                        a[n] = c
                        addqueen(a, n + 1)
                    end
                end
            end
        end
        addqueen({}, 1)
    end
}

-- ch 4
Ch4String = {
    main = function()
        print(tonumber("0x3.1p-3"))
        print(tonumber("10001", 2))
        print(tostring(12))
        print(string.byte("abc", 1, 2))
    end,

    defsomefunc = function()
        local function insert(src, n, word)
            return string.sub(src, 1, n) .. word .. string.sub(src, n, -1)
        end

        local function remove(src, i, j)
            return string.sub(src, 1, i) .. string.sub(src, j, -1)
        end
        local function ispali(src) return string.reverse(src) == src end

        insert("long string", 5, "-o-")
        remove("good evening dwag", 5, 14)
        ispali("step on no pets")
        ispali("dog")
    end
}

-- Ch 5 data structures with table.
Ch5Table = {
    define = function()
        local seasons = {"Spring", "Summer", "Autumn", "Winter"} -- table as array
        print(seasons)
        local point = {x = 0, y = 0} -- table as record
        print(point)

        local polyline = { -- table constructor mixed.
            color = "blue",
            thickness = 2,
            npoints = 4,
            {x = 0, y = 0},
            {x = -10, y = 0},
            {x = 10, y = 0},
            {x = 1, y = 0}
        }

        local polyline2 = { -- for special characters as key.
            ["+"] = "add",
            ["-"] = "minus",
            ["*"] = "multiply",
            ["/"] = "divide"
        }
        print(polyline[2].x == -10)
        print(polyline2["-"] == "minus")
    end,

    traversal = function()
        -- as list
        local list1 = {}
        for i = 1, 10 do list1[i] = io.read() end

        local printlist = function(list)
            for i = 1, #list do print(list[i]) end
        end
        printlist(list1)

        local t = {10, print, x = 12, k = "hi"}
        for k, v in pairs(t) do print(k, v) end

    end,

    safenav = function()
        local E = {}
        local company = {director = {address = {zipcode = 1}}}
        local zip1 = (((company or E).director or E).address or E).zipcode
        local zip2 = (((company1 or E).director or E).address or E).zipcode
        print(zip1 == 1)
        print(zip2 == nil)
    end,

    exercise = function()
        -- recursive reference
        local a = {}
        a.a = a
        a.a.a.a.a.a.a.a.a.a.a.a = 100 -- now a.a is 100

        local escapeseq = {["\n"] = "line break", ["\r"] = "return"}

        local function do_polynomial(t, x)
            local acc = 0
            for i, coeff in pairs(t) do
                acc = acc + coeff * x ^ (i - 1)
            end
            return acc
        end

        local function isseq(t)
            local flag = true
            for i = 1, #t do
                if t[i] == nil then
                    print("spot")
                    flag = false
                end
            end
            return flag
        end

        local function insert_list(dest, src, idx)
            for i = 1, #src do
                table.insert(dest, i + idx - 1, src[i])
            end
        end

        local function tconcat(t, sep)
            local result = ""
            for k, v in pairs(t) do
                result = result .. v
                if k < #t then result = result .. sep end
            end
            return result
        end

        do_polynomial({1, 3, 5, 7}, 10)
        isseq({1, 2, 3})
        isseq({1, 2, nil, 3})
        insert_list({1, 2, 3, 4}, {10, 20, 30}, 2)
    end
}

Ch6Functions {
    func_features = function()

        local s, e = string.find("hello Lua user", "Lua")

        local function foo() return "a", "b", "c" end

        a, b, c = foo() -- unpack tuple
        foot = {foo()} -- unpack in table.
    end,

    varadic = function()
        local function add(...)
            local s = 0
            for _, v in ipairs {...} do -- sugar.
                s = s + v
            end
            return s
        end
        add(1, 2, 3, 4, 5)

        local function printf(fmt, ...) io.write(string.format(fmt, ...)) end
        printf("%d", 1)

        local function pack(...) return table.pack(...) end

        local t = {1, 2, 3}

        print(t == pack(table.unpack {t}))

    end,

    tailcall = function()
        -- f call g at last line. we know f has nothing else to
        -- do when calling g, so its stack is nolong needed.
        local function g(x) return x end
        local function f(x)
            x = x + 1;
            return g(x)
        end
        local function foo(n)
            if n > 0 then
                return foo(n - 1)
            else
                return n
            end
        end
    end,

    exercise = function()

        local printlist = function(list, idx)
            for i = (idx or 1), #list do print(list[i]) end
        end

        local skipfirst = function(list) printlist(list, 2) end
        print(skipfirst({1, 2, 3}))

        -- random
        local randint = function(from, to)
            return math.ceil(math.random() * (from - to) + to)
        end

        local shuffle = function(list)
            local randomness = 500
            for _ = 1, randomness do
                local randidx = randint(1, #list)
                local picked = list[randidx]
                table.remove(list, randidx)
                table.insert(list, 1, picked)
            end
            return list
        end

        for i = 1, 100 do
            print(table.concat(shuffle {1, 2, 3, 4, 5, 6, 7, 8, 9}, " "))
        end

    end
}

Ch7IO {
    simpleIO = function()

        local simple = function()
            io.input("eightqueen.lua")
            local f = io.read("a")
            f = string.gsub(f, "queen", "king")
            io.write(f)
            print(f)
        end

        local bylines = function()
            for _ = 1, math.huge do
                local line = io.read("L")
                if line == nil then break end
                io.write(line)
            end
        end

        local sortfile = function()
            local lines = {}
            for line in io.lines() do lines[#lines + 1] = line end
            table.sort(lines)

            for _, l in pairs(lines) do io.write(l, "\n") end
        end

        local block = function()
            while true do
                local block = io.read(2 ^ 3) -- read 8 bytes.
                if not block then break end
                io.write("write: \n")
                io.write(block)
            end
        end
    end
}

Ch8Gaps = {

    scope = function()
        local i = 10
        x = "a"
        if i > 20 then
            local x = "b"
            print(x)
        else
            print(x)
        end
    end,

    doblock = function()
        local x1, x2
        local a = 10
        do
            local a2 = 2 * a
            local d = a2 ^ 2
            x1 = a2 + d
            x2 = a2 - d
        end
        print(x1, x2)
    end,

    returnlimit = function() -- return must be next to a end keyword.
        local function foo(x)
            if x > 10 then
                do return 10 end -- use do block to return in the middle
            end
            return x
        end
    end,

    mazegame = function()
        local function info(name)
            print("::::: You are in " .. name .. ":::::")
            print("go east or south?")
            io.write("e/s: ")
        end

        goto room1
        ::room1::
        do
            info("room 1")
            local move = io.read()
            if move == "s" then
                goto room3
            elseif move == "e" then
                goto room2
            else
                print("invalid move")
                goto room1
            end
        end

        ::room2::
        do
            info("room 2")
            local move = io.read()
            if move == "s" then
                goto room3
            elseif move == "e" then
                goto room1
            else
                print("invalid move")
                goto room2
            end
        end

        ::room3::
        do
            info("room 3")
            local move = io.read()
            if move == "s" then
                goto room1
            elseif move == "e" then
                goto room4
            else
                print("invalid move")
                goto room2
            end
        end

        ::room4::
        do print("You win") end
    end

}

-- Part II

Ch9Closure {

    trysort = function()
        local network = {
            {name = "grauna", Ip = "210.26.30.34"},
            {name = "arraial", Ip = "210.26.30.23"},
            {name = "lua", Ip = "210.26.30.12"},
            {name = "derain", Ip = "210.26.23.20"}
        }
        table.sort(network, function(a, b) return a.name > b.name end)
        return network
    end,

    derivate = function(f, delta)
        delta = delta or 1e-4
        return function(x) return (f(x + delta) - f(x)) / delta end
    end,

    lib = function()
        local Lib = {}
        Lib.foo = function(x, y) return x + y end
        Lib.bar = function(x, y) return x - y end
        print(Lib.foo(1, 2))
        print(Lib.bar(1, 2))
    end,

    localfunction = function()
        local fact -- declare local first, so it is defined in recursive call.
        fact = function(n)
            if n == 0 then
                return 1
            else
                return n * fact(n - 1)
            end
        end
        print(fact(10))
    end,

    closure = function()
        local function newCounter()
            local count = 0
            return function()
                count = count + 1
                return count
            end
        end
        local c1 = newCounter() -- two different closures.
        local c2 = newCounter()
        print("c2")
        print(c2())
        print(c2())
        print(c2())
        print(c2())
        print("c1")
        print(c1())
        print("c2")
        print(c2())
    end,

    redefine = function()
        do
            local oldsin = math.sin
            local k = math.pi / 180 -- degree to rad
            math.sin = function(x) return oldsin(x / k) end
            -- run
            local thetadegree = 90
            local thetarad = thetadegree * k
            print(math.sin(thetarad)) -- rad sin
            math.sin = oldsin
            print(math.sin(thetadegree)) -- degree sin
        end
    end,

    secureenv = function() -- varify the access to file system.
        do
            local oldopen = io.open
            local accessok = function(filename, mode)
                return true -- fake check.
            end
            io.open = function(filename, mode) -- sandbox open
                if accessok(filename, mode) then
                    return oldopen(filename, mode)
                else
                    return nil, "access denies"
                end
            end
        end
    end,

    Geosystem = {
        shape = {
            disk = function(cx, cy, r)
                return function(x, y)
                    return (x - cx) ^ 2 + (y - cy) ^ 2 <= r ^ 2
                end
            end,

            rect = function(l, r, b, t)
                return function(x, y)
                    return l <= x and x <= r and y <= t and b <= y
                end
            end
        },

        op = {

            complement = function(r)
                return function(x, y) return not r(x, y) end
            end,

            union = function(r1, r2)
                return function(x, y) return r1(x, y) or r2(x, y) end
            end,

            inserect = function(r1, r2)
                return function(x, y)
                    return r1(x, y) and r2(x, y)
                end
            end,

            difference = function(r1, r2)
                return function(x, y)
                    return r1(x, y) and not r2(x, y)
                end
            end,

            translate = function(r, dx, dy)
                return function(x, y) return r(x - dx, y - dx) end
            end
        },

        plot = function(r, m, n) -- portable bitmap.
            io.write("P1\n", m, " ", n, "\n")
            for i = 1, n do
                local y = (n - i * 2) / n
                for j = 1, m do
                    local x = (j * 2 - m) / m
                    io.write(r(x, y) and "1" or "0")
                end
                io.write("\n")
            end
        end
    }
}

Ch10PatternMatching = {

    findsub = function()
        local str = "good morning =="
        print(string.sub(str, string.find(str, "morning")))
    end,

    gs = function()
        local s = string.gsub("Lua is cute", "cute", "great")
        print(s)
        s = string.gsub("Lua lua lua is cute", "lua", "Lua", 1)
        print(s)
    end,

    gm = function()
        local s = "some string"
        local words = {}
        for w in string.gmatch(s, "%a+") do words[#words + 1] = w end
        print(table.concat(words, ", "))
    end,

    matchdate = function()
        local date = "Today is 20/4/2020"
        local d = string.match(date, "%d+/%d+/%d+")
        print(d)
    end,

    charset = function()
        local text = "I think to myself, what a wonderful world"
        local nvowtext, nvow = string.gsub(text, "[AEIOUaeiou]", "*")
        print(nvowtext)
        print(nvow)
    end,

    matchlispparen = function()
        local lisp = "(define a (+(((((lisp)))))))"
        local function foo(str)
            if str == nil then return end
            print(str)
            print(":::::::::::::")
            local res = str:match("%((.*)%)")
            local parenopen = res:find("%(")
            local a, parenclose = res:find(".*" .. "%)" .. "()")
            print(parenopen, parenclose)
            if parenopen and parenclose then
                foo(res:sub(parenopen, parenclose))
            end
        end
        foo(lisp)
    end,

    capture1 = function()
        local pair = "name = Anna"
        local key, value = string.match(pair, "(%a+)%s=%s*(%a+)")
        print(key, value)
    end,

    capture2 = function()
        local date = "Today is 18/7/1020"
        local day, mon, year = string.match(date, "(%d+)/(%d+)/(%d+)")
        print(day, mon, year)
    end,

    capture3 = function()
        local s = [[Then he said: "It's all right!"]]
        local _, quotedPart = string.match(s, "([\"'])(.-)%1") -- - lazy verison of *
        print(quotedPart)
    end

}

Ch11MostFrequentWords = {

    mfw = function(filename, n)
        local counter = {}
        io.input(filename)
        for line in io.lines() do
            for word in string.gmatch(line, "%w+") do
                counter[word] = (counter[word] or 0) + 1
            end
        end
        local words = {}
        for w in pairs(counter) do words[#words + 1] = w end
        table.sort(words, function(w1, w2)
            return
                counter[w1] > counter[w2] or counter[w1] == counter[w2] and w1 <
                    w2
        end)
        for i = 1, n do io.write(words[i], "\t", counter[words[i]], "\n") end
    end

}

Ch12Datetime {
    time = function() print(os.time()) end,

    date = function() print(os.date("%d/%m/%Y", os.time())) end,

    datealgebra = function()
        local t = os.date("*t")
        print(os.date("%Y/%m/%d", os.time(t)))
        t.day = t.day + 40
        print(os.date("%Y/%m/%d", os.time(t)))
    end,

    datediff = function()
        local t1 = os.time({year = 2020, month = 1, day = 12})
        local t2 = os.time({year = 2020, month = 4, day = 11})
        local d = os.difftime(t2, t1)
        print(d // (24 * 3600))
    end
}

Ch13BitsandBytes {

    bitwise = function()
        print(string.format("%x", 0xff & 0xabcd))
        print(string.format("%x", 0xff | 0xabcd))
        print(string.format("%x", 0xaaaa ~ -1))
        print(string.format("%x", ~2 ^ 8))
        print(string.format("%x", -1))
        print(string.format("%x", 0xff << 12))
        print(string.format("%x", 0xff >> -12))
    end,

    udiv = function(n, d)
        if d < 0 then -- if d > 2^63
            if math.ult(n, d) then
                return 0
            else
                return 1
            end
        end
        local q = ((n >> 1) // d) << 1
        local r = n - q * d
        if not math.ult(r, d) then q = q + 1 end
        return q
    end

}

Ch14Datastructure {

    matrix1 = function(m, n)
        local mt = {}
        for i = 1, n do
            local row = {}
            mt[i] = row
            for j = 1, m do row[j] = 0 end
        end
        return mt
    end,

    matrix2 = function(m, n)
        local mt = {}
        for i = 1, n do
            local aux = (i - 1) * m
            for j = 1, m do mt[aux + j] = 0 end
        end
        return mt
    end,

    sprasematirix = function(a, b)
        local c = {}
        for i = 1, #a do
            local resultline = {}
            for k, va in pairs(a[i]) do -- nil will not be visited.
                for j, vb in pairs(b[k]) do
                    local res = (resultline[j] or 0) + va * vb
                    resultline[j] = (res ~= 0) and res or nil
                end
                c[i] = resultline
            end
        end
        return c
    end,

    linkedlist = function()
        local push = function(li, val)
            if li == nil then return {next = nil, value = val} end
            local res = {next = li, value = val}
            return res
        end
        local list = nil
        for i = 1, 100 do list = push(list, i) end
        local head = list
        while head ~= nil do
            print(head.value)
            head = head.next
        end
    end,

    deque = function()
        local function listNew() return {first = 0, last = -1} end
        local function pushl(list, val)
            local first = list.first - 1
            list[first] = val
        end
        local function pushr(list, val)
            local last = list.last + 1
            list[last] = val
        end
        local function popl(list)
            local first = list.first
            if first > list.last then error("list is empty") end
            local value = list[first]
            list.first = first + 1
            return value
        end
        local function popr(list)
            local last = list.last
            if last < list.first then error("list is empty") end
            local value = list[last]
            list.last = last - 1
            return value
        end
    end,

    setsandbags = function()
        local function Set(list)
            local set = {}
            for _, l in ipairs(list) do set[l] = true end
            return set
        end
        local reserved = Set {"while", "end", "function", "local"}
        print("is def a reserved word?: ", reserved["def"])
    end,

    stringbuffer = function()
        local buffer = {}
        for line in io.lines() do buffer[#buffer + 1] = line .. "\n" end
        local s = table.concat(buffer)
        print(s)
    end,

    graphs = function()
        local function name2node(graph, name)
            local node = graph[name]
            if not node then
                node = {name = name, adj = {}}
                graph[name] = node
            end
            return node
        end

        local function readgraph()
            local graph = {}
            for line in io.lines() do
                local namefrom, nameto = string.match(line, "(%S+)%s+(%S+)")
                local from = name2node(graph, namefrom)
                local to = name2node(graph, nameto)
                from.adj[to] = true
            end
            return graph
        end

        local function findpath(curr, to, path, visited)
            path = path or {}
            visited = visited or {}
            if visited[curr] then return nil end
            visited[curr] = true
            path[#path + 1] = curr
            if curr == to then return path end
            for node in pairs(curr.adj) do
                local p = findpath(node, to, path, visited)
                if p then return p end
            end
            table.remove(path)
        end
    end

}

Ch15DataFilesAndSerialization {dof = function() do end end}
-- a coroutine based operating system scheduler emulator.

(* For modules we can also have values, types, and functions
 * *)

signature STACK =
sig
  type 'a stack
  exception EmptyStack

  val empty : 'a stack
  val isEmpty : 'a stack -> bool
  val push : ('a * 'a stack) -> 'a stack
  val pop : 'a stack -> 'a stack
  val peek : 'a stack -> 'a
  val map: ('a -> 'b)  -> 'a stack -> 'b stack
end

(* Functor takes a structure, return a new structure.
 * We can ensure the strucuture being passed in as parameter
 * implemented certain signature. It works like typeclass constraint.
 *
 * It's kind like higher kinded type.
 * *)

functor QueueFN (S:STACK) =
struct
  type 'a queue = 'a S.stack * 'a S.stack
  exception EmptyQueue

  val empty : 'a queue = (S.empty, S.empty)
  fun isEmpty ((s1, s2) : 'a queue) =
    S.isEmpty s1 andalso S.isEmpty s2

  fun enqueue (x : 'a, (s1, s2) : 'a queue) : 'a queue = (S.push (x, s1), s2)

  fun rev (s: 'a S.stack): 'a S.stack = let
    fun loop (old: 'a S.stack, new: 'a S.stack): 'a S.stack =
      if S.isEmpty old
      then new
      else loop (S.pop old, S.push(S.peek old, new)) in
        loop (s, S.empty)
  end

  fun dequeue ((s1, s2) : 'a queue) : 'a * 'a queue =
    if S.isEmpty s2
    then dequeue(S.empty, S.pop (rev s1)) handle S.EmptyStack => raise EmptyQueue
    else let
      val top = S.peek s2
      val q = (s1, S.pop s2 ) in
        (top, q) end

  fun map (f: 'a -> 'b) ((s1, s2) : 'a queue) : 'b queue =
    (S.map f s1, S.map f s2)
end

(* implement the stack *)
structure Stack :> STACK =
struct
  type 'a stack = 'a list
  exception EmptyStack

  val empty = [];
  fun isEmpty n = isEmpty n;
  fun push (n, xs) = n::xs;
  fun pop [] = raise EmptyStack
    | pop (x::xs) = xs

  fun peek [] = raise EmptyStack
    | peek (x::xs) = x

  fun map f [] = []
    | map f (x::xs) =
    let
      val v = f x
      val rest = map f xs in
        v::rest end
end

structure s = Stack;
structure queue1 = QueueFN(s);

signature ORDER = sig
  type element
  val compare : element * element -> order
end

functor BinarySearchTreeFn(O:ORDER) =
struct
  datatype 'a tree = Leaf
                   | Tree of 'a tree * 'a  * 'a tree
end

functor Dinctionary(O:ORDER) =
struct
  datatype ('a, 'b) dictionary = Dict of ('a * 'b) list
end
signature QUEUE =
sig
  type 'a queue
  exception QueueError
  val empty     : 'a queue
  val isEmpty   : 'a queue -> bool
  val singleton : 'a -> 'a queue
  val insert    : 'a * 'a queue -> 'a queue
  val peek      : 'a queue -> 'a
  val remove    : 'a queue -> 'a * 'a queue
end

structure TwoLisQueue :> QUEUE =
struct
  type 'a queue = 'a list * 'a list
  exception QueueError

  val empty = ([], [])
  fun isEmpty ([], []) = true
    | isEmpty _ = false

    fun singleton a = ([], [a])

  fun insert (a, ([], [])) = ([], [a])
      | insert (a, (ins, outs)) = (a::ins, outs)

  fun peek (_, []) = raise QueueError
    | peek (ins, a::outs) = a

  fun remove (_, []) = raise QueueError
    | remove (ins, [a]) = (a, ([], rev ins))
    | remove (ins, a::outs) = (a, (ins, outs))
end
val rent = 100
val negative = ~20
val diameter = 700 : int
val value = true : bool

(* ml list and characters *)
val bar = [#"H", #"e", #"l", #"l", #"o"]

val numbers = [1, 2, 3, 4, 5]

(* :: is cons ins tead of type signature *)
val numbers1 = 12 :: numbers

val guest_list = "Mon" :: "Dad" :: "Aund" :: []
val person = ("Person", 1)

(* record  {b:real, g:real, r:real}*)
val rgb = { r=0.32, g=0.56, b=0.91 }

val Hsv = {H=310.3, s=0.51, v=0.23}

(* sugar to get value out of records *)
val H = #H Hsv

(* define functions *)

fun thermometer temp =
  if temp < 37
  then "Cold"
  else if temp > 37
  then "Worm"
  else "Normal"

fun fib n =
  if n = 0 then 0 else
    if n = 1 then 1 else
      fib (n - 1) + fib (n - 2)

val x = fib 5

(* pattern matching *)
fun first (x::xs) = x;
fun second (x::y::xs) = y;

  (* pattern matching uses guard syntax in haskell... *)
fun on_even_idx (odd::even::xs) = even::on_even_idx xs
  | on_even_idx [odd] = []
  | on_even_idx [] = [];

  (* type alias*)
type loc = real * real

val locx = (1.1, 2.2) : loc

(* adt *)
datatype shape
  = Circle of loc * real
  | Square of loc * real
  | Trig of loc * loc * loc;

fun dist ((x0, y0), (x1, y1)) =
  let
    val dx = x1 - x0;
    val dy = y1 - y0;
  in Math.sqrt (dx * dx + dy * dy)
end

fun heron (a, b, c) = let
  val ab = dist (a, b)
  val bc = dist (b, c)
  val ac = dist (a, c)
  val perim = ab + bc + ac
  val s = perim / 2.0
in
  Math.sqrt (s * (s - ab) * (s - bc) * (s - ac))
end;

fun area (Circle (_, r)) = 3.14 * r * r
  | area (Square (_, s)) = s * s
  | area (Trig (a, b, c)) = heron (a, b, c); (* see above *)

  (* polymorphism *)
  (* one catch, to construct a record type you use the same
   * syntax as tuple.
   * (I think this makes more sense though, if records are really the same
   * as tuple...)
   * *)

datatype 'a btree = Leaf of 'a
                  | Node of 'a btree * 'a * 'a btree;

val mytree = Node (Leaf 3, 8, Node (Leaf 8, 5, Leaf 10));

fun count (Leaf n) = 1
  | count (Node (left, n, right)) = count left + 1 + count right;

count mytree
(* mlton wants every files has a module to export.
 * In sml, files means very little. the logical separations
 * between different parts of the program is defined by different
 * modules.
 * You can think mlton will conceptually combine all files  together
 * before compile, so at compile time it will know the existence of all
 * modules.
 *
 * Of course this doesn't work for separate compilation, which is a good thing
 * to persue. We want to be able to compile only part of the dependency graph
 * when there are changes.
 *
 * This is why we also have cm, compilation manager to help us to do incremental
 * compilation.
 * *)
structure Hello =
struct
  fun hello () = print "Hello, world\n";
  fun main () = hello ();

  (* nested  structure definition *)
  structure Math =
  struct
    fun add (a, b) = a + b;
    fun minus (a, b) = a - b;
    fun multiply (a, b) = a * b;
    fun divide (a, b) = a / b;
  end

  structure Math1 =
  struct
    fun sqrt x = let open Math in multiply (x, x) end
    fun cube x = Math.multiply (x, Math.multiply (x, x))
    end

    (* You still have currying, but people like to use tuple for
     * some reason.
     * *)
  fun add1 a b = a + b;

  structure Dog =
  struct
    datatype dogs = Hasky
                  | Shiba
                  | Chiwawa;
    fun bark Hasky = "Woof"
      | bark Shiba = "Wooof"
      | bark Chiwawa = "wooc";

  end
  end

  signature MAP =
  sig
    type key
    type 'a table

    val empty : 'a table
    val insert : key -> 'a -> 'a table -> 'a table
    val lookup : key -> 'a table -> 'a option
end


(* We defined a signature for queue.
 * You can think it as a typeclass with type family + data family maybe?
 * *)
 signature QUEUE =
 sig
   type 'a queue
   exception QueueError
   val empty : 'a queue
   val isEmpty : 'a queue -> bool
   val singleton : 'a -> 'a queue
   val insert : 'a * 'a queue -> 'a queue
   val peek : 'a queue -> 'a
   val remove : 'a queue -> 'a * 'a queue
  end

  (* Provide an implementation *)
structure TwoListQueue :> QUEUE =
struct
  type 'a queue = 'a list * 'a list
  exception QueueError

  val empty = ([], [])

  fun isEmpty ([], []) = true
    | isEmpty _ = false

  fun singleton a = ([], [a])

  fun insert (a, ([], [])) = ([], [a])
    | insert (a, (ins, outs)) = (a::ins, outs)

  fun peek (_, []) = raise QueueError
    | peek (ins, a::outs) = a

  fun remove (_, []) = raise QueueError
    | remove (ins, [a]) = (a, ([], rev ins))
    | remove (ins, a::outs) = (a, (ins, outs))
 end

 functor BFS (structure Q: QUEUE) = (* after Okasaki, ICFP, 2000 *)
 struct
   datatype 'a tree = E
                    | T of 'a * 'a tree * 'a tree

   fun bfsQ (q  : 'a tree Q.queue)  : 'a list =
     if Q.isEmpty q
     then []
     else let val (t, q') = Q.remove q in
       case t of E => bfsQ q'
          | T (x, l, r) => let
            val q'' = Q.insert (r, Q.insert (l, q')) in
              x  :: bfsQ q'' end end
   fun bfs t = bfsQ (Q.singleton t)
  end
(* ML module system is also responsible for abstraction *)

structure Main =
struct
  open Hello
  val _ = main ()
end
(* Some quirks with sml's type system. sml's type system has been
 * like this since sml 97, so it doesn't have all the fancy support
 * that haskell provides.
 * For instance, there is no rankNtype, and there is these value restruction
 * because of imperative code.
 * *)


structure Restriction =
struct
(* Hidley milner let's sml infer types easily
 * We can tell map : ('a list -> 'b list) -> 'a list -> 'b list
 * right away.
 * *)
  fun map _ [] = []
    | map f (x::xs) = (f xs) :: map f xs;


  (* but there is no subtyping, e.g int and real are different
   * *)

  (* no overload from types, this functions only works for one type
   * (like monomorphization)
   * *)
  fun sqr n = n * n;

  (* equality doesn't work for some types (namely types with function) *)
  fun member (k, []) = false
    | member (k, x::xs) = (x = k) orelse member (k, xs);

  (* no rank N type TAT *)

  (* and the value restriction because of imperative code
   * Basically value restriction means you can only have your
   * syntatic types to be infered as polymorphic.
   * Types like literals, fn, and constructors are ok, but you can't
   * infer types for record. (note fn as lambda)
   * You need to use eta expansion to make expression into a context to
   * allows it to be polymorphic. Example:
   * *)

   val revlists' = map rev; (* in this case it doesn't know what rev is *)

   val revlists = (fn xs => map rev xs); (* works wit eta expansion. *)

  (* The reason why you need value restriction is because sml support imperative
   * programming, and that makes it possible to instantiate a same type
   * parameter in different steps, and violate type safty.
   * *)

   (* a harmless oo example that keeps the type safty *)
    val account =
      let
        val bal = ref 1000 in
          { deposit = fn d => bal := !bal + d,
            balance = fn () => !bal
          }
      end

    (* but this one allows you to do something wacky *)
  val stack =
    let
      val stk = ref [] in
        { push = fn x => stk := x :: !stk,
          pop = fn () => stk := tl (!stk),
          top = fn () => hd (!stk)
        }
    end;

    (* you can push a int and use it as a bool.... *)

end

(* http://users.cs.fiu.edu/~smithg/cop4555/valrestr.html *)
(* https://jozefg.bitbucket.io/posts/2015-03-27-unsafe.html *)
"""
Baseline algorithm. Contains random prediction and zero rule alorithm
For classification now.

2019-05-16
"""
from typing import Union
import numpy as np
from random import seed, randrange


def random_prediction(labels: np.ndarray,
                      test_labels: np.ndarray) -> np.ndarray:
    """
    dumb ass
    """
    seed(1)
    unique: list = list(set(labels))

    test_len: int = len(test_labels)
    predicts: np.ndarray = np.zeros(test_len)  # fixed size array.

    for i, row in enumerate(test_labels):
        rand_index = randrange(len(unique))
        predicts[i] = unique[rand_index]
    return predicts


def zero_rule(labels: np.ndarray,
              test_labels: np.ndarray, mode="clf") -> np.ndarray:
    """
    mode == 'classification': classification,
         == 'regression': regression.
    zero_rule choose the most frequent label in labels.
    """
    seed(1)
    labels = list(labels)
    prediction: Union[int, float] = 0

    test_len: int = len(test_labels)
    predicts: np.ndarray = np.zeros(test_len)

    if mode == "reg":
        prediction = sum(labels) / float(len(labels))
    elif mode == "clf":  # default prediction.
        prediction = max(set(labels), key=labels.count)

    for i in range(test_len):
        predicts[i] = prediction
    return predicts
"""
Hand made Classification and Regression Tree.
It has two cost function with respect to classification
problems and Regression problems.
"""
import numpy as np
from .baseline_algorithms import zero_rule


class DecisionTree:
    """
    a simple CART
    """
    def __init__(self, X: np.ndarray, Y: np.ndarray, maxdepth: int,
                 minnodes: int):
        self.X: np.ndarray = X
        self.Y: np.ndarray = Y
        self.maxdepth = maxdepth
        self.minnodes = minnodes
        self.labels: list = list(set(Y))

    def train(self) -> None:
        pass

    def predict(self) -> np.ndarray:
        pass

    def __split(self):
        """ split accrodig to the smallest gini index """
        pass

    def __split_one(self):
        """ split accroding to one attribute """
        pass

    def gini_index(self, groups_x: np.ndarray, groups_y: np.ndarray) -> float:
        """
        calculate the gini index
        given a split dataset, calculate the gini for this specific splition

        groups_x: splited featrues
        groups_y: splited labels
        """
        # count number of samples
        total_samples: float = float(sum([len(gx) for gx in groups_x]))
        labels_set = set(self.Y)  # the category of labels
        gini: float = 0.0
        for gx, gy in list(zip(groups_x, groups_y)):
            size = float(len(gx))  # the size of sample in one group
            if size == 0:
                continue

            score: float = 0.0
            for label_val in labels_set:
                propotion = list(gy).count(label_val) / size
                score += propotion ** 2
            gini += (1.0 - score) * (size / total_samples)
        return gini

    def __terminal(self):
        """ create terminal node """
        pass

    def build_tree(self):
        pass
"""
Hand made average perceptron.
It only make binary classification.
The average penalty make it adapts for even extremely
deistributed data.
"""
import numpy as np


class Perceptron:
    def __init__(self, X: np.ndarray, Y: np.ndarray, maxiter: int):
        """
        X: training data
        Y: training label
        make sure Y in {1, -1}
        """
        self.X = X  # Train data
        self.Y = Y  # Train label
        self.max_iter: int = maxiter
        self.activation: float = 0.0
        self.w: np.ndarray = np.zeros(X.shape[1])
        self.b: float = 0

        # penalty for overfitting.
        self.mu: np.ndarray = np.zeros(X.shape[1])
        self.beta: float = 0
        self.count = 1

    def train(self) -> None:
        # make sure shapes of matrices are correct.
        assert self.X.shape[0] == self.Y.shape[0] and \
                self.X.shape[1] == self.w.shape[0] and \
                self.max_iter < len(self.X)

        for i in range(0, self.max_iter):
            for x, y in list(zip(self.X, self.Y)):
                self.activation = np.dot(self.w, x) + self.b
                if self.activation * y <= 0:
                    self.w = self. w + y * x  # reweight.
                    self.b = self.b + y

                    self.mu = self.mu + y * self.count * x
                    self.beta = self.beta + y * self.count
                self.count += 1

        # get avg weight and bias.avoid overfitting.
        self.w = self.w - (1 / self.count) * self.mu
        self.b = self.b - (1 / self.count) * self.beta

    def predict(self, x_test: np.ndarray) -> np.ndarray:
        """
        x: test data, a MxN matrix.
        """
        predict_list: np.ndarray = []

        for xh in x_test:
            predict_list.append(self.__predict_one(xh))
        return predict_list

    def accuracy(self, predicts: np.ndarray, y_test: np.ndarray) -> None:
        """
        Show the predict result.
        """
        accuracy: float = 0.0
        print("============ Comparing ===============")
        for pr, t in list(zip(predicts, y_test)):
            if pr == t:
                accuracy += 1
                print("bingo", pr, t)
            else:
                print("miss", pr, t)
        print("======================================")
        accuracy = accuracy / len(predicts)
        print("accuracy of hand made perceptron is {}".format(accuracy))

    def __predict_one(self, x: np.ndarray) -> int:
        self.activation = np.dot(self.w, x) + self.b
        return int(np.sign(self.activation))
import sys
sys.path.append("../")
from sklearn import datasets
from soylearn import baseline_algorithms as baseline_algo

bc = datasets.load_breast_cancer()
boston = datasets.load_boston()

random_pre_clf = baseline_algo.random_prediction(
        bc.target[:200], bc.target[200:])
random_pre_reg = baseline_algo.random_prediction(
        boston.target[:200], boston.target[200:])

z_r_clf = baseline_algo.zero_rule(
        bc.target[:200], bc.target[200:], mode="clf")
z_r_reg = baseline_algo.zero_rule(
        boston.target[:200], boston.target[200:], mode="reg")

print("random prediction clf: ", random_pre_clf, "\n===============")
print("random prediction reg: ", random_pre_reg, "\n===============")
print("zero rule clf: ", z_r_clf, "\n===============")
print("zero rule reg: ", z_r_reg, "\n===============")
import sys
sys.path.append("../")
from soylearn.decisionTree import DecisionTree
from sklearn.datasets import load_breast_cancer

bc = load_breast_cancer()

t = DecisionTree(bc.data, bc.target, 0, 0)

gini = t.gini_index([bc.data[:50], bc.data[50:100]], [bc.target[:50], bc.target[50:]])
print(gini)
import sys
sys.path.append("../")
import numpy as np
from sklearn import datasets
from soylearn import perceptron


# preamble, change all 0 in data to -1
breast_cancer = datasets.load_breast_cancer()
bc_data = breast_cancer.data
bc_target = np.array([-1 if b == 0 else 1 for b in breast_cancer.target])

accuracy = 0.0
predicts: np.ndarray = []
X_train = bc_data[:400]
Y_train = bc_target[:400]

X_test = bc_data[400:500]
Y_test = bc_target[400:500]

p = perceptron.Perceptron(X_train, Y_train, maxiter=350)
p.train()

predicts = p.predict(X_test)
p.accuracy(predicts, Y_test)

# load iris dataset.
from sklearn.datasets import load_iris
iris = load_iris()

# feature and label
X = iris.data
y = iris.target

# seperate data into training set and test set.
from sklearn.model_selection import train_test_split
# random_state = 200 is a magic number for this model. DNW
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=200)


# trainning the model on trainning set
from sklearn.naive_bayes import GaussianNB
gnb = GaussianNB()
gnb.fit(X_train, y_train)

# making prediction on the test set
y_pred = gnb.predict(X_test)

# compare actual response value with predicted value
from sklearn import metrics
print("gnb Accuracy {}".format(metrics.accuracy_score(y_test, y_pred) * 100))
import time
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from sklearn import svm
from sklearn import datasets

# treat the first line of csv as table header.
raw_data = pd.read_csv("./train_binary.csv", header=0)
data = raw_data.values

# column 1 is the pos for labels data.
# [ 1 0 0 ]
# [ 1 0 0 ]
# [ 1 0 0 ]
# [ 1 0 0 ]
# The csv is too big.
# features = data[::, 1::]
# labels = data[::, 0]

iris = datasets.load_iris()
features = iris.data
labels = iris.target

# split data into training data and test data.
train_features, test_features, train_labels, test_labels = \
    train_test_split(
            features, labels, test_size=0.33, random_state=0)

start_time = time.time()
print("Starting training...")
# using SVM
classifier = svm.SVC()
classifier.fit(train_features, train_labels)
end_time = time.time()
print("training cost {} seconds".format(start_time - end_time))

print("Start predicting")
test_predict = classifier.predict(test_features)

score = accuracy_score(test_labels, test_predict)
print("The accuracy is {}".format(score))
import numpy as np
import matplotlib.pyplot as plt

from sklearn.cluster import KMeans
from sklearn.datasets import make_blobs

plt.figure(figsize=(12,12))

# make samples.
n_samples = 1000
random_state = 200
X, y = make_blobs(n_samples=n_samples, random_state=random_state)
# note

# Incorrect # of clusters.
y_pred = KMeans(n_clusters=2, random_state=random_state).fit_predict(X)

plt.subplot(221)
plt.scatter(X[:, 0], X[:, 1], c=y_pred)
plt.title("Incorrect # of Blobs")

# Anisotropicly distributed data
transformation = [[0.60834549, -0.63667341],
                  [-0.40887718, 0.85253229]]
X_ansio = np.dot(X, transformation)
y_pred = KMeans(n_clusters=3, random_state=random_state).fit_predict((X_ansio))

plt.subplot(222)
plt.scatter(X_ansio[:, 0], X_ansio[:, 1], c=y_pred)
plt.title("Anisotropicly Distributed Bolbs")

# Different variance
X_varied, y_varied = make_blobs(n_samples=n_samples,
                                cluster_std=[1.0, 2.5, 0.1],
                                random_state=random_state)
y_pred = KMeans(n_clusters=3, random_state=random_state).fit_predict(X_varied)

plt.subplot(223)
plt.scatter(X_varied[:, 0], X_varied[:, 1], c=y_varied)
plt.title("Unequal Variance")

# unevenly sized bolbs
X_filtered = np.vstack(
        (X[y == 0][:500], X[y == 1][:100], X[y == 2][:10]))
y_pred = KMeans(n_clusters=3,
                random_state=random_state).fit_predict(X_filtered)

plt.subplot(224)
plt.scatter(X_filtered[:, 0], X_filtered[:, 1], c=y_pred)
plt.title("Unevenly Sized Blobs")

plt.show()

# Plot dendrogram of a hierarchical clustering
# with AgglomerativeClustering

import numpy as np
from matplotlib import pyplot as plt
from scipy.cluster.hierarchy import dendrogram
from sklearn.datasets import load_iris
from sklearn.cluster import AgglomerativeClustering


def plot_dendrogram(model: AgglomerativeClustering, **kwargs):
    counts = np.zeros(model.children_.shape[0])
    n_samples: int = len(model.labels_)
    for i, merge in enumerate(model.children_):
        current_count = 0
        for child_idx in merge:
            if child_idx < n_samples:
                current_count += 1
            else:
                current_count += counts[child_idx - n_samples]
        counts[i] = current_count
    linkage_matrix = np.column_stack([model.children_,
                                      model.distances_,
                                      counts]).astype(float)
    dendrogram(linkage_matrix, **kwargs)


if __name__ == "__main__":
    iris = load_iris()
    X = iris.data

    # setting distance_threshold=0 to ensures we compute the entire full tree.
    model = AgglomerativeClustering(distance_threshold=0, n_clusters=None)
    model = model.fit(X)

    plt.title("Hierachical Clustering Dendrogram")
    plot_dendrogram(model, truncate_mode='level', p=3)
    plt.xlabel("NUmber of points in node (index of point if no parenthesis).")
    plt.show()

import numpy as np
import matplotlib.pyplot as plt

from sklearn.cluster import KMeans
from sklearn.datasets import make_blobs


def subplot(pos: int, x, y, c, title: str):
    plt.subplot(pos)
    plt.scatter(x, y, c=c)
    plt.title(title)


plt.figure(figsize=(12, 12))

n_samples = 1500
random_state = 170
X, y = make_blobs(n_samples=n_samples, random_state=random_state)

# incorrect number of clusters
y_pred = KMeans(n_clusters=2, random_state=random_state).fit_predict(X)

subplot(221, X[:, 0], X[:, 1], c=y_pred, title="Incorrect number of blobs")

# Anisotropicly distributed data
transformation = [[0.60834549, -0.63667341], [-0.40887718, 0.85253229]]
X_aniso = np.dot(X, transformation)
y_pred = KMeans(n_clusters=3, random_state=random_state).fit_predict(X_aniso)

subplot(222, X_aniso[:, 0], X_aniso[:, 1],
        c=y_pred, title="Anisotropicly distributed blobs")

# Different variance
X_varied, y_varied = make_blobs(n_samples=n_samples,
                                cluster_std=[1.0, 2.5, 0.5],
                                random_state=random_state)
y_pred = KMeans(n_clusters=3, random_state=random_state).fit_predict(X_varied)

subplot(223, X_varied[:, 0], X_varied[:, 1],
        c=y_pred, title="Unequal variance")


# Unevenly sized blobs
X_filtered = np.vstack((X[y == 0][:500], X[y == 1][:100], X[y == 2][:10]))
y_pred = KMeans(
    n_clusters=3, random_state=random_state).fit_predict(X_filtered)

subplot(224, X_filtered[:, 0], X_filtered[:, 1],
        c=y_pred, title="Unevenly Sized Blobs")

plt.show()

# Take away:
# - K means might produce unintuitive and unexpected clusters.
import numpy as np
from sklearn import datasets

# load data
iris = datasets.load_iris()
iris_X = iris.data
iris_y = iris.target
np.unique(iris_y)

###################################
# K-Nearest neighbors classifier
###################################

# split iris into train and test data. use random permuation to
# split the data randomly.
np.random.seed(0)
indices = np.random.permutation(len(iris_X))
iris_X_train = iris_X[indices[:-10]]
iris_y_train = iris_y[indices[:-10]]

iris_X_test = iris_X[indices[-10:]]
iris_y_test = iris_y[indices[-10:]]

# create and fit a nearest neighbor classifier.
from sklearn.neighbors import KNeighborsClassifier
knn = KNeighborsClassifier(
            n_neighbors=4,
            weights='distance',
            algorithm='brute'
        )  # classifier or regressor == estimator
knn.fit(iris_X_train, iris_y_train)

iris_y_pred = knn.predict(iris_X_test)

# evaluate the prediction with metrics
from sklearn import metrics
print(
        "KNN accuracy: {}".format(
            metrics.accuracy_score(iris_y_test,
                iris_y_pred) * 100)
     )

# the curse of dimensionality for KNN.

print()
###################################
# Linear Regression
###################################

# to minizie the sum of squared resoduals
from sklearn import linear_model
regr = linear_model.LinearRegression(normalize=True)
regr.fit(iris_X_train, iris_y_train)

print("LinearRegression coef {}".format(regr.coef_))

# The mean square error
np.mean((regr.predict(iris_X_test) - iris_y_test) ** 2)
print(
        "Linear regression accuracy: {}"
        .format(regr.score(iris_X_test, iris_y_test) * 100)
      )
# linear regression with tensorflow

import tensorflow as tf

W = tf.Variable([.3], dtype=tf.float32)
b = tf.Variable([-.3], dtype=tf.float32)

x = tf.placeholder(tf.float32)
linear_model = W * x + b
y = tf.placeholder(tf.float32)

# loss
loss = tf.reduce_sum(tf.square(linear_model - y))  # sum of the square
optimizer = tf.train.GradientDescentOptimizer(0.01)
train = optimizer.minimize(loss)

# training data
x_train = [1, 2, 3, 4]
y_train = [0, -1, -2, -3]

# training loop
init = tf.global_variables_initializer()
sess = tf.Session()
sess.run(init)
for i in range(1000):
    if '00' in str(i):
        print(sess.run([loss], {x: x_train, y: y_train}))
    sess.run(train, {x: x_train, y: y_train})

curr_W, curr_b, curr_loss = sess.run([W, b, loss], {x: x_train, y: y_train})
print("W: {} b: {} loss {}".format(curr_W, curr_b, curr_loss))
import tensorflow as tf
from tensorflow.examples.tutorials.mnist import input_data

minst = input_data.read_data_sets("MNIST_data", one_hot=True)

# declare global vars.
IMG_SZ = 28
LABEL_SZ = 10
LEARNING_RATE = 0.05
STEP_N = 2000
BATCH_SZ = 100

# model y = Wx + b.
# define placeholders.
training_data = tf.placeholder(tf.float32, [None, IMG_SZ**2])
labels = tf.placeholder(tf.float32, [None, LABEL_SZ])

# variables to be tuned.
W = tf.Variable(tf.truncated_normal([IMG_SZ**2, LABEL_SZ], stddev=0.1))
b = tf.Variable(tf.constant(0.1, shape=[LABEL_SZ]))

# build the output layer of the network.
output = tf.matmul(training_data, W) + b

# training process works by optimizing the loss function.
# A common technique: Cross entropy.
loss = tf.reduce_mean(
        tf.nn.softmax_cross_entropy_with_logits(
            labels=labels, logits=output
            )
        )

# train step. GradientDescent oper.
optimizer = tf.train.GradientDescentOptimizer(LEARNING_RATE).minimize(loss)

#
# compare which labels we predicted correct with argmax(.).
correct_prediction = tf.equal(tf.argmax(output, 1), tf.argmax(labels, 1))
accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))

# The actual training session.
sess = tf.InteractiveSession()
sess.run(tf.global_variables_initializer())

for i in range(STEP_N):
    # get the next batch.
    input_batch, labels_batch = minst.train.next_batch(BATCH_SZ)
    feed_dict = {training_data: input_batch, labels: labels_batch}

    optimizer.run(feed_dict=feed_dict)

    if i % 100 == 0:
        train_accuracy = accuracy.eval(feed_dict=feed_dict)
        print("Step %d, training batch accuracy {} {} ".format(i, train_accuracy * 100))
nix-instantiate --eval --strict demo1.nix
# a generic bash build script for all autotools.
set -e          # stop in error
source $setup
genericBuild

export PATH="$gnutar/bin:$gcc/bin:$gnumake/bin:$coreutils/bin:$gawk/bin:$gzip/bin:$gnugrep/bin:$gzip/bin:$gnused/bin:$binutils/bin"
tar -xzf $src
cd hello-2.10
./configure --prefix=$out
make
make install
unset PATH      # clean path
# set up avaiable path parameter.
Inputs=${baseInputs}${baseInputs}
Inputs=(`echo ${Inputs}`)

for p in $Inputs; do   # aquire dependencies
    export PATH=$p/bin${PATH:+:}$PATH
done

function unpackPhase() {
    tar -xf $src

    # cd into decompressed directory.
    for d in *; do
        if [ -d "$d" ]; then
            cd "$d"
            break
        fi
    done
}

function configurePhase() {
    ./configure --prefix=$out
}

function buildPhase() {
    make
}

function installPhase() {
    make install
}

function genericBuild() {
    unpackPhase
    configurePhase
    buildPhase
    installPhase
}
set -e          # stop in error
source $setup
genericBuild

unset PATH      # clean path
Inputs=${baseInputs}${baseInputs}
Inputs=(`echo ${Inputs}`)

for p in $Inputs; do   # aquire dependencies
  export PATH=$p/bin${PATH:+:}$PATH
done

function unpackPhase() {
  tar -xf $src

  # cd into decompressed directory.
  for d in *; do
      if [ -d "$d" ]; then
          cd "$d"
          break
      fi
  done
}

function configurePhase() {
  ./configure --prefix=$out
}

function buildPhase() {
  make
}

function installPhase() {
  make install
}

function genericBuild() {
  unpackPhase
  configurePhase
  buildPhase
  installPhase
}
# 2020-04-29
# builder only build.
# all environment setup relies on setup.sh
# This make it easier to setup a development
# environment in nix-shell
set -e          # stop when error occur.
source $setup
genericBuild

unset PATH              # clean path

# 2020-04-29
# here we concat  baseInputs and buildInputs into one
# it should be paths separated by spaces.
# then convert it to array with ()
# shell is insane.
#
Inputs=${baseInputs}${buildInputs}
Inputs=(`echo ${Inputs}`)

for p in $Inputs; do    # aquire dependencies
  export PATH=$p/bin${PATH:+:}$PATH
done

# 2020-04-29
# Good pattern here
# no matter how trivial the thing is you still
# put it into a function. Just simply name each
# process make things a lot easier.
function unpackPhase() {
  tar -xf $src

  # cd into decompressed directory.
  for d in *; do
      if [ -d "$d" ]; then
          cd "$d"
          break
      fi
  done
}

function configurePhase() {
  ./configure --prefix=$out
}

function buildPhase() {
  make
}

function installPhase() {
  make install
}

function genericBuild() {
  unpackPhase
  configurePhase
  buildPhase
  installPhase
}
#include <stdio.h>
int main(void) {
  puts("Simple!");
  return 0;
}
# 2020-04-29
# $out $src are attributes from the derivation.
# when build they will be put in PATH
# nix create sandbox by playing with PATH a lot.
#
export PATH="$coreutils/bin:$gcc/bin"
mkdir $out
gcc -o $out/simple $src
declare -xp         # declare exported env var
echo foo > $out

open List;;

(* basic structures *)
let averate a b =
  let sum = a +. b in
  sum /. 20.0;;

let f a b =
  let x = a +. b in
  x +. x ** 2.0;;     (* common subexpression elimination *)

let v = List.length [1; 2; 3;];;

let tuple : (int * int * string) = (1, 2, "sd");;

(* named argument *)
let f1 ~name1:arg1 ~name2:arg2 = arg1 + arg2
let f2 ~name1 ~name2 = name1 + name2
let f3 ~name1:(arg1:int) ~name2:(arg2:int) = arg1 + arg2
let f4 ?name:(arg1=9) arg2 = arg1 + arg2

let square a = a * a

let sum xs = List.fold_left (+) 0 xs

(* reverse function composition *)
let sum_sq n =
  [1;2;3;4;5]
  |> List.rev_map square
  |> sum
open List;;

let edges = [
  ("a", "b"); ("a", "c");
  ("a", "d"); ("b", "e");
  ("c", "f"); ("d", "e");
  ("e", "f"); ("e", "g");
];;

let successors n e =
  List.map (fun (_, v) -> v) (List.filter (fun (u, _) -> n = u) e);;

let dfs graph start f =
  let rec rdfs visited node =
    if not (List.mem node visited) then
      begin
        f node;
        let s = successors node graph in
        List.fold_left rdfs (node :: visited) s
      end
    else visited
  in rdfs [] start ;;

let () = let _ = dfs edges "a" print_string in ()
type _ term =
  | Int : int -> int term
  | Add : (int -> int -> int) term
  | App : ('b -> 'a) term * 'b term -> 'a term

let rec eval : type a. a term -> a = function
  | Int n -> n
  | Add -> (fun x y -> x + y)
  | App (f, x) -> (eval f) (eval x)

let two = eval (App (App (Add, Int 1), Int 1))
(* some example of imperative programming in ocaml *)
open Graphics;;

open_graph " 640x480";;

for i = 12 downto 1 do
  let radius = 1 * 20 in
  set_color (if i mod 2 = 0 then red else yellow);
  fill_circle 320 240 radius
done;;

module R = Random;;

open_graph " 640x480";;
let rec iterate r xinit i =
  if i = i then xinit
  else
    let x = iterate r xinit (i - 1) in
    r *. x *. (1.0 -. x);;

for x = 0 to 639 do
  let r = 4.0 *. (float_of_int x) /. 640.0 in
  for i = 0 to 39 do
    let xinit = R.float 1.0 in
    let xfinal = iterate r xinit 500 in
    let y = int_of_float (xfinal *. 480.) in
    plot x y
  done
done;;

read_line ();;
(* all code are wrapped into a module.
 * a module itself can be a submodule of another module.
 * *)


(* Hello with only struct *)
module Hello = struct
  let message = "Hello"
  let hello () = print_endline message
end

let goodbye () = print_endline "Goodbye"

let hello_goodbye () =
  Hello.hello ();
  goodbye ()

(* Hi with signature *)
module Hi = sig
  val hi : unit -> unit
end
=
struct
  let message= "Hi"
  let hi () = print_endline message
end

let hi_goodbye () =
  Hi.hi ();
  goodbye ()


(* playing around with it
 * Really plain old module is just a standalone namespace.
 * *)
module M = struct let x = 43 end

module P = struct
  open M
  let y = x
end

let x = M.x;;
let y = P.y;;

module B1 = struct
  let x = 42

  (* idiomatic way to expose the main type *)
  type t = bool

  (* you can define an exception *)
  exception E

  (* above is the same as this
   * type _ += .. is extensible variants. it allows you to extend
   * the type exn (a extensible variant) with a new constructor E1.
   * *)
  type exn += E1 = E
  module N = struct
    let y = 0
  end
end

(* definitions for signature *)
module type Sig = sig
  val f : int -> int
end

module MSig1 : Sig = struct
  let f x = x + 1
end

module MSig2 : Sig = struct
  let f x = x
end


(* module type
 * used to describe groups of related modules.
 * *)

module type Stack = sig
  type 'a stack
  val empty : unit -> 'a stack
  val is_empty : 'a stack -> bool
  val push : 'a -> 'a stack -> 'a stack
  val peek : 'a stack -> 'a
  val pop : 'a stack -> 'a stack
end

(* classical stack examples *)

(* implement Stack sig *)
module MyStack : Stack = struct
  type 'a stack =
    | Empty
    | Entry of 'a * 'a stack

  let empty () = Empty
  let is_empty s = s = Empty
  let push x s = Entry (x, s)
  let peek = function         (* lambda cases *)
    | Empty -> failwith "Empty"
    | Entry (x,_) -> x
  let pop = function
    | Empty -> failwith "Empty"
    | Entry (_,s) -> s
end

module ListStack : Stack = struct
  type 'a stack = { mutable elements : 'a list }
  let empty () = { elements = [] }
  let is_empty s = s.elements = []
  let push x s = s.elements <- x::s.elements; s
  let pop s =
    match s.elements with
      h::t -> s.elements <- t; s
    | [] -> failwith "Empty"
  let peek s =
    match s.elements with
      h::t -> h
    | [] -> failwith "Empty"
end


(* using modules to do abstraction
 * example, don't mix cashes (although they are all floats)
 * *)

module Float = struct
  type t = float
  let unit = 1.0
  let plus = (+.)
  let prod = ( *. )
end

module type Currency = sig
  type t
  val unit : t
  val plus : t -> t -> t
  val prod : float -> t -> t
end

(* bind the implementation later *)
module Euro = (Float : Currency)
module Dollar = (Float : Currency)

let euro x = Euro.prod x Euro.unit
let dollar x = Dollar.prod x Dollar.unit


(* Functor *)

module type T = sig  (* first define a signature *)
  type t
  val x : t
  val g : t -> t
  val to_string : unit -> string
end

module S1 : T = struct  (* one possible implementation *)
  type t = float
  let x = 10.1
  let g x = x +. 1.
  let to_string () = Format.sprintf "%f" (g x)
end

module S2 : T = struct  (* another possible implementation *)
  type t = int
  let x = 10
  let g x = x + 1
  let to_string () = Format.sprintf "%d" (g x)
end

module F = functor(X : T) ->  (* functor to produce new module from any T *)
  struct
    type u = X.t * X.t
    let y = X.g (X.x)
    let foo (s : int) = Printf.printf "parameter number is %d, X.x is %s" s (X.to_string ())
  end

module FS1 = F(S1)
module FS2 = F(S2)
(* ocaml is object oriented imperative language :)*)

(* polymorphic class *)
class ['a] stack =
  object (self)
    val mutable the_list = ([] : 'a list)

    method push x =
      the_list <- x :: the_list

    method pop =
      let result = List.hd the_list in
      the_list <- List.tl the_list;
      result

    method peek =
      List.hd the_list

    method size =
      List.length the_list
  end;;

(* empty a stack *)
let drain_stack (s : 'a stack) =
  while s#size > 0 do
    ignore (s#pop)
  done;;

(* inheritance, virtual classes, initializer *)

(* virtual class, or abstract class that defines the virtual function *)

(* superclass for all widgets *)
class virtual widget (name : string) =
  object (self)
    method get_name =
      name

    method virtual repaint : unit
  end;;

(* any widget that can contain other widgets
 * Though it doesn't containt any virtual methods, we mark it
 * virtual to prevent people from creating an instance for it.
 * *)
class virtual container name =
  object(self)
    inherit widget name
    val mutable widgets = ([] : widget list)
    method add w =
      widgets <- w :: widgets
    method get_widgetes =
      widgets
    method repaint =
      List.iter (fun w -> w#repaint) widgets
  end;;

type button_state = Released | Pressed;;

(* callback is an optional argument
 * we inherit container as super so we can refer it as super in the
 * class definition.
 * *)
class button ?callback name =
  object (self)
    inherit container name as super
    val mutable state = Released
    method press =
      state <- Pressed;
      match callback with
      | None -> ()
      | Some f -> f ()
    method release =
      state <- Released
    method repaint =
      super#repaint;
      print_endline("Button being repainted, state is " ^
                    (match state with
                    | Pressed -> "Pressed"
                    | Released -> "Released"))
  end;;

(* create a new object *)
class label name text =
  object (self)
    inherit widget name
    method repaint =
      print_endline ("Label " ^ text ^ " from " ^ name)
  end;;


let main1 () =
  Printf.printf "main1 :: \n";
  let b = new button ~callback:(fun () -> print_endline "Ouch!!") "button" in
  let l1 = new label "Label left" "Press me!" in
  let l2 = new label "Label right" "Press me!" in
  b#repaint;
  b#press;
  b#repaint;
  b#add l1;
  b#add l2;
  b#repaint;
  Printf.printf "<<<\n"
  ;;

main1 ();;

(* coerce subcalss explicitly in ocaml *)
let coercison () =
  Printf.printf "coercison :: \n";
  let b = new button ~callback:(fun () -> print_endline "Ouch!!") "button" in
  let l1 = new label "Label left" "Press me!" in
  let l2 = new label "Label right" "Press me!" in
  let wl = [] in
  let wl = (b :> widget) :: wl in
  let wl = (l1 :> widget) :: wl in
  let wl = (l2 :> widget) :: wl in
  b#add l1;
  b#add l2;
  List.iter (fun x -> x#repaint) wl;
  Printf.printf "<<<\n"
  ;;

coercison () ;;

(* objects without class (structual subtyping) *)
let o =
  object
    val mutable n = 0
    method incr = n <- n + 1
    method get = n
  end;;

(* equivalent record representation *)
type counter_r = {
  get : unit -> int;
  incr : unit -> unit;
};;

(* full equivalency.
 * functions close on the same state *)
let r =
  let n = ref 0 in
  { get = (fun () -> !n);
    incr = (fun () -> incr n);
  }

(* structural subtyping *)

type ab = [`A | `B]
type abc = [`A | `B | `C]
let x : ab = `A
let y : abc = (x :> abc)
(* not rowpoly *)
type name_home = {
  name: string;
  home: string
}

type name_mobile = {
  name: string;
  mobile: string
}

let jotaro = {
  name = "Jotaro";
  home = "123456"
}

let kakyoin = {
  name = "Kakyoin";
  mobile = "114514"
}
#include <iostream>
#include <vector>

// Builder.
//
// It's used when you need to create an object with many possible
// configurations

class Produce1 {
public:
  std::vector<std::string> parts_;
  void ListParts() const {
    std::cout << "Product parts: ";
    for (int i = 0; i < parts_.size(); ++i) {
      if (parts_[i] == parts_.back()) {
        std::cout << parts_[i];
      } else {
        std::cout << parts_[i] << ", ";
      }
    }
    std::cout << "\n" << std::endl;
  }
};

class Builder {
public:
  virtual ~Builder();
  virtual void produceA() const = 0;
  virtual void produceB() const = 0;
  virtual void produceC() const = 0;
};

class ConcreteBuilder : public Builder {
  Produce1 *product;

public:
  ConcreteBuilder() { this->reset(); }
  ~ConcreteBuilder() { delete product; }

  void reset() { this->product = new Produce1(); }

  void produceA() const override { this->product->parts_.push_back("PA"); }
  void produceB() const override { this->product->parts_.push_back("PB"); }
  void produceC() const override { this->product->parts_.push_back("PC"); }

  //
  Produce1 *get_product() {
    Produce1 *reuslt = this->product;
    this->reset();
    return reuslt;
  }
};

// director is just a helper to call builder in a specific order.

class Director {
private:
  Builder *builder;

public:
  void set_builder(Builder *builder) { this->builder = builder; }

  void build_minimal() { this->builder->produceA(); }

  void build_full() {
    this->builder->produceA();
    this->builder->produceB();
    this->builder->produceC();
  }
};

int main(void) { return 0; }
#include <algorithm>
#include <iostream>
#include <list>
#include <string>

// Base class
// Leaf and composite usually implement the same interface.
// Composite can manage it's childs.
// Leafs only do the job
class Component {
protected:
  Component *parent_;

public:
  virtual ~Component() {}
  void set_parent(Component *parent) { parent_ = parent; }

  Component *get_parent() const { return parent_; }

  // define some child management oerations
  virtual void add(Component *component) {}
  virtual void remove(Component *component) {}

  virtual bool is_composite() const { return false; }

  virtual std::string operation() const = 0;
};

// leaf object that do the actual work.
// leaf has no add and remove, thus it cannot control the
// shape of the tree.
class Leaf : public Component {
public:
  std::string operation() const override { return "leaf"; }
};

// Composite class represent the complex components.
// Usually composite class delegate acutal work to their child.
class Composite : public Component {
protected:
  std::list<Component *> childern_;

public:
  void add(Component *c) override {
    childern_.push_back(c);
    c->set_parent(this);
  }

  void remove(Component *c) override {
    childern_.remove(c);
    c->set_parent(nullptr);
  }

  // this is kinda weird.
  // You need this to differentiate composite from
  // leaves.
  // How sad.
  bool is_composite() const override { return true; }

  // composite use operation
  std::string operation() const override {
    std::string result;

    for (const auto *c : childern_) {
      if (c == childern_.back()) {
        result += c->operation();
      } else {
        result += c->operation() + "+";
      }
    }
    return "Branch(" + result + ")";
  }
};

void client1(Component *c) {
  std::cout << "result: " << c->operation() << std::endl;
}

void client2(Component *c1, Component *c2) {
  if (c1->is_composite()) {
    c1->add(c2);
  }
  std::cout << "result: " << c1->operation() << std::endl;
}

int main(void) {
  Component *simple = new Leaf();
  std::cout << "client: a simple component" << std::endl;
  client1(simple);
  std::cout << "\n" << std::endl;

  Component *tree = new Composite();
  Component *branch1 = new Composite();
  Component *branch2 = new Composite();

  Component *leaf1 = new Leaf();
  Component *leaf2 = new Leaf();
  Component *leaf3 = new Leaf();

  branch1->add(leaf1);
  branch1->add(leaf2);
  branch2->add(leaf3);

  tree->add(branch1);
  tree->add(branch2);
  std::cout << "client: Now I have a tree: " << std::endl;
  client1(tree);
  std::cout << "\n" << std::endl;

  std::cout << "client: manage the tree" << std::endl;
  client2(tree, simple);

  delete leaf1;
  delete leaf2;
  delete leaf3;
  delete branch1;
  delete branch2;
  delete tree;
  delete simple;
  return 0;
}
#include <iostream>
#include <string>

// Tbh, how can this be called as a design patter?
// Isn't this just normal coding?
// I mean if OOP is give everything existed a name, it
// should better be called a dictionary.

class Subsystem1 {
public:
  std::string Operation1() const { return "Subsystem1: Ready!\n"; }
  // ...
  std::string OperationN() const { return "Subsystem1: Go!\n"; }
};
class Subsystem2 {
public:
  std::string Operation1() const { return "Subsystem2: Get ready!\n"; }
  // ...
  std::string OperationZ() const { return "Subsystem2: Fire!\n"; }
};

class Facade {
protected:
  Subsystem1 *subsystem1_;
  Subsystem2 *subsystem2_;

public:
  Facade(Subsystem1 *subsystem1 = nullptr, Subsystem2 *subsystem2 = nullptr) {
    this->subsystem1_ = subsystem1 ?: new Subsystem1;
    this->subsystem2_ = subsystem2 ?: new Subsystem2;
  }
  ~Facade() {
    delete subsystem1_;
    delete subsystem2_;
  }

  std::string Operation() {
    std::string result = "Facade initializes subsystems:\n";
    result += this->subsystem1_->Operation1();
    result += this->subsystem2_->Operation1();
    result += "Facade orders subsystems to perform the action:\n";
    result += this->subsystem1_->OperationN();
    result += this->subsystem2_->OperationZ();
    return result;
  }
};

void ClientCode(Facade *facade) { std::cout << facade->Operation(); }
int main() {
  Subsystem1 *subsystem1 = new Subsystem1;
  Subsystem2 *subsystem2 = new Subsystem2;
  Facade *facade = new Facade(subsystem1, subsystem2);
  ClientCode(facade);

  delete facade;

  return 0;
}
#include <iostream>
#include <string>

// factory create objects from concrete classes but return
// them as objects of abstarct type or interfaces.

// Point of factory
// 1. Allows you to introduce inversion of control easier.
// 2. Allows you to mock interfaces, which make it eaiser to test.
// 3. To replace a long constructor

// To be honest how many of stataments above acutally holds?
// OOP ppl...

class Product {

public:
  virtual ~Product();
  virtual std::string call_me() const = 0;
};

class ConcreteProduct1 : public Product {
public:
  std::string call_me() const override { return "from ConcreteProduct1"; }
};

class ConcreteProduct2 : public Product {
public:
  std::string call_me() const override { return "from ConcreteProduct2"; }
};

class Factory {

public:
  virtual ~Factory();
  virtual Product *factory_call() const = 0;

  std::string some_operation() const {
    Product *p = this->factory_call();
    std::string result = "factory: " + p->call_me();
    delete p;
    return result;
  }
};

// two concrete factories.
class ConcreteFactory1 : public Factory {
public:
  Product *factory_call() const override { return new ConcreteProduct1(); }
};

class ConcreteFactory2 : public Factory {
public:
  Product *factory_call() const override { return new ConcreteProduct2(); }
};

void client(const Factory &factory) {

  std::cout << "I don't know what factory it is, but I call still call"
               "The function"
            << factory.some_operation() << std::endl;
}

int main(void) {
  Factory *f1 = new ConcreteFactory1();
  Factory *f2 = new ConcreteFactory2();

  client(*f1);
  client(*f2);

  delete f1;
  delete f2;

  return 0;
}
#include <iostream>
#include <list>
#include <string>
#include <thread>

// Observer allows you to react to events happening in
// other obejcts without coupling to their classes.

class IObserver {
public:
  virtual ~IObserver(){};
  virtual void update(const std::string &messasge_from_subject) = 0;
};

class ISubject {
public:
  virtual ~ISubject() {}
  virtual void attach(IObserver *observer) = 0;
  virtual void detach(IObserver *observer) = 0;
  virtual void notify() = 0;
};

class Subject : public ISubject {
  // each subject maintain a list of their observer.
  std::list<IObserver *> list_observers;
  std::string message_;

public:
  virtual ~Subject() { std::cout << "good bye" << std::endl; }

  void attach(IObserver *observer) override {
    list_observers.push_back(observer);
  }

  void detach(IObserver *observer) override { list_observers.remove(observer); }

  // use notify to update the message
  void notify() override {
    how_many_observer();
    for (auto o : list_observers) {
      o->update(message_);
    }
  }

  void create_message(const std::string &message = "empty") {
    this->message_ = message;
    notify();
  }

  void how_many_observer() {
    std::cout << "There are " << list_observers.size() << " observers."
              << std::endl;
  }
};

class Observer : public IObserver {
  Subject &subject_;
  std::string messasge_from_subject_;
  static int static_number_;
  int number_;

public:
  Observer(Subject &subject) : subject_(subject) {
    subject_.attach(this);
    std::cout << "I'm the observer " << ++Observer::static_number_ << std::endl;
    number_ = Observer::static_number_;
  }

  virtual ~Observer() {
    std::cout << "I was the observer " << number_ << " bye" << std::endl;
  }

  void update(const std::string &messasge_from_subject) override {
    messasge_from_subject_ = messasge_from_subject;
    print_info();
  }

  void remove_me_from_the_list() {
    subject_.detach(this);
    std::cout << "Observer " << number_ << " removed from the list"
              << std::endl;
  }

  void print_info() {
    std::cout << "Observer " << number_ << " a new message -> "
              << messasge_from_subject_ << std::endl;
  }
};

int Observer::static_number_ = 0;

int main(void) {
  Subject *s = new Subject;

  Observer *o1 = new Observer(*s);
  Observer *o2 = new Observer(*s);
  Observer *o3 = new Observer(*s);

  auto t1 = std::thread([&s]() {
    Observer o4(*s);
    for (int i = 0; i < 200; ++i) {
      std::this_thread::sleep_for(std::chrono::microseconds(40));
    }
  });

  s->create_message("hello");
  o3->remove_me_from_the_list();

  auto t2 = std::thread([&s]() {
    Observer o5(*s);
    for (int i = 0; i < 100; ++i) {
      std::this_thread::sleep_for(std::chrono::microseconds(100));
    }
  });

  s->create_message("good day");
  t1.join();
  t2.join();

  delete o1;
  delete o2;
  delete o3;
  delete s;

  return 0;
}
#include <iostream>
#include <string>
#include <unordered_map>

// Creational design pattern
// allows cloning objects without coupling
// to their specific class

// The point is to let you copy an existing
// object without making the code depend on
// their classes.

// What's the point?
// 1. Copy a pre configured object is faster than making a new one.
// 2. In c++ class is not first class oject, but prototype allows
//    you to define what kind of object create by the caller at the
//    runtime.

enum Type { PROTOTYPE1 = 0, PROTOTYPE2 };

class Prototype {
protected:
  std::string prototype_name_;
  float prototype_field_;

public:
  Prototype() {}
  Prototype(std::string prototype_name) : prototype_name_(prototype_name) {}

  virtual ~Prototype() {}
  virtual Prototype *clone() const = 0;
  virtual void call_me(float prototype_field) {
    prototype_field_ = prototype_field;
    std::cout << "Call from " << prototype_name_ << " with field "
              << prototype_field_ << std::endl;
  }
};

class ConcretePrototype1 : public Prototype {
private:
  float concrete_prototype_field1_;

public:
  ConcretePrototype1(std::string prototype_name,
                     float concrete_prototype_field1)
      : Prototype(prototype_name),
        concrete_prototype_field1_(concrete_prototype_field1) {}

  // idealy this should return a unique_ptr.
  Prototype *clone() const override { return new ConcretePrototype1(*this); }
};

class ConcretePrototype2 : public Prototype {
private:
  float concrete_prototype_field2_;

public:
  ConcretePrototype2(std::string prototype_name,
                     float concrete_prototype_field2)
      : Prototype(prototype_name),
        concrete_prototype_field2_(concrete_prototype_field2) {}

  // idealy this should return a unique_ptr.
  Prototype *clone() const override { return new ConcretePrototype2(*this); }
};

// Use the PrototypeFactory to clone new object from the
// existing one.
class PrototypeFactory {
private:
  std::unordered_map<Type, Prototype *, std::hash<int>> prototypes_;

public:
  PrototypeFactory() {
    prototypes_[Type::PROTOTYPE1] = new ConcretePrototype1("P1", 1.1);
    prototypes_[Type::PROTOTYPE2] = new ConcretePrototype2("P2", 2.2);
  }

  ~PrototypeFactory() {
    delete prototypes_[Type::PROTOTYPE1];
    delete prototypes_[Type::PROTOTYPE2];
  }

  Prototype *create_prototype(Type type) { return prototypes_[type]->clone(); }
};

void client(PrototypeFactory &factory) {
  std::cout << "create a prototype 1" << std::endl;
  Prototype *p1 = factory.create_prototype(PROTOTYPE1);
  p1->call_me(11.2);
  delete p1;

  std::cout << "\n";
  std::cout << "create a prototype 2" << std::endl;

  Prototype *p2 = factory.create_prototype(PROTOTYPE1);
  p2->call_me(1.2);
  delete p2;
}


int main(void)
{
  PrototypeFactory *factory = new PrototypeFactory();
  client(*factory);
  delete factory;
  return 0;
}
#include <iostream>
#include <mutex>
#include <string>
#include <thread>

// Thead safe singleton.
// Creational design pattern.

// Ensure sinlge point of access to it.
class Singleton {
  static std::mutex mutex_;
  static Singleton *singleton_;

  std::string value = "default";
  Singleton() {}

public:
  // You should not be able to create another singleton.
  Singleton(const Singleton &other) = delete;
  Singleton &operator=(const Singleton &other) = delete;

  // the only access poing of the content.
  static Singleton *get_instance();

  const std::string &get_value() const { return value; }
  void set_value(const std::string &str) {
    std::cout << "setting..." << std::endl;
    singleton_->value = str;
  }
};

// define static member outside the clasa
Singleton *Singleton::singleton_ = nullptr;
std::mutex Singleton::mutex_;

// Race condition alert.
// Note, if two threads both calling the get_instance
// for the first time at the same time, there will be
// two Singletons get created.
// That's why we lock the call here.
Singleton *Singleton::get_instance() {
  std::lock_guard<std::mutex> lg(mutex_);
  if (singleton_ == nullptr) {
    std::cout << "oh" << std::endl;
    singleton_ = new Singleton();
  }
  return singleton_;
}

int main(void) {
  auto t1 = std::thread([]() {
    std::this_thread::sleep_for(std::chrono::milliseconds(0));
    Singleton *singleton = Singleton::get_instance();
    singleton->set_value("gogo");
    std::cout << singleton->get_value() << std::endl;
  });

  auto t2 = std::thread([]() {
    std::this_thread::sleep_for(std::chrono::milliseconds(0));
    Singleton *singleton = Singleton::get_instance();
    singleton->set_value("baba");
    std::cout << singleton->get_value() << std::endl;
  });

  t1.join();
  t2.join();

  Singleton::get_instance()->set_value("done!");
  std::cout << Singleton::get_instance()->get_value() << std::endl;
  return 0;
}
#include <array>
#include <iostream>
#include <string>

class ConcreteComponentA;
class ConcreteComponentB;

// visitor interface declare a set of methods that corresponds to
// each concrete component classes.
// The problem of this pattern is you need to have a interface
// for each concrete class you gonna work with.
class Visitor {
public:
  virtual void visit_concreteA(const ConcreteComponentA *element) const = 0;
  virtual void visit_concreteB(const ConcreteComponentB *element) const = 0;
};

// this is the element you traverse through.
class Component {
public:
  virtual ~Component() {}
  virtual void accept(Visitor *visitor) const = 0;
};

class ConcreteComponentA : public Component {
public:
  void accept(Visitor *visitor) const override {
    visitor->visit_concreteA(this);
  }
  std::string exclusive_method_of_A() const { return "A"; }
};

class ConcreteComponentB : public Component {
public:
  void accept(Visitor *visitor) const override {
    visitor->visit_concreteB(this);
  }
  std::string exclusive_method_of_B() const { return "B"; }
};

// define two concrete visitors with different implementation
// of visiti
class ConcreteVisitor1 : public Visitor {
public:
  void visit_concreteA(const ConcreteComponentA *element) const override {
    std::cout << element->exclusive_method_of_A() << " + visitor1" << std::endl;
  }

  void visit_concreteB(const ConcreteComponentB *element) const override {
    std::cout << element->exclusive_method_of_B() << " + visitor1" << std::endl;
  }
};

class ConcreteVisitor2 : public Visitor {
public:
  void visit_concreteA(const ConcreteComponentA *element) const override {
    std::cout << element->exclusive_method_of_A() << " + visitor2" << std::endl;
  }

  void visit_concreteB(const ConcreteComponentB *element) const override {
    std::cout << element->exclusive_method_of_B() << " + visitor2" << std::endl;
  }
};
;

// client can run visitor operation over components.
// basically it traverse the array and call the right function
// based on what concrete type it meets.
void client(std::array<const Component *, 2> components, Visitor *visitor) {

  for (const Component *comp : components) {
    comp->accept(visitor);
  }
}

int main(void) {
  std::array<const Component *, 2> components = {new ConcreteComponentA,
                                                 new ConcreteComponentB};
  std::cout << "the client works with all visitors via the "
               "base visitor interface"
            << std::endl;

  ConcreteVisitor1 *v1 = new ConcreteVisitor1;
  client(components, v1);

  std::cout << "Now we can shove in another concrete visitor "
               "this will change the visitor behavior witout"
               "introduce any new code."
            << std::endl;

  ConcreteVisitor2 *v2 = new ConcreteVisitor2;
  client(components, v2);

  return 0;
}
#include <iostream>
#include <memory>
#include <utility>

template <typename... Types> class Visitor;

template <typename T> class Visitor<T> {
public:
  virtual void visit(T &visitable) = 0;
};

template <typename T, typename... TList>
class Visitor<T, TList...> : public Visitor<TList...> {
public:
  using Visitor<TList...>::visit;

  virtual void visit(T &visitable) = 0;
};

template <typename... TList> class Visitable {
public:
  virtual void accept(Visitor<TList...> &visitor) = 0;
};

template <typename Derived, typename... TList>
class VisitableImpl : public Visitable<TList...> {
public:
  virtual void accept(Visitor<TList...> &visitor) {
    visitor.visit(static_cast<Derived &>(*this));
  }
};

class Expression {
public:
  virtual std::string name() = 0;
};

template <typename T> class Constant;
class Variable;

template <typename T>
class Constant : public Expression,
                 public VisitableImpl<Constant<T>, Constant<T>, Variable> {
public:
  virtual std::string name() { return "Constant"; }
};

class Variable : public Expression,
                 public VisitableImpl<Variable, Constant<double>, Variable> {
public:
  virtual std::string name() { return "Variable"; }
};

template <typename... TList> class GenericVisitor;

template <typename U, typename T> class GenericVisitor<U, T> {
protected:
  U u;

public:
  template <typename... ParamList>
  GenericVisitor(ParamList &&...plist) : u(std::forward<ParamList>(plist)...) {}

  virtual void visit(T &t) { u.visit(t); }
};

template <typename U, typename T, typename... TList>
class GenericVisitor<U, T, TList...> : public GenericVisitor<U, TList...> {
public:
  template <typename... ParamList>
  GenericVisitor(ParamList &&...plist)
      : GenericVisitor<U, TList...>(std::forward<ParamList>(plist)...) {}

  using GenericVisitor<U, TList...>::visit;
  using GenericVisitor<U, TList...>::u;

  virtual void visit(T &t) { u.visit(t); }
};

class TestVisitor {
public:
  TestVisitor(int i, int j) {
    std::cout << "WtfVisitor(" << i << ", " << j << ")\n";
  }

  template <typename T> void visit(Constant<T> c) {
    std::cout << "VISITED: Constant\n";
  }

  void visit(Variable c) { std::cout << "VISITED: Variable\n"; }
};

int main(int argc, char *argv[]) {

  Variable var;
  Constant<double> con;

  GenericVisitor<TestVisitor, Constant<double>, Variable> v(5, 6);

  v.visit(con);

  return 0;
}
#include <iostream>
#include <memory>

class VisitableBase;

class VisitorBaseInternal {
public:
  virtual void visit(VisitableBase &) = 0;
  virtual ~VisitorBaseInternal() {}
};

class VisitableBase {
  virtual void accept(VisitorBaseInternal &visitor) { visitor.visit(*this); }
};

template <typename T> class VisitorBase : public VisitorBaseInternal {
  void visit(VisitableBase &e);
};

#include <iostream>
#include <memory>

// solve the expression problem with visitor pattern.
// Subtyping is easy to extend new types, but hard to add new
// function that works for every types.
//
// Visitor allows you to extend function easiler.
//
// C++ doesn't allows class member template to be virtual.
// it can be done but it's not there.
// This make things a bit harder for using visitors.

// Features:
// 1. Everything are templated. So visitors can return different types
// 2. visit is a virtual function. You can have subclass assign to Expr
//    and still invoke the right method.
// 3. visitor contains heterougenous functions. (not everything visit)

template <typename T> class VisitorBase;

template <typename T> class Expr {
public:
  using visitor_t = VisitorBase<T>;
  virtual T accept(visitor_t &visitor) = 0;
};

template <typename T> class Lit : public Expr<T> {
public:
  using visitor_t = typename Lit::visitor_t;
  int value;

  Lit(int value) : value(value) {}
  virtual T accept(visitor_t &v) override;
};

template <typename T> class Add : public Expr<T> {
public:
  using visitor_t = typename Add::visitor_t;
  std::unique_ptr<Expr<T>> left, right;

  Add(std::unique_ptr<Expr<T>> left, std::unique_ptr<Expr<T>> right)
      : left(std::move(left)), right(std::move(right)) {}

  virtual T accept(visitor_t &v) override;
};

template <typename T> class Sign : public Expr<T> {
public:
  using visitor_t = typename Sign::visitor_t;
  std::unique_ptr<Expr<T>> expr;

  Sign(std::unique_ptr<Expr<T>> expr) : expr(std::move(expr)) {}

  virtual T accept(visitor_t &v) override;
};

template <typename T> class VisitorBase {
public:
  using type = T;
  virtual type visit(Lit<T> &a) = 0;
  virtual type visit(Add<T> &a) = 0;
  virtual type visit(Sign<T> &a) = 0;
  virtual ~VisitorBase() {}
};

template <typename T> T Lit<T>::accept(visitor_t &v) { return v.visit(*this); }
template <typename T> T Add<T>::accept(visitor_t &v) { return v.visit(*this); }
template <typename T> T Sign<T>::accept(visitor_t &v) { return v.visit(*this); }

// eval method on all nodes.
class Eval : public VisitorBase<int> {
public:
  virtual type visit(Lit<int> &a) override { return a.value; }

  virtual type visit(Add<int> &a) override {
    return a.left->accept(*this) + a.right->accept(*this);
  }

  virtual type visit(Sign<int> &a) override {
    auto value = a.expr->accept(*this);
    if (value > 0) {
      return 1;
    } else if (value == 0) {
      return 0;
    } else {
      return -1;
    }
  }
};

// show method on all nodes.
// this is problematic. Expr<T> used for show is different from that used
// for Eval!.
// We need some other implementation.
class Show : public VisitorBase<std::string> {
public:
  virtual type visit(Lit<std::string> &a) override {
    return std::to_string(a.value);
  }

  virtual type visit(Add<std::string> &a) override {
    return a.left->accept(*this) + " + " + a.right->accept(*this);
  }

  virtual type visit(Sign<std::string> &a) override {
    std::string value = a.expr->accept(*this);
    auto x = value[0];
    if (value[0] == '-') {
      return "-";
    }
    return "+";
  }
};

int main(void) {
  std::unique_ptr<Expr<int>> expr =
      std::make_unique<Sign<int>>(std::make_unique<Add<int>>(
          std::make_unique<Add<int>>(std::make_unique<Lit<int>>(7),
                                     std::make_unique<Lit<int>>(2)),
          std::make_unique<Lit<int>>(-10)));

  Eval evaluator{};

  int evaled = expr->accept(evaluator);
  std::cout << "evaluation result:" << evaled << std::endl;


  return 0;
}
;; Meta objecet protocol
from timeit import default_timer
from requests import Session
from concurrent.futures import ThreadPoolExecutor

import asyncio


START_TIME = default_timer()


csvs_to_fetch = [
    "ford_escort.csv",
    "cities.csv",
    "hw_25000.csv",
    "mlb_teams_2012.csv",
    "nile.csv",
    "homes.csv",
    "hooke.csv",
    "lead_shot.csv",
    "news_decline.csv",
    "snakes_count_10000.csv",
    "trees.csv",
    "zillow.csv"
]


def fetch(session: Session, csv: str):
    """ basic worker """
    base_url = "https://people.sc.fsu.edu/~jburkardt/data/csv/"

    with session.get(base_url + csv) as respose:
        data = respose.text

        if respose.status_code != 200:
            print("FAILURE::{0}".format(base_url + csv))

        elapsed = default_timer() - START_TIME
        time_completed_at = "{:5.2f}s".format(elapsed)
        print("{0:<30} {1:>20}".format(csv, time_completed_at))

        return data


async def get_data_asyn():
    print("{0:<30} {1:>20}".format("File", "Complete at"))

    with ThreadPoolExecutor(max_workers=10) as executor:
        with Session() as session:
            loop = asyncio.get_event_loop()

            global START_TIME
            START_TIME = default_timer()

            # list of working executor
            tasks = [
                loop.run_in_executor(
                    executor,
                    fetch,
                    *(session, csv)  # parameters.
                )
                for csv in csvs_to_fetch
            ]

            for respose in await asyncio.gather(*tasks):
                ...


if __name__ == "__main__":
    # create event loop
    loop = asyncio.get_event_loop()

    # promise
    future = asyncio.ensure_future(get_data_asyn())

    # run promise
    loop.run_until_complete(future)
"""
Cooperative multitasking vs Preemptive multitasking:
    coroutines hands out control voluntarily, while threads
    can preempt other threads at the middle of the execution.

    coroutines need a even loop to schedule their execution, while
    threads are scheduled by operating system scheduler.

    Thus:
        - if one coroutine runs for too long it will block the
          entire program.
        - as a concequence one can control the access of shared
          resource and avoid using lock.
        -

"""

import asyncio
import time
import random
from typing import Tuple

"""
asyncio systems relied on even loop. in javascript
event loop is in the runtime.
"""


"""
use lock with async
"""


async def worker_lock(lock):
    print("get lock")
    async with lock:
        print('locked')
        time.sleep(2)
    print('unlocked')


async def run_lock():
    lock = asyncio.Lock()
    # this is seriously wierd.
    # is it some metaprogramming?
    await asyncio.wait([worker_lock(lock), worker_lock(lock)])


def main_lock():
    loop = asyncio.get_event_loop()
    loop.run_until_complete(run_lock())
    loop.close()


"""
streams
high level async primitive to work with network connections.
"""


async def tcp_echo_client(message):
    reader: asyncio.StreamReader
    writer: asyncio.StreamWriter

    reader, writer = await asyncio.open_connection('127.0.0.1', 8888)
    print(f'Send: {message!r}')
    writer.writer(message.encode())
    await writer.drain()

    data = await reader.read(100)
    print(f'Received: {data.decode() !r}')

    print("Close connection")
    writer.close()
    await writer.wait_closed()


def main_tcp_echo_client():
    asyncio.run(tcp_echo_client('Hello world!'))


if __name__ == "__main__":
    main_lock()


if __name__ == "__main__":

    for i in range(0, 4):
        for j in range(0, 4):
            for k in range(0, 4):
                if k > 2:
                    break
                print(i, j, k)
                print("kk")
            print("jj")
        print("ii")

import types
import time
import random


# non-data descriptor: only __get__() is implemented
# data descriptor: has __set__() or __delete__()

class VerboseAttribute():
    """
    A property object that implemented the descriptor protocol
    """

    def __get__(self, obj, type=None) -> object:
        print("accessing attribute to get the value")
        return 99

    def __set__(self, obj, value) -> None:
        print("accessing attribute to set the value")
        raise AttributeError("Can not change the value")


class Foo1:
    attribute = VerboseAttribute()


# with property
class Foo2():
    @property
    def attribute(self) -> object:
        print("accessing attribute to get the value")
        return 99

    @attribute.setter
    def attribute(self, value) -> None:
        print("accessing attribute to get the value")
        raise AttributeError("Cannot change the value")


class Foo3:

    def getter(self) -> object:
        print("accessing attribute to get the value")
        return 99

    def getter(self) -> object:
        print("good")
        return 99

    attribute = property(getter, setter)


# How does python transalte obj.method(*args) into method(obj, *args)
class Function:
    # ...
    # when the function is access with dot notation, __get__ is called
    # and bound method is returned

    def __get__(self, obj, objtype=None):
        "simulate func_descr_get()"
        if obj is None:
            return self
        return types.MethodType(self, obj)


class StaticMehod:
    """
    StaticMehod simply ignore the obj
    call f with regular args
    """

    def __init__(self, f):
        self.f = f

    def __get__(self, obj, objtype=None):
        return self.f


class ClassMethod:
    """
    PyyClassMethod_Type()
    call f with class as the first argument
    """

    def __init__(self, f):
        self.f = f

    def __get__(self, obj, klass=None):
        if klass is None:
            klass = type(obj)

        def newfunc(*args):
            return self.f(klass, *args)
        return newfunc

# look up chain
# 1. data descriptor
# 2. __dict__
# 3. non-data descriptor
# 4. type(self).__dict__
# 5. type(self).__base__.__dict__

# descriptor


class OneDigitNumericValue:
    """
    descriptor. data stored in owner object.
    automatically get assigned a name as identifier.
    """

    def __set_name__(self, owner, name):
        self.name = name

    def __get__(self, obj, type=None) -> object:
        return obj.__dict__.get(self.name) or 0

    def __set__(self, obj, value) -> None:
        obj.__dict__[self.name] = value


class Foo4:
    number = OneDigitNumericValue()


# Lazy properties. result get cached after first invoke.
class LazyProperty:
    """
    LazyProperty is a non data descriptor.
    first time get called __get__ will executes f automatically.
    the result is stored in __dict__.
    __dict__ has higher priority than non data discriptor
    so next time when meaning_of_life is accessed
    the value will be get from __dict__ directly.
    """

    def __init__(self, f):
        self.f = f
        self.name = f.__name__

    def __get__(self, obj, type=None) -> object:
        obj.__dict__.self.name = self.f(obj)
        return obj.__dict__[self.name]


class DeepThough:
    @LazyProperty
    def meaning_of_life(self):
        time.sleep(3)
        return 99


if __name__ == "__main__":
    pass
from .email_client import EmailClient
from .email_reader import EmailReader


class Configs:
    ...


class Clients:
    email_client = EmailReader


class Reader:
    ...





class EmailClient:
    def __init__(self, config):
        self._config = config
        self.connect(self._config)

    def connect(self, config):
        ...
class EmailReader:
    def __init__(self, client):
        try:
            self._client = client
        except Exception as e:
            raise e

    def read(self):
        ...


"""
Proxy `speak for` actual implementation
"""


class Implementation:
    def f(self):
        print("Implementation.f()")

    def g(self):
        print("Implementation.g()")

    def h(self):
        print("Implementation.h()")


class Proxy:
    def __init__(self):
        self.__implementation = Implementation()

    def f(self):
        self.__implementation.f()

    def g(self):
        self.__implementation.g()

    def h(self):
        self.__implementation.h()
"""
Adds more implementation for proxy.
"""


class State:
    def __init__(self, imp):
        self.__implementation = imp

    def changeImp(self, newImp):
        self.__implementation = newImp

    def __getattr__(self, name):
        return getattr(self.__implementation, name)


class Implementation1:
    def f(self):
        print("Implementation.f()")

    def g(self):
        print("Implementation.g()")


class Implementation2:
    def f(self):
        print("Implementation.f()")

    def g(self):
        print("Implementation.g()")


"""
One subject can register multiple observers.
Each observers will be notified when subject changes its state.
"""


class Observable:
    def __init__(self):
        self.__observers = []

    def register_observer(self, observer):
        self.__observers.append(observer)

    def notify_observers(self, *args, **kwargs):
        for observer in self.__observers:
            observer.notify(self, *args, **kwargs)

    def __repr__(self):
        return str(id(self))

    def __str__(self):
        return str(id(self))


class Observer:
    def __init__(self, observable):
        observable.register_observer(self)

    def notify(self, observable, *args, **kwargs):
        print("observer", id(self), "Change", *
              args, *kwargs, "From", observable)


subject = Observable()
observer1 = Observer(subject)
observer2 = Observer(subject)
observer3 = Observer(subject)
subject.notify_observers('test')
from typing import Optional


class Singleton:
    class __OnlyOne:
        def __init__(self, arg):
            self.val = arg

        def __str__(self):
            return repr(self) + str(self.val)

    instance: Optional[__OnlyOne] = None

    def __init__(self, arg):
        if not Singleton.instance:
            Singleton.instance = Singleton.__OnlyOne(arg)
        else:
            Singleton.instance.val = arg

    def __getattr__(self, name):
        return getattr(self.instance, name)

    def __str__(self):
        return str(Singleton.instance)


if __name__ == "__main__":
    x = Singleton('sausage')
    print(x)
    y = Singleton('eggs')
    print(y)
    z = Singleton('spam')
    print(z)
    print(x)
    print(y)








class Framework:
    def __init__(self):
        self.__template_method()

    def __template_method(self):
        for i in range(5):
            self.customize1()
            self.customize2()


class Instance(Framework):
    def customize1(self):
        print("meowmeow")

    def customize2(self):
        print("ho ho ho")

"""
Protocals
"""
from typing import NamedTuple
from collections.abc import Sequence
from random import shuffle


class Foo:
    """
    Python can infer entire interface from partialy implemented class.
    This class only have __getitem__, but most protocols from
    Sequence can be used directly without being defined.
    """

    def __getitem__(self, pos):
        return range(0, 30, 10)[pos]

    def foo(self):
        """ iterable even without __iter__ """
        for i in self:
            print(i)

    def foo1(self, x):
        """ act as a container even without __contains__ """
        return x in self


class Card(NamedTuple):
    rank: str
    suit: str


class FrenchDeck(Sequence):
    """
    It is basically a Sequence by implementing __len__ and
    __getitem__
    """
    ranks = [str(n) for n in range(2, 11)] + list('JQKA')
    suits = 'spades diamonds clubs hearts'.split()

    def __init__(self):
        self._cards = [Card(rank, suit)
                       for suit in self.suits
                       for rank in self.ranks]

    def __len__(self):
        return len(self._cards)

    def __getitem__(self, position):
        return self._cards[position]

    def __delitem__(self, position):
        del self._cards[position]

    def shuffle(self):
        """
        deckMonkey patch a necessary function __setitem__
        in runtime to allow shuffle accept it.
        """
        def _set(self: 'FrenchDeck', position, card):
            self._cards[position] = card
        self.__setitem__ = _set
        shuffle(self)


import random
from tombola import Tombola
from typing import Iterable, Generic, List, TypeVar


T = TypeVar('T')


class BingoCage(Tombola, Generic[T]):
    """ stack like """
    def __init__(self, items: Iterable):
        self._randomizer = random.SystemRandom()
        self._items: List[T] = []
        self.load(items)

    def load(self, items):
        self._items.extends(items)
        self._randomizer.shuffle(self._items)

    def pick(self):
        try:
            return self._items.pop()
        except IndexError:
            raise LookupError('pick from empty BingoCage')

    def __call__(self):
        self.pick()


class LotteryBlower(Tombola, Generic[T]):
    def __init__(self, iterable: Iterable[T]):
        self._balls = list(iterable)

    def load(self, iterable: Iterable[T]):
        self._balls.extend(iterable)

    def pick(self):
        try:
            position = random.randrange(len(self._balls))
        except ValueError:
            raise LookupError('pick from empty BingoCage')
        return self._balls.pop(position)

    def loaded(self):
        return bool(self._balls)

    def inspect(self):
        return tuple(sorted(self._balls))


@Tombola.register
class TomboList(List):
    """
    a virtual subclass, avoid multiinheritence
    isinstance will treat it as Tombola, but Tombola will
    not be in __mro__
    """

    def pick(self):
        if self:
            position = random.randrange(len(self))
            return self.pop(position)
        else:
            raise LookupError('pop from empty TomboList')

    load = list.extend

    def loaded(self):
        return bool(self)

    def inspect(self):
        return tuple(sorted(self))
import doctest

from tombola import Tombola
from bins import BingoCage, TomboList, LotteryBlower

TEST_FILE = 'tombola_tests.rst'
TEST_MSG = '{0:16} {1.attempted:2} tests, {1.failed:2} failed - {2}'


def main(argv):
    verbose = '-v' in argv
    real_subclasses = Tombola.__subclasses__()
    virtual_subclasses = list(Tombola._abc_registry)
    for cls in real_subclasses + virtual_subclasses:
        test(cls, verbose)


def test(cls, verbose=False):
    res = doctest.testfile(
        TEST_FILE,
        globs={'ConcreteTombola': cls},
        verbose=verbose,
        optionflags=doctest.REPORT_ONLY_FIRST_FAILURE)
    tag = 'FAIL' if res.failed else 'OK'
    print(TEST_MSG.format(cls.__name__, res, tag))


if __name__ == '__main__':
    import sys
    main(sys.argv)
"""
Interface for python
"""
from typing import TypeVar, Generic, Iterable, Tuple
from collections.abc import Sequence
from abc import abstractmethod, ABC

T = TypeVar('T')


class Tombola(ABC, Generic[T]):
    """
    non repeating random container.
    concrete method in abc should only depends on
    methods in the same abc.
    """

    @abstractmethod
    def load(self, iterable: Iterable[T]):
        """ Add items from an iterable """

    @abstractmethod
    def pick(self) -> T:
        """
        Pop a random item out.
        @raise e: LookupError
        """

    def loaded(self) -> bool:
        return bool(self.inspect())

    def inspect(self) -> Tuple[T, ...]:
        items = []
        while True:
            try:
                items.append(self.pick())
            except LookupError:
                break
        self.load(items)
        return tuple(sorted(items))

    @classmethod
    def __subclasshook__(cls, c):
        methods = ("__load__", "pick", "loaded", "inspect")
        if cls is Tombola:
            if any(method in b.__dict__
                    for b in c.__mro__
                    for method in methods):
                return True
        return NotImplemented
import array
import random
from pprint import pprint

"""
array:   c type array
bytes:   can convert to array
pickle:  more flexible in terms of storage
array and to file and from file, from byte directly.
memoryview: handle slice of arrays without copy bytes.
"""

#######################################################################
# array with different c types
rand_array_h = array.array('h')
rand_array_i = array.array('i')

byte = b'asjdfoiasjdfoiajsdfajsdlfasdjlfajsdlfjasdf09'
rand_array_h.frombytes(byte)
rand_array_i.frombytes(byte)

print('an h array from bytes {}\n'.format(byte))
pprint(rand_array_h)
print("---------------------------------------------->")
print('an i array from bytes {}\n'.format(byte))
pprint(rand_array_i)

#######################################################################
# write array into file and form array from file
floats_array = array.array('d', (random.random() for _ in range(10**7)))
floats_array2 = array.array('d')
with open('floats.bin', 'wb') as fp:
    floats_array.tofile(fp)

with open('floats.bin', 'rb') as fp:
    floats_array2.fromfile(fp, len(floats_array))


print("---------------------------------------------->")
print('-> floats_array [20:22] {}'.format(floats_array[20:22]))
print('-> floats_array2 [20:22] {}'.format(floats_array2[20:22]))

print("---------------------------------------------->")
floats_array2.byteswap()
print('-> floats_array2 swaped [20:22] {}'.format(floats_array2[20:22]))
floats_array2 = array.array(floats_array2.typecode, sorted(floats_array2))
print('-> floats_array2 sorted [20:22] {}'.format(floats_array2[20:22]))
#######################################################################
# change array (or bytes) dynamically and efficiently with memoryview
print("---------------------------------------------->")
print('memoryview example:')
numbers = array.array('h', [-2, -1, 0, 1, 2])   # short
memv = memoryview(numbers)
memv_oct = memv.cast('B')                       # unsigned char
print('array <numbers>:', numbers)
print('memview in short', list(memv))
print('memoryview in char', list(memv_oct))
memv_oct[5] = 30
print('array <numbers> modified by memoryview:', numbers)



import bisect
import sys

"""
a binary insertion lib.
If you have a sorted list and want to keep it in order when interting
new elements, insert througth bisect.insort
"""

HAYSTACK = [1, 4, 5, 6, 8, 12, 15, 20, 21, 23, 23, 26, 29, 30]
NEDDLES = [0, 1, 2, 5, 8, 10, 22, 23, 29, 30, 31]

ROW_RMT = '{0:2d} @ {1:2d}    {2}{0:<2d}'


def demo(bisect_fn):
    for needle in reversed(NEDDLES):
        pos = bisect_fn(HAYSTACK, needle)
        offset = pos * '  |'
        print(ROW_RMT.format(needle, pos, offset))


if __name__ == '__main__':
    if sys.argv[-1] == 'left':
        bisect_fn = bisect.bisect_left
    else:
        bisect_fn = bisect.bisect

    print("DEMO:", bisect_fn.__name__)
    print("haystack ->", " ".join('%2d' % n for n in HAYSTACK))
    demo(bisect_fn)

import array
import struct


"""
byte is the underline representation of str.
python make the difference between char to unicode exlicit.
"""

numbers = array.array('b', [68, 69, 77])
numbyte = bytes(numbers)        # all buffer like sequence can be converted ty bytes.
numbytearry = bytearray(numbyte)
numbytearry[2] = 98

# create bytes from buffer like seq will copy bytes.
print('-> An array:                  ', numbers)
print('-> Turn the array into bytes: ', numbyte)
print('-> turn bytes into bytearray (mutable): ', numbytearry)
print('-> slice of bytearray return bytearray: ', numbytearry[-1:])
print('-> convert from hex to bytes: ', bytes.fromhex('31 4B CE'))


"""
struct: handle parse packed byte into typle and the opposite.
"""
print()
fmt = '<3s3sHH'
with open('./68.80.gif', 'rb') as fp:
    img = memoryview(fp.read())
    header = img[:10]   # slice a memoryview will not copy bytes.
    print("header of gif represent in bytes ", bytes(header))
    print("header unpacked: ", struct.unpack(fmt, header))

import random


class BingoCage:
    def __init__(self, items):
        """constructor"""
        self._items = list(items)
        random.shuffle(self._items)

    def _pick(self):
        """pick"""
        try:
            return self._items.pop()
        except IndexError:
            raise LookupError('pick from empty BingoCage')

    def __call__(self):
        """callable"""
        return self._pick()


if __name__ == "__main__":
    bc = BingoCage((random.randint(0, 20) for _ in range(10)))
    print(bc.__call__.__doc__)
    print(bc())
    print(bc())
    print(bc())
    print(bc())
import time
import functools


def clock(fmt='[{elapsed:0.8f}s {name}({args}) -> {result}]'):
    def decorate(f):
        @functools.wraps(f)
        def clocked(*args, **kwargs):
            t0 = time.perf_counter()
            result = f(*args, **kwargs)
            elapsed = time.perf_counter() - t0
            name = f.__name__
            args = ', '.join(repr(arg) for arg in args)
            print(fmt.format(**locals()))
            return result
        return clocked
    return decorate


@clock('{elapsed}+{name}+{args}{result}')
def snooze(seconds):
    time.sleep(seconds)


@clock()
def factorial(n):
    return 1 if n < 2 else n * factorial(n - 1)


@clock()
def fib_vanilla(n):
    return n if n < 2 else fib_vanilla(n - 2) + fib_vanilla(n - 1)


@functools.lru_cache(maxsize=128, typed=False)
@clock()
def fib_cached(n):
    return n if n < 2 else fib_vanilla(n - 2) + fib_vanilla(n - 1)


if __name__ == "__main__":
    print('*' * 40, 'snooze(.123)')
    snooze(.123)
    print('*' * 40, 'factorial(5)')
    print('40! =', factorial(5))

    print('*' * 40, 'fib_vanilla(5)')
    print('fib_vanilla')
    fib_vanilla(5)

    print('*' * 40, 'fib_cached(5)')
    print('fib_cached')
    fib_cached(5)
def make_avg():
    count = 0
    total = 0

    def avg(n):
        nonlocal count, total  # declare var as free variable.
        count += 1
        total += n
        return total / count
    return avg


if __name__ == "__main__":
    avg = make_avg()
    exprs = """
        avg.__code__.co_freevars
        avg.__closure__
        avg.__closure__[0].cell_contents
    """

    for expr in exprs.split():
        print(expr, eval(expr))

    print('avg(100)', avg(100))
    for expr in exprs.split():
        print(expr, eval(expr))

    print('avg(200)', avg(200))
    for expr in exprs.split():
        print(expr, eval(expr))

    print('avg(999)', avg(999), '\n')
    for expr in exprs.split():
        print(expr, eval(expr))


from collections import namedtuple
from typing import List


promos: List = []
Customer = namedtuple('Customer', 'name fidelity')


def promotion(promo_func):
    promos.append(promo_func)
    return promo_func


class LineItem:

    def __init__(self, product, quantity, price):
        self.product = product
        self.quantity = quantity
        self.price = price

    def total(self):
        return self.price * self.quantity


class Order:  # context

    def __init__(self, customer, cart, promotion=None):
        self.customer = customer
        self.cart = list(cart)
        self.promotion = promotion

    def total(self):
        if not hasattr(self, '_total'):
            self._total = sum(item.total() for item in self.cart)
        return self._total

    def due(self):
        if self.promotion is None:
            discount = 0
        elif callable(self.promotion):
            discount = self.promotion(self)
        else:
            discount = self.promotion.discount(self)
        return self.total() - discount

    def __repr__(self):
        fmt = '<Order total: {:.2f} due: {:.2f}>'
        return fmt.format(self.total(), self.due())


@promotion
def fidelity(order):
    """ higher order function to replace concret strategy"""
    return order.total() * .05 if order.customer.fidelity >= 1000 else 0


@promotion
def bulk_item(order):
    discount = 0
    for item in order.cart:
        if item.quantity >= 20:
            discount += item.total() * .1
    return discount


@promotion
def large_order(order):
    distinct_items = {item.product for item in order.cart}  # distinct.
    if len(distinct_items) >= 10:
        return order.total() * .07
    return 0


def best_promo(order):
    """get the best promo"""
    return max(promo(order) for promo in promos)


if __name__ == "__main__":
    joe = Customer('John Doe', 0)
    ann = Customer('Ann Smith', 1100)
    cart = [LineItem('banana', 4, .5),
            LineItem('apple', 10, 1.5),
            LineItem('watermellon', 5, 5.0)]
    banana_cart = [LineItem('banana', 30, .5)]
    long_cart = [LineItem(str(i), 1, 1.0) for i in range(20)]
    print(Order(joe, banana_cart, best_promo))



import copy

"""
The only mode of parameter passing is sharing.
"""


def badness_of_mutable_para():
    def f(a, b):
        # inplace assgin for mutable, create a new obj for immutable.
        a += b

    x, y = 1, 2
    a, b = [1, 2], [3, 4]
    u, t = (1, 2), (3, 4)
    print('primitive, ', x, y)
    print('mutable, ', a, b)
    print('immutable, ', u, t)
    f(x, y)
    f(a, b)
    f(u, t)
    print('primitive, ', x, y)
    print('mutable, ', a, b)
    print('immutable, ', u, t)


class Bus:

    def __init__(self, passengers=None):
        if passengers is None:  # defensive programming with mutable paras.
            self.passengers = []
        else:
            self.passengers = list(passengers)  # shallow copy!

    def pick(self, name):
        self.passengers.append(name)

    def drop(self, name):
        self.passengers.remove(name)


class HauntedBus:
    """Bad idea to make mutable types as default parameters"""

    def __init__(self, passengers=[]):
        # default list will be shared by sevaral instances
        # [] is in HauntedBus.__init__.__defaults__
        self.passengers = passengers

    def pick(self, name):
        self.passengers.append(name)

    def drop(self, name):
        self.passengers.remove()


def busmain():
    bus1 = Bus(['A', 'B', 'C', 'D'])
    bus2 = copy.copy(bus1)
    bus3 = copy.deepcopy(bus2)
    print('id of bus 1 2 3: {} {} {}'.format(*map(id, [bus1, bus2, bus3])))
    print('bus1 drop B')
    bus1.drop('B')
    print('bus1: ', bus1.passengers)
    print('bus2: ', bus2.passengers)
    print('id of bus 1 2 3: {} {} {}'.format(*map(id, [bus1, bus2, bus3])))
    print('bus3: ', bus3.passengers)


if __name__ == "__main__":
    badness_of_mutable_para()
    busmain()
import sys
import locale


def encoding_check():
    locale.getpreferredencoding()
    type(my_file)
    my_file.encoding
    sys.stdout.isatty()
    sys.stdout.encoding
    sys.stdin.isatty()
    sys.stdin.encoding
    sys.stderr.isatty()
    sys.stderr.encoding
    sys.getdefaultencoding()
    sys.getfilesystemencoding()


expressions = """
    locale.getpreferredencoding()
    type(my_file)
    my_file.encoding
    sys.stdout.isatty()
    sys.stdout.encoding
    sys.stdin.isatty()
    sys.stdin.encoding
    sys.stderr.isatty()
    sys.stderr.encoding
    sys.getdefaultencoding()
    sys.getfilesystemencoding()
"""

my_file = open('dummy', 'w')


for expression in expressions.split():
    value = eval(expression)
    print(expression.rjust(30), '->', repr(value))

my_file.close()
import sys
import re
import collections
from typing import DefaultDict
WORD_RE = re.compile('\w+')

# Default dict
# list is called a default_factory
index: DefaultDict = collections.defaultdict(list)
with open('./pyzen.txt', 'r') as fp:
    for line_no, line in enumerate(fp):
        for match in WORD_RE.finditer(line):
            word = match.group()
            column_no = match.start()
            location = (line_no, column_no)
            index[word].append(location)

for word in sorted(index, key=str.upper):
    print(word, index[word])


# __missing__ method

class StrKeyDict(dict):

    def __missing__(self, key):
        # isinstance to avoid recursive call if a unkown key is passed in.
        if isinstance(key, str):
            raise KeyError(key)
        return self[str(key)]

    def get(self, key, default=None):
        # handle the default case when KeyError is triggered.
        try:
            return self[key]
        except KeyError:
            return default

    def __contains__(self, key):
        # to make behavior of `k in d` consistent.
        return key in self.keys() or str(key) in self.keys()


print("---------------------------------------------------------->")
sd = StrKeyDict([('2', 'haha'), ('4', 'hehe'), ('9', 'xixi')])
print(sd.get(10))
print(sd.get(2))


from collections import deque

"""
a double ended queue for fast interting and removing.
deque can be bounded.
"""

dq  = deque(range(10), maxlen=10)
print(dq)

dq.rotate(3)        # rotate right end elements of the deque to left.
print('right rotate 3', dq)

dq.rotate(-8)        # rotate right end elements of the deque to left.
print('left rotate 8', dq)

dq.extend([11, 22, 33])
print('push into dq', dq)
"""
Command pattern isa oop replacement for callback.
"""
"""
Strategy pattern:
    define a family of algorithms, encapsulate each one, and make
    them interchangeable.
    (Context)           (strategy)
    |Order|----------> |Promotion|
                           |
                   .---------------.
                   |       |       |
                Promo1   Promo2   Promo3
            (concret strategies)

    even though it is context choose strategy, method in strategy still needs
    to get attributes in context to do computation. So when a data need to be
    applied by a method it always need to pass itself to that method.
    like discount(self)

    concret strategies suppose to be state free, so bascially they are functions.
"""
from abc import ABC, abstractmethod
from collections import namedtuple


Customer = namedtuple('Customer', 'name fidelity')


class LineItem:

    def __init__(self, product, quantity, price):
        self.product = product
        self.quantity = quantity
        self.price = price

    def total(self):
        return self.price * self.quantity


class Order:  # context

    def __init__(self, customer, cart, promotion=None):
        self.customer = customer
        self.cart = list(cart)
        self.promotion = promotion

    def total(self):
        if not hasattr(self, '_total'):
            self._total = sum(item.total() for item in self.cart)
        return self._total

    def due(self):
        if self.promotion is None:
            discount = 0
        elif callable(self.promotion):
            discount = self.promotion(self)
        else:
            discount = self.promotion.discount(self)
        return self.total() - discount

    def __repr__(self):
        fmt = '<Order total: {:.2f} due: {:.2f}>'
        return fmt.format(self.total(), self.due())


class Promotion(ABC):  # the Strategy: an Abstract Base Class

    @abstractmethod
    def discount(self, order):
        """Return discount as positive dollar"""


class FidelityPromo(Promotion):
    """5% discount for customers with 1000 or more fidility points"""

    def discount(self, order):
        return order.total() * .05 if order.customer.fidelity >= 1000 else 0


class BulkItemPromo(Promotion):
    """10% discount for each lineitem with 20 or more units"""

    def discount(self, order):
        discount = 0
        for item in order.cart:
            if item.quantity >= 20:
                discount += item.total() * .1
        return discount


class LargeOrderPromo(Promotion):
    """7% discount for order with 10 or more disctinct items"""

    def discount(self, order):
        distinct_items = {item.product for item in order.cart}  # distinct.
        if len(distinct_items) >= 10:
            return order.total() * .07
        return 0


def fidelity_promo(order):
    """ higher order function to replace concret strategy"""
    return order.total() * .05 if order.customer.fidelity >= 1000 else 0


def bulk_item_promo(order):
    discount = 0
    for item in order.cart:
        if item.quantity >= 20:
            discount += item.total() * .1
    return discount


def large_order_promo(order):
    distinct_items = {item.product for item in order.cart}  # distinct.
    if len(distinct_items) >= 10:
        return order.total() * .07
    return 0


def best_promo(order):
    """select the promo strategy with the highest discount"""
    return max(promo(order) for promo in [fidelity_promo,
                                          bulk_item_promo,
                                          large_order_promo])


def hack_best_promo(order):
    promos = [globals()[name] for name in globals()
              if 'best' not in name
              and name.endswith('_promo')]
    return max(promo(order) for promo in promos)


if __name__ == "__main__":
    joe = Customer('John Doe', 0)
    ann = Customer('Ann Smith', 1100)
    cart = [LineItem('banana', 4, .5),
            LineItem('apple', 10, 1.5),
            LineItem('watermellon', 5, 5.0)]
    banana_cart = [LineItem('banana', 30, .5)]
    long_cart = [LineItem(str(i), 1, 1.0) for i in range(20)]
    print('Fidelity Promo with class strategy')
    print(Order(joe, cart, FidelityPromo()))
    print(Order(ann, cart, FidelityPromo()))

    # use higher order function to replace class
    print("use higher order function instead of class for fidelity promo")
    print(Order(ann, cart, fidelity_promo))

    print("Bulk strategy and large order strategy")
    print(Order(ann, banana_cart, BulkItemPromo()))
    print(Order(ann, long_cart, LargeOrderPromo()))

    fp = FidelityPromo()
    print("Create a singleton concret strategy to avoid flyweight")
    print(Order(ann, cart, fp))
    print(Order(joe, cart, fp))

    print("find the best strategy with higher order funcs")
    print(Order(ann, cart, best_promo))
    print(Order(ann, cart, hack_best_promo))
DIAL_CODES = [
    (86, 'China'),
    (91, 'India'),
    (1, 'United States'),
    (62, 'Indonesia'),
    (55, 'Brazil'),
    (92, 'Pakistan'),
    (880, 'Bangladesh'),
    (234, 'Nigeria'),
    (7, 'Russia'),
    (81, 'Japan')
]

d1 = dict(DIAL_CODES)
print('d1:', d1.keys())

d2 = dict(DIAL_CODES)
print('d2:', d2.keys())

d3 = dict(DIAL_CODES)
print('d3:', d3.keys())

print(d1 == d2 and d2 == d3)
import collections
from typing import Dict
import re
import sys

######################################################
# dict comprehension
DIAL_CODES = [
    (86, 'China'),
    (91, 'India'),
    (1, 'United States'),
    (62, 'Indonesia'),
    (55, 'Brazil'),
    (92, 'Pakistan'),
    (880, 'Bangladesh'),
    (7, 'Russia'),
    (81, 'japan'),
]

contry_code = {contry: code for code, contry in DIAL_CODES}

print(contry_code)

######################################################
# by getting value of mapping with .get you can set a default val if the key
# doesn't exist.
print(contry_code.get('Moon', -1))

######################################################
# use setdefault

WORD_RE = re.compile('\w+')

index: Dict = {}
with open('./pyzen.txt', 'r') as fp:
    for line_no, line in enumerate(fp, 1):
        for match in WORD_RE.finditer(line):
            word = match.group()
            column_no = match.start() + 1
            location = (line_no, column_no)
            index.setdefault(word, []).append(location)  # setdefault return the value

for word in sorted(index, key=str.lower):
    print(word, index[word])


######################################################
# ChainMap to mimic python name lookup.
pylookup = collections.ChainMap(locals(), globals(), vars())


######################################################
# Counter
print("Counter-------------------------------------------------->")
ct = collections.Counter('aadsasdasdasdasdsadsdsdasd')
print(ct)
ct.update('aaaaaazzzzzsp')
ct = collections.Counter('aadsasdasdasdasdsadsdsdasd')
print(ct.most_common(2))


######################################################
# UserDict
# It is designed to be subclassed.
print("UserDict-------------------------------------------------->")


class StrKeyDict(collections.UserDict):
    def __missing__(self, key):
        if isinstance(key, str):
            raise KeyError(key)
        return self[str(key)]

    def __contains__(self, key):
        return str(key) in self.data

    def __setitem__(self, key, item):
        self.data[str(key)] = item


"""
There is no method overload in python.
So we need to use dispatch funtion to achieve the same
goal.

use singedispatch to from a generic function.
"""

import functools
from collections import abc
import numbers
import html


@functools.singledispatch
def htmlize(obj):
    content = html.escape(repr(obj))
    return '<pre>{}</pre>'.format(content)


@htmlize.register(str)
def htmlize_1(text):
    content = html.escape(text).replace('\n', '<br>\n')
    return '<p>{}</p>'.format(content)


@htmlize.register(numbers.Integral)
def htmlize_2(n):
    return '<pre>{0} (0x{0:x})</pre>'.format(n)


@htmlize.register(tuple)
@htmlize.register(abc.MutableSequence)
def htmlize_3(seq):
    inner = '</li>\n</li>'.join(htmlize(item) for item in seq)
    return '<ul>\n<li>' + inner + '</li>\n</ul>'


if __name__ == "__main__":
    print(htmlize({1, 2, 3}))
    print(htmlize(abs))
    print(htmlize('a string with \n'))
    print(htmlize(213))
    print(htmlize(['asdsa\n', 123, [n for n in range(4)]]))

import os

"""
Use chardet to determine string encoding
"""

cafe = 'Café'
fp = open('cafe.txt', 'w', encoding='utf_8')
print('-> fp:', fp)
print('size of utf8 str Café:', len(cafe))
print('size of utf8 byte Café:', len(cafe.encode('utf_8')))
fp.write(cafe)
fp.close()

fp2 = open('cafe.txt', encoding='cp1252')
print(fp2.encoding)
print(fp2.read())
fp2.close()

fp3 = open('cafe.txt', 'rb')
print('-> fp3:', fp3)
print(fp3.read())
fp3.close()

print(os.stat('cafe.txt').st_size)
"""
You don't want to update a dictionary while loop through its key
because when you changed some elements the py iterpreter might
decide to resize the dict, which can cause a big temporay overhead.

Better way to do it is to loop through dict, and record all elements
need to be updated in another dict, update them outside of the loop.

This can decrease the frequency of dict migration in memory.
"""

from random import random, randint

d = {randint(0, 10**6): random() for _ in range(10**6)}
print({key: val for key, val in d.items() if key % 219989 == 0})
# update d:

d.update({key: randint(10**7, 10**8) for key, _ in d.items() if key % 219989 == 0})
print({key: val for key, val in d.items() if key % 219989 == 0})
import collections
from random import choice

Card = collections.namedtuple('Card', ['rank', 'suit'])


class FrenchDeck:
    ranks = [str(n) for n in range(2, 11)] + list('JQKA')
    suits = 'spades diamonds clubs hearts'.split()

    def __init__(self):
        self.__cards = [Card(rank, suit)
                        for suit in self.suits
                        for rank in self.ranks]

    def __len__(self):
        return len(self.__cards)

    def __getitem__(self, position):
        return self.__cards[position]


if __name__ == "__main__":
    deck = FrenchDeck()
    print(deck[:3])
    print(deck[12:13])
    print(choice(deck))
    for card in reversed(deck):
        print(card)

    suit_values = dict(spades=3, hearts=2, diamonds=1, clubs=0)
    def spades_high(card):
        rank_value = FrenchDeck.ranks.index(card.rank)
        return rank_value * len(suit_values) + suit_values[card.suit]

    print('=======================================')
    for card in sorted(deck, key=spades_high):
        print(card)

from types import MappingProxyType

"""
Use mappingproxy to create an immutable view of a mapping.
"""

d = {1: 'A'}
d_proxy = MappingProxyType(d)
print('->', d_proxy)
print('Now trying to change d, d_proxy will change dynamically.')
d[1] = 'C'
try:
    print('->', d_proxy)
    print('Now change d_proxy direcly. The action is not allowed.')
    d_proxy[1] = 'B'
except TypeError:
    print('MappingProxyType is immutable!')
import time
"""
memoryview slice buffer protocol object without slice it.
"""

"""
    pure byte 100000 0.135453462600708
    pure byte 200000 0.5963990688323975
    pure byte 300000 1.4644675254821777
    pure byte 400000 2.7435734272003174
    memoryview 100001 0.007353782653808594
    memoryview 200000 0.014733552932739258
    memoryview 300000 0.02210545539855957
    memoryview 400000 0.029502391815185547
"""


def test(with_memview=False):
    scales = (100000, 200000, 300000, 400000)
    for n in scales:
        data = bytes(('x' * n).encode('ascii'))
        start = time.time()
        if with_memview:
            name = 'memoryview'
            b = memoryview(data)
        else:
            name = 'pure byte'
            b = data
        while b:
            b = b[1:]
        print(f"{name}", n, time.time() - start)


if __name__ == "__main__":
    test()
    test(with_memview=True)
def tag(name, *content, cls=None, **attrs):
    """Generate HTML tags"""
    attrs_str = ''

    if cls is not None:
        attrs['class'] = cls
    if attrs:
        attrs_str = ''.join(' %s="%s"' % (attr, value)
                            for attr, value in sorted(attrs.items()))
    if content:
        return '\n'.join('<%s%s>%s</%s>' %
                         (name, attrs_str, c, name) for c in content)
    else:
        return '<%s%s />' % (name, attrs_str)


if __name__ == "__main__":
    print(tag('br'))
    print(tag('p', 'hello'))
    print(tag('div', 'button', id='button-canvas', cls='div1'))
    print(tag(content='testing', name='img'))
invoice = """
1909  Picoco                                   $121
1939  Cocois                                   $121
1999  papaka                                   $11
1919  shishi                                   $12
1909  kokoai                                   $121
"""

# slice used to abstract complicated sequence operations.

year = slice(0, 6)
name = slice(6, 40)
price = slice(40, None)

lines = invoice.split('\n')
for l in lines:
    print(l[name].strip(), l[price])


import bisect
import random
from typing import List

SIZE = 15

fruits = ['grape', 'raspberry', 'apple', 'banana', 'pineapple-pie']
print(sorted(fruits, key=len))
fruits.sort()
print(fruits)

print('use bisect perfrom table lookup')


def grade(score, breakpoints=[60, 70, 80, 90], grades='FDCBA'):
    i = bisect.bisect(breakpoints, score)
    return grades[i]


print([grade(score) for score in [33, 99, 77, 70, 89, 90, 100]])

# use insort to maintain the order of sequence while inserting.
print('use bisect insort')
random.seed(1729)

alist: List[int] = []
for i in range(SIZE):
    new = random.randrange(SIZE * 2)
    bisect.insort(alist, new)
    print('{:2d} ->'.format(new), alist)
from math import hypot


class Vector:

    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y

    def __repr__(self):
        return 'Vector({}, {})'.format(self.x, self.y)

    def __abs__(self):
        return hypot(self.x, self.y)

    def __bool__(self):
        return (bool(abs(self)))

    def __add__(self, other):
        x = self.x + other.x
        y = self.y + other.y
        return Vector(x, y)

    def __sub__(self, other):
        return self.__add__(Vector(-other.x, -other.y))

    def __mul__(self, scalar):
        return Vector(self.x * scalar, self.y * scalar)


if __name__ == "__main__":
    v1 = Vector(2, 3)
    v2 = Vector(3, 9)
    v3 = v1 - v2
    print(v3 * 3)
from array import array
import math


class Vector:
    __slots__ = ('__x', '__y')
    typecode = 'd'

    def __init__(self, x, y):
        self.__x = float(x)
        self.__y = float(y)

    @property  # make x readonly.
    def x(self):
        return self.__x

    @property
    def y(self):
        return self.__y

    def __iter__(self):  # make vector iterable
        return (i for i in (self.x, self.y))

    def __repr__(self):
        class_name = type(self).__name__
        return '{}({!r}, {!r})'.format(class_name, *self)

    def __str__(self):
        return str(tuple(self))

    def __bytes__(self):
        return (bytes([ord(self.typecode)]) +
                bytes(array(self.typecode, self)))

    def __eq__(self, other):
        return tuple(self) == tuple(other)

    def __abs__(self):
        return math.hypot(self.x, self.y)

    def __bool__(self):
        return bool(abs(self))

    def __complex__(self):
        img = self.__x
        real = self.__y
        return complex(img, real)

    @classmethod
    def frombytes(cls, octets):
        typecode = chr(octets[0])
        memv = memoryview(octets[1:]).cast(typecode)
        return cls(*memv)

    def __format__(self, fmt_spec=''):
        if fmt_spec.endswith('p'):
            fmt_spec = fmt_spec[:-1]
            coords = (abs(self), self.angle())
            outer_fmt = '<r:{}, thera:{}>'
        else:
            coords = self
            outer_fmt = '({}, {})'

        components = (format(c, fmt_spec) for c in coords)
        return outer_fmt.format(*components)

    def angle(self):
        return math.atan2(self.x, self.y)

    def __hash__(self):  # std suggest use ^ to mix hashes for components
        return hash(self.x) ^ hash(self.y)


from array import array
import math


class Vector2d:
    __slots__ = ('__x', '__y')
    typecode = 'd'

    def __init__(self, x, y):
        self.__x = float(x)
        self.__y = float(y)

    @property  # make x readonly.
    def x(self):
        return self.__x

    @property
    def y(self):
        return self.__y

    def __iter__(self):  # make vector iterable
        return (i for i in (self.x, self.y))

    def __repr__(self):
        class_name = type(self).__name__
        return '{}({!r}, {!r})'.format(class_name, *self)

    def __str__(self):
        return str(tuple(self))

    def __bytes__(self):
        return (bytes([ord(self.typecode)]) +
                bytes(array(self.typecode, self)))

    def __eq__(self, other):
        return tuple(self) == tuple(other)

    def __abs__(self):
        return math.hypot(self.x, self.y)

    def __bool__(self):
        return bool(abs(self))

    def __complex__(self):
        img = self.__x
        real = self.__y
        return complex(img, real)

    @classmethod
    def frombytes(cls, octets):
        typecode = chr(octets[0])
        memv = memoryview(octets[1:]).cast(typecode)
        return cls(*memv)

    def __format__(self, fmt_spec=''):
        if fmt_spec.endswith('p'):
            fmt_spec = fmt_spec[:-1]
            coords = (abs(self), self.angle())
            outer_fmt = '<r:{}, thera:{}>'
        else:
            coords = self
            outer_fmt = '({}, {})'

        components = (format(c, fmt_spec) for c in coords)
        return outer_fmt.format(*components)

    def angle(self):
        return math.atan2(self.x, self.y)

    def __hash__(self):  # std suggest use ^ to mix hashes for components
        return hash(self.x) ^ hash(self.y)


class ShortVector2d(Vector2d):
    typecode = 'h'

    def __bytes__(self):
        return (bytes([ord(self.typecode)]) +
                bytes(array(self.typecode, map(lambda x: int(x), self))))

import weakref
from typing import MutableMapping

"""
Weakreference to an object does not increase its reference count.
It doesn't prevent an object from being gabage collected.
weakref are useful in caching.
"""


class Cheese:

    def __init__(self, kind):
        self.kind = kind

    def __repr__(self):
        return 'Cheese(%r)' % self.kind


if __name__ == "__main__":
    stock: MutableMapping = weakref.WeakValueDictionary()
    catalog = [Cheese('Red Leicester'), Cheese('Tilsit'),
               Cheese('Brie'), Cheese('Parmesan')]
    for cheese in catalog:
        stock[cheese.kind] = cheese

    print(sorted(stock.keys()))
    del catalog
    print(sorted(stock.keys()))
    del cheese  # cheese as temporary var is still alive.
    print(sorted(stock.keys()))

import queue, threading


def consume_queue(thequeue: queue.Queue):
    while True:
        item = thequeue.get()
        if item is StopIteration:
            break
        yield item


def consumer(q):
    for item in consume_queue(q):
        print('Consumed', item)
    print('Done')


if __name__ == "__main__":
    inq: queue.Queue = queue.Queue()

    con_thread = threading.Thread(target=consumer, args=(inq,))
    con_thread.start()

    for i in range(100):
        inq.put(i)
    inq.put(StopIteration)

def consumer(func):
    def start(*args, **kwargs):
        c = func(*args, **kwargs)
        next(c)
        return c
    return start


@consumer
def recv_count():
    try:
        while True:
            n = (yield)
            print("T-minux", n)
    except GeneratorExit:
        print("Kaboom!")




class CountDown:
    """ countdown iterator """
    def __init__(self, start):
        self.count = start

    def __iter__(self):
        return self

    def __next__(self):
        if self.count <= 0:
            raise StopIteration
        r = self.count
        self.count -= 1
        return r


def desugar_countdown(start, callback):
    """ desugar for loop over iterator """
    it = iter(CountDown(start))
    while 1:
        try:
            x = next(it)
            callback(x)
        except StopIteration:
            break


def countdown_gen(n):
    """ countdown generator """
    # Generator is a more convinent way of writing iterator
    while n > 0:
        yield n
        n -= 1


def countdown_generator_expression(n):
    return (n for n in range(n, 0, -1))


if __name__ == "__main__":
    # for loop over iter
    print('for loop over iter')
    for i in CountDown(5):
        print(i)

    # desugar for loop over iter
    print('desuager for loop over iter')
    desugar_countdown(5, print)

    # countdown generator
    print('countdown generator')
    for n in countdown_gen(5):
        print(n)

    # countdown_generator_expression
    print('countdown generator expression')
    for n in countdown_generator_expression(5):
        print(n)
import time
from typing import TextIO
import subprocess
from multiprocessing import Process
import os


def follow(thefile: TextIO):
    """ even file is infinite it still works """
    thefile.seek(0, os.SEEK_END)
    while True:
        line = thefile.readline()
        if not line:
            time.sleep(0.1)
            continue
        yield line


if __name__ == "__main__":
    def ping():
        subprocess.call(['ping', 'google.com'], stdout=open('ping-data', 'w'))

    def run():
        with open('ping-data', 'r') as lines:
            for n in follow(lines):
                print(n)

    p1 = Process(target=run)
    p2 = Process(target=ping)

    p1.start()
    p2.start()
    p1.join()
    p2.join()

"""
Generator dp for multiple sources.
"""
from typing import List, Generator


def concatenate(sources: List[Generator]):
    for s in sources:
        for item in s:
            yield item
import pickle
import socket
from typing import Generator, List, Iterator
import queue
import threading


# Pickler/Unpickler
def gen_pickle(source):
    for item in source:
        yield pickle.dumps(item)


def get_unpickle(infile):
    while True:
        try:
            item = pickle.loads(infile)
            yield item
        except EOFError:
            return

# Sender/Receiver


def sendto(source, addr):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect(addr)
    for pitem in gen_pickle(source):
        s.sendall(pitem)
    s.close()


def receivefrom(addr):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    s.bind(addr)
    s.listen(5)

    c, a = s.accept()
    for item in get_unpickle(c.makefile()):
        yield item
    c.close()


# Consuming a queue
def consume_queue(thequeue: queue.Queue):
    while True:
        item = thequeue.get()
        if item is StopIteration:
            break
        yield item


# fanning out to multiple cosummer

# broadcasting
class Consumer:
    def send(self, item):
        print(self, "got", item)


def broadcast(source: Iterator, consumers: List[Consumer]):
    for item in source:
        for c in consumers:
            c.send(item)


# Network consumer
class NetConsumer:
    def __init__(self, addr):
        self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    def send(self, item):
        pitem = pickle.dumps(item)
        self.s.sendall(pitem)

    def close(self):
        self.s.close()


# Consumer Thread
class ConsumerThread(threading.Thread):
    def __init__(self, target):
        threading.Thread.__init__(self)
        self.setDaemon(True)
        self.in_queue = queue.Queue()
        self.target = target

    def send(self, item):
        self.in_queue.put(item)

    def generate(self):
        while True:
            item = self.in_queue.get()
            yield item

    def run(self):
        self.target(self.generate())
from queue import Queue

q: Queue = Queue()

for i in range(100):
    q.put(i)


def it():
    while not q.empty():
        yield q.get()

from queue import Queue
from threading import Thread
import xml
from typing import List, Dict, Coroutine


def coroutine(func):
    def start(*args, **kwarfs):
        cr = func(*args, **kwarfs)
        next(cr)
        return cr
    return start


@coroutine
def buese_to_dicts(target: Coroutine):
    while True:
        event, value = (yield)
        if event == 'start' and value[0] == 'bus':
            busdict: Dict = {}
            fragments: List = []

            while True:
                event, value = (yield)
                if event == 'start':
                    fragments = []
                elif event == 'text':
                    fragments.append(value)
                elif event == 'end':
                    if value != 'bus':
                        busdict[value] = "".join(fragments)
                    else:
                        target.send(busdict)
                        break


@coroutine
def threaded(target: Coroutine):
    messages: Queue = Queue()

    def run_target():
        while True:
            item = messages.get()
            if item is GeneratorExit:
                target.close()
                return
            else:
                target.send(item)
    Thread(target=run_target).start()

    try:
        while True:
            item = (yield)
            messages.put(item)
    except GeneratorExit:
        messages.put(GeneratorExit)




import sys
from PIL import Image
import numpy as np

chars = np.asarray(list(' .,:;irsXA253hMHGS#9B&@'))

if len(sys.argv) != 4:
    print('Usage: ./asciinator.py image scale factor')
    sys.exit()

f, SC, GCF, WCF = sys.argv[1], float(sys.argv[2]), float(sys.argv[3]), 7 / 4

img = Image.open(f)
S = (round(img.size[0] * SC * WCF), round(img.size[1] * SC))
img = np.sum(np.asarray(img.resize(S)), axis=2)
img -= img.min()
img = (1.0 - img / img.max())**GCF * (chars.size - 1)

print("\n".join(("".join(r) for r in chars[img.astype(int)])))
from .llsip import Intepreter as Llisp
from .api import create_env, extend_env, pylib_env_dict

__all__ = ['Llisp', 'create_env', 'extend_env', 'pylib_env_dict']

from llsip import Intepreter
import getopt
import sys


def exec():
    if not sys.argv[1:]:
        usage()
        sys.exit(1)

    intepreter = Intepreter()

    try:
        opts, args = getopt.getopt(
                sys.argv[1:],
                'hit:',
                ['help', 'interactive', 'target']
        )

        for o, a in opts:
            if o in ('-h', '--help'):
                usage()
            elif o in ('-i', '--interactive'):
                intepreter.repl()
            elif o in ('t', '--target'):
                intepreter.run(a)
            else:
                False, 'Unhandled arguments'
    except getopt.GetoptError as e:
        print(e)


def usage():
    print('Llisp --a python implemented lisp')
    print('')
    print('usage:')
    print('     python llisp [opts] <file>')
    print('')
    print('options:')
    print('     -h  --help')
    print('     -i  --interactive')
    print('     -t  --target <code path>')


if __name__ == '__main__':
    exec()

from .llsip import Env
from types import FunctionType
import operator


def create_env(env: dict) -> FunctionType:
    """ return a higher order funtion to generate dict """
    def foo() -> dict:
        env.update(
            {
                'begin': lambda *x: x[-1],
                'print': print,
            }
        )
        return env
    return foo


def extend_env(env: dict) -> FunctionType:
    """ return a env with standard env as subset """
    def foo() -> dict:
        env.update({
            '+': operator.add,
            '-': operator.sub,
            '*': operator.mul,
            '/': operator.truediv,
            '>': operator.gt,
            '<': operator.lt,
            '>=': operator.ge,
            '<=': operator.le,
            '=': operator.eq,
            'abs': abs,
            'append': operator.add,
            'begin': lambda *x: x[-1],
            'car': lambda x: x[0],
            'cdr': lambda x: x[1:],
            'cons': lambda x, y: [x] + y,
            'eq?': operator.is_,
            'expt': pow,
            'equal?': operator.eq,
            'length': len,
            'list': lambda *x: List(x),
            'list?': lambda x: isinstance(x, List),
            'map': map,
            'max': max,
            'min': min,
            'not': operator.not_,
            'null?': lambda x: x==[],
            'number?': lambda x: isinstance(x, Number),
            'print': print,
            'procedure?': callable,
            'round': round,
            'symbol?': lambda x: isinstance(x, Symbol),
            })
        return env
    return foo

def pylib_env_dict(*args) -> dict:
    """ return a dict of given libs """
    env = {}
    for lib in args:
        env.update(vars(lib))
    return env
from typing import Union


class Exp(object):
    pass


class List(list, Exp):
    """ Exp = (List, Atom)"""

    def __repr__(self):
        return '(List ' + ''.join([str(self.__getitem__(i))
                for i in range(0, self.__len__())]) + ') '

    __str__ = __repr__


class Atom(Exp):
    val = None

    def __init__(self, value: Union[str, int, float]):
        self.val = value

    def __repr__(self):
        return '<Atom ' + str(self.val) + '> '

    __str__ = __repr__


class Symbol(Atom):
    """ Atom = (Symbol, Number)"""
    def __init__(self, value: str):
        super().__init__(value)

    def __repr__(self):
        return '<Symbol ' + str(self.val) + '> '

    __str__ = __repr__


class Number(Atom):
    def __init__(self, value: Union[int, float]):
        super().__init__(value)

    def __repr__(self):
        return '<Numer ' + str(self.val) + '> '

    __str__ = __repr__
import math, operator , sys
from expressions import Symbol, Exp, List, Atom, Number


class Env(dict):
    """
    Env hold all language features
    receive foo->dict to generate env
    """

    def __keytransform__(self, key):
        return str(key)

    def __init__(self, parms=(), args=(), outer_env=None):
        self.update(zip(parms, args))
        self.outer_env = outer_env

    def find(self, var):
        # find from local scope to outer scope until reach global scope
        try:
            return self if (var in self) else self.outer_env.find(var)

        except BaseException:
            pass


class Procedure(object):
    """ customizable procedure """

    def __init__(self, parms, body, env):
        self.parms, self.body, self.env = parms, body, env

    # create a new Env with self.env as outer. bind self.parms with args for
    # the sub Env.

    # the  retur value is the parameters for Intepreter.eval to evaluate
    def __call__(self, *args):
        # create a new procedure, generate a local scope
        return self.body, Env(tuple(map(lambda x: x.val, self.parms)), args, self.env)


class Intepreter(object):
    env = None
    keywords = ['if', 'define', 'lambda', 'set!', 'quote']

    def __init__(self, create_global_env=None):
        if create_global_env:
            self.env = Env()
            self.env.update(create_global_env())

        else:
            self.env = Env()
            self.env.update(self.__create_std_global_env())

    def __create_std_global_env(self) -> dict:
        """ to create standard global env """

        env = {}
        env.update(vars(math))
        env.update({
            '+': operator.add,
            '-': operator.sub,
            '*': operator.mul,
            '/': operator.truediv,
            '>': operator.gt,
            '<': operator.lt,
            '>=': operator.ge,
            '<=': operator.le,
            '=': operator.eq,
            'abs': abs,
            'append': operator.add,
            'begin': lambda *x: x[-1],
            'car': lambda x: x[0],
            'cdr': lambda x: x[1:],
            'cons': lambda x, y: [x] + y,
            'eq?': operator.is_,
            'expt': pow,
            'equal?': operator.eq,
            'length': len,
            'list': lambda *x: List(x),
            'list?': lambda x: isinstance(x, List),
            'map': map,
            'max': max,
            'min': min,
            'not': operator.not_,
            'null?': lambda x: x == [],
            'number?': lambda x: isinstance(x, Number),
            'print': print,
            'procedure?': callable,
            'round': round,
            'symbol?': lambda x: isinstance(x, Symbol),
            })
        return env

    def __tokenizer(self, source_code: str) -> list:
        """ create a list of tokens """
        source_code = '(begin(' + source_code + '))'
        return source_code.replace('(', ' ( ').replace(')', ' ) ').split()

    def parse(self, source_code: str) -> Exp:
        """ read Exp from tokens"""
        return self.__parse_parenthesis(self.__tokenizer(source_code))

    def __parse_parenthesis(self, tokens: list) -> Exp:
        """ parse one expression within parethesis """

        if len(tokens) == 0:
            raise SyntaxError('unexpected EOF')

        # get the top most token. pop out ( and ).
        token = tokens.pop(0)

        # generate a list
        if token == '(':
            expression = List()

            while tokens[0] != ')':
                expression.append(self.__parse_parenthesis(tokens))
            tokens.pop(0)

            return expression
        elif token == ')':
            raise SyntaxError(') mismatched')
        else:
            return Intepreter.atom(token)

    def eval(self, x: Exp, env: Env = None) -> Exp:
        """ eval """
        # set env
        if not env:
            env = self.env

        # parse atom ===============
        # variable reference
        if isinstance(x, Symbol):
            try:
                return env.find(x.val)[x.val]

            except KeyError:
                print('Unbounded variable ' + x.val)
            except TypeError:
                print('Unbounded variable')

        # constant number
        elif not isinstance(x, List):
            return x.val

        # parse list =================
        try:
            op, *args = x
            if not args:
                return self.eval(op)

            if op.val == 'quote':
                return args[0].val

            # condition
            elif op.val == 'if':
                (test, conseq, alt) = args
                exp = (conseq if self.eval(test, env) else alt)
                return self.eval(exp, env)

            elif op.val == 'define':
                (symbol, exp) = args
                env[symbol.val] = self.eval(exp, env)

            elif op.val == 'set!':
                (symbol, exp) = args
                env.find(symbol.val)[symbol.val] = self.eval(exp, env)

            # generate procedure
            elif op.val == 'lambda':
                (parms, body) = args
                return Procedure(parms, body, env)

            # procedure call
            else:
                proc = self.eval(op, env)

                vals = List(self.eval(arg, env) for arg in args)

                # user defined procedures. proc(*vals) return the argument for eval
                if isinstance(self.env.find(op.val)[op.val], Procedure):
                    sub_exp, sub_env = proc(*vals)
                    return self.eval(sub_exp, sub_env)

                # build-in procedures
                return proc(*vals)
        except TypeError as e:
            print(e)

    @staticmethod
    def atom(token: str) -> Atom:
        """ method to transfer token from str to Number or Symbol """
        try:
            return Number(int(token))

        except ValueError:
            try:
                return Number(float(token))

            except ValueError:
                return Symbol(token)

    def repl(self, prompt='>'):
        """repl interactive shell"""
        while True:
            typein = input(prompt)

            if typein in ['q', 'exit', 'quit']:
                sys.exit(0)
            val = self.eval(self.parse(typein))

            if val is None:
                pass
            else:
                print(val)

    def run(self, filename):
        """ run code in a seperate file """
        try:
            fp = open(filename, 'r')
            line = fp.readline()
            while line:
                val = self.eval(self.parse(line))
            if val is None:
                pass
            else:
                print(val)

        except IOError as err:
            print(err)
from llisp import Llisp, extend_env, pylib_env_dict
import matplotlib.pyplot as plt
import numpy as np

env = pylib_env_dict(plt, np)
Llisp(extend_env(env)).repl()

class UpperAttrMetaCls(type):
    def __new__(cls, name, bases, attrs):
        # __new__ will be called before __init__
        uppercaseattrs = {}
        for name, val in attrs.items():
            if not name.startswith("--"):
                uppercaseattrs[name.upper()] = val
            else:
                uppercaseattrs[name] = val
        return super().__new__(cls, name, bases, uppercaseattrs)


class SampleA(metaclass=UpperAttrMetaCls):
    name = 10

    def __init__(self):
        print("created a SampleA, with Metacls UpperAttrMetaCls")


def monkey_speak():
    print("ook ook eee eee eee!")


if __name__ == "__main__":
    SampleA.speak = monkey_speak  # BONUS: monkey patching.
    a = SampleA()

    print(a.NAME)  # use metaclass changed the attri names.
    a.speak()
from requests import get


response = None


response = get('https://taobao.com')
import importlib
import sys


def lazy(name):
    try:
        return sys.modules[name]

    except KeyError:
        spec = importlib.util.find_spec(name)
        module = importlib.util.module_from_spec(spec)
        loader = importlib.util.LazyLoader(spec.loader)

        loader.exec_module(module)
        return module


expensive = lazy('expensive')

if __name__ == "__main__":
    print(expensive.response)


from multiprocessing import get_context, Pool
from itertools import tee
from random import random
import time
import os


"""
Multiprocessing use pickle to send objects between processes.
local function is not pickle thus cannot be used for multiprocessing.
all functions needs to be at the top level.

The process spawning mode is very important because they can change the
behavior of the program drastically.

In unix fork is the default spawn methods, which will fork the entire mem of
current process. (note, threads is not copied, so two processes will have
same set of threads.)

Another type of spawning is 'spawn', which will create a new, "empty" python
interpreter, then start the process from the scratch.

One common problem is fork while there is threads running already.
If there is lock in locked state, the lock will be copied by the process,
but since threads are not copied, there is this propability that a
thread that shouldn't block got blocked.
"""


def worker(id: int):
    time.sleep(random() * 2)
    print(id)


def main():
    iterator = range(10)
    (iterator1, iterator2, iterator3, iterator4) = tee(iterator, 4)
    with Pool(7) as pool:
        """
        imap and imap_unordered are lazy version of map, by default they
        will slice one element from the iterator for one worker.
        chunk_size param can change the work load per worker.
        """
        print('----- imap_unordered')
        for n in pool.imap_unordered(worker, iterator1):
            pass

        print('----- imap')
        for n in pool.imap(worker, iterator2):
            pass

        """
        map and map_async are egar evaluations, the program will block until
        all results are returned.

        Before separate the iterator map will convert it into a list, which
        could be problemati if the iterator is very big.

        map will return the result right away, whihle map_async return a
        AsyncResult, which works like future, and one can get the value by
        call AsyncResult.get()
        """
        print('----- map')
        for n in pool.map(worker, iterator3):
            pass

        print('----- map_async')
        res = pool.map_async(worker, iterator4)
        for n in res.get():
            pass


if __name__ == "__main__":
    main()

registry = {}


class MultiMethod:
    def __init__(self, name):
        self.name = name
        self.typemap = {}

    def __call__(self, *args):
        types = tuple(arg.__class__ for arg in args)
        function = self.typemap.get(types)
        if function is None:
            raise TypeError("no match")
        return function(*args)

    def register(self, types, function):
        if types in self.typemap:
            raise TypeError("duplicate registration")
        self.typemap[types] = function


def multimethod(*types):
    def register(fn):
        name = fn.__name__
        mm = registry.get(name)
        if mm is None:
            mm = registry[name] = MultiMethod(name)
        mm.register(types, fn)
        return mm
    return register


@multimethod(int, int)
def foo(a, b=10):
    print("int int")


@multimethod(int)
def foo(a):
    print("int")
from typing import Optional, overload


@overload
def foo(x: None) -> None:
    ...


@overload
def foo(x: int) -> int:
    ...


def foo(x: Optional[int]) -> Optional[int]:
    if x is None:
        return None
    return x


class Bottle1:
    """
    getter a nd setter
    """

    volume_: int = 0

    @property
    def volume(self):
        return self.volume_

    @volume.setter
    def volume(self, v: int):
        print("set bottle")
        self.volume_ = v


class Bottle2:
    """
    Getter but no setter
    """

    volume_: int = 0

    @property
    def volume(self):
        return self.volume_


class Bottle3:
    """
    Getter but no setter
    """

    volume: int = 0

    def __setattr__(self, name, value):
        if name == "volume":
            print("set bottle")
        super().__setattr__("volume", value)


b1 = Bottle1()
b2 = Bottle2()
b3 = Bottle3()
import itertools
import functools
from typing import Iterable, Generator, Callable, List
import random

import pysnooper


def printname(f):
    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        print(f.__name__ + ': ')
        f(*args, **kwargs)
        print()
    return wrapper


# interator
@pysnooper.snoop()
@printname
def top1_iterator():
    li: List = [1, 2, 3]
    it: Iterable = iter(li)
    for i in range(len(li)):
        print(next(it))


@printname
def top2_iterator():
    li: List = [3, 4, 5]
    for i in iter(li):
        print(i)

@printname
def top3_generator():
    line_list: List = ['  line 1\n', ' line 2 \n']
    stripped_iter: Iterable = (line.strip() for line in line_list)
    stripped_list: List = [line.strip() for line in line_list]

    # lazyeval
    _ = list(map(print, stripped_iter))
    _ = list(map(print, stripped_list))


@printname
def top4_generator():

    def gen_ints(n: int) -> Generator:
        i: int = 1
        while i <= n:
            yield i
            i += 1

    for i in gen_ints(3):
        print(i)


@printname
def top5_define_iterator():
    class Iter:

        def __iter__(self):
            self.num = 0
            return self

        def __next__(self):
            self.num += 1
            if self.num > 3:
                raise StopIteration(3)

            return self.num

    for i in Iter():
        print(i)


@printname
def top6_inorder_tree():
    def inorder(t):
        if t:
            for x in inorder(t.left):
                yield x
            yield t.label
            for x in inorder(t.right):
                yield x


@printname
def top7_yield():
    def counter(maximum: int) -> Generator:
        i: int = 0
        while i < maximum:
            val = (yield i)
            if val is not None:
                i = val
            else:
                i += 1
    print(list(counter(4)))

    it: Generator = counter(10)
    next(it)
    it.send(7)  # skip steps
    print(list(it))


@printname
def top8_map():
    print(list(map(lambda s: s.upper(), ['two', 'words'])))
    print(list(filter(lambda x: x % 2 == 0, range(0, 10))))
    print(list((x for x in range(0, 10) if x % 2 != 0)))


@printname
def top9_enum():
    def get_ints(maximum: int) -> Generator:
        i = 1000
        while i < 1000 + maximum:
            val = (yield i)
            if val is not None:
                i = val
            else:
                i += 1
    for i, v in enumerate(get_ints(3)):
        print(i, v)


@printname
def top10_anyall():
    print(all(filter(lambda x: x > 3000, random.sample(range(6000), 1000))))
    print(any(filter(lambda x: x > 5999, random.sample(range(6000), 1000))))


@printname
def top11_zip():
    print(dict(zip(['good', 'bad'], [7, 13])))


@printname
def top12_itertool_funcs():
    from itertools import (
        islice, count, cycle, repeat, chain, tee, starmap, combinations,
        permutations, groupby)

    print(list(islice(count(), 100, 200, 5)))
    print(tuple(islice(cycle([1, 2, 3]), 300, 400, 5)))
    print(tuple(repeat('cat', 10)))
    print(tuple(chain(['a', 'b'], [1, 2], (x for x in range(0, 10) if x > 4))))

    # tee a generator
    iter1, iter2 = tee((x + 1 for x in range(0, 10) if x % 2 == 0))
    print(list(map(lambda x: x * 100, iter1)))
    print(list(iter2))

    # itermap
    from operator import add
    from os.path import join
    print(list(starmap(join, [('/bin', 'haskell'), ('/usr', 'c++')])))
    print(list(starmap(add, [(2, 3), (4, 8)])))

    print(list(combinations(range(4), 2)))
    print(list(permutations(range(4), 2)))

    # Group by
    city: List = [('Beijing', 'Jin'),
                  ('Nantong', 'Su'),
                  ('Suzhou', 'Su'),
                  ('Shanghai', 'Hu')]

    def get_province(city):
        _, prov = city
        return prov
    Jin, Su, Hu = groupby(city, get_province)


def top13_functools():
    from functools import partial, reduce

    def log(msg, subsys):
        print(f'{msg}: {subsys}')

    serverlog = partial(log, subsys='server')
    serverlog('Unable to open socket')

    from operator import mul
    print(reduce(mul, (x for x in range(1, 100) if x % 2 == 0), 1))


if __name__ == "__main__":
    top1_iterator()
    top2_iterator()
    top3_generator()
    top4_generator()
    top5_define_iterator()
    top6_inorder_tree()
    top7_yield()
    top8_map()
    top9_enum()
    top10_anyall()
    top11_zip()
    top12_itertool_funcs()
    top13_functools()
import io

# text IO. Expect string
tio = io.StringIO("Some string")

# binary IO. Expect Byte like objects
bio = io.BytesIO(b"some bytes")
#include <Python.h>

/* Generalized array type received by c extension
 * */

double avg(double *a, int n) {
  double sum;
  for (int i = 0; i < n; i++)
    sum += a[i];
  return sum / n;
}

static PyObject *py_avg(PyObject *self, PyObject *args) {
  PyObject *bufobj;
  Py_buffer view;

  double result;
  // "O" for python object
  if (!PyArg_ParseTuple(args, "O", &bufobj)) {
    return NULL;
  }

  // get passed py object into Py_buffer view
  // PyObject_GetBuffer  trying to obtain information of the underlying mem representation.
  if (PyObject_GetBuffer(bufobj, &view, PyBUF_ANY_CONTIGUOUS | PyBUF_FORMAT) ==
      -1) {
    return NULL;
  }

  if (view.ndim != 1) {
    PyErr_SetString(PyExc_TypeError, "Expected a 1-dimensinoal array");
    PyBuffer_Release(&view);
    return NULL;
  }

  if (strcmp(view.format, "d") != 0) {
    PyErr_SetString(PyExc_TypeError, "Expected an array of doubles");
    // for ref count
    PyBuffer_Release(&view);
    return NULL;
  }

  result = avg((double *)view.buf, view.shape[0]);

  PyBuffer_Release(&view);
  return Py_BuildValue("d", result);
}
#include "sample.h"

int gcd(int x, int y) {
  int g = y;
    while (x > 0) {
      g = x;
      x = y % x;
      y = g;
    }
  return g;
}

bool in_mandel(double x0, double y0, int n) {
    double x = 0, y = 0, xtemp;
    while(n > 0) {
      xtemp = x * x - y * y + x0;
      y = 2 * x * y + y0;
      x = xtemp;
      n -= 1;
      if (x * x + y * y > 4) return false;
    }
    return true;
}

int divide(int a, int b, int *remainder) {
  int quot = a / b;
  *remainder = a % b;
  return quot;
}

double avg(double *a, int n) {
  int i;
  double total = 0.0;
  for (i = 0; i < n; i++) {
    total += a[i];
  }

  return total / n;
}

double distance(Point *p1, Point *p2) {
  return hypot(p1->x - p2->x, p1->y - p2->y);
}

#include <math.h>
#include <stdbool.h>

extern int gcd(int, int);
extern bool in_mandel(double x0, double y0, int n);
extern int divide(int a, int b, int *remainder);
extern double avg(double *a, int n);
typedef struct Point {
  double x, y;
} Point;

extern double distance(Point *p1, Point *p2);

import ctypes
from typing import List, cast
from array import array
import os

"""
c_int is mutable as opposed to int in python.
"""

_file = 'libsample.so'
_path = os.path.join(
    *(os.path.split(os.path.abspath(__file__))[:-1] + (_file,)))
_mod = ctypes.cdll.LoadLibrary(_path)

# int gcd(int x, int y)
gcd = _mod.gcd
gcd.argtypes = (ctypes.c_int, ctypes.c_int)
gcd.restype = ctypes.c_int

# bool in_mandel(double x0, double y0, int n)
in_mandel = _mod.in_mandel
in_mandel.argtypes = (ctypes.c_double, ctypes.c_double, ctypes.c_int)
in_mandel.restype = ctypes.c_bool

# int divide(int a, int b, int *remainder) {
_divide = _mod.divide
_divide.argtypes = (ctypes.c_int, ctypes.c_int,
                    ctypes.POINTER(ctypes.c_int))
_divide.restype = ctypes.c_int


def divide(x, y):
    """
    wrapper around c calling convention that is
    not compatibile with python.
    """
    rem = ctypes.c_int()
    quot = _divide(x, y, rem)
    return quot, rem.value


# double avg(double *a, int n)
# special type for double*
class DoubleArrayType:
    """
    Map equivalent python sequence to c array.
    """

    def from_param(self, param):
        typename = type(param).__name__
        if hasattr(self, 'from_' + typename):
            return getattr(self, 'from_' + typename)(param)
        elif isinstance(param, ctypes.Array):
            return param
        else:
            raise TypeError(f"Can't convert {typename}")

    def from_array(self, param: array):
        if param.typecode != 'd':
            raise TypeError("Must be an array of doubles")
        ptr, _ = param.buffer_info()
        return ctypes.cast(
            ptr, ctypes.POINTER(ctypes.c_double))  # type: ignore

    def from_list(self, param: List[float]):
        val = ((ctypes.c_double) * len(param))(*param)
        return val

    from_tuple = from_list

    def from_ndarray(self, param):
        return param.ctypes.data_as(ctypes.POINTER(ctypes.c_double))


DoubleArray = DoubleArrayType()
_avg = _mod.avg
_avg.argtypes = (DoubleArray, ctypes.c_int)  # type: ignore
_avg.restype = ctypes.c_double


def avg(values):
    return _avg(values, len(values))


class Point(ctypes.Structure):
    _fields_ = [('x', ctypes.c_double),
                ('y', ctypes.c_double)]


distance = _mod.distance
distance.argtypes = (ctypes.POINTER(Point), ctypes.POINTER(Point))
distance.restype = ctypes.c_double
#include <Python.h>
#include <math.h>

typedef struct Point {
  double x, y;
} Point;

double distance(Point *p1, Point *p2) {
  return hypot(p1->x - p2->x, p1->y - p2->y);
}


import sample

if __name__ == "__main__":
    print(sample.gcd(10, 2))
#include <Python.h>
#include "sample.h"

static PyObject *py_gcd(PyObject *self, PyObject *args) {
  int x, y, result;
  if (!PyArg_ParseTuple(args, "li", &x, &y)) {
    return NULL;
  }
  result = gcd(x, y);
  return Py_BuildValue("i", result);
}

static PyObject *py_in_mendel(PyObject *self, PyObject *args) {
  double x0, y0;
  int n;
  int result;

    if (!PyArg_ParseTuple(args, "ddi", &x0, &y0, &n)) {
        return NULL;
    }

    result = in_mandel(x0, y0, n);
    return Py_BuildValue("i", result);
}

static PyObject *py_divide(PyObject *self, PyObject *args) {
  int a, b, quotient, remainder;
  if (!PyArg_ParseTuple(args, "li", &a, &b)) {
    return NULL;
  }

  quotient = divide(a, b, &remainder);
  return Py_BuildValue("(ii)", quotient, remainder);
}

static PyMethodDef SampleMethods[] = {
  {"gcd", py_gcd, METH_VARARGS, "Greatest common divisor"},
  {"in_mandel", py_in_mendel, METH_VARARGS, "Manderbrot test"},
  {"divide", py_divide, METH_VARARGS, "Integer division"},
  {NULL, NULL, 0, NULL}
};

static struct PyModuleDef samplemodule = {
  PyModuleDef_HEAD_INIT,
  "sample",
  "A sample module",
  -1,
  SampleMethods
};

PyMODINIT_FUNC
PyInit_sample(void) {
  return PyModule_Create(&samplemodule);
}



#include "sample.h"

int gcd(int x, int y) {
  int g = y;
    while (x > 0) {
      g = x;
      x = y % x;
      y = g;
    }
  return g;
}

bool in_mandel(double x0, double y0, int n) {
    double x = 0, y = 0, xtemp;
    while(n > 0) {
      xtemp = x * x - y * y + x0;
      y = 2 * x * y + y0;
      x = xtemp;
      n -= 1;
      if (x * x + y * y > 4) return false;
    }
    return true;
}

int divide(int a, int b, int *remainder) {
  int quot = a / b;
  *remainder = a % b;
  return quot;
}

double avg(double *a, int n) {
  int i;
  double total = 0.0;
  for (i = 0; i < n; i++) {
    total += a[i];
  }

  return total / n;
}

double distance(Point *p1, Point *p2) {
  return hypot(p1->x - p2->x, p1->y - p2->y);
}

#include <math.h>
#include <stdbool.h>

extern int gcd(int, int);
extern bool in_mandel(double x0, double y0, int n);
extern int divide(int a, int b, int *remainder);
extern double avg(double *a, int n);
typedef struct Point { double x, y; } Point;
extern double distance(Point *p1, Point *p2);

from distutils.core import setup, Extension


setup(name="sample",
      ext_modules=[
          Extension("sample",
                    sources=["pysample.c"],
                    include_dirs=["./"],
                    define_macros=[("FOO", "1")],
                    undef_macros=["BAR"],
                    library_dirs=["./"],
                    libraries=["sample"])
      ])

import threading
from contextlib import contextmanager
import random

# thread local state to store information on lock already acquired.
_local = threading.local()


@contextmanager
def acquire(*locks):
    locks = sorted(locks, key=lambda x: id(x))
    acquired = getattr(_local, 'acquired', [])

    # make sure lock order of previously acquired locks is not violated
    if acquired and max(id(lock) for lock in acquired) >= id(locks[0]):
        raise RuntimeError("Lock Order Violation")

    acquired.extend(locks)
    _local.acquired = acquired

    try:
        for lock in locks:
            lock.acquire()
        yield
    finally:
        for lock in reversed(locks):
            lock.release()
        del acquired[:]


if __name__ == "__main__":
    # a quirk. You cannot use [Lock()] * 3 because it copy reference
    locks = [threading.Lock(),
             threading.Lock(),
             threading.Lock()]

    def worker(tid: int):
        while True:
            random.shuffle(locks)
            with acquire(*locks):
                print(f"Thread {tid}")

    threads = [threading.Thread(target=worker, args=(i,))
               for i in range(5000)]

    for t in threads:
        t.start()


from threading import Thread, Event
import time


def countdown(n, start_evt: Event):
    print("countdown starting")
    start_evt.set()
    while n > 0:
        print("T-minus", n)
        n -= 1
        time.sleep(1)


if __name__ == "__main__":
    # event object will be used to startup event.
    # it can be passed around and be set by any threads.
    start_evt = Event()

    print("Lanuching countdown")
    t = Thread(target=countdown, args=(10, start_evt))
    t.start()

    start_evt.wait()
    print("countdown is running")
import gzip
import io
import glob
from concurrent import futures


def find_robots(filename):
    robots = set()
    with gzip.open(filename) as f:
        for line in io.TextIOWrapper(f, encoding='ascii'):
            fields = line.split()
            if fields[6] == '/robots.txt':
                robots.add(fields[0])
    return robots


def find_all_robots(logdir):
    files = glob.glob(logdir + '/*.log.gz')
    all_robots = set()
    with futures.ProcessPoolExecutor() as pool:
        for robots in pool.map(find_robots, files):
            all_robots.update(robots)
    return all_robots


if __name__ == "__main__":
    robots = find_all_robots('logs/')
    for ipaddr in robots:
        print(ipaddr)
"""
Actor model. simple approach to concurrency and distributed computing.
"""
from queue import Queue
from threading import Thread, Event
from abc import ABC, abstractmethod
from typing import Generic, TypeVar


T = TypeVar('T')


class ActorExit(Exception):
    pass


class Actor(ABC, Generic[T]):
    """
    communication with actors is one way and async.
    """
    def __init__(self):
        self._queue: Queue[T] = Queue()

    def send(self, msg: T):
        """
        send message to the actor
        """
        self._queue.put(msg)

    def recv(self):
        """
        receive an message.
        """
        msg = self._queue.get()
        if msg is ActorExit:
            raise ActorExit()
        return msg

    def close(self):
        self.send(ActorExit)

    def start(self):
        """
        start concurrent execution
        """
        self._terminated = Event()
        t = Thread(target=self._bootstrap)
        t.daemon = True
        t.start()

    def _bootstrap(self):
        try:
            self.run()
        except ActorExit:
            pass
        finally:
            self._terminated.set()

    def join(self):
        self._terminated.wait()

    @abstractmethod
    def run(self):
        """ override """
        raise NotImplementedError("Actor need to be override")


class PrintActor(Actor):
    def run(self):
        while True:
            msg = self.recv()
            print("Got: ", msg)


class TaggedActor(Actor):
    """
    allows call different methods according to tag message received.
    """
    def run(self):
        while True:
            tag, *payload = self.recv()
            getattr(self, 'do_' + tag)(*payload)

    def do_A(self, x):
        print('running A: ', x)

    def do_B(self, *args):
        print('running A: ', *args)


class Result:
    """ Promiseish """
    def __init__(self):
        self._evt = Event()
        self._result = None

    def set_result(self, value):
        self._result = value
        self._evt.set()

    def result(self):
        self._evt.wait()
        return self._result


class WorkerActor(Actor):
    def submit(self, func, *args, **kwargs):
        r = Result()
        self.send((func, args, kwargs, r))
        return r

    def run(self):
        while True:
            func, args, kwargs, r = self.recv()
            r.set_result(func(*args, **kwargs))


if __name__ == "__main__":
    worker1 = WorkerActor()
    worker2 = WorkerActor()
    worker1.start()
    worker2.start()

    for i in range(0, 50):
        r = worker1.submit(pow, 2, i)
        print("worker 1", r.result())
    for i in range(0, 50):
        r = worker2.submit(pow, i, 2)
        print("worker 2", r.result())

    worker1.close()
    worker1.join()
    worker2.close()
    worker2.join()
from collections import deque


class ActorScheduler:
    def __init__(self):
        self.actors = {}
        self._msg_queue = deque()

    def new_actor(self, name, actor):
        """ get new actor to schduler  """
        self._msg_queue.append((actor, None))
        self._actors[name] = actor

    def send(self, name, msg):
        """ send msg to actor """
        actor = self._actors.get(name)
        if actor:
            self._msg_queue.append((actor, msg))

    def run(self):
        while self._msg_queue:
            actor, msg = self._msg_queue.popleft()
            try:
                actor.send(msg)
            except StopIteration:
                pass
"""
publish/subscribe messaging.
Use a separate exchange obj to route messages.
"""

from collections import defaultdict
from typing import Dict, Set, Tuple, Sequence
from abc import ABC, abstractmethod
from contextlib import contextmanager
import multiprocessing
from functools import partial
import random
import time

Matrix = Sequence[Sequence]


class Task(ABC):
    @abstractmethod
    def send(self, msg):
        """ send message"""


class Exchange:
    """
    Benefit:
        1. simplify wring.
        2. can broadcast msg to a set of tasks
        3. works for any task like object with send. task, generator etc..
    """

    def __init__(self):
        self._subscriber: Set[Task] = set()

    def attach(self, task):
        self._subscriber.add(task)

    def detach(self, task):
        self._subscriber.remove(task)

    @contextmanager
    def subscribe(self, *tasks):
        for task in tasks:
            self.attach(task)
        try:
            yield
        finally:
            for task in tasks:
                self.detach(task)

    def send(self, msg):
        for subscriber in self._subscriber:
            subscriber.send(msg)


_exchange: Dict[str, Exchange] = defaultdict(Exchange)


def get_exchange(name):
    return _exchange[name]


class DisplayMessageTask(Task):
    def __init__(self):
        self.count = 0

    def send(self, msg: str):
        self.count += 1
        print('msg[{}]: {!r}'.format(self.count, msg))


class MatrixMultiplyTask(Task):
    def __init__(self):
        ...

    def send(self, msg: Tuple[Matrix, Matrix]) -> Matrix:
        m1, m2 = msg
        if len(m1[0]) != len(m2):
            raise TypeError("invalid matrix shape")

        start = time.time()
        res1 = self.mul(m1, m2)
        print('time for parallel: ', time.time() - start)

        start = time.time()
        self.mul1(m1, m2)
        print('time for sequential: ', time.time() - start)

        return res1

    def mul(self, m1: Matrix, m2: Matrix) -> Matrix:
        res = []
        with multiprocessing.Pool(7) as pool:
            for v in m1:
                dotonv = partial(self.dot, v)
                vout = pool.map(dotonv, zip(*m2))
                res.append(vout)
        return res

    def mul1(self, m1: Matrix, m2: Matrix) -> Matrix:
        """ sequential """
        res = []
        for v in m1:
            dotonv = partial(self.dot, v)
            vout = map(dotonv, zip(*m2))
            res.append(list(vout))
        return res

    @staticmethod
    def dot(v1: Tuple, v2: Tuple) -> float:
        return sum(map(lambda vtup: vtup[0] * vtup[1], zip(v1, v2)))


def init_square_matrix(nrow) -> Tuple[Matrix, Matrix]:
    m1 = [[random.randint(0, 10) for _ in range(nrow)]
          for _ in range(nrow)]
    m2 = [[(15 if i == j else 0) for j in range(nrow)]
          for i in range(nrow)]
    print('finished initialization')

    return m1, m2


if __name__ == "__main__":
    exc = get_exchange('name')
    matexc = get_exchange('matrix')

#     task1 = DisplayMessageTask()
#     task2 = DisplayMessageTask()
#     with exc.subscribe(task1, task2):
#         exc.send("msg1")
#         exc.send("msg2")

    task3 = MatrixMultiplyTask()
    with matexc.subscribe(task3):
        matexc.send(init_square_matrix(400))

import threading
import time

"""
Use condition if a thread need to set a flag many times.
"""


class PerodicTimer:
    def __init__(self, interval: float):
        self._flag = 0x0
        self._interval = interval
        self._cv = threading.Condition()

    def start(self):
        t = threading.Thread(target=self.run)
        # daemonic thread cannot join.
        # it will join automatically after process terminated.
        t.daemon = True
        t.start()

    def run(self):
        while True:
            time.sleep(self._interval)
            with self._cv:
                self._flag ^= 0x1
                # send a notification.
                self._cv.notify_all()

    def wait_for_tick(self):
        with self._cv:
            last_flag = self._flag
            while last_flag == self._flag:
                # block until notify is received.
                self._cv.wait()


def countdown(nticks):
    while nticks > 0:
        ptimer.wait_for_tick()
        print("T-minus", nticks)
        nticks -= 1


if __name__ == "__main__":
    ptimer = PerodicTimer(0.5)
    ptimer.start()

    t = threading.Thread(target=countdown, args=(5,))
    t.start()
    while True:
        if not t.is_alive():
            print("exit program ...")
            break
"""
Implement your own thread safe data structure.
"""
import heapq
import threading

_sentinel = object()
sentinel_prori = 3


class PriorityQueue:
    def __init__(self):
        self._queue = []
        self._count = 0
        self._cv = threading.Condition()

    def put(self, item, priority):
        with self._cv:
            # note priority queue holds a tuple a priority and items.
            heapq.heappush(self._queue, (-priority, self._count, item))
            self._count += 1
            self._cv.notify()

    def get(self):
        with self._cv:
            while len(self._queue) == 0:
                # wati till new item is put.
                self._cv.wait()
            # pop item
            return heapq.heappop(self._queue)[-1]


def producer(pq: PriorityQueue):
    """ higher priority for even i"""
    for i in range(10):
        priority = 2 if i % 2 == 0 else 1
        pq.put(i, priority)
        print(f"[producer] data: {i}, priority: {priority}")
    pq.put(_sentinel, sentinel_prori)  # sentinel has higher priority.


def consumer(pq: PriorityQueue, tid: int):
    while True:
        data = pq.get()
        if data is _sentinel:
            pq.put(_sentinel, sentinel_prori)
            break
        print(f'[cosumer {tid}]', f'data: {data}')


if __name__ == "__main__":
    q = PriorityQueue()
    threads = [threading.Thread(target=consumer, args=(q, i))
               for i in range(10)]
    threads.append(threading.Thread(target=producer, args=(q,)))

    for t in threads:
        t.start()

    for t in threads:
        t.join()


from threading import Thread, Semaphore
import time


def worker(n, sema: Semaphore):
    sema.acquire()
    print("working", n)
    time.sleep(1)
    sema.release()


if __name__ == "__main__":
    sema = Semaphore(5)
    nworkers = 10

    threads = [Thread(target=worker, args=(i, sema,)) for i in range(10)]
    for t in threads:
        t.start()

    for t in threads:
        t.join()
"""
Storing thread specific state.
"""
from socket import socket, AF_INET, SOCK_STREAM
import threading
from functools import partial


class LazyConnection:
    def __init__(self, address, familiy=AF_INET, type=SOCK_STREAM):
        self.address = address
        self.familiy = familiy
        self.type = type
        self.local = threading.local()

    def __enter__(self):
        """ with thread local each thread create their own socket """
        if hasattr(self.local, 'sock'):
            raise RuntimeError("Already connected")
        self.local.sock = socket(self.familiy, self.type)
        self.local.sock.connect(self.address)
        return self.local.sock

    def __exit__(self, exc_ty, exc_val, tb):
        self.local.sock.close()
        del self.local.sock


def test(conn):
    """
    Each thread has its own local connection, less chaotic.
    """
    with conn as s:
        s.send(b"GET /index.html HTTP/1.0\r\n")
        s.send(b"Host: www.python.org\r\n")
        s.send(b"\r\n")
        resp = b''.join(iter(partial(s.recv, 8192), b''))

    print("Got {} bytes".format(len(resp)))


if __name__ == "__main__":
    conn = LazyConnection(("www.python.org", 80))
    t1 = threading.Thread(target=test, args=(conn,))
    t2 = threading.Thread(target=test, args=(conn,))
    t1.start()
    t2.start()
    t2.join()
    t2.join()
from socket import socket, AF_INET, SOCK_STREAM
from concurrent.futures import ThreadPoolExecutor
from queue import Queue
from threading import Thread


def echo_client1(sock: socket, client_addr):
    print("Got connection from ", client_addr)
    while True:
        msg = sock.recv(65536)
        if not msg:
            break
        sock.sendall(msg)
    print("Client closed connection")
    sock.close()


def echo_server1(addr):
    """ with thread pool """
    pool = ThreadPoolExecutor(128)
    sock = socket(AF_INET, SOCK_STREAM)
    sock.bind(addr)
    sock.listen(5)
    while True:
        client_sock, client_addr = sock.accept()
        pool.submit(echo_client1, client_sock, client_addr)


def echo_client2(q: Queue):
    client_sock, client_addr = q.get()
    print("Got connection from ", client_addr)
    while True:
        msg = client_sock.recv(65536)
        if not msg:
            break
        client_sock.sendall(msg)
    print("Client closed connection")
    client_sock.close()


def echo_server2(addr, nworker):
    """ with queue """
    q = Queue()
    for n in range(nworker):
        t = Thread(target=echo_client2, args=(q,))
        t.daemon = True
        t.start()

    sock = socket(AF_INET, SOCK_STREAM)
    sock.bind(addr)
    sock.listen(5)
    while True:
        client_sock, client_addr = sock.accept()
        q.put((client_sock, client_addr))


if __name__ == "__main__":
    thread_server1 = Thread(target=echo_server1, args=(('', 15000),))
    thread_server2 = Thread(target=echo_server2, args=(('', 15001), 128,))
    thread_server1.start()
    thread_server2.start()

"""
Coordinate shutdown of producer and consumer with queue.
"""
from queue import Queue
from threading import Thread


# a signal object be pushed into queue to
# notify consumers to shutdown.
_sentinel = object()


def producer(out_q: Queue):
    """ when job finished put sentinel into queue """
    for i in range(100, 120):
        out_q.put(i)
    out_q.put(_sentinel)


def consumer(in_q: Queue, tid: int):
    while True:
        data = in_q.get()

        if data is _sentinel:
            # put sentinel back to queue to inform other consumer to shutdown
            in_q.put(_sentinel)
            break

        print(f'cosumer {tid}', f'data: {data}')


if __name__ == "__main__":
    queue: Queue = Queue(maxsize=10)
    threads = [Thread(target=consumer, args=(queue, i)) for i in range(10)]
    threads.append(Thread(target=producer, args=(queue,)))

    for t in threads:
        t.start()

    for t in threads:
        t.join()


import weakref
import gc


class Dummy:
    """
    Dummy with visible lifecycle.
    """
    def __init__(self, name):
        self.obj = None
        self.name = name

    def __del__(self):
        print('destroyed')

    def store(self, obj):
        self.obj = obj

    def show(self):
        print(self.obj)


def weakr():
    print('start ---')
    a = Dummy('1')
    r = weakref.ref(a)
    r().show()
    print('ref deleted')
    del a

    print('try to call weak ref')
    try:
        r().show()
    except AttributeError:
        print('object is collected')
    del r

    print('end ---')


def weakRefToCache():
    """
    its to cache object for a little longer.
    not really cache
    """
    d = Dummy('Big Object')

    w = weakref.WeakValueDictionary()
    w['d'] = d
    d.store('turturtur')

    w['d'].show()
    del d
    gc.collect()



if __name__ == "__main__":
    weakr()
    print('====================')
    weakRefToCache()
import sys


class SkipBlockException(Exception):
    pass


class MyContext:
    def __init__(self, mode=0):
        self.mode = mode

    def __enter__(self):
        if self.mode == 1:
            print('block it...')

            sys.settrace(lambda *args, **kwargs: None)
            frame = sys._getframe(1)
            frame.f_trace = self.trace

    def trace(self, frame, event, arg):
        raise SkipBlockException()

    def __exit__(self, type, value, traceback):
        if type is None:
            return
        if issubclass(type, SkipBlockException):
            return True


if __name__ == "__main__":
    with MyContext(mode=0):
        print('1')

    with MyContext(mode=1):
        print('2')
"""
keyboard need permission.
works better under tmux.
"""

from typing import List
import os
import time
import random
import keyboard
import copy


class Game:
    run = True
    width = 180
    height = 30
    map_style = '.'

    def __init__(self):
        self.pause = False
        self.map = [self.map_style * self.width for _ in range(self.height)]
        self.obj_list: List[Obj] = []
        self.snake = Snake(self.width, self.height)
        self.food = Food(self.width, self.height)

    def _form_obj_list(self):
        self.obj_list = []
        for body in self.snake.body_list:
            body.style = "#"

        self.snake.body_list[-1].style = "A"

        self.obj_list.extend(self.snake.body_list)
        self.obj_list.append(self.food)

    def start(self):
        while self.run:
            if keyboard.is_pressed('p'):
                self.pause = True
                while self.pause:
                    time.sleep(0.02)
                    if (keyboard.is_pressed('w')
                            or keyboard.is_pressed('s')
                            or keyboard.is_pressed('a')
                            or keyboard.is_pressed('d')):
                        self.pause = False

            self._form_obj_list()
            self.update()
            self.snake.move()

            if self.snake.body_list[-1].pos == self.food.pos:  # update food
                self.food = Food(self.width, self.height)
                self.snake.eat()

            if keyboard.is_pressed('up') or keyboard.is_pressed('w'):
                self.snake.move(0)
                continue
            if keyboard.is_pressed('down') or keyboard.is_pressed('s'):
                self.snake.move(1)
                continue
            if keyboard.is_pressed('left') or keyboard.is_pressed('a'):
                self.snake.move(2)
                continue
            if keyboard.is_pressed('right') or keyboard.is_pressed('d'):
                self.snake.move(3)
                continue

    def update(self):
        # update map by object state.

        os.system('clear')
        # the view map is a deep copy of map, discarded in each update.
        view_map = copy.deepcopy(self.map)
        print('snake head: ',
              self.snake.body_list[-1].pos,
              'length: ', len(self.snake.body_list))

        for o in self.obj_list:
            x, y = o.pos
            # if x, y are outside of the map
            if x < self.height and y < self.width:
                map_row = view_map[x]
                map_dots = [map_row[i] for i in range(len(map_row))]
                map_dots[y] = o.style

                new_row = ''
                for dot in map_dots:
                    new_row += dot
                view_map[x] = new_row

        for row in view_map:  # print row by row
            print(row)

        time.sleep(0.03)

class Obj:
    def __init__(self, x, y, style):
        self.pos = (x, y)
        self.style = style


class Food(Obj):
    def __init__(self, width, height):
        super().__init__(random.randint(0, height - 1), random.randint(0, width - 1), '@')


class SnakeBody(Obj):
    def __init__(self, x, y):
        super().__init__(x, y, '#')


class Snake:
    body_list: List[SnakeBody] = []

    def __init__(self, width, height):
        self.body_list.append(SnakeBody(random.randint(
            0, height - 1), random.randint(0, width - 1)))
        self.direction = 0  # init direction 0 left, 1 right, 2 up, 3 down.

    def eat(self):
        last_x, last_y = self.body_list[-1].pos
        if self.direction == 0:
            self.body_list.append(SnakeBody(last_x - 1, last_y))

        if self.direction == 1:
            self.body_list.append(SnakeBody(last_x + 1, last_y))

        if self.direction == 2:
            self.body_list.append(SnakeBody(last_x, last_y - 1))

        if self.direction == 3:
            self.body_list.append(SnakeBody(last_x, last_y + 1))

    def move(self, direction: int = -1):
        snake_head = self.body_list[-1]
        x, y = snake_head.pos

        if direction == -1:
            direction = self.direction

        if direction == 0:
            self.direction = 0
            self.body_list.append(SnakeBody(x - 1, y))
            self.body_list.pop(0)

        if direction == 1:
            self.direction = 1
            self.body_list.append(SnakeBody(x + 1, y))
            self.body_list.pop(0)

        if direction == 2:
            self.direction = 2
            self.body_list.append(SnakeBody(x, y - 1))
            self.body_list.pop(0)

        if direction == 3:
            self.direction = 3
            self.body_list.append(SnakeBody(x, y + 1))
            self.body_list.pop(0)


if __name__ == "__main__":
    game = Game()
    game.start()
from html.parser import HTMLParser
from urllib.request import urlopen
from urllib import parse


class LinkParser(HTMLParser):

    def __init__(self):
        self.baseUrl = ''

    def handle_starttag(self, tag, attrs):
        if tag == 'a':
            for (key, value) in attrs:
                if key == 'href':
                    newUrl = parse.urljoin(self.baseUrl, value)
                    self.links = self.links + [newUrl]

    def getLinks(self, url):
        self.links = []
        self.baseUrl = url
        response = urlopen(url)
        if response.getheader('Content-Type') == 'text/html':
            htmlBytes = response.read()
            htmlString = htmlBytes.decode('utf-8')
            self.feed(htmlString)
            return htmlString, self.links
        else:
            return '', []


def spider(url, word, max_pages=100):
    pages_to_visits = [url]
    number_visited = 0
    found_word = False

    while number_visited < max_pages and pages_to_visits != [] and not found_word:
        number_visited += 1
        url = pages_to_visits[0]
        pages_to_visits = pages_to_visits[1:]
        try:
            print(number_visited, 'Visiting:', url)
            parser = LinkParser()
            data, links = parser.getLinks(url)
            if data.find(word) > -1:
                found_word = True
            pages_to_visits = pages_to_visits + links
            print(' ** Success! **')
        except Exception:
            print(' ** Failed! **')

    if found_word:
        print('The word', word, 'was found at', url)
    else:
        print('Word never found')
"""
be familiar with sqlalchemy.

ORM===================================
              ORM
core =================================
    | ddl |, | sql expr | , | engine |
    | dialect |, | connection |
dbapi ================================
          python DBAPI
======================================

ACID Transaction.
    atomic,
    consistency (order),
    isolation (changes inside transaction aren't visible),
        (historically implemented bylock,
         modern databases use `multiversion councurrency control`)
    durability (commit guarantee).
"""

from sqlalchemy import Table, Column, Enum, Numeric
from sqlalchemy import Integer, String
from sqlalchemy import Unicode, UnicodeText
from sqlalchemy import MetaData
from sqlalchemy import DateTime
from sqlalchemy import ForeignKey
from sqlalchemy import ForeignKeyConstraint
from sqlalchemy import create_engine
from sqlalchemy import inspect
from sqlalchemy import and_, or_, select, func
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import Session
from sqlalchemy.orm import aliased
from sqlalchemy import func
from sqlalchemy import relationship


Base = declarative_base()

# can have as many Base as you want.
Base1 = declarative_base()


"""
NOTE PEP249
"""


"""
Engine Facts:
    Executing via Engine directly is called connectionless exection.
    Engine connect and disconect for us.

    Using Connection is explict execution. we control the span of
    a connection in use.

    Engine ususally use a connection pool, which means "disconecting"
    often means the connection just return to the pool.

    SQL we send to engine.execute() as a string is not modified,
    is consumed by the DBAPI verbatim.
"""


def engine_fn1():
    """
    By default their will be a connection pool run on the background
    engine.execute(...) will be automatically assigned with a connection
    """
    # Engine
    engine = create_engine("sqlite:///some.db")

    # different dbapi has different url
    # engine2 = create_engine("postgresql:///some:db@localhost/test")

    # Result. (like a handle on returned value on cursor.)
    # NOTE: DBAPI doesn't autocommit by default.
    # execute() will "autocommit" statements like INSERT by default.
    result = engine.execute(
        "select emp_id, emp_name from employee where emp_id=:emp_id",
        emp_id=3)

    # fetch one row.
    row = result.fetchone()
    print(row)
    print(row['emp_name'])
    print(row['emp_id'])

    # result is iterartor.
    for row in result:
        print(row)

    # when get all the rows under the cursor
    # the result will close automatically.
    # clean up the connection back to the connection pool.
    result.close()


def engine_fn2():
    """
    control the scope of the connection by explicitly create a conection
    from engine, and execute sql under the same connection.
    """
    engine = create_engine("sqlite:///some.db")
    conn = engine.connect()
    result = conn.execute("select * from employee")
    result.fetchall()
    conn.close()


def engine_fn3():
    """
    run several statements inside a transaction.
    connection features a begin() method that returns a Transaction.

    `Transaction` is a session that multiple sql are executed within
    one connection. it happens on one connection at a time.

    In the senarios the connection is a session to the database.
    """
    engine = create_engine("sqlite:///some.db")

    conn = engine.connect()

    trans = conn.begin()
    conn.execute("insert into employee (emp_name) values (:emp_name)",
                 emp_name="wendy")
    conn.execute("insert into employee (emp_name) values (:emp_name)",
                 emp_name="wendy")
    trans.commit()

    conn.close()

    # transaction also works with
    with engine.begin() as conn:
        conn.execute("insert into employee (emp_name) values (:emp_name)",
                     emp_name="wendy")
        conn.execute("insert into employee (emp_name) values (:emp_name)",
                     emp_name="wendy")


"""
DDL, metadata.

Metadata/Schema:
    - describe the structure of database in terms of python structure.
    - Generate to and from schema.

`Metadata` as a collection of mutiple `Table`.
`Table` is a object representation of database table
 calling Table registers the Table to Metadata directly.
"""


def ddl_fn1():
    """ Metadata that describe db table """
    meta = MetaData()
    user_table = Table(
        'user', meta,
        Column('id', Integer, primary_key=True),
        Column('name', String),
        Column('fullname', String))

    # .c is an associative array of column objects
    print(user_table.c.name)   # [out] Column('name', String)
    print(user_table.c.id)

    # each column has it's attributes.
    name_col: Column = user_table.c.name
    print(name_col.type)    # String
    print(name_col.name)    # 'name'

    # The table object is the core of sql expression
    # this will output a string of sql.
    print(user_table.select())  # [out] SELECT "user".id,  ...


def ddl_fn2():
    engine = create_engine("sqlite://")

    meta = MetaData()
    user_table = Table(
        'user', meta,
        Column('id', Integer, primary_key=True),
        Column('name', String),
        Column('fullname', String),
        Column('price', Numeric(10, 2)),
        Column('type', Enum('a', 'b', 'c')))

    # table meta data allows for constraints and indexes.
    # ForeignKey is used to link one column to a remote
    # primary key.
    address_table = Table(
        'address', meta,
        Column('id', Integer, primary_key=True),
        Column('email_address', String(100), nullable=False),
        Column('user_id', Integer, ForeignKey('user.id')))

    # create  a schema in database.
    meta.create_all(engine)


def ddl_fn3():
    """
    Composite key as foregin key
    """

    meta = MetaData()
    story_table = Table(
        'story', meta,
        Column('story_id', Integer, primary_key=True),
        Column('version_id', Integer, primary_key=True),
        Column('headline', Unicode(100), nullable=False),
        Column('body', UnicodeText))

    published_table = Table(
        'published', meta,
        Column('pub_id', Integer, primary_key=True),
        Column('pub_time', DateTime, nullable=False),
        Column('story_id', Integer),
        Column('version_id', Integer),
        ForeignKeyConstraint(['story_id', 'version_id'],
                             ['story.story_id', 'story.version_id']))


def ddl_fn4():
    """
    reflection. Pull table into metadata from a existed database.
    """
    engine = create_engine("sqlite://")
    meta = MetaData()
    user_reflected = Table('user', meta, autoload=True, autoload_with=engine)
    print(user_reflected)

    # inspect information of a tale.
    inspector = inspect(engine)
    print(inspector.get_columns())


def ddl_fn5():
    """
    create drop
    """

    engine = create_engine("sqlite://")
    meta = MetaData()
    meta.create_all(engine)
    meta.drop_all(engine)

    user_reflected = Table('user', meta, autoload=True, autoload_with=engine)
    user_reflected.drop()


"""
 This is used either directly or throught the ORM.
 sql expression is build upon table matadata in order
 to compose sql statements in python.
 workflow:
    - build python object that represents individual sql statement.
    - the object is composed of other objects that each represents some
      unit of sql.
    - we work with this objects, which are than converted to strings when
      we 'execute' them.
"""


def sql_fn1():
    engine = create_engine("sqlite://")
    meta = MetaData()
    user_table = Table(
        'user', meta,
        Column('id', Integer, primary_key=True),
        Column('username', String(50)),
        Column('fullname', String(50)),
        Column('type', Enum('a', 'b', 'c')))
    meta.create_all(engine)

    # Type: sql.expression.BinaryExpression
    # mro of sql.expression.BinaryExpression will
    # resolve to operators of column elements.
    print(user_table.c.username == 'ed')
    print(str(user_table.c.username == 'ed'))

    # both | and and_ are logic operetion over
    # column elements. They serves the same purpose.
    print((user_table.c.username == 'ed')
          | (user_table.c.username == 'jack')
          | (user_table.c.username == 'ma'))
    print(
        and_(
            user_table.c.fullname == 'ed jones',
            or_(
                user_table.c.username == 'ed',
                user_table.c.username == 'jones',
                user_table.c.id > 10
            )
        ))
    print(user_table.c.username.in_(["wendy", "marry", "ed"]))


def sql_fn2():
    engine = create_engine("sqlite://")
    meta = MetaData()
    user_table = Table(
        'user', meta,
        Column('id', Integer, primary_key=True),
        Column('username', String(50)),
        Column('fullname', String(50)),
        Column('type', Enum('a', 'b', 'c')))
    meta.create_all(engine)

    # Column operator object.
    expression = (user_table.c.username == 'ed')
    print(expression.left)
    print(expression.right)
    print(expression.operator)  # from python operator lib

    # compile to sql.compiler.SQLCompiler
    compiled = expression.compile()
    # print embeded object into sql.
    print(compiled.params)


def sql_fn3():
    engine = create_engine("sqlite://")
    meta = MetaData()
    user_table = Table(
        'user', meta,
        Column('id', Integer, primary_key=True),
        Column('username', String(50)),
        Column('fullname', String(50)),
        Column('type', Enum('a', 'b', 'c')))

    address_table = Table(
        'address', meta,
        Column('id', Integer, primary_key=True),
        Column('email_address', String(100), nullable=False),
        Column('user_id', Integer, ForeignKey('user.id')))

    meta.create_all(engine)

    engine.execute(user_table
                   .select()
                   .where(user_table.c.username == 'ed'))

    engine.execute(user_table
                   .insert()
                   .values(username='ed', fullname='Ed Jones'))

    # some sql expressions
    with engine.connect() as conn:
        with conn.begin():
            conn.execute(user_table.insert(), [
                {'username': 'jack', 'fullname': 'Jack Burger'},
                {'username': 'wendy', 'fullname': 'Wendy Weathersmith'}
            ])

            d = conn.execute(user_table
                             .select()
                             .where((user_table.c.user_table == 'ed')
                                    | (user_table.c.user_table == 'wendy'))
                             .where(user_table.c.fullname != 'Sam')
                             .order_by(user_table.c.username)).fetchall()
            print(d)

            conn.execute(user_table
                         .join(address_table,
                               user_table.c.id == address_table.c.user_id))

            # subquery against "address" counts addresses per use.
            # select address.user_id, count(address.id) as count
            # from address group by address.user_id
            address_subq = select(
                [address_table.c.user_id,
                 func.count(address_table.c.id).label(
                     'count')
                 ]).group_by(address_table.c.user_id).alias()
            print(address_subq)

            # scalar select. the result is used as a part of another sql
            select_stmt = select(
                [user_table.c.username, address_subq.as_scalar()])
            print(select_stmt)

            update_stmt = (address_table
                           .update()
                           .values(email_address="j@a.com")
                           .where(address_table.c.email_address == "j@b.com"))
            print(update_stmt)


"""
    Object relational mapping.
        associating object oriented classes with database tables.
    object class as `domain model`

    +------------+              +------------+
    | Application|              |    db      |
    +------------+ class.save() +------------+
    |           ------------------>          |
    |            |              |            |
    | domain obj |              |  table row |
    |           <------------------          |
    |            | class.load() |            |
    +------------+              +------------+

    - most orm also repsent basic compositions, primarily one-to-many,
      many-to-one, use foregin key associations.
    - provide a mean of querying dtabase in terms of domain model
    - represent class inheritance hierachies
    - handle sharding of data. (store a domain model across multiple schemas)
    - provide various patterns for councurrency (row versioning)
    - provide pattern for data validation and coercion.

    // Two types of ORM
        Active record VS Data mapper.
    sqlalchemy is data mapper.

    <Key ORM pattern>
    | Unit of work. |
        : objects are maintained by a system that tracks changes over the
          course of a transaction, and flushes pending changes periodically,
          in a transparent manner.
    | Identity Map |
        : objs are tracked by their primary key within the unit of work, and
        are kept unique on that primary key identity. (one object for one
        primary key).
    | lazy loading |
        : Some attributes of an object may emit additional sql queries when
        they are accessed.
    | eager loading |
        : multple tables are quried at once in order to load related objects
        and collections.
    | method chaining |
        : ...
"""


class User(Base):
    __tablename__ = 'user'

    id = Column(Integer, primary_key=True)
    name = Column(String)
    fullname = Column(String)

    def __repr__(self):
        return "<User (%r %r)>" % (self.name, self.fullname)


class Network(Base):
    __tablename__ = "network"
    network_id = Column(Integer, primary_key=True)
    name = Column(String(20), nullable=False)


"""
Joins and relationships
"""


class Adress(Base):
    __tablename__ = 'address'

    id = Column(Integer, primary_key=True)
    email_address = Column(String, nullable=False)
    user_id = Column(Integer, ForeignKey('user.id'))

    # backref set up Adress.user for each User.address.
    # establish a one to many relationship.
    user = relationship('User', backref='addresses')

    def __repr__(self):
        return '<Adress (%r)>' % self.email_address


def orm_fn1():
    # table object for user.
    print(User.__table__)

    # mediate relationship between user class and table
    print(User.__mapper__)


def orm_fn2():
    engine = create_engine("sqlite://")
    Base.metadta.create_all(engine)


def orm_fn3():
    """
    TO persist and load User Object from databse, we use
    Session objecet.

    engine has source of connection. it is typically used
    by being passed to other control objects
    """
    engine = create_engine("sqlite://")
    session = Session(bind=engine)

    # Add a new user, it's at PENDING state.
    # nothing get flush into database yet.
    ed_user = User(name="ed", fullname="Ed Jone")
    session.add(ed_user)
    print(session.new)

    # =========================================================
    # Session will flush PENDING objects into
    # database before each Query.
    # "AUTOFLUSH" // lazy. don't flush until it has to.
    our_user = session.query(User).filter_by(name='ed').first()
    print(our_user)

    # =========================================================
    # identity map. this two are actually the same.
    # as long as they are in the same session.
    #
    # flush is defered, so you need to make sure everything
    # in the same session see the same state, identity map
    # helps us to do that.
    print(ed_user is our_user)  # True

    # repeatable read ...

    session.add_all([
        User(name="Ed", fullname="Ed Je"),
        User(name="eD", fullname="Ed Joe")])

    ed_user.fullname = "Ed JoNES"
    print(session.new)
    print(session.dirty)   # ed_user is changed.

    # =========================================================
    # commit the whole transaction.
    # after commit there is no transaction. The
    # Session "invalidates" all data, so accessing them will
    # automatically start a new transaction and reload from the
    # database.
    session.commit()

    print(ed_user.__dict__)  # not is empty
    print(ed_user.fullname)  # new transaction started.
    print(ed_user.__dict__)  # object is mapped.

    # =========================================================
    # When their is no transaction heppening, Session assumes
    # it knows nothing about the data.
    # transaction is the real source of data.

    ed_user.fullname = "a"
    session.flush()  # forcibaly flush

    # ======= QUERY =============================================
    sel = (select([User.name, User.fullname])
           .where(User.name == 'ed')
           .order_by(User.id))
    # use session.connection() to pull out underneath connection
    res = session.connection().execute(sel).fetchall()
    print(res)

    # or
    query = session.query(User).filter(User.name == 'ed').order_by(User.id)
    print(query.all())

    # use as iterator
    for row in session.query(User, User.name):
        print(row.User, row.name)


def orm_fn4():
    engine = create_engine("sqlite://")
    session = Session(bind=engine)

    ed_user = User(name="ed", fullname="Ed Jone")
    # one to many relationship.
    ed_user.addresses = [
        Adress(email_address="asd@a.com"),
        Adress(email_address="asdi@a.com"),
        Adress(email_address="asd2@a.com"),
    ]

    # cascate rule: cascade objects and flush in the
    # right order.
    session.add(ed_user)

    # commit
    session.commit()

    # after commit, ed_user is gone (expiration.)
    # ed_user.addresses emits a "lazy load" when first
    # accessed.
    print(ed_user.addresses)

    # query with join
    query = (session
             .query(User, Adress)
             .join(Adress, User.id == Adress.user_id)
             .all())
    print(query)

    # alias
    a1, a2 = aliased(Adress)
    query = (session
             .query
             .join(a1)
             .join(a2)
             .filter(a1.email_address == 'asd@gmail.com')
             .filter(a2.email_address == "asd@b.com")
             .all())
    print(query)

    # subquery.
    subq = (session
            .query(func.count(Adress.id).label('count'),
                   User.id.label('user_id'))
            .join(Adress.user)
            .group_by(User.id)
            .subquery())

    query = (session   # use subquery in other queries.
             .query(User.name, func.coalesce(subq.c.count, 0))
             .outerjoin(subq, User.id == subq.c.user_id)
             .all())
    print(query)


"""
many-to-many
"""


class Employee(Base):
    __tablename__ = 'employee'

    id = Column(Integer, primary_key=True)
    name = Column(String(30))

    projects = relationship(
        'Project',
        secondary=Table(
            'employee_project',
            Base.metadata,
            Column('employee_id', Integer, ForeignKey('employee.id'),
                   primary_key=True),
            Column('employee_id', Integer, ForeignKey('employee.id'),
                   primary_key=True)),
        backref='employees')


class Project(Base):
    __tablename__ = 'project'
    id = Column(Integer, primary_key=True)
    name = Column(String(30))
#include <iostream>

// again, the rust example.
void compute1(const int &input, int &output) {
  if (input > 10) {
    output = 1;
  }
  if (input > 5) {
    output *= 2;
  }
}

// rewrite like this
void compute2(const int &input, int &output) {
  if (input > 10) {
    output = 1;
  } else if (input > 5) {
    output *= 2;
  }
}

int main() {

  int value = 10;
  int result = 0;

  // ok, this two have results.
  compute1(value, result);
  compute2(value, result);

  // have different results.
  // because input and output are aliases of the same value,
  // and compute1 mutate the value, which it's value is used for
  // branching.
  compute1(value, value);
  compute2(value, value);
}
// given this function
fn compute1(input: &i32, output: &mut i32) {
    if *input > 10 {
        *output = 1;
    }
    if *input > 5 {
        *output *= 2;
    }
}

// we can rewrite it as this in rust:
// we can do this because a mutable reference cannot be aliased.
// this ensure input and output are different references.
fn compute2(input: &i32, output: &mut i32) {
    let v = *input;
    if v > 10 {
        *output = 1;
    } else if v > 5 {
        *output *= 2;
    }
}

// but in C this will be unsafe. Because we can guarantee input and output
// are aliases of the same value.

// the key point is write is what makes aliasing problematic.
// if there is no write operation, we don't really care how many aliases
// are there.
//
// So we have mutable reference that can't have any aliases, and normal
// references that can have as many aliases as you want.
//
// Aliases in rust carries the notion of liveness and mutation.
// normally you write your code like this.
// but it's actually a sugar. it really looks like this:
// Every thing after a statement will have a new lifetime.
fn lifetime1() {
    let x = 0;
    let y = &x;
    let z = &y;
}

fn lifetime2() {
    // 'a
    let x = 0;
    {
        // 'b
        let y = &x;
        {
            // 'c
            let z = &y;
        }
    }
}

// an example of return dangling pointer
fn as_str(data: &u32) -> String {
    format!("{}", data)
}

fn static_str(data: &u32, out: &mut String) {
    let s = format!("{}", data);
    *out = s;
}

// aliasing a mutable reference

fn aliasing_a_mutable_reference() {
    let mut data = vec![1, 2, 3];
    let x = &data[0]; // immutable borrow of data
    data.push(4); // mutable data

    // using immutable data here.
    // this is not allowed as mutable and immutable references are
    // in the same lifetime.
    // println!("{}", x);
}

fn aliasing_a_mutable_reference_revealed() {
    let mut data = vec![1, 2, 3];
    {
        let x = &data[0]; // immutable borrow of data
        {
            data.push(4); // mutable data
        }
        // data.push creates a mutable reference.
        // x lives longer than data.push,
        // which means we have a mutable reference and an immutable
        // reference at the same time.
        // which fires a lifetime error.

        // println!("{}", x);
    }
}

#[derive(Debug)]
struct X<'a>(&'a i32);

impl Drop for X<'_> {
    fn drop(&mut self) {}
}

fn drop_causes_problem() {
    let mut data = vec![1, 2, 3];
    let x = X(&data[0]);
    println!("{:?}", x);

    // we need to drop x before data.push.
    // because Drop also takes a reference.
    drop(x);
    data.push(4);
}

// limitation of life time.
// TODO
mod aliasing;
mod lifetime;
mod move_out_of_a_field;
mod moves;
use std::mem;


// Rust doesn't allow you to move out a value that implement Drop.

#[derive(Debug)]
struct A;

#[derive(Debug)]
struct B;

#[derive(Debug)]
struct Foo {
    a: A,
    b: B,
}

impl Foo {
    fn take(self) -> (A, B) {
        (self.a, self.b)
    }
}

#[derive(Debug)]
struct Boo {
    a: A,
    b: B,
}

impl Drop for Boo {
    fn drop(&mut self) {}
}

// because we implemened drop foo, so when take()
// returns, self is out of scope.
// self.drop will be called.
// but since self's fields a, b are moved out,
// the original fields will be dangling reference, and
// dropping on it will be UB.

macro_rules! assume_init {
    () => {{
        mem::MaybeUninit::uninit().assume_init()
    }};
}

// here we replcae old fields with dummy value, then just forget self all together.
// forget means destruct the value with
impl Boo {
    fn take(mut self) -> (A, B) {
        let a = mem::replace(&mut self.a, unsafe { assume_init!() });
        let b = mem::replace(&mut self.b, unsafe { assume_init!() });
        mem::forget(self);
        (a, b)
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn basic() {
        let foo = Foo { a: A, b: B };
        let (a, b) = foo.take();
        println!("{:?}", a);
        println!("{:?}", b);
    }
}
// simple moves

struct AType;

impl Drop for AType {
    fn drop(&mut self) {
        println!("Droping A type");
    }
}

fn foo_move<T>(x: T) -> Option<T> {
    println!("foo_move: ");
    None
}

fn foo_borrow<T>(x: &T) -> Option<T> {
    println!("foo_borrow: ");
    None
}

fn foo_borrow_mut<T>(x: &mut T) -> Option<T> {
    println!("foo_borrow_mut: ");
    None
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn drop_atype() {
        let _ = {
            let a = AType {};
            a
        };
    }

    #[test]
    fn basics() {
        let a = AType {};

        foo_move(a);

        // this doesn't work any more.
        // a is moved
        // foo_move(a);

        let a = AType {};

        // shared reference. Have has many as you like.
        foo_borrow(&a);
        foo_borrow(&a);
        foo_borrow(&a);
        foo_borrow(&a);
    }
}
mod macros1 {

    macro_rules! four {
        () => {
            1 + 3
        };
    }

    macro_rules! gibberish {
        (4 fn ['spang "whoammo"] @_@) => {...};
    }

    // different kinds of captures
    // - item: (function, sturct, module, etc.)
    // - block: a block of statement/expression
    // - stmt: a statement
    // - pat: a pattern
    // - expr: an expression
    // - ty: a type
    // - ident: an indentifier
    // - path: a path (::std::mem::replace)
    // - meta: a meta item in #[...] or #![...]
    // - tt: single token tree.

    macro_rules! one_expression {
        ( $e:expr ) => {...};
    }

    macro_rules! times_five {
        ( $e:expr ) => {
            5 * $e
        };
    }

    macro_rules! multiple_add {
        ( $a:expr, $b:expr, $c:expr ) => {
            $a + ($b + $c)
        };
    }

    macro_rules! vec_strs {
        ( $( $e:expr),* ) => {
            {
                let mut v = Vec::new();
                $(v.push(format!("{}", $e));)*
                v
            }
        }
    }

    #[cfg(test)]
    mod test {
        #[test]
        fn test1() {
            let a = 1 + four!();
            let b = times_five!(a);
            let c = multiple_add!(a, b, 10);
            println!("{:?}", c);
        }

        #[test]
        fn test2() {
            let vecs = vec_strs![1, 2, "asd", 'a'];
        }
    }
}
// macros doesn't support backtracking, so you
// need to list macthing rules from the most specific
// to the least

mod macros2 {

    macro_rules! capture_expr_then_stringify {
        ( $e:expr ) => {
            stringify!($e)
        };
    }

    macro_rules! capture_then_match_tokens {
        ( $e:expr ) => {
            match_tokens!($e);
        };
    }

    macro_rules! match_tokens {
        ($a:tt + $b:tt) => {
            "Got an addition"
        };
        (($i:ident)) => {
            "Got an identifier"
        };
        ($($other:tt)*) => {
            "Got something else"
        };
    }

    macro_rules! what_is {
        (#[no_mangle]) => {"no_mangle attribute"};
        (#[inline]) => {"inline attribute"};
        ($($tts:tt)*) => {concat!("Something else (", stringify!($($tts)*), ")")};
        // tt can be used to capture anthing else.
    }

    macro_rules! capture_then_what_is {
        (#[$m:meta]) => {
            what_is!(#[$m])
        };
    }

    macro_rules! using_a {
        ($a:ident, $e:expr) => {{
            let $a = 42;
            $e
        }};
    }

    #[cfg(test)]
    mod test {

        #[test]
        fn test1() {
            // shows stringified token tree.
            println!("{:?}", stringify!(dummy(2 * (1 + (3)))));

            // shows stringified AST nodes.
            println!("{:?}", capture_expr_then_stringify!(dummy(2 * (1 + (3)))));
        }

        #[test]
        fn test2() {
            println!(
                "{}\n{}\n{}\n",
                match_tokens!((caravan)),
                match_tokens!(3 + 6),
                match_tokens!(5)
            );

            // alwasy got something else.
            println!(
                "{}\n{}\n{}\n",
                capture_then_match_tokens!((caravan)),
                capture_then_match_tokens!(3 + 6),
                capture_then_match_tokens!(5)
            );
        }

        #[test]
        fn test3() {
            println!(
                "{}\n{}\n{}\n{}",
                what_is!(#[no_mangle]),
                what_is!(#[inline]),
                capture_then_what_is!(#[no_mangle]),
                capture_then_what_is!(#[inline]),
            );
        }

        #[test]
        fn test4() {
            using_a!(a, a / 10);
        }
    }
}

// debug macros
pub mod macros1;
pub mod macros2;
pub mod macros3;

#![feature(trace_macros)]

// rust macro expand after all code transformed into  AST.
// so any macro written must be valid rust syntax in the first place.

// token tree: [..], {..}, (..) creates a sub tree.

// syntax extension form we can expand.
// $name ! $args

mod examples1 {
    use std::collections::HashMap;

    // code we pass in will be initialized only when they are used.
    lazy_static! {
        static ref HASHMAP: HashMap<u32, &'static str> = {
            let mut m = HashMap::new();
            m.insert(0, "foo");
            m.insert(1, "foo");
            m.insert(2, "foo");
            m
        };
        static ref COUNT: usize = HASHMAP.len();
        static ref NUMBER: u32 = times_two(21);
    }

    fn times_two(n: u32) -> u32 {
        n * 2
    }

    fn run() {
        println!("The map has {} entries", *COUNT);
        println!("The entry for 0 is {}", HASHMAP.get(&0).unwrap());
        println!("A expensive calculatio on a static result in: {}.", *NUMBER);
    }
}

mod examples2 {

    // another example of using macros.
    bitflags! {
        struct Flags: u32 {
            const A = 0b00000001;
            const B = 0b00000010;
            const C = 0b00000100;
            const ABC = Self::A.bits | Self::B.bits | Self::C.bits;
        }
    }

    fn run() {
        let e1 = Flags::A | Flags::C;
        let e2 = Flags::B | Flags::C;
        assert_eq!((e1 | e2), Flags::ABC);
        assert_eq!((e1 & e2), Flags::C);
        assert_eq!((e1 - e2), Flags::A);
        assert_eq!(!e2, Flags::A);
    }
}

mod examples3 {
    bitflags! {
        struct Color: u8 {
            const RED = 0b0001;
            const GREEN = 0b0010;
            const BLUE = 0b0100;
            const BRIGHT = 0b1000;
        }
    }

    lazy_static! {
        static ref FIB_100: u32 = {
            fn fib(a: u32) -> u32 {
                match a {
                    0 => 0,
                    1 => 1,
                    a => fib(a - 1) + fib(a - 2),
                }
            }
            fib(100)
        };
    }

    fn run() {
        let colors = vec![Color::RED, Color::GREEN, Color::BLUE];
        println!("Helo, world");
    }
}
pub mod borrow;
pub mod macros;
pub mod other;
pub mod stdlib;

#![feature(trace_macros)]

#[macro_use]
extern crate lazy_static;

#[macro_use]
extern crate bitfield;

#[macro_use]
extern crate bitflags;

fn main() {
    println!("Hello, world!");
}
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;
use std::thread;

macro_rules! wait {
    ( $lock:expr ) => {
        while $lock.load(Ordering::SeqCst) != 0 {}
    };
}

macro_rules! lock {
    () => {
        Arc::new(AtomicUsize::new(1))
    };
}

macro_rules! clone_lock {
    ( $lock:expr ) => {
        Arc::clone(&$lock)
    };
}

fn atomic_demo1() {
    let spinlock = lock!();
    let spinlock_clone = clone_lock!(&spinlock);

    let thread = thread::spawn(move || {
        spinlock_clone.store(0, Ordering::SeqCst);
    });

    wait!(spinlock);

    if let Err(panic) = thread.join() {
        println!("Thread has an error {:?}", panic);
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test1() {
        atomic_demo1();
    }
}
// a value with alignment n must be stored at
// an address that is multiple of n.

// by default, composite structures have an alignment equal to
// the max of their fields alignment.

/// repr(Rust)
/// Composite types will have all fields aligned by the largest field.
// This struct will be 32 bit aligned.
struct A {
    a: u8,
    b: u32,
    c: u16,
}

// and it might look like this in memory
struct AAlignedLayout1 {
    a: u8,
    _pad1: [u8; 3], // align 32 bits.
    b: u32,
    c: u16,
    _pad2: [u8; 2], // align 32 bits.
}

// another posibility:
struct AAlignedLayout2 {
    a: u8,
    b: u32,
    c: u16,
    _pad: u8, // align 32 bits.
}

/// field ordering is not necessarily the same as their order in code.

// this is because certain order of layout is more space efficient.

struct Foo<T, U> {
    count: u16,
    data1: T,
    data2: U,
}

type Foo1 = Foo<u16, u32>;

// Foo1's layout will look like this, you can't be more efficient than this layout
// unless you do some hecky stuffs.
struct Foo1Layout {
    count: u16,
    data1: u16,
    data2: u32,
}

type Foo2 = Foo<u32, u16>;

// if you keep the order of fields in code, Foo2 will be quite wasteful.
struct Foo2Layout {
    count: u16,
    _pad1: u16, // wasteful
    data1: u32,
    _pad2: u16, // wasteful
    data2: u16,
}

/// enum is even more complicated

enum Bar {
    A(u32),
    B(u64),
    C(u8),
}

// this might looks like this
struct BarRepr {
    data: u64, // either u64, u32, or u8 based on tag.
    tag: u8,   // A = 0, B = 1, C = 2
}

/// Exotically Sized type
/// Some types might not have a statically known type at compile time.

/// Dynamicaly Sized types (DST)

struct MySuperSliceable<T: ?Sized> {
    info: u32,
    data: T,
}

#[cfg(test)]
mod test_dst {
    use super::MySuperSliceable;

    #[test]
    fn test_dst() {
        let sized: MySuperSliceable<[u8; 8]> = MySuperSliceable {
            info: 17,
            data: [0; 8],
        };

        // here, dynamic has dynamic size
        let dynamic: &MySuperSliceable<[u8]> = &sized;
        println!("{} {:?}", dynamic.info, &dynamic.data);
    }
}

/// zero sized type ZTS
// zero size
struct Nothing;

// the whole struct has size 0.
struct LostsOfNothing {
    foo: Nothing,
    qux: (),
    baz: [u8; 0],
}

/// Void type

// the opposite of unit. This type can only be talked about at the type level,
// but never the term level.
enum Void {}

#[cfg(test)]
mod test_void {
    use super::Void;

    #[test]
    fn test_void() {
        // saying error is impossible for this type.
        let res: Result<u32, Void> = Ok(0);
        if let Ok(num) = res {
            println!("{:?}", num);
        }
    }
}

/// repr(C)
/// using C representation to interface with C code.

#[repr(C)]
struct B {
    a: u8,
    b: u32,
    c: u16,
}

// force to align 1 byte.
#[repr(packed)]
struct C {
    a: u8,
    b: u32,
    c: u16,
}
use memmap::Mmap;
use std::fs::File;
use std::io::{BufRead, BufReader, Error, Write};

fn read_lines_of_strings_from_file() -> Result<(), Error> {
    let path = "lines.txt";
    let mut output = File::create(path)?;
    write!(output, "Hihi tostitos\n")?;
    write!(output, "Add another line\n")?;
    write!(output, "is never a problem\n")?;
    write!(output, "yohoho")?;

    let input = File::open(path)?;
    let buffered = BufReader::new(input);

    buffered
        .lines()
        .for_each(|line| println!("{}", line.unwrap()));

    Ok(())
}

fn memory_map() -> Result<(), Error> {
    let file = File::open("content.txt")?;
    let map = unsafe { Mmap::map(&file)? };

    let random_indexes = [0, 1, 2, 20, 10, 11, 34];
    assert_eq!(&map[3..13], b"minecraft");
    let random_bytes: Vec<u8> = random_indexes.iter().map(|&idx| map[idx]).collect();
    assert_eq!(&random_bytes[..], b"My loaf!");
    Ok(())
}
#![deny(warnings)]

mod client {
    // use bytes::Buf as _;
    // use hyper::Client;

    // type Result<T> = std::result::Result<T, Box<dyn std::error::Error + Send + Sync>>;

}
pub mod vector;
pub mod data_layout;
pub mod hyper_http;
pub mod tokio_demo1;
pub mod threads;
pub mod server1;
pub mod os1;
pub mod filesys;
pub mod oop;
pub mod atomic;
// dynamic dispatch with trait object
// how do we achieve subtypeing?

pub trait Draw {
    fn draw(&self);
}

// use trait oject.
// same as hide different types in a constructor with exitential type
// in haskell.
pub struct Screen {
    pub components: Vec<Box<dyn Draw>>,
}

impl Screen {
    pub fn run(&self) {
        for components in self.components.iter() {
            components.draw();
        }
    }
}

// use trait bound
pub struct Screen1<T: Draw> {
    pub components: Vec<T>,
}

impl<T> Screen1<T>
where
    T: Draw,
{
    pub fn run(&self) {
        for components in self.components.iter() {
            components.draw();
        }
    }
}
use error_chain;
use regex::Regex;
use std::collections::HashSet;
use std::fs::File;
use std::{
    io::Write,
    process::{Command, Stdio},
};

#[derive(PartialEq, Default, Clone, Debug)]
struct Commit {
    hash: String,
    message: String,
}

type Result<T> = std::result::Result<T, Box<dyn std::error::Error>>;

fn get_git_log() -> Result<()> {
    let output = Command::new("git").arg("log").arg("--oneline").output()?;
    if !output.status.success() {
        error_chain::bail!("Command executed with failing error code");
    }

    let pattern = Regex::new(r"(?x) ([0-9a-fA-F]+) (.*)")?;

    String::from_utf8(output.stdout)?
        .lines()
        .filter_map(|line| pattern.captures(line))
        .map(|cap| Commit {
            hash: cap[1].to_string(),
            message: cap[2].trim().to_string(),
        })
        .take(5)
        .for_each(|x| println!("{:?}", x));

    Ok(())
}

fn run_command_check_error_code() -> Result<()> {
    // pipe all standard fd to rust process.
    let mut child = Command::new("python")
        .stdin(Stdio::piped())
        .stderr(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()?;

    child
        .stdin
        .as_mut()
        .ok_or("Child process stdin has not been captured!")?
        .write_all(b"import this; copyright(); credits(); exit()")?;

    let output = child.wait_with_output()?;

    if output.status.success() {
        let raw_output = String::from_utf8(output.stdout)?;
        let words = raw_output
            .split_whitespace()
            .map(|word| word.to_lowercase())
            .collect::<HashSet<_>>();
        println!("Found {} unique words", words.len());
        println!("{:#?}", words);
        Ok(())
    } else {
        let err = String::from_utf8(output.stderr)?;
        error_chain::bail!("External command error: \n {}", err)
    }
}

fn run_piped_commands() -> Result<()> {
    let directory = std::env::current_dir()?;
    let mut du_output_child = Command::new("du")
        .arg("-ah")
        .arg(&directory)
        .stdout(Stdio::piped())
        .spawn()?;

    if let Some(du_output) = du_output_child.stdout.take() {
        let mut sort_output_child = Command::new("sort")
            .arg("-hr")
            .stdin(du_output)
            .stdout(Stdio::piped())
            .spawn()?;
        du_output_child.wait()?;

        if let Some(sort_output) = sort_output_child.stdout.take() {
            let head_output_child = Command::new("head")
                .args(&["-n", "10"])
                .stdin(sort_output)
                .stdout(Stdio::piped())
                .spawn()?;

            let head_stdout = head_output_child.wait_with_output()?;
            sort_output_child.wait()?;

            println!(
                "Top 10 biggest files and directories in '{}': \n {}",
                directory.display(),
                String::from_utf8(head_stdout.stdout).unwrap()
            );
        }
    }
    Ok(())
}

fn redirect_stdout_stderr_to_samefile() -> std::result::Result<(), std::io::Error> {
    let outputs = File::create("output")?;
    let errors = outputs.try_clone()?;

    // redirect stdout and stderr to the file oops.
    // oops doesn't exists thus will appear in file output.
    Command::new("ls")
        .args(&[".", "oops"])
        .stdout(Stdio::from(outputs))
        .stderr(Stdio::from(errors))
        .spawn()?
        .wait_with_output()?;
    Ok(())
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test1() {
        get_git_log();
    }

    #[test]
    fn test2() {
        run_command_check_error_code();
    }

    #[test]
    fn test3() {
        run_piped_commands();
    }
}
use std::io::{Error, Read};
use std::net::{Ipv4Addr, SocketAddrV4, TcpListener};

fn run() -> Result<(), Error> {
    let loopback = Ipv4Addr::new(127, 0, 0, 1);
    let socket = SocketAddrV4::new(loopback, 0);
    let listener = TcpListener::bind(socket)?;
    let port = listener.local_addr()?;

    println!(
        "Listening on {}, access thisport to enable the program.",
        port
    );
    let (mut tcp_stream, addr) = listener.accept()?;
    println!("Connection received {:?} is sending data.", addr);

    let mut input = String::new();

    let _ = tcp_stream.read_to_string(&mut input);
    println!("{:?} says {}", addr, input);
    Ok(())
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test1() {
        run();
    }
}
use crossbeam;
use crossbeam::channel::bounded;
use rand::Rng;
use std::io::Read;
use std::sync::mpsc::channel;
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::{Duration, Instant};

fn why_need_move_in_spane() {
    let v = vec![1, 2, 3];
    let handle = thread::spawn(move || {
        println!("The vector: {:?}", v);
    });

    // if we don't move, the closure holds a referencee to v, and
    // what if this happen?
    // drop(v);

    handle.join().unwrap();
}

fn thread_with_channel() {
    let (tx, rx) = channel();

    let tx1 = tx.clone();

    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from("more"),
            String::from("messages"),
            String::from("for"),
            String::from("you"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {}", received);
    }
}

fn using_mutex() {
    let m = Mutex::new(5);

    // the MutexGuard num will be droped at the end of the scope.
    // it's the same concetp as scope_lock or lock_guard in c++.
    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }
    println!("m = {:?}", m);
}

// note counter is immutable, but we can mutate the integer in
// Mutex.
// Mutex gives us interior mutability.
// Cell/RefCell are other examples that has interior mutability.

fn sharing_mutex() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }
}

// note for marker:
// Send means you can transfer the ownership between threads.
// e.g Rc<T> if you clone an Rc<T> and send it over to another thread,
// both threads might modify the counter at the same time, hence race condition.
//
// Sync means for a type T, &T is Send. It's safe to have a value be referenced by
// another thread.
// Types with interior mutablity cannot be sync:w

// find max in two theads
fn find_max(arr: &[i32], thread_num: usize) -> Option<i32> {
    let chunk_size = (arr.len() as f64 / thread_num as f64).round() as usize;

    fn find_max_(arr: &[i32], thread_num: usize, threadshold: usize) -> Option<i32> {
        if arr.len() <= threadshold {
            return arr.iter().cloned().max();
        }

        let bounds = (0..thread_num)
            .map(|n| (n * threadshold, (n + 1) * threadshold))
            .map(|(begin, end)| {
                let end = if end >= arr.len() { arr.len() } else { end };

                (begin, end)
            })
            .collect::<Vec<(usize, usize)>>();

        // can't use closure because the scope there is very important.
        crossbeam::scope(|s| {
            let mut threads = Vec::new();
            let mut results = Vec::new();
            for (begin, end) in bounds {
                let t = s.spawn(move |_| find_max_(&arr[begin..end], thread_num, threadshold));
                threads.push(t);
            }

            for t in threads {
                let v = t.join().unwrap();
                results.push(v);
            }

            results.into_iter().flatten().max()
        })
        .ok()
        .flatten()
    }

    find_max_(arr, thread_num, chunk_size)
}

// fn parallel_pipeline() {
//     // bounded channel that can holds n message at a time.
//     let (snd1, rcv1) = bounded(1);
// }

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test1() {
        let mut rng = rand::thread_rng();
        let vecs = (0..999999999)
            .into_iter()
            .map(|_| rng.gen::<i32>())
            .collect::<Vec<i32>>();

        {
            let start = Instant::now();
            let max = find_max(&vecs[..], 4);
            println!("find max: {:?}, takes: {:.2?}", max, start.elapsed());
        }

        {
            let start = Instant::now();
            let max = vecs.iter().cloned().max();
            println!("real max: {:?}, takes: {:.2?}", max, start.elapsed());
        }
    }
}
// use tokio::io::{AsyncReadExt, AsyncWriteExt};
// use tokio::net::TcpListener;

// #[tokio::main]
// async fn main() -> Result<(), Box<dyn std::error::Error>> {
//     let mut listener = TcpListener::bind("127.0.0.1:8080").await?;
// }
use std::marker::PhantomData;
use std::mem;
use std::ops::Deref;

// implement vector to get a feel of the overall flow.

struct Unique<T> {
    ptr: *const T,
    _marker: PhantomData<T>,
}

unsafe impl<T: Send> Send for Unique<T> {}
unsafe impl<T: Sync> Sync for Unique<T> {}

impl<T> Unique<T> {
    pub fn new(ptr: *mut T) -> Self {
        Unique {
            ptr,
            _marker: PhantomData,
        }
    }

    pub fn as_ptr(&self) -> *mut T {
        self.ptr as *mut T
    }
}

pub struct Vector<T> {
    ptr: Unique<T>,
    cap: usize,
    len: usize,
}
use std::alloc::{GlobalAlloc, Layout, System};

// global memory allocator.

struct MyAllocator;

unsafe impl GlobalAlloc for MyAllocator {
    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        System.alloc(layout)
    }

    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
        System.dealloc(ptr, layout);
    }
}

// configure the choice of global allocator. We can use this allocator
// for all types.
#[global_allocator]
static GLOBAL: MyAllocator = MyAllocator;

pub fn run () {
    let mut v = Vec::new();
    v.push(1);
}
// some boxed values.

pub fn boxed_demo() {}
use std::vec;

/// vector
pub fn vector_demo() {
    let _v: Vec<i32> = Vec::new();
    let mut v: Vec<i32> = vec![1, 2, 3];
    v.push(3);
    let i = v.pop().map(move |x| x + 1).unwrap();
    assert!(i == 4);
}

/// option
pub fn divide(numerator: f64, denominator: f64) -> Option<f64> {
    if denominator == 0.0 {
        None
    } else {
        Some(numerator / denominator)
    }
}

pub fn try_divide(a: f64, b: f64) -> Option<bool> {
    let result = divide(a, b);
    Some(match result {
        Some(_) => true,
        None => false,
    })
}
pub mod alloc_demo;
pub mod boxed_survey;
pub mod containers_survey;
pub fn optional() {
    let ints: Vec<i32> = (0..10).collect::<Vec<_>>();
    let slice = &ints;
    let first = slice.get(0);
    let last = slice.get(11);
    println!("first {} {}", first.is_some(), first.is_none());
    println!("last {} {}", last.is_some(), last.is_none());
    println!("fist value {}", *first.unwrap());
    let last_result = *slice.get(11).unwrap_or(&-1);
    println!("{}", last_result);
}

pub fn vectors() {
    let mut v = Vec::new();
    v.push(1);
    v.push(2);
    v.push(3);
    let first = v[0];
    let maybe_first = v.get(0);
    println!("v is {:?}", v);
    println!("first is {}", first);
    println!("maybe_first is {:?}", maybe_first);
    // use borrow operator.
    // the slice borrow the memory from vector.
    let slice = &v[1..];
    println!("slice is {:?}", slice);
}

pub fn iterators() {
    // like python iterator.
    let mut iter = 0..3;
    assert_eq!(iter.next(), Some(0));
    assert_eq!(iter.next(), Some(1));
    assert_eq!(iter.next(), Some(2));
    assert_eq!(iter.next(), None);
    let arr = (0..5).collect::<Vec<_>>();
    for n in arr.iter() {
        println!("{}", n);
    }
    let sum: i32 = (0..5).sum();
    println!("sum was {}", sum);
    let sum: i64 = [10, 20, 30].iter().sum();
    println!("sum was {}", sum);
    // window of slice of arr.
    for s in (&arr).windows(2) {
        println!("window {:?}", s);
    }
    for s in arr.chunks(3) {
        println!("chunk {:?}", s);
    }
    let mut v1 = vec![10, 20, 30, 40];
    v1.pop();
    let mut v2 = Vec::new();
    v2.push(10);
    v2.push(20);
    v2.push(30);
    assert_eq!(v1, v2);
    v2.extend(0..2);
    assert_eq!(v2, &[10, 20, 30, 0, 1]);
    let mut v3 = vec![1, 10, 5, 1, 2, 11, 2, 540];
    v3.sort();
    v3.dedup(); // remove duplicates.
    println!("{:?}", v3);
}

pub fn strings() {
    // slice of String is str
    fn dump(s: &str) {
        println!("str '{}'", s);
    }

    fn convert_string_and_literal_str() {
        let text = "hello dolly"; // string slice.
        let s = text.to_string(); // now heap string.
        let mut string = String::new();
        string.push('H');
        string.push_str("ello");
        string.push(' ');
        string += "world"; // push_str
        string.pop();
        dump(text);
        dump(&s);
        dump(&string);
    }

    fn format() {
        // pass in a arry with i32.
        fn array_to_str(arr: &[i32]) -> String {
            // initialize a char into string.
            let mut res = '['.to_string();
            for v in arr {
                // iter through the slice.
                res += &v.to_string();
                res.push(',');
            }
            res.pop();
            res.push(']');
            res
        }
        let arr = array_to_str(&[10, 20, 30]);
        let res = format!("hello {}", arr);
        println!("{}", res);
    }
    convert_string_and_literal_str();
    format();
}

pub fn more_string() {
    fn slice_on_string() {
        // a literal str
        let text = "static";
        // convert into string.
        let string = "dynamic".to_string();
        // slice a str
        let text_s = &text[1..];
        // slice a string
        let strings = &string[2..4];
        println!("slices {:?} {:?}", text_s, strings);
    }

    fn string_encodeing_form() {
        let chinese = "一行中文";
        // chars to return a char iterator of str.
        for ch in chinese.chars() {
            println!("{}", ch);
        }
        println!("");
        println!("len {}", chinese.len()); // len of byte.
        println!("count {}", chinese.chars().count());
        // find will convert character position to byte position.
        let maybe = chinese.find('行');
        if maybe.is_some() {
            // use character to slice.
            let h = &chinese[maybe.unwrap()..];
            println!("Chinese {}", h);
        }
    }

    fn string_slice_and_chars_slice() {
        // let s = "个";  // these will be a runtime error.
        let s = "i";
        assert_eq!(s, "i");
        println!("{}", &s[0..1]);
    }

    fn split() {
        let text = "the quick fox jumps over the lazy dog";
        let words: Vec<&str> = text.split(' ').collect();
        println!("{:?}", words);
        let stripped: String = text.chars().filter(|ch| !ch.is_whitespace()).collect();
        print!("{:?}", stripped);
        let mut stripped: String = String::new();
        for ch in text.chars() {
            if !ch.is_whitespace() {
                stripped.push(ch);
            }
        }
    };

    slice_on_string();
    string_encodeing_form();
    string_slice_and_chars_slice();
    split();
}
pub enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

pub fn ipaddress() -> (IpAddr, IpAddr) {
    let home = IpAddr::V4(127, 0, 0, 1);
    let loopback = IpAddr::V6(String::from("::1"));
    (loopback, home)
}

pub enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message {
    pub fn call(&self) {
        match self {
            Message::Quit => println!("Quit"),
            Message::Move { x, y } => println!("{} {}", x, y),
            Message::Write(s) => println!("{}", s),
            Message::ChangeColor(r, g, b) => println!("{}{}{}", r, g, b),
        }
    }
}
use std::fs::File;
use std::io;
use std::io::ErrorKind;
use std::io::Read;

pub fn no_file() {
    let name: &str = "not_a_file.txt";
    let f = File::open(name);
    let mut buf = String::new(); // initialize the string first.
    let mut f = match f {
        // use match to handle Results.
        Ok(file) => file,
        // nested match for different errors.
        Err(error) => match error.kind() {
            // here can use a if let.
            // different error types.
            ErrorKind::NotFound => match File::create(name) {
                Ok(fc) => fc,
                Err(e) => panic!("Can not create file {:?}", e),
            },
            other_err => panic!("Can not create file {:?}", other_err),
        },
    };
    // if let discard the fail case.
    if let Ok(_) = f.read_to_string(&mut buf) {
        println!("{}", buf);
    };
}

pub fn closure_error_handling() -> Result<String, io::Error> {
    // use closure to handle error instead of match
    // This make code more concise.
    let filename: &str = "not_a_file_2.txt";
    let mut buf = String::new();
    let mut f = File::open(filename).unwrap_or_else(|e| {
        if e.kind() == ErrorKind::NotFound {
            File::create(filename).unwrap_or_else(|e| {
                panic!("Problem creating the file {:?}", e);
            })
        } else {
            panic!("Problem creating the file {:?}", e);
        }
    });
    match f.read_to_string(&mut buf) {
        Ok(_) => Ok(buf),
        Err(e) => Err(e),
    }
}

pub fn use_question_mark() -> Result<String, io::Error> {
    let mut buf = String::new();
    let filename = "not_a_file_3.txt";
    // the quetion mark gonna return the error automatically.
    File::open(filename)?.read_to_string(&mut buf)?;
    Ok(buf)
}
pub struct Fibnacci {
    curr: u64,
    next: u64
}

impl Fibnacci {
    pub fn new() -> Fibnacci {
        Fibnacci { curr: 0, next: 1}
    }
}

impl Iterator for Fibnacci {
    type Item = u64;
    fn next(&mut self) -> Option<u64> {
        let new_next = self.curr + self.next;
        self.curr = self.next;
        self.next = new_next;
        Some(self.curr)
    }
}
use std::env;
use std::fs::File;
use std::io;
use std::io::Read;

pub fn reading_files() {
    // read file without handling exceptions.
    let first = env::args().nth(1).expect("please supply a file name");
    let mut file = File::open(&first).expect("can't open the file");
    let mut text = String::new();
    file.read_to_string(&mut text).expect("can't read the file");
    println!("file had {} bytes", text.len());
}

pub fn use_result() {
    // result is like either.
    fn good_or_bad(good: bool) -> Result<i32, String> {
        if good {
            Ok(42)
        } else {
            Err("bad".to_string())
        }
    }
    println!("{:?}", good_or_bad(true));
    println!("{:?}", good_or_bad(false));
    match good_or_bad(true) {
        Ok(n) => println!("Ok, it is {}", n),
        Err(e) => println!("Err {}", e),
    }
}

pub fn reading_files_safe() {
    /* use result to handle error cases */
    fn read_to_string(filename: &str) -> Result<String, io::Error> {
        let mut file = match File::open(&filename) {
            Ok(f) => f,
            Err(e) => return Err(e), // early return.
        };
        let mut text = String::new();
        match file.read_to_string(&mut text) {
            Ok(_) => Ok(text),
            Err(e) => Err(e),
        }
    }
    let file = env::args().nth(1).expect("please supply a filename");
    let text = read_to_string(&file).expect("bad file");
    println!("file content {}", text);
}

pub fn use_io_result_type() {
    fn read_to_string(filename: &str) -> io::Result<String> {
        let mut file = File::open(&filename)?; // early return for error.
        let mut text = String::new();
        file.read_to_string(&mut text)?;
        // should not have ; at the end.
        Ok(text)
    }
    let file = env::args().nth(1).expect("please supply a filename");
    let text = read_to_string(&file).expect("bad file");
    println!("file content: {}", text);
}
pub fn largest<T>(list: &[T]) -> T
where
    T: PartialOrd + Copy,
{
    let mut largest = list[0];
    for &item in list.iter() {
        if item > largest {
            largest = item;
        }
    }
    largest
}

pub struct Point<T> {
    x: T,
    y: T,
}

// here it return a reference.
// If the return type is T, then this method
// will hand over the ownership of x, which is
// not desirable.
// The ownershipo things is also reverlent when making
// libraries.
impl<T> Point<T> {
    pub fn x(&self) -> &T {
        &self.x
    }
}

pub struct HeterPoint<T, U> {
    x: T,
    y: U,
}

impl<T, U> HeterPoint<T, U> {
    pub fn mixup<V, W>(self, other: HeterPoint<V, W>) -> HeterPoint<T, W> {
        HeterPoint {
            x: self.x,
            y: other.y,
        }
    }
}

pub fn use_point() {
    let hp = HeterPoint::<i32, i32> {
        // turbo fish to specify type.
        x: 10,
        y: 10,
    };
    let p = Point::<i32> { x: 10, y: 20 };
    println!("{:?}", p.x());
    let hp2 = hp.mixup(HeterPoint::<u32, u32> { x: 100, y: 100 });
    println!("{:?}", hp2.x);
}
use std::collections::HashMap;

pub fn create_from_zip() {
    let teams = vec![String::from("T1"), String::from("T2")];
    let init_scores = vec![10, 50];
    let scores: HashMap<_, _> = teams.iter().zip(init_scores.iter()).collect();
    println!("{:#?}", scores);
}

pub fn insert_m() {
    let mut map = HashMap::new();
    map.insert(String::from("hello"), 10);
    map.insert(String::from("world"), 20);
    println!("{:#?}", map);
}

pub fn insert_or() {
    let text = "The brown quick fox jumps over The lazy dog";
    let mut map = HashMap::new();
    for word in text.split(' ') {
        let count = map.entry(word).or_insert(0);
        *count += 1;
    }
    println!("{:#?}", map);
}
use std::f64::consts;

pub fn hello_world() {
    /* basics of rusts */

    // print is a macro
    print!("hello");
    // val are immutable by default.
    let value = 42;
    // assert is a macro
    assert_eq!(value, 42);
}

pub fn looping_if() {
    // for in range
    for i in 0..5 {
        if i % 2 == 0 {
            println!("even {}", i);
        } else {
            println!("odd {}", i);
        }
    }
    for i in 0..5 {
        // if as expression
        let even_odd = if i % 2 == 0 { "even" } else { "odd" };
        print!("{} {}", even_odd, i);
    }
}

pub fn adding_thigns_up() {
    // delare mutable variable.
    let mut sum = 0.0;
    for i in 0..5 {
        sum += i as f64;
    }
    print!("sum is {}", sum);
}

pub fn function_types() {
    fn sqr(x: f64) -> f64 {
        x * x
    };

    fn abs(x: f64) -> f64 {
        if x > 0.0 {
            x
        } else {
            -x
        }
    }

    fn clamp(x: f64, start: f64, end: f64) -> f64 {
        if x < start {
            start
        } else if x > end {
            end
        } else {
            x
        }
    }

    fn factorial(n: u64) -> u64 {
        if n == 0 {
            1
        } else {
            n * factorial(n - 1)
        }
    }

    fn by_ref(x: &i32) -> i32 {
        *x + 1
    }

    fn modifies(x: &mut f64) {
        *x = 10.0;
    }

    let res = sqr(clamp(abs(-0.9), 0.1, 1.4));
    println!("square is {}", res);
    println!("factorial is {}", factorial(10));
    let i = 10;
    let res1 = by_ref(&i);
    let res2 = by_ref(&31);
    println!("{} {}", res1, res2);
    let mut j = 1.0;
    modifies(&mut j as &mut f64);
    print!("{} ", j);
}

pub fn find_the_ropes() {
    fn pi1() {
        let pi: f64 = 3.1415;
        let x = pi / 2.0;
        let cosine = x.cos();
        print!("cosine {}", cosine);
    }

    fn pi2() {
        let x = 2.0 * consts::PI;
        let abs_difference = (x.cos() - 1.0).abs();
        assert!(abs_difference < 1e-10);
    }
    pi1();
    pi2();
}

pub fn array_and_slices() {
    let arr: [i32; 4] = [10, 20, 30, 40];
    let first = arr[0];
    let res = sum(&arr);

    // pass array by ref
    fn sum(values: &[i32]) -> i32 {
        let mut acc = 0;
        for i in 0..values.len() {
            acc += values[i];
        }
        acc
    }

    println!("first {}", first);
    for i in 0..arr.len() {
        println!("[{}] = {}", i, arr[i]);
    }
    print!("length {}", arr.len());
    println!("sum {}", res);

    // slice
    let ints = [1, 2, 3];
    let floats = [1.1, 2.2, 3.3];
    let strings = ["hello", "world"];
    let ints_ints = [[1, 2], [3, 4]];

    // rust slice borrow data rather than copying.
    let slice1 = &ints[0..2];
    let slice2 = &ints[1..];

    println!("ints {:?}", ints);
    println!("floats {:?}", floats);
    println!("strings {:?}", strings);
    println!("ints_ints {:?}", ints_ints);
    println!("slice1 {:?}", slice1);
    println!("slice2 {:?}", slice2);
}
use std::fmt;

pub struct PRange {
    start: f64,
    end: f64,
    step: f64,
}

pub fn range(start: f64, end: f64, step: f64) -> PRange {
    return PRange { start, end, step };
}

impl fmt::Debug for PRange {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{} | {} | {}", self.start, self.end, self.step)
    }
}

// typeclass
impl Iterator for PRange {
    type Item = f64;
    fn next(&mut self) -> Option<Self::Item> {
        let res = self.start;
        if res > self.end {
            None
        } else {
            self.start += self.step;
            Some(res)
        }
    }
}

fn dump<T>(value: &T)
where
    T: fmt::Debug,
{
    // called trait bound.
    // just type class constraint.
    println!("from dumps: {:?} ", value);
}

pub fn rust_filter() {
    let r = range(0.0, 10.0, 1.0);
    dump(&r);
    let v: Vec<f64> = r.map(|x| x.sin()).collect();
    println!("{:?}", v);
}

pub fn sqrt<T>(x: T) -> T::Output
where
    T: std::ops::Mul + Copy,
{
    x * x
}
use std::fmt::Display;

pub fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

struct ImportantExcerpt<'a> {
    // instance of ImportantExcerpt cannot outlive part.
    part: &'a str,
}

pub fn struct_lifetime() {
    let novel = String::from("McCafe. is better than Timhortons");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    let i = ImportantExcerpt {
        part: first_sentence,
    };
    println!("struct with a reference {}", i.part);
}

// an example that doesn't need a lifetime annotation.
// lifetime elision rules.
pub fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }
    &s[..]
}

// lifetime_mixture
pub fn longest_with_an_announcement<'a, T>(x: &'a str, y: &'a str, ann: T) -> &'a str
where
    T: Display,
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
mod basic;
mod enums;
mod error;
mod files;
mod generics;
mod hashm;
mod hello;
mod impl_iterator;
mod matching;
mod other;
mod structs;
mod traits;
mod lifetime;
mod fib_iter;

fn main() {
    let args: Vec<String> = std::env::args().skip(1).collect();

    println!("args: {:?}", args);

    println!("pub fn hello_world():");
    hello::hello_world();

    println!("pub fn looping_if() ");
    hello::looping_if();

    println!("pub fn adding_thigns_Up()");
    hello::adding_thigns_up();

    println!("function_types");
    hello::function_types();

    println!("pub fn find_the_ropes()");
    hello::find_the_ropes();

    println!("pub fun array_and_slices()");
    hello::array_and_slices();

    println!("pub fn optional()");
    basic::optional();

    println!("pub fn vectors()");
    basic::vectors();

    println!("pub fn iterators()");
    basic::iterators();

    println!("pub fn strings()");
    basic::strings();

    println!("pub fn more_string()");
    basic::more_string();

    println!("pub fn matching()");
    matching::matching();

    println!("pub fn reading_files()");
    files::reading_files();

    println!("use result");
    files::use_result();

    println!("pub fn reading_files_safe()");
    files::reading_files_safe();

    println!("pub fn use_io_result_type()");
    files::use_io_result_type();

    println!("tuple()");
    structs::tuples();

    println!("strucst()");
    structs::structs();

    println!("lifetime()");
    structs::lifetime();

    println!("show_trait()");
    traits::show_trait();

    println!("type trait for iterator");
    println!("{:?}", impl_iterator::range(0.0, 10.0, 1.0).next());

    println!("rust_filter()");
    impl_iterator::rust_filter();

    println!("sqrt() generic");
    println!("{}", impl_iterator::sqrt(3.4));

    println!("ipaddress()");
    enums::ipaddress();

    enums::Message::Write(String::from("writing")).call();
    enums::Message::Quit.call();
    enums::Message::Move { x: 10, y: 10 }.call();

    other::restuarant::front::Tables::BigRound(String::from("no 1"));

    println!("Hello, world!");

    hashm::insert_m();
    hashm::insert_or();
    hashm::create_from_zip();

    error::no_file();
    error::closure_error_handling();
    error::use_question_mark();

    let l = generics::largest::<u16>(&vec![20, 30, 10, 320, 2, 3, 12, 1000]);
    println!("{}", &l); // has Copy trait. No move here.
    println!("{}", l);

    generics::use_point();

    let s: &str = lifetime::longest("abc", "bcdsd");
    println!("{}", s);

    lifetime::struct_lifetime();

    let s: &str = lifetime::first_word("first word");
    println!("{}", s);

    let s: &str = lifetime::longest_with_an_announcement("a", "asd", "good");
    println!("{}", s);

    let fib = fib_iter::Fibnacci::new();
    for (i, f) in fib.take(80).enumerate() {
        println!("fib {}-> {} or\n {:#b}\n or {:#x}\n", i, f, f, f);
        println!("==================================>");
    }
}
pub fn matching() {
    let string = "the quick fox jumps over the lazy dog";
    match string.find('l') {
        Some(idx) => {
            let lazydog = &string[idx..];
            println!("{}", lazydog);
        }
        None => println!("Cannot find lazy dog"),
    };
    // ignore None
    if let Some(idx) = string.find('l') {
        println!("againg, {}", &string[idx..]);
    }
    // nested and switch
    let text = match string.find("l") {
        Some(idx) => match idx {
            0 => "ZERO",
            1 => "ONE",
            2 => "TWO",
            3 => "THREE",
            _ => "MANY ...",
        },
        None => "NONE...",
    };
    println!("{}", text);
}
pub mod restuarant {
    pub mod front {
        pub enum Tables {
            BigRound(String),
            FourSears(u8, u8, u8, u8),
        }
    }
}
pub fn tuples() {
    fn add_mul(x: f64, y: f64) -> (f64, f64) {
        (x + y, x * y)
    }
    let t = add_mul(1.0, 2.0);
    let (a, b) = add_mul(3.0, 4.0);
    println!("{}, {}", t.0, t.1);
    println!("{}, {}", a, b);
    for t in ["zero", "one", "two"].iter().enumerate() {
        println!("idx: {}, value: {}", t.0, t.1);
    }
    for t in ["a", "b", "c"].iter().zip([1, 2, 3].iter()) {
        println!("name: {}, value: {}", t.0, t.1);
    }
}

#[derive(Debug)]
struct Person {
    first: String,
    second: String,
}

impl Person {
    // static method.
    fn new(first: &str, second: &str) -> Person {
        Person {
            first: first.to_string(),
            second: second.to_string(),
        }
    }

    // access data but not modify it.
    fn full_name(&self) -> String {
        format!("{} . {}", self.first, self.second)
    }

    fn copy(&self) -> Self {
        Self::new(&self.first, &self.second)
    }

    // access data and modify it.
    fn set_first(&mut self, name: &str) {
        self.first = name.to_string();
    }

    // deconstruct.
    fn to_tuple(self) -> (String, String) {
        (self.first, self.second)
    }
}

pub fn structs() {
    // like an interface.
    let p = Person {
        first: "Jane".to_string(),
        second: "John".to_string(),
    };
    let p2 = Person::new("Jimmy", "Yao");
    println!("Person {} {}", p.first, p.second);
    println!("Person {} {}", p2.first, p2.second);
    println!("Full name: {} ", p2.full_name());
    println!("Copied name: {}", p2.copy().full_name());
    let mut p3 = p2.copy();
    p3.set_first("Jummy");
    println!("Set name: {}", p3.full_name());
    // this will move the value, p3 now is destructed.
    let (first, second) = p3.to_tuple();
    println!("To tuple {} {}", first, second);
    println!("print debug p {:?}", p);
}

#[derive(Debug)]
struct A {
    // static lifetime, which exists through the whole program.
    s: &'static str,
}

#[derive(Debug)]
struct B<'a> {
    // 'a: the lifetime of struct itself.
    s: &'a str,
}

// the claim will never happen.
// fn makes_B() -> B<'static> {

//   let string = "I am a string".to_string();
//   A { s: &string }
// }

pub fn lifetime() {
    // all references to be stored must have a lifetime.
    // references cannot outlive owner.
    let a = A { s: "Hello" };
    println!("{}", a.s);
}
use std::fmt;

trait Show {
    fn show(&self) -> String;
}

// implement type trait.
// like interface, or typeclass.
impl Show for i32 {
    fn show(&self) -> String {
        format!("four-byte signed {}", self)
    }
}

impl Show for f64 {
    fn show(&self) -> String {
        format!("eight-byte signed {}", self)
    }
}

pub fn show_trait() {
    let i = 53;
    let f = 2.71;
    let i_show = i.show();
    let f_show = f.show();
    println!("values: {} {}", i, f);
    println!("show: {} {}", i_show, f_show);
}

struct Person<'a> {
    first: &'a str,
    second: &'a str,
}

// implement debug type trait for Person.
impl fmt::Debug for Person<'static> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", format!("{} - {}", self.first, self.second))
    }
}
use std::rc::Rc;
use std::cell::RefCell;


use std::mem;

// handle of the heap space.
#[derive(Debug)]
pub struct List<T> {
    head: Link<T>,
}

// This layout avoids non uniform allocation (first element in stack
// but others in the heap).
// Also the layout allows null pointer optimization. No space for tag is
// needed for Empty, since the alternative is always non zero, we can just
// treat Empty as 0.
#[derive(Debug)]
pub enum Link<T> {
    Empty,
    More(Box<Node<T>>),
}

#[derive(Debug)]
pub struct Node<T> {
    elem: T,
    next: Link<T>,
}

impl<T> List<T> {
    pub fn new() -> Self {
        List { head: Link::Empty }
    }

    pub fn push(&mut self, elem: T) {
        let new_node = Box::new(Node {
            elem,
            next: mem::replace(&mut self.head, Link::Empty),
        });
        self.head = Link::More(new_node);
    }

    pub fn pop(&mut self) -> Option<T> {
        match mem::replace(&mut self.head, Link::Empty) {
            Link::Empty => None,
            Link::More(node) => {
                self.head = node.next;
                Some(node.elem)
            }
        }
    }
}

impl<T> Drop for List<T> {
    fn drop(&mut self) {
        let mut cur_link = mem::replace(&mut self.head, Link::Empty);

        while let Link::More(mut boxed_node) = cur_link {
            cur_link = mem::replace(&mut boxed_node.next, Link::Empty);
        }
    }
}

#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let mut list = List::new();
        assert_eq!(list.pop(), None);
        list.push(1);
        list.push(2);
        list.push(3);

        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(2));

        list.push(5);
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), None);
        assert_eq!(list.pop(), None);
    }
}
use std::mem;

#[derive(Debug)]
pub enum List<T> {
    Cons(T, Box<List<T>>),
    Nil,
}

macro_rules! assume_init {
    () => {{
        mem::MaybeUninit::uninit().assume_init()
    }};
}

impl<T> List<T> {
    pub fn new() -> Self {
        List::Nil
    }

    // what's the take away?
    // if you want to move out a value from a mutable reference, technically
    // you can't. but actually you can! With replace, you can sneak in another
    // value to avoid dangling ptr, and get the ownership of the content of the
    // mutable reference.
    pub fn push(&mut self, elem: T) {
        match mem::replace(self, Self::Nil) {
            Self::Nil => (),
            cons => {
                let new_list = Self::Cons(elem, Box::new(cons));
                *self = new_list;
            }
        }
    }

    pub fn pop(&mut self) -> Option<T> {
        match mem::replace(self, Self::Nil) {
            Self::Nil => None,
            Self::Cons(ref mut x, ref mut xs) => {
                let elem = mem::replace(x, unsafe { assume_init!() });
                *self = *mem::replace(xs, Box::new(Self::Nil));
                Some(elem)
            }
        }
    }
}

impl<T> Drop for List<T> {
    fn drop(&mut self) {
        match self {
            List::Nil => (),
            List::Cons(_, xs) => {
                drop(xs.as_mut());
                drop(xs);
            }
        }
    }
}

#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));
        println!("{:?}", list);
    }

    #[test]
    fn test1() {
        let mut list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));
        list.push(1);
        list.push(2);
        list.push(3);

        assert_eq!(list.pop().unwrap(), 3);
        assert_eq!(list.pop().unwrap(), 2);
        assert_eq!(list.pop().unwrap(), 1);
        list.push(1);
        list.push(2);
        list.push(3);
        list.push(4);
        list.push(5);

        println!("{:?}", list);
    }
}
mod bad_stack;
mod basic_stack;
mod ok_stack;
mod persistent_singly_linked_stack;
mod bad_safe_deque;

fn main() {
    println!("Hello, world!");
}
// several improvements:
// Use Option instead of our own ADT for link, so we can use
// all functions provided by Option.

// handle of the heap space.
#[derive(Debug)]
pub struct List<T> {
    head: Link<T>,
}

type Link<T> = Option<Box<Node<T>>>;

#[derive(Debug)]
pub struct Node<T> {
    elem: T,
    next: Link<T>,
}

impl<T> List<T> {
    pub fn new() -> Self {
        List { head: None }
    }

    pub fn push(&mut self, elem: T) {
        let new_node = Box::new(Node {
            elem,
            next: self.head.take(),
        });
        self.head = Link::Some(new_node);
    }

    pub fn pop(&mut self) -> Option<T> {
        self.head.take().map(|node| {
            self.head = node.next;
            node.elem
        })
    }

    pub fn peek(&self) -> Option<&T> {
        self.head.as_ref().map(|node| &node.elem)
    }

    pub fn peek_mut(&mut self) -> Option<&mut T> {
        self.head.as_mut().map(|node| &mut node.elem)
    }

    pub fn into_iter(self) -> IntoIter<T> {
        IntoIter(self)
    }

    pub fn iter(&self) -> Iter<'_, T> {
        Iter {
            next: self.head.as_deref(),
        }
    }

    pub fn iter_mut(&mut self) -> IterMut<'_, T> {
        IterMut {
            next: self.head.as_deref_mut(),
        }
    }
}

// tuple struct for newtypes.
pub struct IntoIter<T>(List<T>);

impl<T> Iterator for IntoIter<T> {
    type Item = T;
    fn next(&mut self) -> Option<Self::Item> {
        self.0.pop()
    }
}

pub struct Iter<'a, T> {
    next: Option<&'a Node<T>>,
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;
    fn next(&mut self) -> Option<Self::Item> {
        self.next.map(|node| {
            self.next = node.next.as_deref();
            &node.elem
        })
    }
}

pub struct IterMut<'a, T> {
    next: Option<&'a mut Node<T>>,
}

impl<'a, T> Iterator for IterMut<'a, T> {
    type Item = &'a mut T;
    fn next(&mut self) -> Option<Self::Item> {
        self.next.take().map(|node| {
            self.next = node.next.as_deref_mut();
            &mut node.elem
        })
    }
}

impl<T> Drop for List<T> {
    fn drop(&mut self) {
        let mut cur_link = self.head.take();

        while let Link::Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}

#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let mut list = List::new();
        assert_eq!(list.pop(), None);
        list.push(1);
        list.push(2);
        list.push(3);

        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(2));

        list.push(5);
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), None);
        assert_eq!(list.pop(), None);

        list.push(1);
        assert_eq!(list.peek(), Some(&1));
        list.peek_mut().map(|node| {
            *node = 99;
        });
        assert_eq!(list.peek(), Some(&99));
    }
}
use std::rc::Rc;
// persistent singly linked list,
// multiple values share a common part.

pub struct List<T> {
    head: Link<T>,
}

type Link<T> = Option<Rc<Node<T>>>;

struct Node<T> {
    elem: T,
    next: Link<T>,
}

impl<T> List<T> {
    pub fn new() -> Self {
        List { head: None }
    }

    pub fn append(&self, elem: T) -> Self {
        List {
            head: Some(Rc::new(Node {
                elem,
                next: self.head.clone(),
            })),
        }
    }

    pub fn tail(&self) -> Self {
        List {
            head: self.head.as_ref().and_then(|node| node.next.clone()),
        }
    }

    pub fn iter(&self) -> Iter<'_, T> {
        Iter {
            next: self.head.as_deref(),
        }
    }
}

pub struct Iter<'a, T> {
    next: Option<&'a Node<T>>,
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;

    fn next(&mut self) -> Option<Self::Item> {
        self.next.map(|node| {
            self.next = node.next.as_deref();
            &node.elem
        })
    }
}

impl<T> Drop for List<T> {
    fn drop(&mut self) {
        let mut head = self.head.take();
        while let Some(node) = head {
            if let Ok(mut node) = Rc::try_unwrap(node) {
                head = node.next.take();
            } else {
                break;
            }
        }
    }
}
